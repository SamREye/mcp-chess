/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1";
exports.ids = ["vendor-chunks/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably-node.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably-node.js ***!
  \*************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)\n\nAbly JavaScript Library v2.17.1\nhttps://github.com/ably/ably-js\n\nReleased under the Apache Licence v2.0*/(function (g, f) {\n    if (true) {\n      module.exports = f(__webpack_require__(/*! ws */ \"(ssr)/./node_modules/.pnpm/ws@8.19.0/node_modules/ws/index.js\"), __webpack_require__(/*! got */ \"(ssr)/./node_modules/.pnpm/got@11.8.6/node_modules/got/dist/source/index.js\"));\n    } else {}\n  }(this, (__da, __db) => {\nvar exports = {};\nvar module = { exports };\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __await = function(promise, isYieldStar) {\n  this[0] = promise;\n  this[1] = isYieldStar;\n};\nvar __asyncGenerator = (__this, __arguments, generator) => {\n  var resume = (k, v, yes, no) => {\n    try {\n      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;\n      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === \"return\" ? k : \"next\", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume(\"throw\", e, yes, no));\n    } catch (e) {\n      no(e);\n    }\n  };\n  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));\n  var it = {};\n  return generator = generator.apply(__this, __arguments), it[Symbol.asyncIterator] = () => it, method(\"next\"), method(\"throw\"), method(\"return\"), it;\n};\n\n// node_modules/bops/from.js\nvar require_from = __commonJS({\n  \"node_modules/bops/from.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var version2 = ((process || {}).version || \"v0.0.0\").slice(1).split(\".\")[0];\n    module2.exports = Number(version2) < 6 ? function from(source, encoding) {\n      return new Buffer2(source, encoding);\n    } : function from(source, encoding) {\n      return Buffer2.from(source, encoding);\n    };\n  }\n});\n\n// node_modules/bops/to.js\nvar require_to = __commonJS({\n  \"node_modules/bops/to.js\"(exports2, module2) {\n    module2.exports = function(source, encoding) {\n      return source.toString(encoding);\n    };\n  }\n});\n\n// node_modules/bops/is.js\nvar require_is = __commonJS({\n  \"node_modules/bops/is.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    module2.exports = function(buffer) {\n      return Buffer2.isBuffer(buffer);\n    };\n  }\n});\n\n// node_modules/bops/subarray.js\nvar require_subarray = __commonJS({\n  \"node_modules/bops/subarray.js\"(exports2, module2) {\n    module2.exports = function(source, from, to) {\n      return arguments.length === 2 ? source.slice(from) : source.slice(from, to);\n    };\n  }\n});\n\n// node_modules/bops/join.js\nvar require_join = __commonJS({\n  \"node_modules/bops/join.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    module2.exports = function(targets, hint) {\n      return hint !== void 0 ? Buffer2.concat(targets, hint) : Buffer2.concat(targets);\n    };\n  }\n});\n\n// node_modules/bops/copy.js\nvar require_copy = __commonJS({\n  \"node_modules/bops/copy.js\"(exports2, module2) {\n    module2.exports = copy2;\n    function copy2(source, target, target_start, source_start, source_end) {\n      return source.copy(target, target_start, source_start, source_end);\n    }\n  }\n});\n\n// node_modules/bops/create.js\nvar require_create = __commonJS({\n  \"node_modules/bops/create.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var version2 = ((process || {}).version || \"v0.0.0\").slice(1).split(\".\")[0];\n    module2.exports = Number(version2) < 6 ? function create(size) {\n      return new Buffer2(size);\n    } : function create(size) {\n      return Buffer2.alloc(size);\n    };\n  }\n});\n\n// node_modules/bops/read.js\nvar require_read = __commonJS({\n  \"node_modules/bops/read.js\"(exports2, module2) {\n    var proto = {};\n    var rex = /read.+/;\n    var buildFn;\n    buildFn = function(key2) {\n      var code = \"return buf.\" + key2 + \"(\" + [\"a\", \"b\", \"c\"].join(\",\") + \")\";\n      return new Function([\"buf\", \"a\", \"b\", \"c\"], code);\n    };\n    module2.exports = proto;\n    for (key in Buffer.prototype) {\n      if (rex.test(key)) {\n        proto[key] = buildFn(key);\n      }\n    }\n    var key;\n  }\n});\n\n// node_modules/bops/write.js\nvar require_write = __commonJS({\n  \"node_modules/bops/write.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var proto = {};\n    var rex = /write.+/;\n    var buildFn;\n    buildFn = function(key2) {\n      var code = \"return buf.\" + key2 + \"(\" + [\"a\", \"b\", \"c\"].join(\",\") + \")\";\n      return new Function([\"buf\", \"a\", \"b\", \"c\"], code);\n    };\n    module2.exports = proto;\n    for (key in Buffer2.prototype) {\n      if (rex.test(key)) {\n        proto[key] = buildFn(key);\n      }\n    }\n    var key;\n  }\n});\n\n// node_modules/bops/index.js\nvar require_bops = __commonJS({\n  \"node_modules/bops/index.js\"(exports2, module2) {\n    var proto = {};\n    module2.exports = proto;\n    proto.from = require_from();\n    proto.to = require_to();\n    proto.is = require_is();\n    proto.subarray = require_subarray();\n    proto.join = require_join();\n    proto.copy = require_copy();\n    proto.create = require_create();\n    mix(require_read(), proto);\n    mix(require_write(), proto);\n    function mix(from, into) {\n      for (var key in from) {\n        into[key] = from[key];\n      }\n    }\n  }\n});\n\n// node_modules/@ably/msgpack-js/msgpack.js\nvar require_msgpack = __commonJS({\n  \"node_modules/@ably/msgpack-js/msgpack.js\"(exports2) {\n    \"use strict\";\n    var bops = require_bops();\n    exports2.encode = function(value, sparse) {\n      var size = sizeof(value, sparse);\n      if (size == 0)\n        return void 0;\n      var buffer = bops.create(size);\n      encode2(value, buffer, 0, sparse);\n      return buffer;\n    };\n    exports2.decode = decode2;\n    var SH_L_32 = (1 << 16) * (1 << 16);\n    var SH_R_32 = 1 / SH_L_32;\n    function readInt64BE(buf, offset) {\n      offset = offset || 0;\n      return buf.readInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n    }\n    function readUInt64BE(buf, offset) {\n      offset = offset || 0;\n      return buf.readUInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n    }\n    function writeInt64BE(buf, val, offset) {\n      if (val < 9223372036854776e3) {\n        buf.writeInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n      } else {\n        buf.writeUInt32BE(2147483647, offset);\n        buf.writeUInt32BE(4294967295, offset + 4);\n      }\n    }\n    function writeUInt64BE(buf, val, offset) {\n      if (val < 18446744073709552e3) {\n        buf.writeUInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n      } else {\n        buf.writeUInt32BE(4294967295, offset);\n        buf.writeUInt32BE(4294967295, offset + 4);\n      }\n    }\n    function Decoder(buffer, offset) {\n      this.offset = offset || 0;\n      this.buffer = buffer;\n      this.bufferLength = buffer.length;\n    }\n    Decoder.prototype.map = function(length) {\n      if (length * 2 > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a map of length ${length})`);\n      }\n      var value = {};\n      for (var i = 0; i < length; i++) {\n        var key = this.parse();\n        value[key] = this.parse();\n      }\n      return value;\n    };\n    Decoder.prototype.bin = Decoder.prototype.buf = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a binary of length ${length})`);\n      }\n      var value = bops.subarray(this.buffer, this.offset, this.offset + length);\n      this.offset += length;\n      return value;\n    };\n    Decoder.prototype.str = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a string of length ${length})`);\n      }\n      var value = bops.to(bops.subarray(this.buffer, this.offset, this.offset + length));\n      this.offset += length;\n      return value;\n    };\n    Decoder.prototype.array = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced an array of length ${length})`);\n      }\n      var value = new Array(length);\n      for (var i = 0; i < length; i++) {\n        value[i] = this.parse();\n      }\n      return value;\n    };\n    Decoder.prototype.parse = function() {\n      var type = this.buffer[this.offset];\n      var value, length, extType;\n      if (type === void 0) {\n        throw new Error(\"malformed messagepack (referenced offset is outside buffer)\");\n      }\n      if ((type & 128) === 0) {\n        this.offset++;\n        return type;\n      }\n      if ((type & 240) === 128) {\n        length = type & 15;\n        this.offset++;\n        return this.map(length);\n      }\n      if ((type & 240) === 144) {\n        length = type & 15;\n        this.offset++;\n        return this.array(length);\n      }\n      if ((type & 224) === 160) {\n        length = type & 31;\n        this.offset++;\n        return this.str(length);\n      }\n      if ((type & 224) === 224) {\n        value = bops.readInt8(this.buffer, this.offset);\n        this.offset++;\n        return value;\n      }\n      switch (type) {\n        case 192:\n          this.offset++;\n          return null;\n        case 194:\n          this.offset++;\n          return false;\n        case 195:\n          this.offset++;\n          return true;\n        case 196:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return this.bin(length);\n        case 197:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.bin(length);\n        case 198:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.bin(length);\n        case 199:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 2);\n          this.offset += 3;\n          return [extType, this.bin(length)];\n        case 200:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 3);\n          this.offset += 4;\n          return [extType, this.bin(length)];\n        case 201:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 5);\n          this.offset += 6;\n          return [extType, this.bin(length)];\n        case 202:\n          value = bops.readFloatBE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 203:\n          value = bops.readDoubleBE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 204:\n          value = this.buffer[this.offset + 1];\n          this.offset += 2;\n          return value;\n        case 205:\n          value = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 206:\n          value = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 207:\n          value = readUInt64BE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 208:\n          value = bops.readInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 209:\n          value = bops.readInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 210:\n          value = bops.readInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 211:\n          value = readInt64BE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 212:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          value = bops.readUInt8(this.buffer, this.offset + 2);\n          this.offset += 3;\n          return extType === 0 && value === 0 ? void 0 : [extType, value];\n        case 213:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(2)];\n        case 214:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(4)];\n        case 215:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(8)];\n        case 216:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(16)];\n        case 217:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return this.str(length);\n        case 218:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.str(length);\n        case 219:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.str(length);\n        case 220:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.array(length);\n        case 221:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.array(length);\n        case 222:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.map(length);\n        case 223:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.map(length);\n      }\n      throw new Error(\"Unknown type 0x\" + type.toString(16));\n    };\n    function decode2(buffer) {\n      var decoder = new Decoder(buffer);\n      var value = decoder.parse();\n      if (decoder.offset !== buffer.length)\n        throw new Error(buffer.length - decoder.offset + \" trailing bytes\");\n      return value;\n    }\n    function encodeableKeys(value, sparse) {\n      return Object.keys(value).filter(function(e) {\n        var val = value[e], type = typeof val;\n        return (!sparse || val !== void 0 && val !== null) && (\"function\" !== type || !!val.toJSON);\n      });\n    }\n    function encode2(value, buffer, offset, sparse, isMapElement) {\n      var type = typeof value;\n      var length, size;\n      if (type === \"string\") {\n        value = bops.from(value);\n        length = value.length;\n        if (length < 32) {\n          buffer[offset] = length | 160;\n          bops.copy(value, buffer, offset + 1);\n          return 1 + length;\n        }\n        if (length < 256) {\n          buffer[offset] = 217;\n          bops.writeUInt8(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 2);\n          return 2 + length;\n        }\n        if (length < 65536) {\n          buffer[offset] = 218;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 3);\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          buffer[offset] = 219;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 5);\n          return 5 + length;\n        }\n      }\n      if (bops.is(value)) {\n        length = value.length;\n        if (length < 256) {\n          buffer[offset] = 196;\n          bops.writeUInt8(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 2);\n          return 2 + length;\n        }\n        if (length < 65536) {\n          buffer[offset] = 197;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 3);\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          buffer[offset] = 198;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 5);\n          return 5 + length;\n        }\n      }\n      if (type === \"number\") {\n        if (Math.floor(value) !== value) {\n          buffer[offset] = 203;\n          bops.writeDoubleBE(buffer, value, offset + 1);\n          return 9;\n        }\n        if (value >= 0) {\n          if (value < 128) {\n            buffer[offset] = value;\n            return 1;\n          }\n          if (value < 256) {\n            buffer[offset] = 204;\n            buffer[offset + 1] = value;\n            return 2;\n          }\n          if (value < 65536) {\n            buffer[offset] = 205;\n            bops.writeUInt16BE(buffer, value, offset + 1);\n            return 3;\n          }\n          if (value < 4294967296) {\n            buffer[offset] = 206;\n            bops.writeUInt32BE(buffer, value, offset + 1);\n            return 5;\n          }\n          if (value < 18446744073709552e3) {\n            buffer[offset] = 207;\n            writeUInt64BE(buffer, value, offset + 1);\n            return 9;\n          }\n          throw new Error(\"Number too big 0x\" + value.toString(16));\n        }\n        if (value >= -32) {\n          bops.writeInt8(buffer, value, offset);\n          return 1;\n        }\n        if (value >= -128) {\n          buffer[offset] = 208;\n          bops.writeInt8(buffer, value, offset + 1);\n          return 2;\n        }\n        if (value >= -32768) {\n          buffer[offset] = 209;\n          bops.writeInt16BE(buffer, value, offset + 1);\n          return 3;\n        }\n        if (value >= -2147483648) {\n          buffer[offset] = 210;\n          bops.writeInt32BE(buffer, value, offset + 1);\n          return 5;\n        }\n        if (value >= -9223372036854776e3) {\n          buffer[offset] = 211;\n          writeInt64BE(buffer, value, offset + 1);\n          return 9;\n        }\n        throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n      }\n      if (type === \"undefined\") {\n        if (sparse && isMapElement)\n          return 0;\n        buffer[offset] = 212;\n        buffer[offset + 1] = 0;\n        buffer[offset + 2] = 0;\n        return 3;\n      }\n      if (value === null) {\n        if (sparse && isMapElement)\n          return 0;\n        buffer[offset] = 192;\n        return 1;\n      }\n      if (type === \"boolean\") {\n        buffer[offset] = value ? 195 : 194;\n        return 1;\n      }\n      if (\"function\" === typeof value.toJSON)\n        return encode2(value.toJSON(), buffer, offset, sparse);\n      if (type === \"object\") {\n        size = 0;\n        var isArray = Array.isArray(value);\n        if (isArray) {\n          length = value.length;\n        } else {\n          var keys = encodeableKeys(value, sparse);\n          length = keys.length;\n        }\n        if (length < 16) {\n          buffer[offset] = length | (isArray ? 144 : 128);\n          size = 1;\n        } else if (length < 65536) {\n          buffer[offset] = isArray ? 220 : 222;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          size = 3;\n        } else if (length < 4294967296) {\n          buffer[offset] = isArray ? 221 : 223;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          size = 5;\n        }\n        if (isArray) {\n          for (var i = 0; i < length; i++) {\n            size += encode2(value[i], buffer, offset + size, sparse);\n          }\n        } else {\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            size += encode2(key, buffer, offset + size);\n            size += encode2(value[key], buffer, offset + size, sparse, true);\n          }\n        }\n        return size;\n      }\n      if (type === \"function\")\n        return void 0;\n      throw new Error(\"Unknown type \" + type);\n    }\n    function sizeof(value, sparse, isMapElement) {\n      var type = typeof value;\n      var length, size;\n      if (type === \"string\") {\n        length = bops.from(value).length;\n        if (length < 32) {\n          return 1 + length;\n        }\n        if (length < 256) {\n          return 2 + length;\n        }\n        if (length < 65536) {\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          return 5 + length;\n        }\n      }\n      if (bops.is(value)) {\n        length = value.length;\n        if (length < 256) {\n          return 2 + length;\n        }\n        if (length < 65536) {\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          return 5 + length;\n        }\n      }\n      if (type === \"number\") {\n        if (Math.floor(value) !== value)\n          return 9;\n        if (value >= 0) {\n          if (value < 128)\n            return 1;\n          if (value < 256)\n            return 2;\n          if (value < 65536)\n            return 3;\n          if (value < 4294967296)\n            return 5;\n          if (value < 18446744073709552e3)\n            return 9;\n          throw new Error(\"Number too big 0x\" + value.toString(16));\n        }\n        if (value >= -32)\n          return 1;\n        if (value >= -128)\n          return 2;\n        if (value >= -32768)\n          return 3;\n        if (value >= -2147483648)\n          return 5;\n        if (value >= -9223372036854776e3)\n          return 9;\n        throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n      }\n      if (type === \"boolean\")\n        return 1;\n      if (value === null)\n        return sparse && isMapElement ? 0 : 1;\n      if (value === void 0)\n        return sparse && isMapElement ? 0 : 3;\n      if (\"function\" === typeof value.toJSON)\n        return sizeof(value.toJSON(), sparse);\n      if (type === \"object\") {\n        size = 0;\n        if (Array.isArray(value)) {\n          length = value.length;\n          for (var i = 0; i < length; i++) {\n            size += sizeof(value[i], sparse);\n          }\n        } else {\n          var keys = encodeableKeys(value, sparse);\n          length = keys.length;\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            size += sizeof(key) + sizeof(value[key], sparse, true);\n          }\n        }\n        if (length < 16) {\n          return 1 + size;\n        }\n        if (length < 65536) {\n          return 3 + size;\n        }\n        if (length < 4294967296) {\n          return 5 + size;\n        }\n        throw new Error(\"Array or object too long 0x\" + length.toString(16));\n      }\n      if (type === \"function\")\n        return 0;\n      throw new Error(\"Unknown type \" + type);\n    }\n  }\n});\n\n// src/common/platform.ts\nvar Platform = class {\n};\n\n// src/common/lib/util/logger.ts\nvar globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\nfunction pad(timeSegment, three) {\n  return `${timeSegment}`.padStart(three ? 3 : 2, \"0\");\n}\nfunction getHandler(logger) {\n  return Platform.Config.logTimestamps ? function(msg) {\n    const time = /* @__PURE__ */ new Date();\n    logger(\n      pad(time.getHours()) + \":\" + pad(time.getMinutes()) + \":\" + pad(time.getSeconds()) + \".\" + pad(time.getMilliseconds(), 1) + \" \" + msg\n    );\n  } : function(msg) {\n    logger(msg);\n  };\n}\nvar getDefaultLoggers = () => {\n  var _a2;\n  let consoleLogger;\n  let errorLogger;\n  if (typeof ((_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) === \"function\") {\n    consoleLogger = function(...args) {\n      console.log.apply(console, args);\n    };\n    errorLogger = console.warn ? function(...args) {\n      console.warn.apply(console, args);\n    } : consoleLogger;\n  } else {\n    consoleLogger = errorLogger = function() {\n    };\n  }\n  return [consoleLogger, errorLogger].map(getHandler);\n};\nvar _Logger = class _Logger {\n  constructor() {\n    this.deprecated = (description, msg) => {\n      this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\n    };\n    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n      the object being serialised if the log level will not output the message */\n    this.shouldLog = (level) => {\n      return level <= this.logLevel;\n    };\n    this.setLog = (level, handler) => {\n      if (level !== void 0)\n        this.logLevel = level;\n      if (handler !== void 0)\n        this.logHandler = this.logErrorHandler = handler;\n    };\n    this.logLevel = _Logger.defaultLogLevel;\n    this.logHandler = _Logger.defaultLogHandler;\n    this.logErrorHandler = _Logger.defaultLogErrorHandler;\n  }\n  static initLogHandlers() {\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\n    this.defaultLogHandler = logHandler;\n    this.defaultLogErrorHandler = logErrorHandler;\n    this.defaultLogger = new _Logger();\n  }\n  /**\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\n   */\n  static logActionNoStrip(logger, level, action, message) {\n    logger.logAction(level, action, message);\n  }\n  logAction(level, action, message) {\n    if (this.shouldLog(level)) {\n      (level === 1 /* Error */ ? this.logErrorHandler : this.logHandler)(\"Ably: \" + action + \": \" + message, level);\n    }\n  }\n  renamedClientOption(oldName, newName) {\n    this.deprecationWarning(\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  renamedMethod(className, oldName, newName) {\n    this.deprecationWarning(\n      `\\`${className}\\`\\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  deprecationWarning(message) {\n    if (this.shouldLog(1 /* Error */)) {\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, 1 /* Error */);\n    }\n  }\n};\n_Logger.defaultLogLevel = 1 /* Error */;\n// public constants\n_Logger.LOG_NONE = 0 /* None */;\n_Logger.LOG_ERROR = 1 /* Error */;\n_Logger.LOG_MAJOR = 2 /* Major */;\n_Logger.LOG_MINOR = 3 /* Minor */;\n_Logger.LOG_MICRO = 4 /* Micro */;\n/* public static functions */\n/**\n * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\n *\n * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you canâ€™t dynamically specify the log level.\n */\n_Logger.logAction = (logger, level, action, message) => {\n  _Logger.logActionNoStrip(logger, level, action, message);\n};\nvar Logger = _Logger;\nvar logger_default = Logger;\n\n// src/common/lib/util/utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Format: () => Format,\n  allSame: () => allSame,\n  allToLowerCase: () => allToLowerCase,\n  allToUpperCase: () => allToUpperCase,\n  arrChooseN: () => arrChooseN,\n  arrDeleteValue: () => arrDeleteValue,\n  arrEquals: () => arrEquals,\n  arrIntersect: () => arrIntersect,\n  arrIntersectOb: () => arrIntersectOb,\n  arrPopRandomElement: () => arrPopRandomElement,\n  arrWithoutValue: () => arrWithoutValue,\n  cheapRandStr: () => cheapRandStr,\n  containsValue: () => containsValue,\n  copy: () => copy,\n  createMissingPluginError: () => createMissingPluginError,\n  dataSizeBytes: () => dataSizeBytes,\n  decodeBody: () => decodeBody,\n  encodeBody: () => encodeBody,\n  ensureArray: () => ensureArray,\n  forInOwnNonNullProperties: () => forInOwnNonNullProperties,\n  getBackoffCoefficient: () => getBackoffCoefficient,\n  getGlobalObject: () => getGlobalObject,\n  getJitterCoefficient: () => getJitterCoefficient,\n  getRetryTime: () => getRetryTime,\n  inherits: () => inherits,\n  inspectBody: () => inspectBody,\n  inspectError: () => inspectError,\n  intersect: () => intersect,\n  isEmpty: () => isEmpty,\n  isErrorInfoOrPartialErrorInfo: () => isErrorInfoOrPartialErrorInfo,\n  isNil: () => isNil,\n  isObject: () => isObject,\n  keysArray: () => keysArray,\n  listenerToAsyncIterator: () => listenerToAsyncIterator,\n  matchDerivedChannel: () => matchDerivedChannel,\n  mixin: () => mixin,\n  parseQueryString: () => parseQueryString,\n  prototypicalClone: () => prototypicalClone,\n  randomString: () => randomString,\n  shallowClone: () => shallowClone,\n  shallowEquals: () => shallowEquals,\n  stringifyValues: () => stringifyValues,\n  throwMissingPluginError: () => throwMissingPluginError,\n  toBase64: () => toBase64,\n  toQueryString: () => toQueryString,\n  valuesArray: () => valuesArray,\n  whenPromiseSettles: () => whenPromiseSettles,\n  withTimeoutAsync: () => withTimeoutAsync\n});\n\n// src/common/lib/types/errorinfo.ts\nfunction toString(err) {\n  let result = \"[\" + err.constructor.name;\n  if (err.message)\n    result += \": \" + err.message;\n  if (err.statusCode)\n    result += \"; statusCode=\" + err.statusCode;\n  if (err.code)\n    result += \"; code=\" + err.code;\n  if (err.cause)\n    result += \"; cause=\" + inspectError(err.cause);\n  if (err.href && !(err.message && err.message.indexOf(\"help.ably.io\") > -1))\n    result += \"; see \" + err.href + \" \";\n  result += \"]\";\n  return result;\n}\nvar ErrorInfo = class _ErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _ErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || typeof code !== \"number\" || typeof statusCode !== \"number\") {\n      throw new Error(\"ErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\nvar PartialErrorInfo = class _PartialErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _PartialErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || !isNil(code) && typeof code !== \"number\" || !isNil(statusCode) && typeof statusCode !== \"number\") {\n      throw new Error(\"PartialErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _PartialErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\n\n// src/common/lib/util/utils.ts\nfunction randomPosn(arrOrStr) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\nfunction mixin(target, ...args) {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\nfunction copy(src) {\n  return mixin({}, src);\n}\nfunction ensureArray(obj) {\n  if (isNil(obj)) {\n    return [];\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\nfunction isObject(ob) {\n  return Object.prototype.toString.call(ob) == \"[object Object]\";\n}\nfunction isEmpty(ob) {\n  for (const prop in ob)\n    return false;\n  return true;\n}\nfunction isNil(arg) {\n  return arg == null;\n}\nfunction shallowClone(ob) {\n  const result = new Object();\n  for (const prop in ob)\n    result[prop] = ob[prop];\n  return result;\n}\nfunction prototypicalClone(ob, ownProperties) {\n  class F {\n  }\n  F.prototype = ob;\n  const result = new F();\n  if (ownProperties)\n    mixin(result, ownProperties);\n  return result;\n}\nvar inherits = function(ctor, superCtor) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\nfunction containsValue(ob, val) {\n  for (const i in ob) {\n    if (ob[i] == val)\n      return true;\n  }\n  return false;\n}\nfunction intersect(arr, ob) {\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\nfunction arrIntersect(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arr2.indexOf(member) != -1)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrIntersectOb(arr, ob) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrDeleteValue(arr, val) {\n  const idx = arr.indexOf(val);\n  const res = idx != -1;\n  if (res)\n    arr.splice(idx, 1);\n  return res;\n}\nfunction arrWithoutValue(arr, val) {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\nfunction keysArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(prop);\n  }\n  return result;\n}\nfunction valuesArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\nfunction forInOwnNonNullProperties(ob, fn) {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\nfunction allSame(arr, prop) {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arr.every(function(item) {\n    return item[prop] === first;\n  });\n}\nvar Format = /* @__PURE__ */ ((Format2) => {\n  Format2[\"msgpack\"] = \"msgpack\";\n  Format2[\"json\"] = \"json\";\n  return Format2;\n})(Format || {});\nfunction arrPopRandomElement(arr) {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\nfunction toQueryString(params) {\n  const parts = [];\n  if (params) {\n    for (const key in params)\n      parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n  return parts.length ? \"?\" + parts.join(\"&\") : \"\";\n}\nfunction stringifyValues(params) {\n  return Object.fromEntries(Object.entries(params).map(([k, v]) => [k, String(v)]));\n}\nfunction parseQueryString(query) {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result = {};\n  while (match = search.exec(query))\n    result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n  return result;\n}\nfunction isErrorInfoOrPartialErrorInfo(err) {\n  return typeof err == \"object\" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\nfunction inspectError(err) {\n  var _a2, _b;\n  if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === \"ErrorInfo\" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === \"PartialErrorInfo\")\n    return err.toString();\n  return Platform.Config.inspect(err);\n}\nfunction inspectBody(body) {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return body.toString();\n  } else if (typeof body === \"string\") {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\nfunction dataSizeBytes(data) {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === \"string\") {\n    return Platform.Config.stringByteSize(data);\n  }\n  if (typeof data === \"number\") {\n    return 8;\n  }\n  if (typeof data === \"boolean\") {\n    return 1;\n  }\n  throw new Error(\n    `Expected input of Utils.dataSizeBytes to be a string, a number, a boolean or a buffer, but was: ${typeof data}`\n  );\n}\nfunction cheapRandStr() {\n  return String(Math.random()).substr(2);\n}\nvar randomString = async (numBytes) => {\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n  return Platform.BufferUtils.base64Encode(buffer);\n};\nfunction arrChooseN(arr, n) {\n  const numItems = Math.min(n, arr.length), mutableArr = arr.slice(), result = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\nfunction whenPromiseSettles(promise, callback) {\n  promise.then((result) => {\n    callback == null ? void 0 : callback(null, result);\n  }).catch((err) => {\n    callback == null ? void 0 : callback(err);\n  });\n}\nfunction decodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.decode(body);\n  }\n  return JSON.parse(String(body));\n}\nfunction encodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.encode(body, true);\n  }\n  return JSON.stringify(body);\n}\nfunction allToLowerCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toLowerCase();\n  });\n}\nfunction allToUpperCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toUpperCase();\n  });\n}\nfunction getBackoffCoefficient(count) {\n  return Math.min((count + 2) / 3, 2);\n}\nfunction getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\nfunction getRetryTime(initialTimeout, retryAttempt) {\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\nfunction getGlobalObject() {\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return self;\n}\nfunction shallowEquals(source, target) {\n  return Object.keys(source).every((key) => source[key] === target[key]) && Object.keys(target).every((key) => target[key] === source[key]);\n}\nfunction matchDerivedChannel(name) {\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/;\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo(\"regex match failed\", 400, 40010);\n  }\n  if (match[2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  return {\n    qualifierParam: match[3] || \"\",\n    channelName: match[4]\n  };\n}\nfunction toBase64(str) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\nfunction arrEquals(a, b) {\n  return a.length === b.length && a.every(function(val, i) {\n    return val === b[i];\n  });\n}\nfunction createMissingPluginError(pluginName) {\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n}\nfunction throwMissingPluginError(pluginName) {\n  throw createMissingPluginError(pluginName);\n}\nasync function withTimeoutAsync(promise, timeout = 5e3, err = \"Timeout expired\") {\n  const e = new ErrorInfo(err, 5e4, 500);\n  return Promise.race([promise, new Promise((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\n}\nfunction listenerToAsyncIterator(registerListener) {\n  return __asyncGenerator(this, null, function* () {\n    const eventQueue = [];\n    let resolveNext = null;\n    const removeListener2 = registerListener((event) => {\n      if (resolveNext) {\n        const resolve = resolveNext;\n        resolveNext = null;\n        resolve(event);\n      } else {\n        eventQueue.push(event);\n      }\n    });\n    try {\n      while (true) {\n        if (eventQueue.length > 0) {\n          yield eventQueue.shift();\n        } else {\n          if (resolveNext) {\n            throw new ErrorInfo(\"Concurrent next() calls are not supported\", 4e4, 400);\n          }\n          const event = yield new __await(new Promise((resolve) => {\n            resolveNext = resolve;\n          }));\n          yield event;\n        }\n      }\n    } finally {\n      removeListener2();\n    }\n  });\n}\n\n// package.json\nvar version = \"2.17.1\";\n\n// src/common/lib/util/defaults.ts\nvar agent = \"ably-js/\" + version;\nvar Defaults = {\n  ENDPOINT: \"main\",\n  ENVIRONMENT: \"\",\n  REST_HOST: \"rest.ably.io\",\n  REALTIME_HOST: \"realtime.ably.io\",\n  FALLBACK_HOSTS: [\n    \"main.a.fallback.ably-realtime.com\",\n    \"main.b.fallback.ably-realtime.com\",\n    \"main.c.fallback.ably-realtime.com\",\n    \"main.d.fallback.ably-realtime.com\",\n    \"main.e.fallback.ably-realtime.com\"\n  ],\n  PORT: 80,\n  TLS_PORT: 443,\n  TIMEOUTS: {\n    /* Documented as options params: */\n    disconnectedRetryTimeout: 15e3,\n    suspendedRetryTimeout: 3e4,\n    /* Undocumented, but part of the api and can be used by customers: */\n    httpRequestTimeout: 1e4,\n    httpMaxRetryDuration: 15e3,\n    channelRetryTimeout: 15e3,\n    fallbackRetryTimeout: 6e5,\n    /* For internal / test use only: */\n    connectionStateTtl: 12e4,\n    realtimeRequestTimeout: 1e4,\n    recvTimeout: 9e4,\n    webSocketConnectTimeout: 1e4,\n    webSocketSlowTimeout: 4e3\n  },\n  httpMaxRetryCount: 3,\n  maxMessageSize: 65536,\n  version,\n  protocolVersion: 5,\n  agent,\n  getPort,\n  getHttpScheme,\n  getPrimaryDomainFromEndpoint,\n  getEndpointFallbackHosts,\n  getFallbackHosts,\n  getHosts,\n  checkHost,\n  objectifyOptions,\n  normaliseOptions,\n  defaultGetHeaders,\n  defaultPostHeaders\n};\nfunction getPort(options, tls) {\n  return tls || options.tls ? options.tlsPort : options.port;\n}\nfunction getHttpScheme(options) {\n  return options.tls ? \"https://\" : \"http://\";\n}\nfunction isFqdnIpOrLocalhost(endpoint) {\n  return endpoint.includes(\".\") || endpoint.includes(\"::\") || endpoint === \"localhost\";\n}\nfunction getPrimaryDomainFromEndpoint(endpoint) {\n  if (isFqdnIpOrLocalhost(endpoint))\n    return endpoint;\n  if (endpoint.startsWith(\"nonprod:\")) {\n    const routingPolicyId = endpoint.replace(\"nonprod:\", \"\");\n    return `${routingPolicyId}.realtime.ably-nonprod.net`;\n  }\n  return `${endpoint}.realtime.ably.net`;\n}\nfunction getEndpointFallbackHosts(endpoint) {\n  if (isFqdnIpOrLocalhost(endpoint))\n    return [];\n  if (endpoint.startsWith(\"nonprod:\")) {\n    const routingPolicyId = endpoint.replace(\"nonprod:\", \"\");\n    return endpointFallbacks(routingPolicyId, \"ably-realtime-nonprod.com\");\n  }\n  return endpointFallbacks(endpoint, \"ably-realtime.com\");\n}\nfunction endpointFallbacks(routingPolicyId, domain) {\n  return [\"a\", \"b\", \"c\", \"d\", \"e\"].map((id) => `${routingPolicyId}.${id}.fallback.${domain}`);\n}\nfunction getFallbackHosts(options) {\n  const fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== \"undefined\" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n  return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\nfunction getHosts(options) {\n  return [options.primaryDomain].concat(getFallbackHosts(options));\n}\nfunction checkHost(host) {\n  if (typeof host !== \"string\") {\n    throw new ErrorInfo(\"host must be a string; was a \" + typeof host, 4e4, 400);\n  }\n  if (!host.length) {\n    throw new ErrorInfo(\"host must not be zero-length\", 4e4, 400);\n  }\n}\nfunction getTimeouts(options) {\n  const timeouts = {};\n  for (const prop in Defaults.TIMEOUTS) {\n    timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];\n  }\n  return timeouts;\n}\nfunction getAgentString(options) {\n  let agentStr = Defaults.agent;\n  if (options.agents) {\n    for (var agent2 in options.agents) {\n      agentStr += \" \" + agent2 + \"/\" + options.agents[agent2];\n    }\n  }\n  return agentStr;\n}\nfunction objectifyOptions(options, allowKeyOrToken, sourceForErrorMessage, logger, modularPluginsToInclude) {\n  if (options === void 0) {\n    const msg = allowKeyOrToken ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token` : `${sourceForErrorMessage} must be initialized with a client options object`;\n    logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n    throw new Error(msg);\n  }\n  let optionsObj;\n  if (typeof options === \"string\") {\n    if (options.indexOf(\":\") == -1) {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\\u2019s \\`token\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { token: options };\n    } else {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\\u2019s \\`key\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { key: options };\n    }\n  } else {\n    optionsObj = options;\n  }\n  if (modularPluginsToInclude) {\n    optionsObj = __spreadProps(__spreadValues({}, optionsObj), { plugins: __spreadValues(__spreadValues({}, modularPluginsToInclude), optionsObj.plugins) });\n  }\n  return optionsObj;\n}\nfunction checkIfClientOptionsAreValid(options) {\n  if (options.endpoint && (options.environment || options.restHost || options.realtimeHost)) {\n    throw new ErrorInfo(\n      \"The `endpoint` option cannot be used in conjunction with the `environment`, `restHost`, or `realtimeHost` options.\",\n      40106,\n      400\n    );\n  }\n  if (options.environment && (options.restHost || options.realtimeHost)) {\n    throw new ErrorInfo(\n      \"The `environment` option cannot be used in conjunction with the `restHost`, or `realtimeHost` options.\",\n      40106,\n      400\n    );\n  }\n}\nfunction normaliseOptions(options, MsgPack, logger) {\n  const loggerToUse = logger != null ? logger : logger_default.defaultLogger;\n  if (options.environment) {\n    loggerToUse.deprecated(\"The `environment` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  if (options.restHost) {\n    loggerToUse.deprecated(\"The `restHost` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  if (options.realtimeHost) {\n    loggerToUse.deprecated(\"The `realtimeHost` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  checkIfClientOptionsAreValid(options);\n  if (typeof options.recover === \"function\" && options.closeOnUnload === true) {\n    logger_default.logAction(\n      loggerToUse,\n      logger_default.LOG_ERROR,\n      \"Defaults.normaliseOptions\",\n      \"closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter\"\n    );\n    options.recover = void 0;\n  }\n  if (!(\"closeOnUnload\" in options)) {\n    options.closeOnUnload = !options.recover;\n  }\n  if (!(\"queueMessages\" in options))\n    options.queueMessages = true;\n  const endpoint = options.endpoint || Defaults.ENDPOINT;\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n    options.fallbackHosts = getEndpointFallbackHosts(options.environment || endpoint);\n  }\n  const primaryDomainFromEnvironment = options.environment && `${options.environment}.realtime.ably.net`;\n  const primaryDomainFromLegacyOptions = options.restHost || options.realtimeHost || primaryDomainFromEnvironment;\n  const primaryDomain = primaryDomainFromLegacyOptions || getPrimaryDomainFromEndpoint(endpoint);\n  (options.fallbackHosts || []).concat(primaryDomain).forEach(checkHost);\n  options.port = options.port || Defaults.PORT;\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n  if (!(\"tls\" in options))\n    options.tls = true;\n  const timeouts = getTimeouts(options);\n  if (MsgPack) {\n    if (\"useBinaryProtocol\" in options) {\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n    } else {\n      options.useBinaryProtocol = Platform.Config.preferBinary;\n    }\n  } else {\n    options.useBinaryProtocol = false;\n  }\n  const headers = {};\n  if (options.clientId) {\n    headers[\"X-Ably-ClientId\"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n  }\n  if (!(\"idempotentRestPublishing\" in options)) {\n    options.idempotentRestPublishing = true;\n  }\n  let connectivityCheckParams = null;\n  let connectivityCheckUrl = options.connectivityCheckUrl;\n  if (options.connectivityCheckUrl) {\n    let [uri, qs] = options.connectivityCheckUrl.split(\"?\");\n    connectivityCheckParams = qs ? parseQueryString(qs) : {};\n    if (uri.indexOf(\"://\") === -1) {\n      uri = \"https://\" + uri;\n    }\n    connectivityCheckUrl = uri;\n  }\n  let wsConnectivityCheckUrl = options.wsConnectivityCheckUrl;\n  if (wsConnectivityCheckUrl && wsConnectivityCheckUrl.indexOf(\"://\") === -1) {\n    wsConnectivityCheckUrl = \"wss://\" + wsConnectivityCheckUrl;\n  }\n  return __spreadProps(__spreadValues({}, options), {\n    primaryDomain,\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\n    timeouts,\n    connectivityCheckParams,\n    connectivityCheckUrl,\n    wsConnectivityCheckUrl,\n    headers\n  });\n}\nfunction normaliseChannelOptions(Crypto2, logger, options) {\n  const channelOptions = options || {};\n  if (channelOptions.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(channelOptions.cipher, logger);\n    channelOptions.cipher = cipher.cipherParams;\n    channelOptions.channelCipher = cipher.cipher;\n  } else if (\"cipher\" in channelOptions) {\n    channelOptions.cipher = void 0;\n    channelOptions.channelCipher = null;\n  }\n  return channelOptions;\n}\nvar contentTypes = {\n  json: \"application/json\",\n  xml: \"application/xml\",\n  html: \"text/html\",\n  msgpack: \"application/x-msgpack\",\n  text: \"text/plain\"\n};\nvar defaultHeadersOptions = {\n  format: \"json\" /* json */,\n  protocolVersion: Defaults.protocolVersion\n};\nfunction defaultGetHeaders(options, { format, protocolVersion = defaultHeadersOptions.protocolVersion } = {}) {\n  const accept = contentTypes[format != null ? format : options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */];\n  return {\n    accept,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nfunction defaultPostHeaders(options, { format, protocolVersion = defaultHeadersOptions.protocolVersion } = {}) {\n  const accept = contentTypes[format != null ? format : options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */];\n  const contentType = accept;\n  return {\n    accept,\n    \"content-type\": contentType,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nvar defaults_default = Defaults;\nfunction getDefaults(platformDefaults) {\n  return Object.assign(Defaults, platformDefaults);\n}\n\n// src/common/lib/util/multicaster.ts\nvar Multicaster = class _Multicaster {\n  // Private constructor; use static Multicaster.create instead\n  constructor(logger, members) {\n    this.logger = logger;\n    this.members = members || [];\n  }\n  call(err, result) {\n    for (const member of this.members) {\n      if (member) {\n        try {\n          member(err, result);\n        } catch (e) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Multicaster multiple callback handler\",\n            \"Unexpected exception: \" + e + \"; stack = \" + e.stack\n          );\n        }\n      }\n    }\n  }\n  push(...args) {\n    this.members.push(...args);\n  }\n  createPromise() {\n    return new Promise((resolve, reject) => {\n      this.push((err, result) => {\n        err ? reject(err) : resolve(result);\n      });\n    });\n  }\n  resolveAll(result) {\n    this.call(null, result);\n  }\n  rejectAll(err) {\n    this.call(err);\n  }\n  static create(logger, members) {\n    const instance = new _Multicaster(logger, members);\n    return Object.assign((err, result) => instance.call(err, result), {\n      push: (fn) => instance.push(fn),\n      createPromise: () => instance.createPromise(),\n      resolveAll: (result) => instance.resolveAll(result),\n      rejectAll: (err) => instance.rejectAll(err)\n    });\n  }\n};\nvar multicaster_default = Multicaster;\n\n// src/common/constants/HttpMethods.ts\nvar HttpMethods = /* @__PURE__ */ ((HttpMethods2) => {\n  HttpMethods2[\"Get\"] = \"get\";\n  HttpMethods2[\"Delete\"] = \"delete\";\n  HttpMethods2[\"Post\"] = \"post\";\n  HttpMethods2[\"Put\"] = \"put\";\n  HttpMethods2[\"Patch\"] = \"patch\";\n  return HttpMethods2;\n})(HttpMethods || {});\nvar HttpMethods_default = HttpMethods;\n\n// src/common/constants/HttpStatusCodes.ts\nvar HttpStatusCodes = /* @__PURE__ */ ((HttpStatusCodes2) => {\n  HttpStatusCodes2[HttpStatusCodes2[\"Success\"] = 200] = \"Success\";\n  HttpStatusCodes2[HttpStatusCodes2[\"NoContent\"] = 204] = \"NoContent\";\n  HttpStatusCodes2[HttpStatusCodes2[\"BadRequest\"] = 400] = \"BadRequest\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Unauthorized\"] = 401] = \"Unauthorized\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Forbidden\"] = 403] = \"Forbidden\";\n  HttpStatusCodes2[HttpStatusCodes2[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n  HttpStatusCodes2[HttpStatusCodes2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  return HttpStatusCodes2;\n})(HttpStatusCodes || {});\nfunction isSuccessCode(statusCode) {\n  return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;\n}\nvar HttpStatusCodes_default = HttpStatusCodes;\n\n// src/common/lib/client/auth.ts\nvar MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction random() {\n  return (\"000000\" + Math.floor(Math.random() * 1e16)).slice(-16);\n}\nfunction isRealtime(client) {\n  return !!client.connection;\n}\nfunction normaliseAuthcallbackError(err) {\n  if (!isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\nvar hmac = (text, key) => {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n  return bufferUtils.base64Encode(digest);\n};\nfunction c14n(capability) {\n  if (!capability)\n    return \"\";\n  if (typeof capability == \"string\")\n    capability = JSON.parse(capability);\n  const c14nCapability = /* @__PURE__ */ Object.create(null);\n  const keys = keysArray(capability, true);\n  if (!keys)\n    return \"\";\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = capability[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\nfunction logAndValidateTokenAuthMethod(authOptions, logger) {\n  if (authOptions.authCallback) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authCallback\");\n  } else if (authOptions.authUrl) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authUrl\");\n  } else if (authOptions.key) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with client-side signing\");\n  } else if (authOptions.tokenDetails) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with supplied token only\");\n  } else {\n    const msg = \"authOptions must include valid authentication parameters\";\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n    throw new Error(msg);\n  }\n}\nfunction basicAuthForced(options) {\n  return \"useTokenAuth\" in options && !options.useTokenAuth;\n}\nfunction useTokenAuth(options) {\n  return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);\n}\nfunction noWayToRenew(options) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\nvar trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\nvar Auth = class {\n  constructor(client, options) {\n    // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n    this.authOptions = {};\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n    if (useTokenAuth(options)) {\n      if (noWayToRenew(options)) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"Auth()\",\n          \"Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams, options);\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    } else {\n      if (!options.key) {\n        const msg = \"No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth()\", \"anonymous, using basic auth\");\n      this._saveBasicOptions(options);\n    }\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async authorize(tokenParams, authOptions) {\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n      throw new ErrorInfo(\"Unable to update auth options with incompatible key\", 40102, 401);\n    }\n    try {\n      let tokenDetails = await this._forceNewToken(tokenParams != null ? tokenParams : null, authOptions != null ? authOptions : null);\n      if (isRealtime(this.client)) {\n        return new Promise((resolve, reject) => {\n          this.client.connection.connectionManager.onAuthUpdated(\n            tokenDetails,\n            (err, tokenDetails2) => err ? reject(err) : resolve(tokenDetails2)\n          );\n        });\n      } else {\n        return tokenDetails;\n      }\n    } catch (err) {\n      if (this.client.connection && err.statusCode === HttpStatusCodes_default.Forbidden) {\n        this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n      }\n      throw err;\n    }\n  }\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  async _forceNewToken(tokenParams, authOptions) {\n    this.tokenDetails = null;\n    this._saveTokenOptions(tokenParams, authOptions);\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    try {\n      return this._ensureValidAuthCredentials(true);\n    } finally {\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n    }\n  }\n  async requestToken(tokenParams, authOptions) {\n    const resolvedAuthOptions = authOptions || this.authOptions;\n    const resolvedTokenParams = tokenParams || copy(this.tokenParams);\n    let tokenRequestCallback, client = this.client;\n    if (resolvedAuthOptions.authCallback) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authCallback\");\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\n    } else if (resolvedAuthOptions.authUrl) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authUrl\");\n      tokenRequestCallback = (params, cb) => {\n        const authHeaders = mixin(\n          { accept: \"application/json, text/plain\" },\n          resolvedAuthOptions.authHeaders\n        );\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === \"post\";\n        let providedQsParams;\n        const queryIdx = resolvedAuthOptions.authUrl.indexOf(\"?\");\n        if (queryIdx > -1) {\n          providedQsParams = parseQueryString(resolvedAuthOptions.authUrl.slice(queryIdx));\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl.slice(0, queryIdx);\n          if (!usePost) {\n            resolvedAuthOptions.authParams = mixin(\n              providedQsParams,\n              resolvedAuthOptions.authParams\n            );\n          }\n        }\n        const authParams = mixin({}, resolvedAuthOptions.authParams || {}, params);\n        const authUrlRequestCallback = (result) => {\n          var _a2, _b;\n          let body = (_a2 = result.body) != null ? _a2 : null;\n          let contentType = null;\n          if (result.error) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received Error: \" + inspectError(result.error)\n            );\n          } else {\n            const contentTypeHeaderOrHeaders = (_b = result.headers[\"content-type\"]) != null ? _b : null;\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\n              contentType = contentTypeHeaderOrHeaders.join(\", \");\n            } else {\n              contentType = contentTypeHeaderOrHeaders;\n            }\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received; content-type: \" + contentType + \"; body: \" + inspectBody(body)\n            );\n          }\n          if (result.error) {\n            cb(result.error, null);\n            return;\n          }\n          if (result.unpacked) {\n            cb(null, body);\n            return;\n          }\n          if (Platform.BufferUtils.isBuffer(body))\n            body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo(\"authUrl response is missing a content-type header\", 40170, 401), null);\n            return;\n          }\n          const json = contentType.indexOf(\"application/json\") > -1, text = contentType.indexOf(\"text/plain\") > -1 || contentType.indexOf(\"application/jwt\") > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                \"authUrl responded with unacceptable content-type \" + contentType + \", should be either text/plain, application/jwt or application/json\",\n                40170,\n                401\n              ),\n              null\n            );\n            return;\n          }\n          if (json) {\n            if (body.length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo(\"authUrl response exceeded max permitted length\", 40170, 401), null);\n              return;\n            }\n            try {\n              body = JSON.parse(body);\n            } catch (e) {\n              cb(\n                new ErrorInfo(\n                  \"Unexpected error processing authURL response; err = \" + e.message,\n                  40170,\n                  401\n                ),\n                null\n              );\n              return;\n            }\n          }\n          cb(null, body, contentType);\n        };\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Auth.requestToken().tokenRequestCallback\",\n          \"Requesting token from \" + resolvedAuthOptions.authUrl + \"; Params: \" + JSON.stringify(authParams) + \"; method: \" + (usePost ? \"POST\" : \"GET\")\n        );\n        if (usePost) {\n          const headers = authHeaders || {};\n          headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n          const body = toQueryString(authParams).slice(1);\n          whenPromiseSettles(\n            this.client.http.doUri(\n              HttpMethods_default.Post,\n              resolvedAuthOptions.authUrl,\n              headers,\n              body,\n              providedQsParams\n            ),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        } else {\n          whenPromiseSettles(\n            this.client.http.doUri(HttpMethods_default.Get, resolvedAuthOptions.authUrl, authHeaders || {}, null, authParams),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        }\n      };\n    } else if (resolvedAuthOptions.key) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth.requestToken()\",\n        \"using token auth with client-side signing\"\n      );\n      tokenRequestCallback = (params, cb) => {\n        whenPromiseSettles(\n          this.createTokenRequest(params, resolvedAuthOptions),\n          (err, result) => cb(err, result != null ? result : null)\n        );\n      };\n    } else {\n      const msg = \"Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)\";\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Auth()\",\n        \"library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n      );\n      throw new ErrorInfo(msg, 40171, 403);\n    }\n    if (\"capability\" in resolvedTokenParams)\n      resolvedTokenParams.capability = c14n(\n        resolvedTokenParams.capability\n      );\n    const tokenRequest = (signedTokenParams, tokenCb) => {\n      const keyName = signedTokenParams.keyName, path = \"/keys/\" + keyName + \"/requestToken\", tokenUri = function(host) {\n        return client.baseUri(host) + path;\n      };\n      const requestHeaders = defaults_default.defaultPostHeaders(this.client.options, { format: \"json\" /* json */ });\n      if (resolvedAuthOptions.requestHeaders)\n        mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Auth.requestToken().requestToken\",\n        \"Sending POST to \" + path + \"; Token params: \" + JSON.stringify(signedTokenParams)\n      );\n      whenPromiseSettles(\n        this.client.http.do(HttpMethods_default.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\n        (err, result) => err ? tokenCb(err) : tokenCb(result.error, result.body, result.unpacked)\n      );\n    };\n    return new Promise((resolve, reject) => {\n      let tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(() => {\n        tokenRequestCallbackTimeoutExpired = true;\n        const msg = \"Token request callback timed out after \" + timeoutLength / 1e3 + \" seconds\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n        reject(new ErrorInfo(msg, 40170, 401));\n      }, timeoutLength);\n      tokenRequestCallback(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\n        if (tokenRequestCallbackTimeoutExpired)\n          return;\n        clearTimeout(tokenRequestCallbackTimeout);\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Auth.requestToken()\",\n            \"token request signing call returned error; err = \" + inspectError(err)\n          );\n          reject(normaliseAuthcallbackError(err));\n          return;\n        }\n        if (typeof tokenRequestOrDetails === \"string\") {\n          if (tokenRequestOrDetails.length === 0) {\n            reject(new ErrorInfo(\"Token string is empty\", 40170, 401));\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n            reject(\n              new ErrorInfo(\n                \"Token string exceeded max permitted length (was \" + tokenRequestOrDetails.length + \" bytes)\",\n                40170,\n                401\n              )\n            );\n          } else if (tokenRequestOrDetails === \"undefined\" || tokenRequestOrDetails === \"null\") {\n            reject(new ErrorInfo(\"Token string was literal null/undefined\", 40170, 401));\n          } else if (tokenRequestOrDetails[0] === \"{\" && !(contentType && contentType.indexOf(\"application/jwt\") > -1)) {\n            reject(\n              new ErrorInfo(\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n                40170,\n                401\n              )\n            );\n          } else {\n            resolve({ token: tokenRequestOrDetails });\n          }\n          return;\n        }\n        if (typeof tokenRequestOrDetails !== \"object\" || tokenRequestOrDetails === null) {\n          const msg = \"Expected token request callback to call back with a token string or token request/details object, but got a \" + typeof tokenRequestOrDetails;\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n          reject(\n            new ErrorInfo(\n              \"Token request/details object exceeded max permitted stringified size (was \" + objectSize + \" bytes)\",\n              40170,\n              401\n            )\n          );\n          return;\n        }\n        if (\"issued\" in tokenRequestOrDetails) {\n          resolve(tokenRequestOrDetails);\n          return;\n        }\n        if (!(\"keyName\" in tokenRequestOrDetails)) {\n          const msg = \"Expected token request callback to call back with a token string, token request object, or token details object\";\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        tokenRequest(tokenRequestOrDetails, (err2, tokenResponse, unpacked) => {\n          if (err2) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Auth.requestToken()\",\n              \"token request API call returned error; err = \" + inspectError(err2)\n            );\n            reject(normaliseAuthcallbackError(err2));\n            return;\n          }\n          if (!unpacked)\n            tokenResponse = JSON.parse(tokenResponse);\n          logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"token received\");\n          resolve(tokenResponse);\n        });\n      });\n    });\n  }\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async createTokenRequest(tokenParams, authOptions) {\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || copy(this.tokenParams);\n    const key = authOptions.key;\n    if (!key) {\n      throw new ErrorInfo(\"No key specified\", 40101, 403);\n    }\n    const keyParts = key.split(\":\"), keyName = keyParts[0], keySecret = keyParts[1];\n    if (!keySecret) {\n      throw new ErrorInfo(\"Invalid key specified\", 40101, 403);\n    }\n    if (tokenParams.clientId === \"\") {\n      throw new ErrorInfo(\"clientId can\\u2019t be an empty string\", 40012, 400);\n    }\n    if (\"capability\" in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n    const request = mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || \"\", ttl = tokenParams.ttl || \"\", capability = tokenParams.capability || \"\";\n    if (!request.timestamp) {\n      request.timestamp = await this._getTimestamp(authOptions && authOptions.queryTime);\n    }\n    const nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;\n    const signText = request.keyName + \"\\n\" + ttl + \"\\n\" + capability + \"\\n\" + clientId + \"\\n\" + timestamp + \"\\n\" + nonce + \"\\n\";\n    request.mac = request.mac || hmac(signText, keySecret);\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getTokenRequest()\", \"generated signed request\");\n    return request;\n  }\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  async getAuthParams() {\n    if (this.method == \"basic\")\n      return { key: this.key };\n    else {\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { access_token: tokenDetails.token };\n    }\n  }\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  async getAuthHeaders() {\n    if (this.method == \"basic\") {\n      return { authorization: \"Basic \" + this.basicKey };\n    } else {\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { authorization: \"Bearer \" + toBase64(tokenDetails.token) };\n    }\n  }\n  _saveBasicOptions(authOptions) {\n    this.method = \"basic\";\n    this.key = authOptions.key;\n    this.basicKey = toBase64(authOptions.key);\n    this.authOptions = authOptions || {};\n    if (\"clientId\" in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n  _saveTokenOptions(tokenParams, authOptions) {\n    this.method = \"token\";\n    if (tokenParams) {\n      this.tokenParams = tokenParams;\n    }\n    if (authOptions) {\n      if (authOptions.token) {\n        authOptions.tokenDetails = typeof authOptions.token === \"string\" ? { token: authOptions.token } : authOptions.token;\n      }\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n      if (\"clientId\" in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n      this.authOptions = authOptions;\n    }\n  }\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  async _ensureValidAuthCredentials(forceSupersede) {\n    const token = this.tokenDetails;\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        throw new ErrorInfo(\n          \"Mismatch between clientId in token (\" + token.clientId + \") and current clientId (\" + this.clientId + \")\",\n          40102,\n          403\n        );\n      }\n      if (!this.client.isTimeOffsetSet() || !token.expires || token.expires >= this.client.getTimestampUsingOffset()) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Auth.getToken()\",\n          \"using cached token; expires = \" + token.expires\n        );\n        return token;\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"deleting expired token\");\n      this.tokenDetails = null;\n    }\n    const promise = (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create(this.logger))).createPromise();\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return promise;\n    }\n    const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();\n    let tokenResponse, caughtError = null;\n    try {\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n    } catch (err) {\n      caughtError = err;\n    }\n    if (this.currentTokenRequestId > tokenRequestId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth._ensureValidAuthCredentials()\",\n        \"Discarding token request response; overtaken by newer one\"\n      );\n      return promise;\n    }\n    this.currentTokenRequestId = null;\n    const multicaster = this.waitingForTokenRequest;\n    this.waitingForTokenRequest = null;\n    if (caughtError) {\n      multicaster == null ? void 0 : multicaster.rejectAll(caughtError);\n      return promise;\n    }\n    multicaster == null ? void 0 : multicaster.resolveAll(this.tokenDetails = tokenResponse);\n    return promise;\n  }\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId) {\n    if (!(typeof clientId === \"string\" || clientId === null)) {\n      throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n    } else if (clientId === \"*\") {\n      throw new ErrorInfo(\n        'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err)\n        throw err;\n    }\n  }\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      const msg = \"Unexpected clientId mismatch: client has \" + this.clientId + \", requested \" + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth._uncheckedSetClientId()\", msg);\n      return err;\n    } else {\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n  _tokenClientIdMismatch(tokenClientId) {\n    return !!(this.clientId && this.clientId !== \"*\" && tokenClientId && tokenClientId !== \"*\" && this.clientId !== tokenClientId);\n  }\n  static isTokenErr(error) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n  revokeTokens(specifiers, options) {\n    return this.client.rest.revokeTokens(specifiers, options);\n  }\n  /**\n   * Same as {@link BaseClient.getTimestamp} but also takes into account {@link Auth.authOptions}\n   */\n  async _getTimestamp(queryTime) {\n    return this.client.getTimestamp(queryTime || !!this.authOptions.queryTime);\n  }\n};\nvar auth_default = Auth;\n\n// src/common/types/http.ts\nfunction paramString(params) {\n  const paramPairs = [];\n  if (params) {\n    for (const needle in params) {\n      paramPairs.push(needle + \"=\" + params[needle]);\n    }\n  }\n  return paramPairs.join(\"&\");\n}\nfunction appendingParams(uri, params) {\n  return uri + (params ? \"?\" : \"\") + paramString(params);\n}\nfunction logResult(result, method, uri, params, logger) {\n  if (result.error) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(uri, params) + \"; Error: \" + inspectError(result.error)\n    );\n  } else {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received; \" + appendingParams(uri, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body\" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + result.body)\n    );\n  }\n}\nfunction logRequest(method, uri, body, params, logger) {\n  if (logger.shouldLog(logger_default.LOG_MICRO)) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Sending; \" + appendingParams(uri, params) + \"; Body\" + (Platform.BufferUtils.isBuffer(body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(body) : \": \" + body)\n    );\n  }\n}\nvar Http = class {\n  constructor(client) {\n    this.client = client;\n    this.platformHttp = new Platform.Http(client);\n    this.checkConnectivity = this.platformHttp.checkConnectivity ? () => this.platformHttp.checkConnectivity() : void 0;\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  get supportsAuthHeaders() {\n    return this.platformHttp.supportsAuthHeaders;\n  }\n  get supportsLinkHeaders() {\n    return this.platformHttp.supportsLinkHeaders;\n  }\n  _getHosts(client) {\n    const connection = client.connection, connectionHost = connection && connection.connectionManager.host;\n    if (connectionHost) {\n      return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));\n    }\n    return defaults_default.getHosts(client.options);\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async do(method, path, headers, body, params) {\n    try {\n      const client = this.client;\n      if (!client) {\n        return { error: new ErrorInfo(\"http.do called without client\", 5e4, 500) };\n      }\n      const uriFromHost = typeof path === \"function\" ? path : function(host) {\n        return client.baseUri(host) + path;\n      };\n      const currentFallback = client._currentFallback;\n      if (currentFallback) {\n        if (currentFallback.validUntil > Date.now()) {\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\n          if (result.error && this.platformHttp.shouldFallback(result.error)) {\n            client._currentFallback = null;\n            return this.do(method, path, headers, body, params);\n          }\n          return result;\n        } else {\n          client._currentFallback = null;\n        }\n      }\n      const hosts = this._getHosts(client);\n      if (hosts.length === 1) {\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\n      }\n      let tryAHostStartedAt = null;\n      const tryAHost = async (candidateHosts, persistOnSuccess) => {\n        const host = candidateHosts.shift();\n        tryAHostStartedAt = tryAHostStartedAt != null ? tryAHostStartedAt : /* @__PURE__ */ new Date();\n        const result = await this.doUri(method, uriFromHost(host), headers, body, params);\n        if (result.error && this.platformHttp.shouldFallback(result.error) && candidateHosts.length) {\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\n            return {\n              error: new ErrorInfo(\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\n                50003,\n                500\n              )\n            };\n          }\n          return tryAHost(candidateHosts, true);\n        }\n        if (persistOnSuccess) {\n          client._currentFallback = {\n            host,\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout\n          };\n        }\n        return result;\n      };\n      return tryAHost(hosts);\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async doUri(method, uri, headers, body, params) {\n    try {\n      logRequest(method, uri, body, params, this.logger);\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\n      if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n        logResult(result, method, uri, params, this.logger);\n      }\n      return result;\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n};\n\n// src/common/lib/util/eventemitter.ts\nfunction callListener(logger, eventThis, listener, args) {\n  try {\n    listener.apply(eventThis, args);\n  } catch (e) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_ERROR,\n      \"EventEmitter.emit()\",\n      \"Unexpected listener exception: \" + e + \"; stack = \" + (e && e.stack)\n    );\n  }\n}\nfunction removeListener(targetListeners, listener, eventFilter) {\n  let listeners;\n  let index;\n  let eventName;\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n    listeners = targetListeners[targetListenersIndex];\n    if (eventFilter) {\n      listeners = listeners[eventFilter];\n    }\n    if (Array.isArray(listeners)) {\n      while ((index = listeners.indexOf(listener)) !== -1) {\n        listeners.splice(index, 1);\n      }\n      if (eventFilter && listeners.length === 0) {\n        delete targetListeners[targetListenersIndex][eventFilter];\n      }\n    } else if (isObject(listeners)) {\n      for (eventName in listeners) {\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\n          removeListener([listeners], listener, eventName);\n        }\n      }\n    }\n  }\n}\nvar EventEmitter = class {\n  constructor(logger) {\n    this.logger = logger;\n    this.any = [];\n    this.events = /* @__PURE__ */ Object.create(null);\n    this.anyOnce = [];\n    this.eventsOnce = /* @__PURE__ */ Object.create(null);\n  }\n  on(...args) {\n    if (args.length === 1) {\n      const listener = args[0];\n      if (typeof listener === \"function\") {\n        this.any.push(listener);\n      } else {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n    }\n    if (args.length === 2) {\n      const [event, listener] = args;\n      if (typeof listener !== \"function\") {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n      if (isNil(event)) {\n        this.any.push(listener);\n      } else if (Array.isArray(event)) {\n        event.forEach((eventName) => {\n          this.on(eventName, listener);\n        });\n      } else {\n        if (typeof event !== \"string\") {\n          throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n        }\n        const listeners = this.events[event] || (this.events[event] = []);\n        listeners.push(listener);\n      }\n    }\n  }\n  off(...args) {\n    if (args.length == 0 || isNil(args[0]) && isNil(args[1])) {\n      this.any = [];\n      this.events = /* @__PURE__ */ Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = /* @__PURE__ */ Object.create(null);\n      return;\n    }\n    const [firstArg, secondArg] = args;\n    let listener = null;\n    let event = null;\n    if (args.length === 1 || !secondArg) {\n      if (typeof firstArg === \"function\") {\n        listener = firstArg;\n      } else {\n        event = firstArg;\n      }\n    } else {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      [event, listener] = [firstArg, secondArg];\n    }\n    if (listener && isNil(event)) {\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n      return;\n    }\n    if (Array.isArray(event)) {\n      event.forEach((eventName) => {\n        this.off(eventName, listener);\n      });\n      return;\n    }\n    if (typeof event !== \"string\") {\n      throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n    }\n    if (listener) {\n      removeListener([this.events, this.eventsOnce], listener, event);\n    } else {\n      delete this.events[event];\n      delete this.eventsOnce[event];\n    }\n  }\n  /**\n   * Get the array of listeners for a given event; excludes once events\n   * @param event (optional) the name of the event, or none for 'any'\n   * @return array of events, or null if none\n   */\n  listeners(event) {\n    if (event) {\n      const listeners = this.events[event] || [];\n      if (this.eventsOnce[event])\n        Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n      return listeners.length ? listeners : null;\n    }\n    return this.any.length ? this.any : null;\n  }\n  /**\n   * Emit an event\n   * @param event the event name\n   * @param args the arguments to pass to the listener\n   */\n  emit(event, ...args) {\n    const eventThis = { event };\n    const listeners = [];\n    if (this.anyOnce.length) {\n      Array.prototype.push.apply(listeners, this.anyOnce);\n      this.anyOnce = [];\n    }\n    if (this.any.length) {\n      Array.prototype.push.apply(listeners, this.any);\n    }\n    const eventsOnceListeners = this.eventsOnce[event];\n    if (eventsOnceListeners) {\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\n      delete this.eventsOnce[event];\n    }\n    const eventsListeners = this.events[event];\n    if (eventsListeners) {\n      Array.prototype.push.apply(listeners, eventsListeners);\n    }\n    listeners.forEach((listener) => {\n      callListener(this.logger, eventThis, listener, args);\n    });\n  }\n  once(...args) {\n    const argCount = args.length;\n    if (argCount === 0 || argCount === 1 && typeof args[0] !== \"function\") {\n      const event = args[0];\n      return new Promise((resolve) => {\n        this.once(event, resolve);\n      });\n    }\n    const [firstArg, secondArg] = args;\n    if (args.length === 1 && typeof firstArg === \"function\") {\n      this.anyOnce.push(firstArg);\n    } else if (isNil(firstArg)) {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      this.anyOnce.push(secondArg);\n    } else if (Array.isArray(firstArg)) {\n      const self2 = this;\n      const listenerWrapper = function() {\n        const innerArgs = Array.prototype.slice.call(arguments);\n        firstArg.forEach(function(eventName) {\n          self2.off(eventName, listenerWrapper);\n        });\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        secondArg.apply(this, innerArgs);\n      };\n      firstArg.forEach(function(eventName) {\n        self2.on(eventName, listenerWrapper);\n      });\n    } else {\n      if (typeof firstArg !== \"string\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n      if (secondArg) {\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        listeners.push(secondArg);\n      }\n    }\n  }\n  /**\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n   * @param targetState the name of the state event to listen to\n   * @param currentState the name of the current state of this object\n   */\n  async whenState(targetState, currentState) {\n    if (typeof targetState !== \"string\" || typeof currentState !== \"string\") {\n      throw new Error(\"whenState requires a valid state String argument\");\n    }\n    if (targetState === currentState) {\n      return null;\n    } else {\n      return this.once(targetState);\n    }\n  }\n};\nvar eventemitter_default = EventEmitter;\n\n// src/common/lib/types/protocolmessagecommon.ts\nvar actions = {\n  HEARTBEAT: 0,\n  ACK: 1,\n  NACK: 2,\n  CONNECT: 3,\n  CONNECTED: 4,\n  DISCONNECT: 5,\n  DISCONNECTED: 6,\n  CLOSE: 7,\n  CLOSED: 8,\n  ERROR: 9,\n  ATTACH: 10,\n  ATTACHED: 11,\n  DETACH: 12,\n  DETACHED: 13,\n  PRESENCE: 14,\n  MESSAGE: 15,\n  SYNC: 16,\n  AUTH: 17,\n  ACTIVATE: 18,\n  OBJECT: 19,\n  OBJECT_SYNC: 20,\n  ANNOTATION: 21\n};\nvar ActionName = [];\nObject.keys(actions).forEach(function(name) {\n  ActionName[actions[name]] = name;\n});\nvar flags = {\n  /* Channel attach state flags */\n  HAS_PRESENCE: 1 << 0,\n  HAS_BACKLOG: 1 << 1,\n  RESUMED: 1 << 2,\n  TRANSIENT: 1 << 4,\n  ATTACH_RESUME: 1 << 5,\n  HAS_OBJECTS: 1 << 7,\n  /* Channel mode flags */\n  PRESENCE: 1 << 16,\n  PUBLISH: 1 << 17,\n  SUBSCRIBE: 1 << 18,\n  PRESENCE_SUBSCRIBE: 1 << 19,\n  ANNOTATION_PUBLISH: 1 << 21,\n  ANNOTATION_SUBSCRIBE: 1 << 22,\n  OBJECT_SUBSCRIBE: 1 << 24,\n  OBJECT_PUBLISH: 1 << 25\n};\nvar flagNames = Object.keys(flags);\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE | flags.ANNOTATION_PUBLISH | flags.ANNOTATION_SUBSCRIBE | flags.OBJECT_SUBSCRIBE | flags.OBJECT_PUBLISH;\nvar channelModes = [\n  \"PRESENCE\",\n  \"PUBLISH\",\n  \"SUBSCRIBE\",\n  \"PRESENCE_SUBSCRIBE\",\n  \"ANNOTATION_PUBLISH\",\n  \"ANNOTATION_SUBSCRIBE\",\n  \"OBJECT_SUBSCRIBE\",\n  \"OBJECT_PUBLISH\"\n];\n\n// src/common/lib/types/basemessage.ts\nfunction normaliseContext(context) {\n  if (!context || !context.channelOptions) {\n    return {\n      channelOptions: context,\n      plugins: {},\n      baseEncodedPreviousPayload: void 0\n    };\n  }\n  return context;\n}\nfunction normalizeCipherOptions(Crypto2, logger, options) {\n  if (options && options.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(options.cipher, logger);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher\n    };\n  }\n  return options != null ? options : {};\n}\nasync function encrypt(msg, cipherOptions) {\n  const { data, encoding } = await encryptData(msg.data, msg.encoding, cipherOptions);\n  msg.data = data;\n  msg.encoding = encoding;\n  return msg;\n}\nasync function encryptData(data, encoding, cipherOptions) {\n  let cipher = cipherOptions.channelCipher;\n  let dataToEncrypt = data;\n  let finalEncoding = encoding ? encoding + \"/\" : \"\";\n  if (!Platform.BufferUtils.isBuffer(dataToEncrypt)) {\n    dataToEncrypt = Platform.BufferUtils.utf8Encode(String(dataToEncrypt));\n    finalEncoding = finalEncoding + \"utf-8/\";\n  }\n  const ciphertext = await cipher.encrypt(dataToEncrypt);\n  finalEncoding = finalEncoding + \"cipher+\" + cipher.algorithm;\n  return {\n    data: ciphertext,\n    encoding: finalEncoding\n  };\n}\nasync function encode(msg, options) {\n  const { data, encoding } = encodeData(msg.data, msg.encoding);\n  msg.data = data;\n  msg.encoding = encoding;\n  if (options != null && options.cipher) {\n    return encrypt(msg, options);\n  } else {\n    return msg;\n  }\n}\nfunction encodeData(data, encoding) {\n  const nativeDataType = typeof data == \"string\" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;\n  if (nativeDataType) {\n    return {\n      data,\n      encoding\n    };\n  }\n  if (isObject(data) || Array.isArray(data)) {\n    return {\n      data: JSON.stringify(data),\n      encoding: encoding ? encoding + \"/json\" : \"json\"\n    };\n  }\n  throw new ErrorInfo(\"Data type is unsupported\", 40013, 400);\n}\nasync function decode(message, inputContext) {\n  const { data, encoding, error } = await decodeData(message.data, message.encoding, inputContext);\n  message.data = data;\n  message.encoding = encoding;\n  if (error) {\n    throw error;\n  }\n}\nasync function decodeData(data, encoding, inputContext) {\n  const context = normaliseContext(inputContext);\n  let lastPayload = data;\n  let decodedData = data;\n  let finalEncoding = encoding;\n  let decodingError;\n  if (encoding) {\n    const xforms = encoding.split(\"/\");\n    let lastProcessedEncodingIndex;\n    let encodingsToProcess = xforms.length;\n    let xform = \"\";\n    try {\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n        if (!match)\n          break;\n        xform = match[1];\n        switch (xform) {\n          case \"base64\":\n            decodedData = Platform.BufferUtils.base64Decode(String(decodedData));\n            if (lastProcessedEncodingIndex == xforms.length) {\n              lastPayload = decodedData;\n            }\n            continue;\n          case \"utf-8\":\n            decodedData = Platform.BufferUtils.utf8Decode(decodedData);\n            continue;\n          case \"json\":\n            decodedData = JSON.parse(decodedData);\n            continue;\n          case \"cipher\":\n            if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {\n              const xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;\n              if (xformAlgorithm != cipher.algorithm) {\n                throw new Error(\"Unable to decrypt message with given cipher; incompatible cipher params\");\n              }\n              decodedData = await cipher.decrypt(decodedData);\n              continue;\n            } else {\n              throw new Error(\"Unable to decrypt message; not an encrypted channel\");\n            }\n          case \"vcdiff\":\n            if (!context.plugins || !context.plugins.vcdiff) {\n              throw new ErrorInfo(\"Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)\", 40019, 400);\n            }\n            if (typeof Uint8Array === \"undefined\") {\n              throw new ErrorInfo(\n                \"Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)\",\n                40020,\n                400\n              );\n            }\n            try {\n              let deltaBase = context.baseEncodedPreviousPayload;\n              if (typeof deltaBase === \"string\") {\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n              }\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase);\n              decodedData = Platform.BufferUtils.toBuffer(decodedData);\n              decodedData = Platform.BufferUtils.arrayBufferViewToBuffer(\n                context.plugins.vcdiff.decode(decodedData, deltaBaseBuffer)\n              );\n              lastPayload = decodedData;\n            } catch (e) {\n              throw new ErrorInfo(\"Vcdiff delta decode failed with \" + e, 40018, 400);\n            }\n            continue;\n          default:\n            throw new Error(\"Unknown encoding\");\n        }\n      }\n    } catch (e) {\n      const err = e;\n      decodingError = new ErrorInfo(\n        `Error processing the ${xform} encoding, decoder returned \\u2018${err.message}\\u2019`,\n        err.code || 40013,\n        400\n      );\n    } finally {\n      finalEncoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join(\"/\");\n    }\n  }\n  if (decodingError) {\n    return {\n      error: decodingError,\n      data: decodedData,\n      encoding: finalEncoding\n    };\n  }\n  context.baseEncodedPreviousPayload = lastPayload;\n  return {\n    data: decodedData,\n    encoding: finalEncoding\n  };\n}\nfunction wireToJSON(...args) {\n  const format = args.length > 0 ? \"json\" /* json */ : \"msgpack\" /* msgpack */;\n  const { data, encoding } = encodeDataForWire(this.data, this.encoding, format);\n  return Object.assign({}, this, { encoding, data });\n}\nfunction encodeDataForWire(data, encoding, format) {\n  if (!data || !Platform.BufferUtils.isBuffer(data)) {\n    return {\n      data,\n      encoding\n    };\n  }\n  if (format === \"msgpack\" /* msgpack */) {\n    return {\n      data: Platform.BufferUtils.toBuffer(data),\n      encoding\n    };\n  }\n  return {\n    data: Platform.BufferUtils.base64Encode(data),\n    encoding: encoding ? encoding + \"/base64\" : \"base64\"\n  };\n}\nvar MessageEncoding = {\n  encryptData,\n  encodeData,\n  encodeDataForWire,\n  decodeData\n};\nfunction populateFieldsFromParent(parent) {\n  const { id, connectionId, timestamp } = parent;\n  let msgs;\n  switch (parent.action) {\n    case actions.MESSAGE: {\n      msgs = parent.messages;\n      break;\n    }\n    case actions.PRESENCE:\n    case actions.SYNC:\n      msgs = parent.presence;\n      break;\n    case actions.ANNOTATION:\n      msgs = parent.annotations;\n      break;\n    case actions.OBJECT:\n    case actions.OBJECT_SYNC:\n      msgs = parent.state;\n      break;\n    default:\n      throw new ErrorInfo(\"Unexpected action \" + parent.action, 4e4, 400);\n  }\n  for (let i = 0; i < msgs.length; i++) {\n    const msg = msgs[i];\n    if (!msg.connectionId) {\n      msg.connectionId = connectionId;\n    }\n    if (!msg.timestamp) {\n      msg.timestamp = timestamp;\n    }\n    if (id && !msg.id) {\n      msg.id = id + \":\" + i;\n    }\n  }\n}\nfunction strMsg(m, cls) {\n  let result = \"[\" + cls;\n  for (const attr in m) {\n    if (attr === \"data\") {\n      if (typeof m.data == \"string\") {\n        result += \"; data=\" + m.data;\n      } else if (Platform.BufferUtils.isBuffer(m.data)) {\n        result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(m.data);\n      } else if (typeof m.data !== \"undefined\") {\n        result += \"; data (json)=\" + JSON.stringify(m.data);\n      }\n    } else if (attr && (attr === \"extras\" || attr === \"operation\")) {\n      result += \"; \" + attr + \"=\" + JSON.stringify(m[attr]);\n    } else if (attr === \"version\") {\n      result += \"; version=\" + JSON.stringify(m[attr]);\n    } else if (attr === \"annotations\") {\n      result += \"; annotations=\" + JSON.stringify(m[attr]);\n    } else if (m[attr] !== void 0) {\n      result += \"; \" + attr + \"=\" + m[attr];\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar BaseMessage = class {\n};\n\n// src/common/lib/client/baseclient.ts\nvar BaseClient = class {\n  constructor(options) {\n    /**\n     * These exports are for use by UMD plugins; reason being so that constructors and static methods can be accessed by these plugins without needing to import the classes directly and result in the class existing in both the plugin and the core library.\n     */\n    this.Platform = Platform;\n    this.ErrorInfo = ErrorInfo;\n    this.Logger = logger_default;\n    this.Defaults = defaults_default;\n    this.Utils = utils_exports;\n    this.EventEmitter = eventemitter_default;\n    this.MessageEncoding = MessageEncoding;\n    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    this._additionalHTTPRequestImplementations = (_a2 = options.plugins) != null ? _a2 : null;\n    this.logger = new logger_default();\n    this.logger.setLog(options.logLevel, options.logHandler);\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"BaseClient()\",\n      \"initialized with clientOptions \" + Platform.Config.inspect(options)\n    );\n    this._MsgPack = (_c = (_b = options.plugins) == null ? void 0 : _b.MsgPack) != null ? _c : null;\n    const normalOptions = this.options = defaults_default.normaliseOptions(options, this._MsgPack, this.logger);\n    if (normalOptions.key) {\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n      if (!keyMatch) {\n        const msg = \"invalid key parameter\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"BaseClient()\", msg);\n        throw new ErrorInfo(msg, 40400, 404);\n      }\n      normalOptions.keyName = keyMatch[1];\n      normalOptions.keySecret = keyMatch[2];\n    }\n    if (\"clientId\" in normalOptions) {\n      if (!(typeof normalOptions.clientId === \"string\" || normalOptions.clientId === null))\n        throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n      else if (normalOptions.clientId === \"*\")\n        throw new ErrorInfo(\n          'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\n          40012,\n          400\n        );\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"BaseClient()\", \"started; version = \" + defaults_default.version);\n    this._currentFallback = null;\n    this.serverTimeOffset = null;\n    this.http = new Http(this);\n    this.auth = new auth_default(this, normalOptions);\n    this._rest = ((_d = options.plugins) == null ? void 0 : _d.Rest) ? new options.plugins.Rest(this) : null;\n    this._Crypto = (_f = (_e = options.plugins) == null ? void 0 : _e.Crypto) != null ? _f : null;\n    this.__FilteredSubscriptions = (_h = (_g = options.plugins) == null ? void 0 : _g.MessageInteractions) != null ? _h : null;\n    this._Annotations = (_j = (_i = options.plugins) == null ? void 0 : _i.Annotations) != null ? _j : null;\n  }\n  get rest() {\n    if (!this._rest) {\n      throwMissingPluginError(\"Rest\");\n    }\n    return this._rest;\n  }\n  get _FilteredSubscriptions() {\n    if (!this.__FilteredSubscriptions) {\n      throwMissingPluginError(\"MessageInteractions\");\n    }\n    return this.__FilteredSubscriptions;\n  }\n  get channels() {\n    return this.rest.channels;\n  }\n  get push() {\n    return this.rest.push;\n  }\n  /** RSH8 */\n  device() {\n    var _a2;\n    if (!((_a2 = this.options.plugins) == null ? void 0 : _a2.Push) || !this.push.LocalDevice) {\n      throwMissingPluginError(\"Push\");\n    }\n    if (!this._device) {\n      this._device = this.push.LocalDevice.load(this);\n    }\n    return this._device;\n  }\n  baseUri(host) {\n    return defaults_default.getHttpScheme(this.options) + host + \":\" + defaults_default.getPort(this.options, false);\n  }\n  async stats(params) {\n    return this.rest.stats(params);\n  }\n  async time(params) {\n    return this.rest.time(params);\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    return this.rest.request(method, path, version2, params, body, customHeaders);\n  }\n  batchPublish(specOrSpecs) {\n    return this.rest.batchPublish(specOrSpecs);\n  }\n  batchPresence(channels) {\n    return this.rest.batchPresence(channels);\n  }\n  setLog(logOptions) {\n    this.logger.setLog(logOptions.level, logOptions.handler);\n  }\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  async getTimestamp(queryTime) {\n    if (!this.isTimeOffsetSet() && queryTime) {\n      return this.time();\n    }\n    return this.getTimestampUsingOffset();\n  }\n  getTimestampUsingOffset() {\n    return Date.now() + (this.serverTimeOffset || 0);\n  }\n  isTimeOffsetSet() {\n    return this.serverTimeOffset !== null;\n  }\n};\nBaseClient.Platform = Platform;\nvar baseclient_default = BaseClient;\n\n// src/common/lib/types/devicedetails.ts\nvar DeviceDetails = class _DeviceDetails {\n  toJSON() {\n    var _a2, _b, _c;\n    return {\n      id: this.id,\n      deviceSecret: this.deviceSecret,\n      platform: this.platform,\n      formFactor: this.formFactor,\n      clientId: this.clientId,\n      metadata: this.metadata,\n      deviceIdentityToken: this.deviceIdentityToken,\n      push: {\n        recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,\n        state: (_b = this.push) == null ? void 0 : _b.state,\n        error: (_c = this.push) == null ? void 0 : _c.error\n      }\n    };\n  }\n  toString() {\n    var _a2, _b, _c, _d;\n    let result = \"[DeviceDetails\";\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.platform)\n      result += \"; platform=\" + this.platform;\n    if (this.formFactor)\n      result += \"; formFactor=\" + this.formFactor;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.metadata)\n      result += \"; metadata=\" + this.metadata;\n    if (this.deviceIdentityToken)\n      result += \"; deviceIdentityToken=\" + JSON.stringify(this.deviceIdentityToken);\n    if ((_a2 = this.push) == null ? void 0 : _a2.recipient)\n      result += \"; push.recipient=\" + JSON.stringify(this.push.recipient);\n    if ((_b = this.push) == null ? void 0 : _b.state)\n      result += \"; push.state=\" + this.push.state;\n    if ((_c = this.push) == null ? void 0 : _c.error)\n      result += \"; push.error=\" + JSON.stringify(this.push.error);\n    if ((_d = this.push) == null ? void 0 : _d.metadata)\n      result += \"; push.metadata=\" + this.push.metadata;\n    result += \"]\";\n    return result;\n  }\n  static toRequestBody(body, MsgPack, format) {\n    return encodeBody(body, MsgPack, format);\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _DeviceDetails.fromValuesArray(body);\n    } else {\n      return _DeviceDetails.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    values.error = values.error && ErrorInfo.fromValues(values.error);\n    return Object.assign(new _DeviceDetails(), values);\n  }\n  static fromLocalDevice(device) {\n    return Object.assign(new _DeviceDetails(), device);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _DeviceDetails.fromValues(values[i]);\n    return result;\n  }\n};\nvar devicedetails_default = DeviceDetails;\n\n// src/common/lib/client/resource.ts\nasync function withAuthDetails(client, headers, params, opCallback) {\n  if (client.http.supportsAuthHeaders) {\n    const authHeaders = await client.auth.getAuthHeaders();\n    return opCallback(mixin(authHeaders, headers), params);\n  } else {\n    const authParams = await client.auth.getAuthParams();\n    return opCallback(headers, mixin(authParams, params));\n  }\n}\nfunction unenvelope(result, MsgPack, format) {\n  if (result.err && !result.body) {\n    return { err: result.err };\n  }\n  if (result.statusCode === HttpStatusCodes_default.NoContent) {\n    return __spreadProps(__spreadValues({}, result), { body: [], unpacked: true });\n  }\n  let body = result.body;\n  if (!result.unpacked) {\n    try {\n      body = decodeBody(body, MsgPack, format);\n    } catch (e) {\n      if (isErrorInfoOrPartialErrorInfo(e)) {\n        return { err: e };\n      } else {\n        return { err: new PartialErrorInfo(inspectError(e), null) };\n      }\n    }\n  }\n  if (!body) {\n    return { err: new PartialErrorInfo(\"unenvelope(): Response body is missing\", null) };\n  }\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body;\n  if (wrappedStatusCode === void 0) {\n    return __spreadProps(__spreadValues({}, result), { body, unpacked: true });\n  }\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n    let wrappedErr = response && response.error || result.err;\n    if (!wrappedErr) {\n      wrappedErr = new Error(\"Error in unenveloping \" + body);\n      wrappedErr.statusCode = wrappedStatusCode;\n    }\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n  }\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n}\nfunction logResult2(result, method, path, params, logger) {\n  if (result.err) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(path, params) + \"; Error: \" + inspectError(result.err)\n    );\n  } else {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received; \" + appendingParams(path, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body: \" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + Platform.Config.inspect(result.body))\n    );\n  }\n}\nvar Resource = class _Resource {\n  static async get(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, throwError != null ? throwError : false);\n  }\n  static async delete(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, throwError);\n  }\n  static async post(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, throwError);\n  }\n  static async patch(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, throwError);\n  }\n  static async put(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, throwError);\n  }\n  static async do(method, client, path, body, headers, params, envelope, throwError) {\n    if (envelope) {\n      (params = params || {})[\"envelope\"] = envelope;\n    }\n    const logger = client.logger;\n    async function doRequest(headers2, params2) {\n      var _a2;\n      if (logger.shouldLog(logger_default.LOG_MICRO)) {\n        let decodedBody = body;\n        if (((_a2 = headers2[\"content-type\"]) == null ? void 0 : _a2.indexOf(\"msgpack\")) > 0) {\n          try {\n            if (!client._MsgPack) {\n              throwMissingPluginError(\"MsgPack\");\n            }\n            decodedBody = client._MsgPack.decode(body);\n          } catch (decodeErr) {\n            logger_default.logAction(\n              logger,\n              logger_default.LOG_MICRO,\n              \"Resource.\" + method + \"()\",\n              \"Sending MsgPack Decoding Error: \" + inspectError(decodeErr)\n            );\n          }\n        }\n        logger_default.logAction(\n          logger,\n          logger_default.LOG_MICRO,\n          \"Resource.\" + method + \"()\",\n          \"Sending; \" + appendingParams(path, params2) + \"; Body: \" + decodedBody\n        );\n      }\n      const httpResult = await client.http.do(method, path, headers2, body, params2);\n      if (httpResult.error && auth_default.isTokenErr(httpResult.error)) {\n        await client.auth.authorize(null, null);\n        return withAuthDetails(client, headers2, params2, doRequest);\n      }\n      return {\n        err: httpResult.error,\n        body: httpResult.body,\n        headers: httpResult.headers,\n        unpacked: httpResult.unpacked,\n        statusCode: httpResult.statusCode\n      };\n    }\n    let result = await withAuthDetails(client, headers, params, doRequest);\n    if (envelope) {\n      result = unenvelope(result, client._MsgPack, envelope);\n    }\n    if (logger.shouldLog(logger_default.LOG_MICRO)) {\n      logResult2(result, method, path, params, logger);\n    }\n    if (throwError) {\n      if (result.err) {\n        throw result.err;\n      } else {\n        const response = __spreadValues({}, result);\n        delete response.err;\n        return response;\n      }\n    }\n    return result;\n  }\n};\nvar resource_default = Resource;\n\n// src/common/lib/client/paginatedresource.ts\nfunction getRelParams(linkUrl) {\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n  return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);\n}\nfunction parseRelLinks(linkHeader) {\n  if (typeof linkHeader == \"string\")\n    linkHeader = linkHeader.split(\",\");\n  const relParams = {};\n  for (let i = 0; i < linkHeader.length; i++) {\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n    if (linkMatch) {\n      const params = getRelParams(linkMatch[1]);\n      if (params)\n        relParams[linkMatch[2]] = params;\n    }\n  }\n  return relParams;\n}\nfunction returnErrOnly(err, body, useHPR) {\n  return !(useHPR && (body || typeof err.code === \"number\"));\n}\nvar PaginatedResource = class {\n  constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {\n    this.client = client;\n    this.path = path;\n    this.headers = headers;\n    this.envelope = envelope != null ? envelope : null;\n    this.bodyHandler = bodyHandler;\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async get(params) {\n    const result = await resource_default.get(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async delete(params) {\n    const result = await resource_default.delete(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async post(params, body) {\n    const result = await resource_default.post(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async put(params, body) {\n    const result = await resource_default.put(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async patch(params, body) {\n    const result = await resource_default.patch(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async handlePage(result) {\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"PaginatedResource.handlePage()\",\n        \"Unexpected error getting resource: err = \" + inspectError(result.err)\n      );\n      throw result.err;\n    }\n    let items, linkHeader, relParams;\n    try {\n      items = result.statusCode == HttpStatusCodes_default.NoContent ? [] : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\n    } catch (e) {\n      throw result.err || e;\n    }\n    if (result.headers && (linkHeader = result.headers[\"Link\"] || result.headers[\"link\"])) {\n      relParams = parseRelLinks(linkHeader);\n    }\n    if (this.useHttpPaginatedResponse) {\n      return new HttpPaginatedResponse(\n        this,\n        items,\n        result.headers || {},\n        result.statusCode,\n        relParams,\n        result.err\n      );\n    } else {\n      return new PaginatedResult(this, items, relParams);\n    }\n  }\n};\nvar PaginatedResult = class {\n  constructor(resource, items, relParams) {\n    this.resource = resource;\n    this.items = items;\n    this._relParams = relParams;\n  }\n  async first() {\n    if (this.hasFirst()) {\n      return this.get(this._relParams.first);\n    }\n    throw new ErrorInfo(\"No link to the first page of results\", 40400, 404);\n  }\n  async current() {\n    if (this.hasCurrent()) {\n      return this.get(this._relParams.current);\n    }\n    throw new ErrorInfo(\"No link to the current page of results\", 40400, 404);\n  }\n  async next() {\n    if (this.hasNext()) {\n      return this.get(this._relParams.next);\n    }\n    return null;\n  }\n  hasFirst() {\n    return this._relParams != null && \"first\" in this._relParams;\n  }\n  hasCurrent() {\n    return this._relParams != null && \"current\" in this._relParams;\n  }\n  hasNext() {\n    return this._relParams != null && \"next\" in this._relParams;\n  }\n  isLast() {\n    return !this.hasNext();\n  }\n  /* We assume that only the initial request can be a POST, and that accessing\n   * the rest of a multipage set of results can always be done with GET */\n  async get(params) {\n    const res = this.resource;\n    const result = await resource_default.get(res.client, res.path, res.headers, params, res.envelope, false);\n    return res.handlePage(result);\n  }\n};\nvar HttpPaginatedResponse = class extends PaginatedResult {\n  constructor(resource, items, headers, statusCode, relParams, err) {\n    super(resource, items, relParams);\n    this.statusCode = statusCode;\n    this.success = statusCode < 300 && statusCode >= 200;\n    this.headers = headers;\n    this.errorCode = err && err.code;\n    this.errorMessage = err && err.message;\n  }\n  toJSON() {\n    return {\n      items: this.items,\n      statusCode: this.statusCode,\n      success: this.success,\n      headers: this.headers,\n      errorCode: this.errorCode,\n      errorMessage: this.errorMessage\n    };\n  }\n};\nvar paginatedresource_default = PaginatedResource;\n\n// src/common/lib/types/pushchannelsubscription.ts\nvar _PushChannelSubscription = class _PushChannelSubscription {\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    return {\n      channel: this.channel,\n      deviceId: this.deviceId,\n      clientId: this.clientId\n    };\n  }\n  toString() {\n    let result = \"[PushChannelSubscription\";\n    if (this.channel)\n      result += \"; channel=\" + this.channel;\n    if (this.deviceId)\n      result += \"; deviceId=\" + this.deviceId;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    result += \"]\";\n    return result;\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _PushChannelSubscription.fromValuesArray(body);\n    } else {\n      return _PushChannelSubscription.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    return Object.assign(new _PushChannelSubscription(), values);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _PushChannelSubscription.fromValues(values[i]);\n    return result;\n  }\n};\n_PushChannelSubscription.toRequestBody = encodeBody;\nvar PushChannelSubscription = _PushChannelSubscription;\nvar pushchannelsubscription_default = PushChannelSubscription;\n\n// src/common/lib/client/push.ts\nvar Push = class {\n  constructor(client) {\n    var _a2;\n    this.client = client;\n    this.admin = new Admin(client);\n    if (Platform.Config.push && ((_a2 = client.options.plugins) == null ? void 0 : _a2.Push)) {\n      this.stateMachine = new client.options.plugins.Push.ActivationStateMachine(client);\n      this.LocalDevice = client.options.plugins.Push.localDeviceFactory(devicedetails_default);\n    }\n  }\n  async activate(registerCallback, updateFailedCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.activatedCallback) {\n        reject(new ErrorInfo(\"Activation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.activatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.updateFailedCallback = updateFailedCallback;\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledActivate(this.stateMachine, registerCallback)\n      );\n    });\n  }\n  async deactivate(deregisterCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.deactivatedCallback) {\n        reject(new ErrorInfo(\"Deactivation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.deactivatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledDeactivate(this.stateMachine, deregisterCallback)\n      );\n    });\n  }\n};\nvar Admin = class {\n  constructor(client) {\n    this.client = client;\n    this.deviceRegistrations = new DeviceRegistrations(client);\n    this.channelSubscriptions = new ChannelSubscriptions(client);\n  }\n  async publish(recipient, payload) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    const body = mixin({ recipient }, payload);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    await resource_default.post(client, \"/push/publish\", requestBody, headers, params, null, true);\n  }\n};\nvar DeviceRegistrations = class {\n  constructor(client) {\n    this.client = client;\n  }\n  async save(device) {\n    const client = this.client;\n    const body = devicedetails_default.fromValues(device);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.put(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(device.id),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async get(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    const response = await resource_default.get(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      {},\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/deviceRegistrations\", headers, envelope, async function(body, headers2, unpacked) {\n      return devicedetails_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async remove(deviceIdOrDetails) {\n    const client = this.client, headers = defaults_default.defaultGetHeaders(client.options), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/deviceRegistrations\", headers, params, null, true);\n  }\n};\nvar ChannelSubscriptions = class _ChannelSubscriptions {\n  constructor(client) {\n    /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n    this.remove = _ChannelSubscriptions.prototype.removeWhere;\n    this.client = client;\n  }\n  async save(subscription) {\n    const client = this.client;\n    const body = pushchannelsubscription_default.fromValues(subscription);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.post(\n      client,\n      \"/push/channelSubscriptions\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return pushchannelsubscription_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/channelSubscriptions\", headers, envelope, async function(body, headers2, unpacked) {\n      return pushchannelsubscription_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/channelSubscriptions\", headers, params, null, true);\n  }\n  async listChannels(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    return new paginatedresource_default(client, \"/push/channels\", headers, envelope, async function(body, headers2, unpacked) {\n      const parsedBody = !unpacked && format ? decodeBody(body, client._MsgPack, format) : body;\n      for (let i = 0; i < parsedBody.length; i++) {\n        parsedBody[i] = String(parsedBody[i]);\n      }\n      return parsedBody;\n    }).get(params);\n  }\n};\nvar push_default = Push;\n\n// src/common/lib/types/presencemessage.ts\nvar actions2 = [\"absent\", \"present\", \"enter\", \"leave\", \"update\"];\nasync function fromEncoded(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wpm = WirePresenceMessage.fromValues(encoded);\n  return wpm.decode(options, logger);\n}\nasync function fromEncodedArray(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded(encoded, channel) {\n  return WirePresenceMessage.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded(encoded, channel);\n    })\n  );\n}\nvar PresenceMessage = class _PresenceMessage extends BaseMessage {\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n   * sent by the connection (usually means a leave event sent 15s after a\n   * disconnection). This is useful because synthesized messages cannot be\n   * compared for newness by id lexicographically - RTP2b1\n   */\n  isSynthesized() {\n    if (!this.id || !this.connectionId) {\n      return true;\n    }\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n  }\n  /* RTP2b2 */\n  parseId() {\n    if (!this.id)\n      throw new Error(\"parseId(): Presence message does not contain an id\");\n    const parts = this.id.split(\":\");\n    return {\n      connectionId: parts[0],\n      msgSerial: parseInt(parts[1], 10),\n      index: parseInt(parts[2], 10)\n    };\n  }\n  async encode(options) {\n    const res = Object.assign(new WirePresenceMessage(), this, {\n      action: actions2.indexOf(this.action || \"present\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _PresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _PresenceMessage.fromValues(v));\n  }\n  static fromData(data) {\n    if (data instanceof _PresenceMessage) {\n      return data;\n    }\n    return _PresenceMessage.fromValues({\n      data\n    });\n  }\n  toString() {\n    return strMsg(this, \"PresenceMessage\");\n  }\n};\nvar WirePresenceMessage = class _WirePresenceMessage extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WirePresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WirePresenceMessage.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new PresenceMessage(), __spreadProps(__spreadValues({}, this), {\n      action: actions2[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WirePresenceMessage.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WirePresenceMessage\");\n  }\n};\nvar presencemessage_default = PresenceMessage;\n\n// src/common/lib/client/restpresence.ts\nvar RestPresence = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  get logger() {\n    return this.channel.logger;\n  }\n  async get(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.get()\", \"channel = \" + this.channel.name);\n    const client = this.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.channel.client.rest.presenceMixin.basePath(this),\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, this.channel);\n      }\n    ).get(params);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.history()\", \"channel = \" + this.channel.name);\n    return this.channel.client.rest.presenceMixin.history(this, params);\n  }\n};\nvar restpresence_default = RestPresence;\n\n// src/common/lib/types/message.ts\nvar actions3 = [\n  \"message.create\",\n  \"message.update\",\n  \"message.delete\",\n  \"meta\",\n  \"message.summary\",\n  \"message.append\"\n];\nfunction stringifyAction(action) {\n  return actions3[action || 0] || \"unknown\";\n}\nfunction getMessageSize(msg) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += dataSizeBytes(msg.data);\n  }\n  return size;\n}\nasync function fromEncoded2(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(options, logger);\n}\nasync function fromEncodedArray2(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded2(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded2(encoded, channel) {\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray2(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded2(encoded, channel);\n    })\n  );\n}\nasync function encodeArray(messages, options) {\n  return Promise.all(messages.map((message) => message.encode(options)));\n}\nvar serialize = encodeBody;\nfunction getMessagesSize(messages) {\n  let msg, total = 0;\n  for (let i = 0; i < messages.length; i++) {\n    msg = messages[i];\n    total += msg.size || (msg.size = getMessageSize(msg));\n  }\n  return total;\n}\nvar Message = class _Message extends BaseMessage {\n  expandFields() {\n    if (!this.version) {\n      this.version = {};\n    }\n    if (!this.version.serial && this.serial) {\n      this.version.serial = this.serial;\n    }\n    if (!this.version.timestamp && this.timestamp) {\n      this.version.timestamp = this.timestamp;\n    }\n    if (!this.annotations) {\n      this.annotations = {\n        summary: {}\n      };\n    } else if (!this.annotations.summary) {\n      this.annotations.summary = {};\n    }\n    if (this.annotations && this.annotations.summary) {\n      for (const [type, summaryEntry] of Object.entries(this.annotations.summary)) {\n        if (type.endsWith(\":distinct.v1\") || type.endsWith(\":unique.v1\") || type.endsWith(\":multiple.v1\")) {\n          for (const [, entry] of Object.entries(summaryEntry)) {\n            if (!entry.clipped) {\n              entry.clipped = false;\n            }\n          }\n        } else if (type.endsWith(\":flag.v1\")) {\n          if (!summaryEntry.clipped) {\n            summaryEntry.clipped = false;\n          }\n        }\n      }\n    }\n  }\n  async encode(options) {\n    const res = Object.assign(new WireMessage(), this, {\n      action: actions3.indexOf(this.action || \"message.create\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _Message(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Message.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Message\");\n  }\n};\nvar WireMessage = class _WireMessage extends BaseMessage {\n  // Overload toJSON() to intercept JSON.stringify()\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireMessage.fromValues(v));\n  }\n  // for contexts where some decoding errors need to be handled specially by the caller\n  async decodeWithErr(inputContext, logger) {\n    const res = Object.assign(new Message(), __spreadProps(__spreadValues({}, this), {\n      action: stringifyAction(this.action)\n    }));\n    let err;\n    try {\n      await decode(res, inputContext);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireMessage.decode()\", inspectError(e));\n      err = e;\n    }\n    res.expandFields();\n    return { decoded: res, err };\n  }\n  async decode(inputContext, logger) {\n    const { decoded } = await this.decodeWithErr(inputContext, logger);\n    return decoded;\n  }\n  toString() {\n    return strMsg(this, \"WireMessage\");\n  }\n};\nvar message_default = Message;\n\n// src/common/lib/client/restchannel.ts\nvar MSG_ID_ENTROPY_BYTES = 9;\nfunction allEmptyIds(messages) {\n  return messages.every(function(message) {\n    return !message.id;\n  });\n}\nvar RestChannel = class {\n  constructor(client, name, channelOptions) {\n    this._annotations = null;\n    var _a2, _b;\n    logger_default.logAction(client.logger, logger_default.LOG_MINOR, \"RestChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.client = client;\n    this.presence = new restpresence_default(this);\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, channelOptions);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RestAnnotations(this);\n    }\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  setOptions(options) {\n    var _a2;\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.history()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.history(this, params);\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null) {\n      messages = [message_default.fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [message_default.fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = message_default.fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    if (!params) {\n      params = {};\n    }\n    const client = this.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, idempotentRestPublishing = client.options.idempotentRestPublishing, headers = defaults_default.defaultPostHeaders(client.options);\n    mixin(headers, options.headers);\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\n      const msgIdBase = await randomString(MSG_ID_ENTROPY_BYTES);\n      messages.forEach(function(message, index) {\n        message.id = msgIdBase + \":\" + index.toString();\n      });\n    }\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages), maxMessageSize = options.maxMessageSize;\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        `Maximum size of messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400\n      );\n    }\n    return this._publish(serialize(wireMessages, client._MsgPack, format), headers, params);\n  }\n  async _publish(requestBody, headers, params) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const { body, unpacked } = await resource_default.post(\n      client,\n      client.rest.channelMixin.basePath(this) + \"/messages\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    const decoded = (unpacked ? body : decodeBody(body, client._MsgPack, format)) || {};\n    delete decoded[\"channel\"];\n    delete decoded[\"messageId\"];\n    return decoded;\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n  async getMessage(serialOrMessage) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.getMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.getMessage(this, serialOrMessage);\n  }\n  async updateMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.updateMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.updateDeleteMessage(this, \"message.update\", message, operation, params);\n  }\n  async deleteMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.deleteMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.updateDeleteMessage(this, \"message.delete\", message, operation, params);\n  }\n  async appendMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.appendMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.updateDeleteMessage(this, \"message.append\", message, operation, params);\n  }\n  async getMessageVersions(serialOrMessage, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.getMessageVersions()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.getMessageVersions(this, serialOrMessage, params);\n  }\n};\nvar restchannel_default = RestChannel;\n\n// src/common/lib/types/stats.ts\nvar Stats = class _Stats {\n  constructor(values) {\n    this.entries = values && values.entries || void 0;\n    this.schema = values && values.schema || void 0;\n    this.appId = values && values.appId || void 0;\n    this.inProgress = values && values.inProgress || void 0;\n    this.unit = values && values.unit || void 0;\n    this.intervalId = values && values.intervalId || void 0;\n  }\n  static fromValues(values) {\n    return new _Stats(values);\n  }\n};\nvar stats_default = Stats;\n\n// src/common/lib/client/restchannelmixin.ts\nvar RestChannelMixin = class {\n  static basePath(channel) {\n    return \"/channels/\" + encodeURIComponent(channel.name);\n  }\n  static history(channel, params) {\n    const client = channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, this.basePath(channel) + \"/messages\", headers, envelope, async function(body, headers2, unpacked) {\n      const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n      return _fromEncodedArray2(decoded, channel);\n    }).get(params);\n  }\n  static async status(channel) {\n    const format = channel.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(channel.client.options);\n    const response = await resource_default.get(\n      channel.client,\n      this.basePath(channel),\n      headers,\n      {},\n      format,\n      true\n    );\n    return response.body;\n  }\n  static async getMessage(channel, serialOrMessage) {\n    const serial = typeof serialOrMessage === \"string\" ? serialOrMessage : serialOrMessage.serial;\n    if (!serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    const client = channel.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    const { body, unpacked } = await resource_default.get(\n      client,\n      this.basePath(channel) + \"/messages/\" + encodeURIComponent(serial),\n      headers,\n      {},\n      null,\n      true\n    );\n    const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n    return _fromEncoded2(decoded, channel);\n  }\n  static async updateDeleteMessage(channel, action, message, operation, params) {\n    if (!message.serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial and cannot be updated. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    const client = channel.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(client.options);\n    mixin(headers, client.options.headers);\n    const requestMessage = message_default.fromValues(message);\n    requestMessage.action = action;\n    requestMessage.version = operation;\n    const encoded = await requestMessage.encode(channel.channelOptions);\n    const requestBody = serialize(encoded, client._MsgPack, format);\n    let method = resource_default.patch;\n    const { body, unpacked } = await method(\n      client,\n      this.basePath(channel) + \"/messages/\" + encodeURIComponent(message.serial),\n      requestBody,\n      headers,\n      params || {},\n      null,\n      true\n    );\n    const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n    return decoded || { versionSerial: null };\n  }\n  static getMessageVersions(channel, serialOrMessage, params) {\n    const serial = typeof serialOrMessage === \"string\" ? serialOrMessage : serialOrMessage.serial;\n    if (!serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    const client = channel.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const envelope = channel.client.http.supportsLinkHeaders ? void 0 : format;\n    const headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.basePath(channel) + \"/messages/\" + encodeURIComponent(serial) + \"/versions\",\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray2(decoded, channel);\n      }\n    ).get(params || {});\n  }\n};\n\n// src/common/lib/client/restpresencemixin.ts\nvar RestPresenceMixin = class {\n  static basePath(presence) {\n    return RestChannelMixin.basePath(presence.channel) + \"/presence\";\n  }\n  static async history(presence, params) {\n    const client = presence.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = presence.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.basePath(presence) + \"/history\",\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, presence.channel);\n      }\n    ).get(params);\n  }\n};\n\n// src/common/lib/client/rest.ts\nvar Rest = class {\n  constructor(client) {\n    this.channelMixin = RestChannelMixin;\n    this.presenceMixin = RestPresenceMixin;\n    // exposed for plugins but shouldn't be bundled with minimal realtime\n    this.Resource = resource_default;\n    this.PaginatedResource = paginatedresource_default;\n    this.DeviceDetails = devicedetails_default;\n    this.PushChannelSubscription = pushchannelsubscription_default;\n    this.client = client;\n    this.channels = new Channels(this.client);\n    this.push = new push_default(this.client);\n  }\n  async stats(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options), format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    mixin(headers, this.client.options.headers);\n    return new paginatedresource_default(this.client, \"/stats\", headers, envelope, async (body, _, unpacked) => {\n      const statsValues = unpacked ? body : decodeBody(body, this.client._MsgPack, format);\n      for (let i = 0; i < statsValues.length; i++)\n        statsValues[i] = stats_default.fromValues(statsValues[i]);\n      return statsValues;\n    }).get(params);\n  }\n  async time(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options, { format: \"json\" /* json */ });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const timeUri = (host) => {\n      return this.client.baseUri(host) + \"/time\";\n    };\n    let { error, body, unpacked } = await this.client.http.do(\n      HttpMethods_default.Get,\n      timeUri,\n      headers,\n      null,\n      params\n    );\n    if (error) {\n      throw error;\n    }\n    if (!unpacked)\n      body = JSON.parse(body);\n    const time = body[0];\n    if (!time) {\n      throw new ErrorInfo(\"Internal error (unexpected result type from GET /time)\", 5e4, 500);\n    }\n    this.client.serverTimeOffset = time - Date.now();\n    return time;\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    var _a2;\n    const [encoder, decoder, format] = (() => {\n      if (this.client.options.useBinaryProtocol) {\n        if (!this.client._MsgPack) {\n          throwMissingPluginError(\"MsgPack\");\n        }\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, \"msgpack\" /* msgpack */];\n      } else {\n        return [JSON.stringify, JSON.parse, \"json\" /* json */];\n      }\n    })();\n    const envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    params = params || {};\n    const _method = method.toLowerCase();\n    const headers = _method == \"get\" ? defaults_default.defaultGetHeaders(this.client.options, { format, protocolVersion: version2 }) : defaults_default.defaultPostHeaders(this.client.options, { format, protocolVersion: version2 });\n    if (typeof body !== \"string\") {\n      body = (_a2 = encoder(body)) != null ? _a2 : null;\n    }\n    mixin(headers, this.client.options.headers);\n    if (customHeaders) {\n      mixin(headers, customHeaders);\n    }\n    const paginatedResource = new paginatedresource_default(\n      this.client,\n      path,\n      headers,\n      envelope,\n      async function(resbody, headers2, unpacked) {\n        return ensureArray(unpacked ? resbody : decoder(resbody));\n      },\n      /* useHttpPaginatedResponse: */\n      true\n    );\n    if (!Platform.Http.methods.includes(_method)) {\n      throw new ErrorInfo(\"Unsupported method \" + _method, 40500, 405);\n    }\n    if (Platform.Http.methodsWithBody.includes(_method)) {\n      return paginatedResource[_method](params, body);\n    } else {\n      return paginatedResource[_method](params);\n    }\n  }\n  async batchPublish(specOrSpecs) {\n    let requestBodyDTO;\n    let singleSpecMode;\n    if (Array.isArray(specOrSpecs)) {\n      requestBodyDTO = specOrSpecs;\n      singleSpecMode = false;\n    } else {\n      requestBodyDTO = [specOrSpecs];\n      singleSpecMode = true;\n    }\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(this.client, \"/messages\", requestBody, headers, {}, null, true);\n    const batchResults = response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n    if (singleSpecMode) {\n      return batchResults[0];\n    } else {\n      return batchResults;\n    }\n  }\n  async batchPresence(channels) {\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const channelsParam = channels.join(\",\");\n    const response = await resource_default.get(this.client, \"/presence\", headers, { channels: channelsParam }, null, true);\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n  async revokeTokens(specifiers, options) {\n    if (useTokenAuth(this.client.options)) {\n      throw new ErrorInfo(\"Cannot revoke tokens when using token auth\", 40162, 401);\n    }\n    const keyName = this.client.options.keyName;\n    let resolvedOptions = options != null ? options : {};\n    const requestBodyDTO = __spreadValues({\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`)\n    }, resolvedOptions);\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(\n      this.client,\n      `/keys/${keyName}/revokeTokens`,\n      requestBody,\n      headers,\n      {},\n      null,\n      true\n    );\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n};\nvar Channels = class {\n  constructor(client) {\n    this.client = client;\n    this.all = /* @__PURE__ */ Object.create(null);\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      this.all[name] = channel = new restchannel_default(this.client, name, channelOptions);\n    } else if (channelOptions) {\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    delete this.all[String(name)];\n  }\n};\n\n// src/common/lib/client/baserest.ts\nvar BaseRest = class extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    super(defaults_default.objectifyOptions(options, false, \"BaseRest\", logger_default.defaultLogger, { Rest }));\n  }\n};\n\n// src/common/lib/client/modularplugins.ts\nvar allCommonModularPlugins = { Rest };\n\n// src/common/lib/types/defaultmessage.ts\nvar DefaultMessage = class extends message_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded2(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray2(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return message_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/defaultpresencemessage.ts\nvar DefaultPresenceMessage = class extends presencemessage_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return presencemessage_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/annotation.ts\nvar actions4 = [\"annotation.create\", \"annotation.delete\"];\nasync function fromEncoded3(logger, encoded, options) {\n  const wa = WireAnnotation.fromValues(encoded);\n  return wa.decode(options || {}, logger);\n}\nasync function fromEncodedArray3(logger, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded3(logger, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded3(encoded, channel) {\n  return WireAnnotation.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray3(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded3(encoded, channel);\n    })\n  );\n}\nvar Annotation = class _Annotation extends BaseMessage {\n  async encode() {\n    const res = Object.assign(new WireAnnotation(), this, {\n      action: actions4.indexOf(this.action || \"annotation.create\")\n    });\n    return encode(res, {});\n  }\n  static fromValues(values) {\n    return Object.assign(new _Annotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Annotation.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Annotation\");\n  }\n};\nvar WireAnnotation = class _WireAnnotation extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireAnnotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireAnnotation.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new Annotation(), __spreadProps(__spreadValues({}, this), {\n      action: actions4[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireAnnotation.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WireAnnotation\");\n  }\n};\nvar annotation_default = Annotation;\n\n// src/common/lib/types/defaultannotation.ts\nvar DefaultAnnotation = class extends annotation_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded3(logger_default.defaultLogger, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray3(logger_default.defaultLogger, encodedArray, options);\n  }\n  static fromValues(values) {\n    return annotation_default.fromValues(values);\n  }\n};\n\n// src/common/lib/client/restannotations.ts\nfunction serialFromMsgOrSerial(msgOrSerial) {\n  let messageSerial;\n  switch (typeof msgOrSerial) {\n    case \"string\":\n      messageSerial = msgOrSerial;\n      break;\n    case \"object\":\n      messageSerial = msgOrSerial.serial;\n      break;\n  }\n  if (!messageSerial || typeof messageSerial !== \"string\") {\n    throw new ErrorInfo(\n      \"First argument of annotations.publish() must be either a Message (or at least an object with a string `serial` property) or a message serial (string)\",\n      40003,\n      400\n    );\n  }\n  return messageSerial;\n}\nfunction constructValidateAnnotation(msgOrSerial, annotationValues) {\n  const messageSerial = serialFromMsgOrSerial(msgOrSerial);\n  if (!annotationValues || typeof annotationValues !== \"object\") {\n    throw new ErrorInfo(\n      \"Second argument of annotations.publish() must be an object (the intended annotation to publish)\",\n      40003,\n      400\n    );\n  }\n  const annotation = annotation_default.fromValues(annotationValues);\n  annotation.messageSerial = messageSerial;\n  if (!annotation.action) {\n    annotation.action = \"annotation.create\";\n  }\n  return annotation;\n}\nfunction basePathForSerial(channel, serial) {\n  return channel.client.rest.channelMixin.basePath(channel) + \"/messages/\" + encodeURIComponent(serial) + \"/annotations\";\n}\nvar RestAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    const client = this.channel.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    mixin(headers, client.options.headers);\n    const requestBody = encodeBody([wireAnnotation], client._MsgPack, format);\n    await resource_default.post(\n      client,\n      basePathForSerial(this.channel, annotation.messageSerial),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    return this.publish(msgOrSerial, annotationValues);\n  }\n  async get(msgOrSerial, params) {\n    const client = this.channel.client, messageSerial = serialFromMsgOrSerial(msgOrSerial), format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      basePathForSerial(this.channel, messageSerial),\n      headers,\n      envelope,\n      async (body, _, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray3(decoded, this.channel);\n      }\n    ).get(params);\n  }\n};\nvar restannotations_default = RestAnnotations;\n\n// src/common/lib/types/protocolmessage.ts\nvar serialize2 = encodeBody;\nfunction toStringArray(array) {\n  const result = [];\n  if (array) {\n    for (let i = 0; i < array.length; i++) {\n      result.push(array[i].toString());\n    }\n  }\n  return \"[ \" + result.join(\", \") + \" ]\";\n}\nfunction deserialize(serialized, MsgPack, presenceMessagePlugin, annotationsPlugin, objectsPlugin, format) {\n  const deserialized = decodeBody(serialized, MsgPack, format);\n  return fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin, objectsPlugin);\n}\nfunction fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin, objectsPlugin) {\n  let error;\n  if (deserialized.error) {\n    error = ErrorInfo.fromValues(deserialized.error);\n  }\n  let messages;\n  if (deserialized.messages) {\n    messages = WireMessage.fromValuesArray(deserialized.messages);\n  }\n  let presence;\n  if (presenceMessagePlugin && deserialized.presence) {\n    presence = presenceMessagePlugin.WirePresenceMessage.fromValuesArray(\n      deserialized.presence\n    );\n  }\n  let annotations;\n  if (annotationsPlugin && deserialized.annotations) {\n    annotations = annotationsPlugin.WireAnnotation.fromValuesArray(\n      deserialized.annotations\n    );\n  }\n  let state;\n  if (objectsPlugin && deserialized.state) {\n    state = objectsPlugin.WireObjectMessage.fromValuesArray(\n      deserialized.state,\n      utils_exports,\n      MessageEncoding\n    );\n  }\n  return Object.assign(new ProtocolMessage(), __spreadProps(__spreadValues({}, deserialized), { presence, messages, annotations, state, error }));\n}\nfunction makeFromDeserializedWithDependencies(dependencies) {\n  return (deserialized) => {\n    var _a2;\n    return fromDeserialized(\n      deserialized,\n      {\n        PresenceMessage: presencemessage_default,\n        WirePresenceMessage\n      },\n      { Annotation: annotation_default, WireAnnotation, RealtimeAnnotations: realtimeannotations_default, RestAnnotations: restannotations_default },\n      (_a2 = dependencies == null ? void 0 : dependencies.LiveObjectsPlugin) != null ? _a2 : null\n    );\n  };\n}\nfunction fromValues(values) {\n  return Object.assign(new ProtocolMessage(), values);\n}\nfunction stringify(msg, presenceMessagePlugin, annotationsPlugin, objectsPlugin) {\n  let result = \"[ProtocolMessage\";\n  if (msg.action !== void 0)\n    result += \"; action=\" + ActionName[msg.action] || 0;\n  const simpleAttributes = [\"id\", \"channel\", \"channelSerial\", \"connectionId\", \"count\", \"msgSerial\", \"timestamp\"];\n  let attribute;\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n    attribute = simpleAttributes[attribIndex];\n    if (msg[attribute] !== void 0)\n      result += \"; \" + attribute + \"=\" + msg[attribute];\n  }\n  if (msg.messages)\n    result += \"; messages=\" + toStringArray(WireMessage.fromValuesArray(msg.messages));\n  if (msg.presence && presenceMessagePlugin)\n    result += \"; presence=\" + toStringArray(presenceMessagePlugin.WirePresenceMessage.fromValuesArray(msg.presence));\n  if (msg.annotations && annotationsPlugin) {\n    result += \"; annotations=\" + toStringArray(annotationsPlugin.WireAnnotation.fromValuesArray(msg.annotations));\n  }\n  if (msg.state && objectsPlugin) {\n    result += \"; state=\" + toStringArray(objectsPlugin.WireObjectMessage.fromValuesArray(msg.state, utils_exports, MessageEncoding));\n  }\n  if (msg.error)\n    result += \"; error=\" + ErrorInfo.fromValues(msg.error).toString();\n  if (msg.auth && msg.auth.accessToken)\n    result += \"; token=\" + msg.auth.accessToken;\n  if (msg.flags)\n    result += \"; flags=\" + flagNames.filter(msg.hasFlag).join(\",\");\n  if (msg.params) {\n    let stringifiedParams = \"\";\n    forInOwnNonNullProperties(msg.params, function(prop) {\n      if (stringifiedParams.length > 0) {\n        stringifiedParams += \"; \";\n      }\n      stringifiedParams += prop + \"=\" + msg.params[prop];\n    });\n    if (stringifiedParams.length > 0) {\n      result += \"; params=[\" + stringifiedParams + \"]\";\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar ProtocolMessage = class {\n  constructor() {\n    this.hasFlag = (flag) => {\n      return (this.flags & flags[flag]) > 0;\n    };\n  }\n  setFlag(flag) {\n    return this.flags = this.flags | flags[flag];\n  }\n  getMode() {\n    return (this.flags || 0) & flags.MODE_ALL;\n  }\n  encodeModesToFlags(modes) {\n    modes.forEach((mode) => this.setFlag(mode));\n  }\n  decodeModesFromFlags() {\n    const modes = [];\n    channelModes.forEach((mode) => {\n      if (this.hasFlag(mode)) {\n        modes.push(mode);\n      }\n    });\n    return modes.length > 0 ? modes : void 0;\n  }\n};\nvar protocolmessage_default = ProtocolMessage;\n\n// src/common/lib/client/channelstatechange.ts\nvar ChannelStateChange = class {\n  constructor(previous, current, resumed, hasBacklog, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (current === \"attached\") {\n      this.resumed = resumed;\n      this.hasBacklog = hasBacklog;\n    }\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar channelstatechange_default = ChannelStateChange;\n\n// src/common/lib/client/realtimechannel.ts\nvar noop = function() {\n};\nfunction validateChannelOptions(options) {\n  if (options && \"params\" in options && !isObject(options.params)) {\n    return new ErrorInfo(\"options.params must be an object\", 4e4, 400);\n  }\n  if (options && \"modes\" in options) {\n    if (!Array.isArray(options.modes)) {\n      return new ErrorInfo(\"options.modes must be an array\", 4e4, 400);\n    }\n    for (let i = 0; i < options.modes.length; i++) {\n      const currentMode = options.modes[i];\n      if (!currentMode || typeof currentMode !== \"string\" || !channelModes.includes(String.prototype.toUpperCase.call(currentMode))) {\n        return new ErrorInfo(\"Invalid channel mode: \" + currentMode, 4e4, 400);\n      }\n    }\n  }\n}\nvar RealtimeChannel = class _RealtimeChannel extends eventemitter_default {\n  constructor(client, name, options) {\n    var _a2, _b, _c;\n    super(client.logger);\n    this._annotations = null;\n    this._mode = 0;\n    this.retryCount = 0;\n    this.history = async function(params) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.history()\", \"channel = \" + this.name);\n      const restMixin = this.client.rest.channelMixin;\n      if (params && params.untilAttach) {\n        if (this.state !== \"attached\") {\n          throw new ErrorInfo(\"option untilAttach requires the channel to be attached\", 4e4, 400);\n        }\n        if (!this.properties.attachSerial) {\n          throw new ErrorInfo(\n            \"untilAttach was specified and channel is attached, but attachSerial is not defined\",\n            4e4,\n            400\n          );\n        }\n        delete params.untilAttach;\n        params.from_serial = this.properties.attachSerial;\n      }\n      return restMixin.history(this, params);\n    };\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, options);\n    this.client = client;\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RealtimeAnnotations(this);\n    }\n    this.connectionManager = client.connection.connectionManager;\n    this.state = \"initialized\";\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.syncChannelSerial = void 0;\n    this.properties = {\n      attachSerial: void 0,\n      channelSerial: void 0\n    };\n    this.setOptions(options);\n    this.errorReason = null;\n    this._attachResume = false;\n    this._decodingContext = {\n      channelOptions: this.channelOptions,\n      plugins: client.options.plugins || {},\n      baseEncodedPreviousPayload: void 0\n    };\n    this._lastPayload = {\n      messageId: null,\n      protocolMessageChannelSerial: null,\n      decodeFailureRecoveryInProgress: null\n    };\n    this._allChannelChanges = new eventemitter_default(this.logger);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n    if ((_c = client.options.plugins) == null ? void 0 : _c.LiveObjects) {\n      this._object = new client.options.plugins.LiveObjects.RealtimeObject(this);\n    }\n  }\n  get presence() {\n    if (!this._presence) {\n      throwMissingPluginError(\"RealtimePresence\");\n    }\n    return this._presence;\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  /** @spec RTL27 */\n  get object() {\n    if (!this._object) {\n      throwMissingPluginError(\"LiveObjects\");\n    }\n    return this._object;\n  }\n  invalidStateError() {\n    return new ErrorInfo(\n      \"Channel operation failed as channel state is \" + this.state,\n      90001,\n      400,\n      this.errorReason || void 0\n    );\n  }\n  static processListenerArgs(args) {\n    args = Array.prototype.slice.call(args);\n    if (typeof args[0] === \"function\") {\n      args.unshift(null);\n    }\n    return args;\n  }\n  async setOptions(options) {\n    var _a2;\n    const previousChannelOptions = this.channelOptions;\n    const err = validateChannelOptions(options);\n    if (err) {\n      throw err;\n    }\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n    if (this._decodingContext)\n      this._decodingContext.channelOptions = this.channelOptions;\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n      this.attachImpl();\n      return new Promise((resolve, reject) => {\n        this._allChannelChanges.once(\n          [\"attached\", \"update\", \"detached\", \"failed\"],\n          function(stateChange) {\n            switch (this.event) {\n              case \"update\":\n              case \"attached\":\n                resolve();\n                break;\n              default:\n                reject(stateChange.reason);\n            }\n          }\n        );\n      });\n    }\n  }\n  _shouldReattachToSetOptions(options, prevOptions) {\n    if (!(this.state === \"attached\" || this.state === \"attaching\")) {\n      return false;\n    }\n    if (options == null ? void 0 : options.params) {\n      const requestedParams = omitAgent(options.params);\n      const existingParams = omitAgent(prevOptions.params);\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n        return true;\n      }\n      if (!shallowEquals(existingParams, requestedParams)) {\n        return true;\n      }\n    }\n    if (options == null ? void 0 : options.modes) {\n      if (!prevOptions.modes || !arrEquals(options.modes, prevOptions.modes)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null || first === void 0) {\n      messages = [message_default.fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [message_default.fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = message_default.fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    const maxMessageSize = this.client.options.maxMessageSize;\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages);\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        `Maximum size of messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400\n      );\n    }\n    this.throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.publish()\",\n      \"sending message; channel state is \" + this.state + \", message count = \" + wireMessages.length\n    );\n    const pm = fromValues({\n      action: actions.MESSAGE,\n      channel: this.name,\n      messages: wireMessages,\n      params: params ? stringifyValues(params) : void 0\n    });\n    const res = await this.sendMessage(pm);\n    return res || { serials: [] };\n  }\n  throwIfUnpublishableState() {\n    if (!this.connectionManager.activeState()) {\n      throw this.connectionManager.getError();\n    }\n    if (this.state === \"failed\" || this.state === \"suspended\") {\n      throw this.invalidStateError();\n    }\n  }\n  onEvent(messages) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.onEvent()\", \"received message\");\n    const subscriptions = this.subscriptions;\n    for (let i = 0; i < messages.length; i++) {\n      const message = messages[i];\n      subscriptions.emit(message.name, message);\n    }\n  }\n  async attach() {\n    if (this.state === \"attached\") {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      this._attach(false, null, (err, result) => err ? reject(err) : resolve(result));\n    });\n  }\n  _attach(forceReattach, attachReason, callback) {\n    if (!callback) {\n      callback = (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"RealtimeChannel._attach()\",\n            \"Channel attach failed: \" + err.toString()\n          );\n        }\n      };\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      callback(connectionManager.getError());\n      return;\n    }\n    if (this.state !== \"attaching\" || forceReattach) {\n      this.requestState(\"attaching\", attachReason);\n    }\n    this.once(function(stateChange) {\n      switch (this.event) {\n        case \"attached\":\n          callback == null ? void 0 : callback(null, stateChange);\n          break;\n        case \"detached\":\n        case \"suspended\":\n        case \"failed\":\n          callback == null ? void 0 : callback(\n            stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to attach; reason unknown; state = \" + this.event, 9e4, 500)\n          );\n          break;\n        case \"detaching\":\n          callback == null ? void 0 : callback(new ErrorInfo(\"Attach request superseded by a subsequent detach request\", 9e4, 409));\n          break;\n      }\n    });\n  }\n  attachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.attachImpl()\", \"sending ATTACH message\");\n    const attachMsg = fromValues({\n      action: actions.ATTACH,\n      channel: this.name,\n      params: this.channelOptions.params,\n      // RTL4c1: Includes the channel serial to resume from a previous message\n      // or attachment.\n      channelSerial: this.properties.channelSerial\n    });\n    if (this.channelOptions.modes) {\n      attachMsg.encodeModesToFlags(allToUpperCase(this.channelOptions.modes));\n    }\n    if (this._attachResume) {\n      attachMsg.setFlag(\"ATTACH_RESUME\");\n    }\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n    }\n    this.sendMessage(attachMsg).catch(noop);\n  }\n  async detach() {\n    const connectionManager = this.connectionManager;\n    switch (this.state) {\n      case \"suspended\":\n        this.notifyState(\"detached\");\n        return;\n      case \"detached\":\n        return;\n      case \"failed\":\n        throw new ErrorInfo(\"Unable to detach; channel state = failed\", 90001, 400);\n      default:\n        if (connectionManager.state.state !== \"connected\") {\n          this.notifyState(\"detached\");\n          return;\n        }\n        this.requestState(\"detaching\");\n      case \"detaching\":\n        return new Promise((resolve, reject) => {\n          this.once(function(stateChange) {\n            switch (this.event) {\n              case \"detached\":\n                resolve();\n                break;\n              case \"attached\":\n              case \"suspended\":\n              case \"failed\":\n                reject(\n                  stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to detach; reason unknown; state = \" + this.event, 9e4, 500)\n                );\n                break;\n              case \"attaching\":\n                reject(new ErrorInfo(\"Detach request superseded by a subsequent attach request\", 9e4, 409));\n                break;\n            }\n          });\n        });\n    }\n  }\n  detachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.detach()\", \"sending DETACH message\");\n    const msg = fromValues({ action: actions.DETACH, channel: this.name });\n    this.sendMessage(msg).catch(noop);\n  }\n  async subscribe(...args) {\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (this.state === \"failed\") {\n      throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n    if (event && typeof event === \"object\" && !Array.isArray(event)) {\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\n    } else {\n      this.subscriptions.on(event, listener);\n    }\n    if (this.channelOptions.attachOnSubscribe !== false) {\n      return this.attach();\n    } else {\n      return null;\n    }\n  }\n  unsubscribe(...args) {\n    var _a2;\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (typeof event === \"object\" && !listener || ((_a2 = this.filteredSubscriptions) == null ? void 0 : _a2.has(listener))) {\n      this.client._FilteredSubscriptions.getAndDeleteFilteredSubscriptions(this, event, listener).forEach((l) => this.subscriptions.off(l));\n      return;\n    }\n    this.subscriptions.off(event, listener);\n  }\n  sync() {\n    switch (this.state) {\n      case \"initialized\":\n      case \"detaching\":\n      case \"detached\":\n        throw new PartialErrorInfo(\"Unable to sync to channel; not attached\", 4e4);\n      default:\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    const syncMessage = fromValues({ action: actions.SYNC, channel: this.name });\n    if (this.syncChannelSerial) {\n      syncMessage.channelSerial = this.syncChannelSerial;\n    }\n    connectionManager.send(syncMessage);\n  }\n  async sendMessage(msg) {\n    return new Promise((resolve, reject) => {\n      this.connectionManager.send(msg, this.client.options.queueMessages, (err, publishResponse) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(publishResponse);\n        }\n      });\n    });\n  }\n  async sendPresence(presence) {\n    const msg = fromValues({\n      action: actions.PRESENCE,\n      channel: this.name,\n      presence\n    });\n    await this.sendMessage(msg);\n  }\n  async sendState(objectMessages) {\n    const msg = fromValues({\n      action: actions.OBJECT,\n      channel: this.name,\n      state: objectMessages\n    });\n    await this.sendMessage(msg);\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\n  async processMessage(message) {\n    if (message.action === actions.ATTACHED || message.action === actions.MESSAGE || message.action === actions.PRESENCE || message.action === actions.OBJECT || message.action === actions.ANNOTATION) {\n      this.setChannelSerial(message.channelSerial);\n    }\n    let syncChannelSerial, isSync = false;\n    switch (message.action) {\n      case actions.ATTACHED: {\n        this.properties.attachSerial = message.channelSerial;\n        this._mode = message.getMode();\n        this.params = message.params || {};\n        const modesFromFlags = message.decodeModesFromFlags();\n        this.modes = modesFromFlags && allToLowerCase(modesFromFlags) || void 0;\n        const resumed = message.hasFlag(\"RESUMED\");\n        const hasPresence = message.hasFlag(\"HAS_PRESENCE\");\n        const hasBacklog = message.hasFlag(\"HAS_BACKLOG\");\n        const hasObjects = message.hasFlag(\"HAS_OBJECTS\");\n        if (this.state === \"attached\") {\n          if (!resumed) {\n            if (this._presence) {\n              this._presence.onAttached(hasPresence);\n            }\n            if (this._object) {\n              this._object.onAttached(hasObjects);\n            }\n          }\n          const change = new channelstatechange_default(this.state, this.state, resumed, hasBacklog, message.error);\n          this._allChannelChanges.emit(\"update\", change);\n          if (!resumed || this.channelOptions.updateOnAttached) {\n            this.emit(\"update\", change);\n          }\n        } else if (this.state === \"detaching\") {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"attached\", message.error, resumed, hasPresence, hasBacklog, hasObjects);\n        }\n        break;\n      }\n      case actions.DETACHED: {\n        const detachErr = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo(\"Channel detached\", 90001, 404);\n        if (this.state === \"detaching\") {\n          this.notifyState(\"detached\", detachErr);\n        } else if (this.state === \"attaching\") {\n          this.notifyState(\"suspended\", detachErr);\n        } else if (this.state === \"attached\" || this.state === \"suspended\") {\n          this.requestState(\"attaching\", detachErr);\n        }\n        break;\n      }\n      case actions.SYNC:\n        isSync = true;\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n        if (!message.presence)\n          break;\n      case actions.PRESENCE: {\n        if (!message.presence) {\n          break;\n        }\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._presence) {\n          const presenceMessages = await Promise.all(\n            message.presence.map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._presence.setPresence(presenceMessages, isSync, syncChannelSerial);\n        }\n        break;\n      }\n      case actions.OBJECT:\n      case actions.OBJECT_SYNC: {\n        if (!this._object || !message.state) {\n          return;\n        }\n        populateFieldsFromParent(message);\n        const format = this.client.connection.connectionManager.getActiveTransportFormat();\n        const objectMessages = message.state.map((om) => om.decode(this.client, format));\n        if (message.action === actions.OBJECT) {\n          this._object.handleObjectMessages(objectMessages);\n        } else {\n          this._object.handleObjectSyncMessages(objectMessages, message.channelSerial);\n        }\n        break;\n      }\n      case actions.MESSAGE: {\n        if (this.state !== \"attached\") {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"RealtimeChannel.processMessage()\",\n            'Message \"' + message.id + '\" skipped as this channel \"' + this.name + '\" state is not \"attached\" (state is \"' + this.state + '\").'\n          );\n          return;\n        }\n        populateFieldsFromParent(message);\n        const encoded = message.messages, firstMessage = encoded[0], lastMessage = encoded[encoded.length - 1];\n        if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {\n          const msg = 'Delta message decode failure - previous message not available for message \"' + message.id + '\" on this channel \"' + this.name + '\".';\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", msg);\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\n          break;\n        }\n        let messages = [];\n        for (let i = 0; i < encoded.length; i++) {\n          const { decoded, err } = await encoded[i].decodeWithErr(this._decodingContext, this.logger);\n          messages[i] = decoded;\n          if (err) {\n            switch (err.code) {\n              case 40018:\n                this._startDecodeFailureRecovery(err);\n                return;\n              case 40019:\n              case 40021:\n                this.notifyState(\"failed\", err);\n                return;\n              default:\n            }\n          }\n        }\n        this._lastPayload.messageId = lastMessage.id;\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n        this.onEvent(messages);\n        break;\n      }\n      case actions.ANNOTATION: {\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._annotations) {\n          const annotations = await Promise.all(\n            (message.annotations || []).map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._annotations._processIncoming(annotations);\n        }\n        break;\n      }\n      case actions.ERROR: {\n        const err = message.error;\n        if (err && err.code == 80016) {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"failed\", ErrorInfo.fromValues(err));\n        }\n        break;\n      }\n      default:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"RealtimeChannel.processMessage()\",\n          \"Protocol error: unrecognised message action (\" + message.action + \")\"\n        );\n    }\n  }\n  _startDecodeFailureRecovery(reason) {\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MAJOR,\n        \"RealtimeChannel.processMessage()\",\n        \"Starting decode failure recovery process.\"\n      );\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\n      this._attach(true, reason, () => {\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\n      });\n    }\n  }\n  onAttached() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.onAttached\",\n      \"activating channel; name = \" + this.name\n    );\n  }\n  notifyState(state, reason, resumed, hasPresence, hasBacklog, hasObjects) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.notifyState\",\n      \"name = \" + this.name + \", current state = \" + this.state + \", notifying state \" + state\n    );\n    this.clearStateTimer();\n    if ([\"detached\", \"suspended\", \"failed\"].includes(state)) {\n      this.properties.channelSerial = null;\n    }\n    if (state === this.state) {\n      return;\n    }\n    if (this._presence) {\n      this._presence.actOnChannelState(state, hasPresence, reason);\n    }\n    if (this._object) {\n      this._object.actOnChannelState(state, hasObjects);\n    }\n    if (state === \"suspended\" && this.connectionManager.state.sendEvents) {\n      this.startRetryTimer();\n    } else {\n      this.cancelRetryTimer();\n    }\n    if (reason) {\n      this.errorReason = reason;\n    }\n    const change = new channelstatechange_default(this.state, state, resumed, hasBacklog, reason);\n    const action = 'Channel state for channel \"' + this.name + '\"';\n    const message = state + (reason ? \"; reason: \" + reason : \"\");\n    if (state === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    if (state !== \"attaching\" && state !== \"suspended\") {\n      this.retryCount = 0;\n    }\n    if (state === \"attached\") {\n      this.onAttached();\n    }\n    if (state === \"attached\") {\n      this._attachResume = true;\n    } else if (state === \"detaching\" || state === \"failed\") {\n      this._attachResume = false;\n    }\n    this.state = state;\n    this._allChannelChanges.emit(state, change);\n    this.emit(state, change);\n  }\n  requestState(state, reason) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.requestState\",\n      \"name = \" + this.name + \", state = \" + state\n    );\n    this.notifyState(state, reason);\n    this.checkPendingState();\n  }\n  checkPendingState() {\n    const cmState = this.connectionManager.state;\n    if (!cmState.sendEvents) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.checkPendingState\",\n        \"sendEvents is false; state is \" + this.connectionManager.state.state\n      );\n      return;\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.checkPendingState\",\n      \"name = \" + this.name + \", state = \" + this.state\n    );\n    switch (this.state) {\n      case \"attaching\":\n        this.startStateTimerIfNotRunning();\n        this.attachImpl();\n        break;\n      case \"detaching\":\n        this.startStateTimerIfNotRunning();\n        this.detachImpl();\n        break;\n      case \"attached\":\n        this.sync();\n        break;\n      default:\n        break;\n    }\n  }\n  timeoutPendingState() {\n    switch (this.state) {\n      case \"attaching\": {\n        const err = new ErrorInfo(\"Channel attach timed out\", 90007, 408);\n        this.notifyState(\"suspended\", err);\n        break;\n      }\n      case \"detaching\": {\n        const err = new ErrorInfo(\"Channel detach timed out\", 90007, 408);\n        this.notifyState(\"attached\", err);\n        break;\n      }\n      default:\n        this.checkPendingState();\n        break;\n    }\n  }\n  startStateTimerIfNotRunning() {\n    if (!this.stateTimer) {\n      this.stateTimer = setTimeout(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel.startStateTimerIfNotRunning\", \"timer expired\");\n        this.stateTimer = null;\n        this.timeoutPendingState();\n      }, this.client.options.timeouts.realtimeRequestTimeout);\n    }\n  }\n  clearStateTimer() {\n    const stateTimer = this.stateTimer;\n    if (stateTimer) {\n      clearTimeout(stateTimer);\n      this.stateTimer = null;\n    }\n  }\n  startRetryTimer() {\n    if (this.retryTimer)\n      return;\n    this.retryCount++;\n    const retryDelay = getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\n    this.retryTimer = setTimeout(() => {\n      if (this.state === \"suspended\" && this.connectionManager.state.sendEvents) {\n        this.retryTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"RealtimeChannel retry timer expired\",\n          \"attempting a new attach\"\n        );\n        this.requestState(\"attaching\");\n      }\n    }, retryDelay);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n  getReleaseErr() {\n    const s = this.state;\n    if (s === \"initialized\" || s === \"detached\" || s === \"failed\") {\n      return null;\n    }\n    return new ErrorInfo(\n      \"Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was \" + s,\n      90001,\n      400\n    );\n  }\n  setChannelSerial(channelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.setChannelSerial()\",\n      \"Updating channel serial; serial = \" + channelSerial + \"; previous = \" + this.properties.channelSerial\n    );\n    if (channelSerial) {\n      this.properties.channelSerial = channelSerial;\n    }\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n  async getMessage(serialOrMessage) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.getMessage()\", \"channel = \" + this.name);\n    const restMixin = this.client.rest.channelMixin;\n    return restMixin.getMessage(this, serialOrMessage);\n  }\n  async updateMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.updateMessage()\", \"channel = \" + this.name);\n    return this.sendUpdate(message, \"message.update\", operation, params);\n  }\n  async deleteMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.deleteMessage()\", \"channel = \" + this.name);\n    return this.sendUpdate(message, \"message.delete\", operation, params);\n  }\n  async appendMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.appendMessage()\", \"channel = \" + this.name);\n    return this.sendUpdate(message, \"message.append\", operation, params);\n  }\n  async sendUpdate(message, action, operation, params) {\n    var _a2, _b;\n    if (!message.serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial and cannot be updated. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    this.throwIfUnpublishableState();\n    const updateDeleteMsg = message_default.fromValues(__spreadProps(__spreadValues({}, message), {\n      action,\n      version: operation\n    }));\n    const wireMessage = await updateDeleteMsg.encode(this.channelOptions);\n    const pm = fromValues({\n      action: actions.MESSAGE,\n      channel: this.name,\n      messages: [wireMessage],\n      params: params ? stringifyValues(params) : void 0\n    });\n    const publishResponse = await this.sendMessage(pm);\n    return { versionSerial: (_b = (_a2 = publishResponse == null ? void 0 : publishResponse.serials) == null ? void 0 : _a2[0]) != null ? _b : null };\n  }\n  async getMessageVersions(serialOrMessage, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.getMessageVersions()\", \"channel = \" + this.name);\n    const restMixin = this.client.rest.channelMixin;\n    return restMixin.getMessageVersions(this, serialOrMessage, params);\n  }\n  /**\n   * Ensures the channel is attached, attaching if necessary.\n   *\n   * This method is intended for use by features like Presence or Objects that need to\n   * implicitly attach the channel when an operation is called (e.g., `presence.get()` per RTP11b,\n   * or `objects.get()`). This guarantees that the corresponding sync sequence will start and\n   * that the operation will resolve for callers even if they did not explicitly attach beforehand.\n   */\n  async ensureAttached() {\n    switch (this.state) {\n      case \"attached\":\n      case \"suspended\":\n        break;\n      case \"initialized\":\n      case \"detached\":\n      case \"detaching\":\n      case \"attaching\":\n        await this.attach();\n        break;\n      case \"failed\":\n      default:\n        throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n  }\n};\nfunction omitAgent(channelParams) {\n  const _a2 = channelParams || {}, { agent: _ } = _a2, paramsWithoutAgent = __objRest(_a2, [\"agent\"]);\n  return paramsWithoutAgent;\n}\nvar realtimechannel_default = RealtimeChannel;\n\n// src/common/lib/client/realtimeannotations.ts\nvar RealtimeAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n    this.logger = channel.logger;\n    this.subscriptions = new eventemitter_default(this.logger);\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const channelName = this.channel.name;\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    this.channel.throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeAnnotations.publish()\",\n      \"channelName = \" + channelName + \", sending annotation with messageSerial = \" + annotation.messageSerial + \", type = \" + annotation.type\n    );\n    const pm = fromValues({\n      action: actions.ANNOTATION,\n      channel: channelName,\n      annotations: [wireAnnotation]\n    });\n    await this.channel.sendMessage(pm);\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    await this.publish(msgOrSerial, annotationValues);\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (this.channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n    if ((this.channel.state === \"attached\" && this.channel._mode & flags.ANNOTATION_SUBSCRIBE) === 0) {\n      throw new ErrorInfo(\n        \"You are trying to add an annotation listener, but you haven't requested the annotation_subscribe channel mode in ChannelOptions, so this won't do anything (we only deliver annotations to clients who have explicitly requested them)\",\n        93001,\n        400\n      );\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n  _processIncoming(annotations) {\n    for (const annotation of annotations) {\n      this.subscriptions.emit(annotation.type || \"\", annotation);\n    }\n  }\n  async get(msgOrSerial, params) {\n    return restannotations_default.prototype.get.call(this, msgOrSerial, params);\n  }\n};\nvar realtimeannotations_default = RealtimeAnnotations;\n\n// src/common/lib/client/defaultrest.ts\nvar _DefaultRest = class _DefaultRest extends BaseRest {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2, _b;\n    const MsgPack = _DefaultRest._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRest._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Rest\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRest.Crypto) != null ? _a2 : void 0,\n        MsgPack: (_b = _DefaultRest._MsgPack) != null ? _b : void 0,\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        }\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRest._Crypto = null;\n_DefaultRest.Message = DefaultMessage;\n_DefaultRest.PresenceMessage = DefaultPresenceMessage;\n_DefaultRest.Annotation = DefaultAnnotation;\n_DefaultRest._MsgPack = null;\n// Used by tests\n_DefaultRest._Http = Http;\nvar DefaultRest = _DefaultRest;\n\n// src/common/lib/transport/messagequeue.ts\nvar MessageQueue = class extends eventemitter_default {\n  constructor(logger) {\n    super(logger);\n    this.messages = [];\n  }\n  count() {\n    return this.messages.length;\n  }\n  push(message) {\n    this.messages.push(message);\n  }\n  shift() {\n    return this.messages.shift();\n  }\n  last() {\n    return this.messages[this.messages.length - 1];\n  }\n  copyAll() {\n    return this.messages.slice();\n  }\n  append(messages) {\n    this.messages.push.apply(this.messages, messages);\n  }\n  prepend(messages) {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n  /**\n   * For all messages targeted by the selector, calls their callback and removes them from the queue.\n   *\n   * @param selector - Describes which messages to target. 'all' means all messages in the queue (regardless of whether they have had a `msgSerial` assigned); `serial` / `count` targets a range of messages described by an `ACK` or `NACK` received from Ably (this assumes that all the messages in the queue have had a `msgSerial` assigned).\n   */\n  completeMessages(selector, err, res) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.completeMessages()\",\n      selector == \"all\" ? \"(all)\" : \"serial = \" + selector.serial + \"; count = \" + selector.count\n    );\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error(\"MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue\");\n    }\n    let completeMessages = [];\n    if (selector === \"all\") {\n      completeMessages = messages.splice(0);\n    } else {\n      const first = messages[0];\n      if (first) {\n        const startSerial = first.message.msgSerial;\n        const endSerial = selector.serial + selector.count;\n        if (endSerial > startSerial) {\n          completeMessages = messages.splice(0, endSerial - startSerial);\n        }\n      }\n    }\n    for (let i = 0; i < completeMessages.length; i++) {\n      const message = completeMessages[i];\n      const publishResponse = res == null ? void 0 : res[i];\n      message.callback(err, publishResponse);\n    }\n    if (messages.length == 0)\n      this.emit(\"idle\");\n  }\n  completeAllMessages(err) {\n    this.completeMessages(\"all\", err);\n  }\n  resetSendAttempted() {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n  clear() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.clear()\",\n      \"clearing \" + this.messages.length + \" messages\"\n    );\n    this.messages = [];\n    this.emit(\"idle\");\n  }\n};\nvar messagequeue_default = MessageQueue;\n\n// src/common/lib/transport/protocol.ts\nvar PendingMessage = class {\n  constructor(message, callback) {\n    this.message = message;\n    this.callback = callback;\n    this.merged = false;\n    const action = message.action;\n    this.sendAttempted = false;\n    this.ackRequired = typeof action === \"number\" && [actions.MESSAGE, actions.PRESENCE, actions.ANNOTATION, actions.OBJECT].includes(action);\n  }\n};\nvar Protocol = class extends eventemitter_default {\n  constructor(transport) {\n    super(transport.logger);\n    this.transport = transport;\n    this.messageQueue = new messagequeue_default(this.logger);\n    transport.on(\"ack\", (serial, count, res) => {\n      this.onAck(serial, count, res);\n    });\n    transport.on(\"nack\", (serial, count, err) => {\n      this.onNack(serial, count, err);\n    });\n  }\n  onAck(serial, count, res) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"Protocol.onAck()\", \"serial = \" + serial + \"; count = \" + count);\n    this.messageQueue.completeMessages({ serial, count }, null, res);\n  }\n  onNack(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_ERROR,\n      \"Protocol.onNack()\",\n      \"serial = \" + serial + \"; count = \" + count + \"; err = \" + inspectError(err)\n    );\n    if (!err) {\n      err = new ErrorInfo(\"Unable to send message; channel not responding\", 50001, 500);\n    }\n    this.messageQueue.completeMessages({ serial, count }, err);\n  }\n  onceIdle(listener) {\n    const messageQueue = this.messageQueue;\n    if (messageQueue.count() === 0) {\n      listener();\n      return;\n    }\n    messageQueue.once(\"idle\", listener);\n  }\n  send(pendingMessage) {\n    if (pendingMessage.ackRequired) {\n      this.messageQueue.push(pendingMessage);\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Protocol.send()\",\n        \"sending msg; \" + stringify(\n          pendingMessage.message,\n          this.transport.connectionManager.realtime._RealtimePresence,\n          this.transport.connectionManager.realtime._Annotations,\n          this.transport.connectionManager.realtime._liveObjectsPlugin\n        )\n      );\n    }\n    pendingMessage.sendAttempted = true;\n    this.transport.send(pendingMessage.message);\n  }\n  getTransport() {\n    return this.transport;\n  }\n  getPendingMessages() {\n    return this.messageQueue.copyAll();\n  }\n  clearPendingMessages() {\n    return this.messageQueue.clear();\n  }\n  finish() {\n    const transport = this.transport;\n    this.onceIdle(function() {\n      transport.disconnect();\n    });\n  }\n};\nvar protocol_default = Protocol;\n\n// src/common/lib/client/connectionstatechange.ts\nvar ConnectionStateChange = class {\n  constructor(previous, current, retryIn, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn)\n      this.retryIn = retryIn;\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar connectionstatechange_default = ConnectionStateChange;\n\n// src/common/lib/transport/connectionerrors.ts\nvar ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 8e4,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001\n};\nvar ConnectionErrors = {\n  disconnected: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.DISCONNECTED,\n    message: \"Connection to server temporarily unavailable\"\n  }),\n  suspended: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.SUSPENDED,\n    message: \"Connection to server unavailable\"\n  }),\n  failed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.FAILED,\n    message: \"Connection failed or disconnected by server\"\n  }),\n  closing: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSING,\n    message: \"Connection closing\"\n  }),\n  closed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSED,\n    message: \"Connection closed\"\n  }),\n  unknownConnectionErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal connection error\"\n  }),\n  unknownChannelErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal channel error\"\n  })\n};\nfunction isRetriable(err) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\nvar connectionerrors_default = ConnectionErrors;\n\n// src/common/lib/transport/transport.ts\nvar closeMessage = fromValues({ action: actions.CLOSE });\nvar disconnectMessage = fromValues({ action: actions.DISCONNECT });\nvar Transport = class extends eventemitter_default {\n  constructor(connectionManager, auth, params, forceJsonProtocol) {\n    super(connectionManager.logger);\n    if (forceJsonProtocol) {\n      params.format = void 0;\n      params.heartbeats = true;\n    }\n    this.connectionManager = connectionManager;\n    this.auth = auth;\n    this.params = params;\n    this.timeouts = params.options.timeouts;\n    this.format = params.format;\n    this.isConnected = false;\n    this.isFinished = false;\n    this.isDisposed = false;\n    this.maxIdleInterval = null;\n    this.idleTimer = null;\n    this.lastActivity = null;\n  }\n  connect() {\n  }\n  close() {\n    if (this.isConnected) {\n      this.requestClose();\n    }\n    this.finish(\"closed\", connectionerrors_default.closed());\n  }\n  disconnect(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"disconnected\", err || connectionerrors_default.disconnected());\n  }\n  fail(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"failed\", err || connectionerrors_default.failed());\n  }\n  finish(event, err) {\n    var _a2;\n    if (this.isFinished) {\n      return;\n    }\n    this.isFinished = true;\n    this.isConnected = false;\n    this.maxIdleInterval = null;\n    clearTimeout((_a2 = this.idleTimer) != null ? _a2 : void 0);\n    this.idleTimer = null;\n    this.emit(event, err);\n    this.dispose();\n  }\n  onProtocolMessage(message) {\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Transport.onProtocolMessage()\",\n        \"received on \" + this.shortName + \": \" + stringify(\n          message,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations,\n          this.connectionManager.realtime._liveObjectsPlugin\n        ) + \"; connectionId = \" + this.connectionManager.connectionId\n      );\n    }\n    this.onActivity();\n    switch (message.action) {\n      case actions.HEARTBEAT:\n        logger_default.logActionNoStrip(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Transport.onProtocolMessage()\",\n          this.shortName + \" heartbeat; connectionId = \" + this.connectionManager.connectionId\n        );\n        this.emit(\"heartbeat\", message.id);\n        break;\n      case actions.CONNECTED:\n        this.onConnect(message);\n        this.emit(\"connected\", message.error, message.connectionId, message.connectionDetails, message);\n        break;\n      case actions.CLOSED:\n        this.onClose(message);\n        break;\n      case actions.DISCONNECTED:\n        this.onDisconnect(message);\n        break;\n      case actions.ACK:\n        this.emit(\"ack\", message.msgSerial, message.count, message.res);\n        break;\n      case actions.NACK:\n        this.emit(\"nack\", message.msgSerial, message.count, message.error);\n        break;\n      case actions.SYNC:\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      case actions.ACTIVATE:\n        break;\n      case actions.AUTH:\n        whenPromiseSettles(this.auth.authorize(), (err) => {\n          if (err) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Transport.onProtocolMessage()\",\n              \"Ably requested re-authentication, but unable to obtain a new token: \" + inspectError(err)\n            );\n          }\n        });\n        break;\n      case actions.ERROR:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Transport.onProtocolMessage()\",\n          \"received error action; connectionId = \" + this.connectionManager.connectionId + \"; err = \" + Platform.Config.inspect(message.error) + (message.channel ? \", channel: \" + message.channel : \"\")\n        );\n        if (message.channel === void 0) {\n          this.onFatalError(message);\n          break;\n        }\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      default:\n        this.connectionManager.onChannelMessage(message, this);\n    }\n  }\n  onConnect(message) {\n    this.isConnected = true;\n    if (!message.connectionDetails) {\n      throw new Error(\"Transport.onConnect(): Connect message recieved without connectionDetails\");\n    }\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval;\n    if (maxPromisedIdle) {\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n      this.onActivity();\n    }\n  }\n  onDisconnect(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onDisconnect()\", \"err = \" + inspectError(err));\n    this.finish(\"disconnected\", err);\n  }\n  onFatalError(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onFatalError()\", \"err = \" + inspectError(err));\n    this.finish(\"failed\", err);\n  }\n  onClose(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onClose()\", \"err = \" + inspectError(err));\n    this.finish(\"closed\", err);\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestClose()\", \"\");\n    this.send(closeMessage);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestDisconnect()\", \"\");\n    this.send(disconnectMessage);\n  }\n  ping(id) {\n    const msg = { action: actions.HEARTBEAT };\n    if (id)\n      msg.id = id;\n    this.send(fromValues(msg));\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.dispose()\", \"\");\n    this.isDisposed = true;\n    this.off();\n  }\n  onActivity() {\n    if (!this.maxIdleInterval) {\n      return;\n    }\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\n    this.setIdleTimer(this.maxIdleInterval + 100);\n  }\n  setIdleTimer(timeout) {\n    if (!this.idleTimer) {\n      this.idleTimer = setTimeout(() => {\n        this.onIdleTimerExpire();\n      }, timeout);\n    }\n  }\n  onIdleTimerExpire() {\n    if (!this.lastActivity || !this.maxIdleInterval) {\n      throw new Error(\"Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set\");\n    }\n    this.idleTimer = null;\n    const sinceLast = Date.now() - this.lastActivity;\n    const timeRemaining = this.maxIdleInterval - sinceLast;\n    if (timeRemaining <= 0) {\n      const msg = \"No activity seen from realtime in \" + sinceLast + \"ms; assuming connection has dropped\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Transport.onIdleTimerExpire()\", msg);\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\n    } else {\n      this.setIdleTimer(timeRemaining + 100);\n    }\n  }\n  static tryConnect(transportCtor, connectionManager, auth, transportParams, callback) {\n    const transport = new transportCtor(connectionManager, auth, transportParams);\n    let transportAttemptTimer;\n    const errorCb = function(err) {\n      clearTimeout(transportAttemptTimer);\n      callback({ event: this.event, error: err });\n    };\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n    transportAttemptTimer = setTimeout(() => {\n      transport.off([\"preconnect\", \"disconnected\", \"failed\"]);\n      transport.dispose();\n      errorCb.call(\n        { event: \"disconnected\" },\n        new ErrorInfo(\"Timeout waiting for transport to indicate itself viable\", 5e4, 500)\n      );\n    }, realtimeRequestTimeout);\n    transport.on([\"failed\", \"disconnected\"], errorCb);\n    transport.on(\"preconnect\", function() {\n      logger_default.logAction(\n        connectionManager.logger,\n        logger_default.LOG_MINOR,\n        \"Transport.tryConnect()\",\n        \"viable transport \" + transport\n      );\n      clearTimeout(transportAttemptTimer);\n      transport.off([\"failed\", \"disconnected\"], errorCb);\n      callback(null, transport);\n    });\n    transport.connect();\n    return transport;\n  }\n  static isAvailable() {\n    throw new ErrorInfo(\"isAvailable not implemented for transport\", 5e4, 500);\n  }\n};\nvar transport_default = Transport;\n\n// src/common/constants/TransportName.ts\nvar TransportNames;\n((TransportNames2) => {\n  TransportNames2.WebSocket = \"web_socket\";\n  TransportNames2.Comet = \"comet\";\n  TransportNames2.XhrPolling = \"xhr_polling\";\n})(TransportNames || (TransportNames = {}));\n\n// src/common/lib/transport/connectionmanager.ts\nvar globalObject2 = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\nvar haveWebStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.localSupported);\n};\nvar haveSessionStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.sessionSupported);\n};\nvar noop2 = function() {\n};\nvar transportPreferenceName = \"ably-transport-preference\";\nfunction decodeRecoveryKey(recoveryKey) {\n  try {\n    return JSON.parse(recoveryKey);\n  } catch (e) {\n    return null;\n  }\n}\nvar TransportParams = class {\n  constructor(options, host, mode, connectionKey) {\n    this.options = options;\n    this.host = host;\n    this.mode = mode;\n    this.connectionKey = connectionKey;\n    this.format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n  }\n  getConnectParams(authParams) {\n    const params = authParams ? copy(authParams) : {};\n    const options = this.options;\n    switch (this.mode) {\n      case \"resume\":\n        params.resume = this.connectionKey;\n        break;\n      case \"recover\": {\n        const recoveryContext = decodeRecoveryKey(options.recover);\n        if (recoveryContext) {\n          params.recover = recoveryContext.connectionKey;\n        }\n        break;\n      }\n      default:\n    }\n    if (options.clientId !== void 0) {\n      params.clientId = options.clientId;\n    }\n    if (options.echoMessages === false) {\n      params.echo = \"false\";\n    }\n    if (this.format !== void 0) {\n      params.format = this.format;\n    }\n    if (this.stream !== void 0) {\n      params.stream = this.stream;\n    }\n    if (this.heartbeats !== void 0) {\n      params.heartbeats = this.heartbeats;\n    }\n    params.v = defaults_default.protocolVersion;\n    params.agent = getAgentString(this.options);\n    if (options.transportParams !== void 0) {\n      mixin(params, options.transportParams);\n    }\n    return params;\n  }\n  toString() {\n    let result = \"[mode=\" + this.mode;\n    if (this.host) {\n      result += \",host=\" + this.host;\n    }\n    if (this.connectionKey) {\n      result += \",connectionKey=\" + this.connectionKey;\n    }\n    if (this.format) {\n      result += \",format=\" + this.format;\n    }\n    result += \"]\";\n    return result;\n  }\n};\nvar ConnectionManager = class _ConnectionManager extends eventemitter_default {\n  constructor(realtime, options) {\n    super(realtime.logger);\n    this.supportedTransports = {};\n    this.disconnectedRetryCount = 0;\n    this.pendingChannelMessagesState = { isProcessing: false, queue: [] };\n    this.realtime = realtime;\n    this.initTransports();\n    this.options = options;\n    const timeouts = options.timeouts;\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\n    this.states = {\n      initialized: {\n        state: \"initialized\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        failState: \"disconnected\"\n      },\n      connecting: {\n        state: \"connecting\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: connectingTimeout,\n        failState: \"disconnected\"\n      },\n      connected: {\n        state: \"connected\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: true,\n        failState: \"disconnected\"\n      },\n      disconnected: {\n        state: \"disconnected\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: timeouts.disconnectedRetryTimeout,\n        failState: \"disconnected\"\n      },\n      suspended: {\n        state: \"suspended\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.suspendedRetryTimeout,\n        failState: \"suspended\"\n      },\n      closing: {\n        state: \"closing\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.realtimeRequestTimeout,\n        failState: \"closed\"\n      },\n      closed: { state: \"closed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"closed\" },\n      failed: { state: \"failed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"failed\" }\n    };\n    this.state = this.states.initialized;\n    this.errorReason = null;\n    this.queuedMessages = new messagequeue_default(this.logger);\n    this.msgSerial = 0;\n    this.connectionDetails = void 0;\n    this.connectionId = void 0;\n    this.connectionKey = void 0;\n    this.connectionStateTtl = timeouts.connectionStateTtl;\n    this.maxIdleInterval = null;\n    this.transports = intersect(options.transports || defaults_default.defaultTransports, this.supportedTransports);\n    this.transportPreference = null;\n    if (this.transports.includes(TransportNames.WebSocket)) {\n      this.webSocketTransportAvailable = true;\n    }\n    if (this.transports.includes(TransportNames.XhrPolling)) {\n      this.baseTransport = TransportNames.XhrPolling;\n    } else if (this.transports.includes(TransportNames.Comet)) {\n      this.baseTransport = TransportNames.Comet;\n    }\n    this.domains = defaults_default.getHosts(options);\n    this.activeProtocol = null;\n    this.host = null;\n    this.lastAutoReconnectAttempt = null;\n    this.lastActivity = null;\n    this.forceFallbackHost = false;\n    this.connectCounter = 0;\n    this.wsCheckResult = null;\n    this.webSocketSlowTimer = null;\n    this.webSocketGiveUpTimer = null;\n    this.abandonedWebSocket = false;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.ConnectionManager()\", \"started\");\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"requested transports = [\" + (options.transports || defaults_default.defaultTransports) + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"available transports = [\" + this.transports + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"http domains = [\" + this.domains + \"]\"\n    );\n    if (!this.transports.length) {\n      const msg = \"no requested transports available\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"realtime.ConnectionManager()\", msg);\n      throw new Error(msg);\n    }\n    const addEventListener = Platform.Config.addEventListener;\n    if (addEventListener) {\n      if (haveSessionStorage() && typeof options.recover === \"function\") {\n        addEventListener(\"beforeunload\", this.persistConnection.bind(this));\n      }\n      if (options.closeOnUnload === true) {\n        addEventListener(\"beforeunload\", () => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"Realtime.ConnectionManager()\",\n            \"beforeunload event has triggered the connection to close as closeOnUnload is true\"\n          );\n          this.requestState({ state: \"closing\" });\n        });\n      }\n      addEventListener(\"online\", () => {\n        var _a2;\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018online\\u2019 event\",\n            \"reattempting connection\"\n          );\n          this.requestState({ state: \"connecting\" });\n        } else if (this.state == this.states.connecting) {\n          (_a2 = this.pendingTransport) == null ? void 0 : _a2.off();\n          this.disconnectAllTransports();\n          this.startConnect();\n        }\n      });\n      addEventListener(\"offline\", () => {\n        if (this.state == this.states.connected) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018offline\\u2019 event\",\n            \"disconnecting active transport\"\n          );\n          this.disconnectAllTransports();\n        }\n      });\n    }\n  }\n  /*********************\n   * transport management\n   *********************/\n  // Used by tests\n  static supportedTransports(additionalImplementations) {\n    const storage = { supportedTransports: {} };\n    this.initTransports(additionalImplementations, storage);\n    return storage.supportedTransports;\n  }\n  static initTransports(additionalImplementations, storage) {\n    const implementations = __spreadValues(__spreadValues({}, Platform.Transports.bundledImplementations), additionalImplementations);\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\n      const transport = implementations[transportName];\n      if (transport && transport.isAvailable()) {\n        storage.supportedTransports[transportName] = transport;\n      }\n    });\n  }\n  initTransports() {\n    _ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\n  }\n  createTransportParams(host, mode) {\n    return new TransportParams(this.options, host, mode, this.connectionKey);\n  }\n  getTransportParams(callback) {\n    const decideMode = (modeCb) => {\n      if (this.connectionKey) {\n        modeCb(\"resume\");\n        return;\n      }\n      if (typeof this.options.recover === \"string\") {\n        modeCb(\"recover\");\n        return;\n      }\n      const recoverFn = this.options.recover, lastSessionData = this.getSessionRecoverData(), sessionRecoveryName = this.sessionRecoveryName();\n      if (lastSessionData && typeof recoverFn === \"function\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Calling clientOptions-provided recover function with last session data (recovery scope: \" + sessionRecoveryName + \")\"\n        );\n        recoverFn(lastSessionData, (shouldRecover) => {\n          if (shouldRecover) {\n            this.options.recover = lastSessionData.recoveryKey;\n            modeCb(\"recover\");\n          } else {\n            modeCb(\"clean\");\n          }\n        });\n        return;\n      }\n      modeCb(\"clean\");\n    };\n    decideMode((mode) => {\n      const transportParams = this.createTransportParams(null, mode);\n      if (mode === \"recover\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport recovery mode = recover; recoveryKey = \" + this.options.recover\n        );\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\n        if (recoveryContext) {\n          this.msgSerial = recoveryContext.msgSerial;\n        }\n      } else {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport params = \" + transportParams.toString()\n        );\n      }\n      callback(transportParams);\n    });\n  }\n  /**\n   * Attempt to connect using a given transport\n   * @param transportParams\n   * @param candidate, the transport to try\n   * @param callback\n   */\n  tryATransport(transportParams, candidate, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.tryATransport()\", \"trying \" + candidate);\n    this.proposedTransport = transport_default.tryConnect(\n      this.supportedTransports[candidate],\n      this,\n      this.realtime.auth,\n      transportParams,\n      (wrappedErr, transport) => {\n        const state = this.state;\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\n          if (transport) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager.tryATransport()\",\n              \"connection \" + state.state + \" while we were attempting the transport; closing \" + transport\n            );\n            transport.close();\n          }\n          callback(true);\n          return;\n        }\n        if (wrappedErr) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.tryATransport()\",\n            \"transport \" + candidate + \" \" + wrappedErr.event + \", err: \" + wrappedErr.error.toString()\n          );\n          if (auth_default.isTokenErr(wrappedErr.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason))) {\n            this.errorReason = wrappedErr.error;\n            whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err) => {\n              if (err) {\n                this.actOnErrorFromAuthorize(err);\n                return;\n              }\n              this.tryATransport(transportParams, candidate, callback);\n            });\n          } else if (wrappedErr.event === \"failed\") {\n            this.notifyState({ state: \"failed\", error: wrappedErr.error });\n            callback(true);\n          } else if (wrappedErr.event === \"disconnected\") {\n            if (!isRetriable(wrappedErr.error)) {\n              this.notifyState({ state: this.states.connecting.failState, error: wrappedErr.error });\n              callback(true);\n            } else {\n              callback(false);\n            }\n          }\n          return;\n        }\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.tryATransport()\",\n          \"viable transport \" + candidate + \"; setting pending\"\n        );\n        this.setTransportPending(transport, transportParams);\n        callback(null, transport);\n      }\n    );\n  }\n  /**\n   * Called when a transport is indicated to be viable, and the ConnectionManager\n   * expects to activate this transport as soon as it is connected.\n   * @param transport\n   * @param transportParams\n   */\n  setTransportPending(transport, transportParams) {\n    const mode = transportParams.mode;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.setTransportPending()\",\n      \"transport = \" + transport + \"; mode = \" + mode\n    );\n    this.pendingTransport = transport;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    transport.once(\"connected\", (error, connectionId, connectionDetails) => {\n      this.activateTransport(error, transport, connectionId, connectionDetails);\n      if (mode === \"recover\" && this.options.recover) {\n        delete this.options.recover;\n        this.unpersistConnection();\n      }\n    });\n    const self2 = this;\n    transport.on([\"disconnected\", \"closed\", \"failed\"], function(error) {\n      self2.deactivateTransport(transport, this.event, error);\n    });\n    this.emit(\"transport.pending\", transport);\n  }\n  /**\n   * Called when a transport is connected, and the connectionmanager decides that\n   * it will now be the active transport. Returns whether or not it activated\n   * the transport (if the connection is closing/closed it will choose not to).\n   * @param transport the transport instance\n   * @param connectionId the id of the new active connection\n   * @param connectionDetails the details of the new active connection\n   */\n  activateTransport(error, transport, connectionId, connectionDetails) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"transport = \" + transport\n    );\n    if (error) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", \"error = \" + error);\n    }\n    if (connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionId =  \" + connectionId\n      );\n    }\n    if (connectionDetails) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionDetails =  \" + JSON.stringify(connectionDetails)\n      );\n    }\n    this.persistTransportPreference(transport);\n    const existingState = this.state, connectedState = this.states.connected.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"current state = \" + existingState.state\n    );\n    if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Disconnecting transport and abandoning\"\n      );\n      transport.disconnect();\n      return false;\n    }\n    delete this.pendingTransport;\n    if (!transport.isConnected) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Declining to activate transport \" + transport + \" since it appears to no longer be connected\"\n      );\n      return false;\n    }\n    const existingActiveProtocol = this.activeProtocol;\n    this.activeProtocol = new protocol_default(transport);\n    this.host = transport.params.host;\n    const connectionKey = connectionDetails.connectionKey;\n    if (connectionKey && this.connectionKey != connectionKey) {\n      this.setConnection(connectionId, connectionDetails, !!error);\n    }\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\n    Platform.Config.nextTick(() => {\n      transport.on(\n        \"connected\",\n        (connectedErr, _connectionId, connectionDetails2) => {\n          this.onConnectionDetailsUpdate(connectionDetails2, transport);\n          this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, connectedErr));\n        }\n      );\n    });\n    if (existingState.state === this.states.connected.state) {\n      if (error) {\n        this.errorReason = this.realtime.connection.errorReason = error;\n        this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, error));\n      }\n    } else {\n      this.notifyState({ state: \"connected\", error });\n      this.errorReason = this.realtime.connection.errorReason = error || null;\n    }\n    this.emit(\"transport.active\", transport);\n    if (existingActiveProtocol) {\n      if (existingActiveProtocol.messageQueue.count() > 0) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.activateTransport()\",\n          \"Previous active protocol (for transport \" + existingActiveProtocol.transport.shortName + \", new one is \" + transport.shortName + \") finishing with \" + existingActiveProtocol.messageQueue.count() + \" messages still pending\"\n        );\n      }\n      if (existingActiveProtocol.transport === transport) {\n        const msg = \"Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = \" + transport.shortName + \"; stack = \" + new Error().stack;\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", msg);\n      } else {\n        existingActiveProtocol.finish();\n      }\n    }\n    return true;\n  }\n  /**\n   * Called when a transport is no longer the active transport. This can occur\n   * in any transport connection state.\n   * @param transport\n   */\n  deactivateTransport(transport, state, error) {\n    const currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = transport === this.pendingTransport, noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"transport = \" + transport\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"state = \" + state + (wasActive ? \"; was active\" : wasPending ? \"; was pending\" : \"\") + (noTransportsScheduledForActivation ? \"\" : \"; another transport is scheduled for activation\")\n    );\n    if (error && error.message)\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"reason =  \" + error.message\n      );\n    if (wasActive) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"Getting, clearing, and requeuing \" + this.activeProtocol.messageQueue.count() + \" pending messages\"\n      );\n      this.queuePendingMessages(currentProtocol.getPendingMessages());\n      currentProtocol.clearPendingMessages();\n      this.activeProtocol = this.host = null;\n    }\n    this.emit(\"transport.inactive\", transport);\n    if (wasActive && noTransportsScheduledForActivation || wasActive && state === \"failed\" || state === \"closed\" || currentProtocol === null && wasPending) {\n      if (state === \"disconnected\" && error && error.statusCode > 500 && this.domains.length > 1) {\n        this.unpersistTransportPreference();\n        this.forceFallbackHost = true;\n        this.notifyState({ state, error, retryImmediately: true });\n        return;\n      }\n      const newConnectionState = state === \"failed\" && auth_default.isTokenErr(error) ? \"disconnected\" : state;\n      this.notifyState({ state: newConnectionState, error });\n      return;\n    }\n  }\n  /* Helper that returns true if there are no transports which are pending,\n   * have been connected, and are just waiting for onceNoPending to fire before\n   * being activated */\n  noTransportsScheduledForActivation() {\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\n  }\n  setConnection(connectionId, connectionDetails, hasConnectionError) {\n    const prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;\n    if (connIdChanged || recoverFailure) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.setConnection()\", \"Resetting msgSerial\");\n      this.msgSerial = 0;\n      this.queuedMessages.resetSendAttempted();\n    }\n    if (this.connectionId !== connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.setConnection()\",\n        \"New connectionId; reattaching any attached channels\"\n      );\n    }\n    this.realtime.connection.id = this.connectionId = connectionId;\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n  }\n  clearConnection() {\n    this.realtime.connection.id = this.connectionId = void 0;\n    this.realtime.connection.key = this.connectionKey = void 0;\n    this.msgSerial = 0;\n    this.queuedMessages.resetSendAttempted();\n    this.unpersistConnection();\n  }\n  createRecoveryKey() {\n    if (!this.connectionKey) {\n      return null;\n    }\n    return JSON.stringify({\n      connectionKey: this.connectionKey,\n      msgSerial: this.msgSerial,\n      channelSerials: this.realtime.channels.channelSerials()\n    });\n  }\n  checkConnectionStateFreshness() {\n    if (!this.lastActivity || !this.connectionId) {\n      return;\n    }\n    const sinceLast = Date.now() - this.lastActivity;\n    if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.checkConnectionStateFreshness()\",\n        \"Last known activity from realtime was \" + sinceLast + \"ms ago; discarding connection state\"\n      );\n      this.clearConnection();\n      this.states.connecting.failState = \"suspended\";\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  persistConnection() {\n    if (haveSessionStorage()) {\n      const recoveryKey = this.createRecoveryKey();\n      if (recoveryKey) {\n        this.setSessionRecoverData({\n          recoveryKey,\n          disconnectedAt: Date.now(),\n          location: globalObject2.location,\n          clientId: this.realtime.auth.clientId\n        });\n      }\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  unpersistConnection() {\n    this.clearSessionRecoverData();\n  }\n  getActiveTransportFormat() {\n    var _a2;\n    return (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport().format;\n  }\n  /*********************\n   * state management\n   *********************/\n  getError() {\n    if (this.errorReason) {\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\n      newError.cause = this.errorReason;\n      return newError;\n    }\n    return this.getStateError();\n  }\n  getStateError() {\n    var _a2, _b;\n    return (_b = (_a2 = connectionerrors_default)[this.state.state]) == null ? void 0 : _b.call(_a2);\n  }\n  activeState() {\n    return this.state.queueEvents || this.state.sendEvents;\n  }\n  enactStateChange(stateChange) {\n    const action = \"Connection state\";\n    const message = stateChange.current + (stateChange.reason ? \"; reason: \" + stateChange.reason : \"\");\n    if (stateChange.current === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.enactStateChange\",\n      \"setting new state: \" + stateChange.current + \"; reason = \" + (stateChange.reason && stateChange.reason.message)\n    );\n    const newState = this.state = this.states[stateChange.current];\n    if (stateChange.reason) {\n      this.errorReason = stateChange.reason;\n      this.realtime.connection.errorReason = stateChange.reason;\n    }\n    if (newState.terminal || newState.state === \"suspended\") {\n      this.clearConnection();\n    }\n    this.emit(\"connectionstate\", stateChange);\n  }\n  /****************************************\n   * ConnectionManager connection lifecycle\n   ****************************************/\n  startTransitionTimer(transitionState) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.startTransitionTimer()\",\n      \"transitionState: \" + transitionState.state\n    );\n    if (this.transitionTimer) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startTransitionTimer()\",\n        \"clearing already-running timer\"\n      );\n      clearTimeout(this.transitionTimer);\n    }\n    this.transitionTimer = setTimeout(() => {\n      if (this.transitionTimer) {\n        this.transitionTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager \" + transitionState.state + \" timer expired\",\n          \"requesting new state: \" + transitionState.failState\n        );\n        this.notifyState({ state: transitionState.failState });\n      }\n    }, transitionState.retryDelay);\n  }\n  cancelTransitionTimer() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.cancelTransitionTimer()\", \"\");\n    if (this.transitionTimer) {\n      clearTimeout(this.transitionTimer);\n      this.transitionTimer = null;\n    }\n  }\n  startSuspendTimer() {\n    if (this.suspendTimer)\n      return;\n    this.suspendTimer = setTimeout(() => {\n      if (this.suspendTimer) {\n        this.suspendTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager suspend timer expired\",\n          \"requesting new state: suspended\"\n        );\n        this.states.connecting.failState = \"suspended\";\n        this.notifyState({ state: \"suspended\" });\n      }\n    }, this.connectionStateTtl);\n  }\n  checkSuspendTimer(state) {\n    if (state !== \"disconnected\" && state !== \"suspended\" && state !== \"connecting\")\n      this.cancelSuspendTimer();\n  }\n  cancelSuspendTimer() {\n    this.states.connecting.failState = \"disconnected\";\n    if (this.suspendTimer) {\n      clearTimeout(this.suspendTimer);\n      this.suspendTimer = null;\n    }\n  }\n  startRetryTimer(interval) {\n    this.retryTimer = setTimeout(() => {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager retry timer expired\", \"retrying\");\n      this.retryTimer = null;\n      this.requestState({ state: \"connecting\" });\n    }, interval);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  startWebSocketSlowTimer() {\n    this.webSocketSlowTimer = setTimeout(() => {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager WebSocket slow timer\",\n        \"checking connectivity\"\n      );\n      this.checkWsConnectivity().then(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check succeeded\"\n        );\n        this.wsCheckResult = true;\n      }).catch(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check failed\"\n        );\n        this.wsCheckResult = false;\n      });\n      if (this.realtime.http.checkConnectivity) {\n        whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n          if (err || !connectivity) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MAJOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check failed\"\n            );\n            this.cancelWebSocketGiveUpTimer();\n            this.notifyState({\n              state: \"disconnected\",\n              error: new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404)\n            });\n          } else {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check succeeded\"\n            );\n          }\n        });\n      }\n    }, this.options.timeouts.webSocketSlowTimeout);\n  }\n  cancelWebSocketSlowTimer() {\n    if (this.webSocketSlowTimer) {\n      clearTimeout(this.webSocketSlowTimer);\n      this.webSocketSlowTimer = null;\n    }\n  }\n  startWebSocketGiveUpTimer(transportParams) {\n    this.webSocketGiveUpTimer = setTimeout(() => {\n      var _a2, _b;\n      if (!this.wsCheckResult) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket give up timer\",\n          \"websocket connection took more than 10s; \" + (this.baseTransport ? \"trying base transport\" : \"\")\n        );\n        if (this.baseTransport) {\n          this.abandonedWebSocket = true;\n          (_a2 = this.proposedTransport) == null ? void 0 : _a2.dispose();\n          (_b = this.pendingTransport) == null ? void 0 : _b.dispose();\n          this.connectBase(transportParams, ++this.connectCounter);\n        } else {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"ConnectionManager WebSocket give up timer\",\n            \"websocket connectivity appears to be unavailable but no other transports to try\"\n          );\n        }\n      }\n    }, this.options.timeouts.webSocketConnectTimeout);\n  }\n  cancelWebSocketGiveUpTimer() {\n    if (this.webSocketGiveUpTimer) {\n      clearTimeout(this.webSocketGiveUpTimer);\n      this.webSocketGiveUpTimer = null;\n    }\n  }\n  notifyState(indicated) {\n    var _a2, _b;\n    const state = indicated.state;\n    const retryImmediately = state === \"disconnected\" && (this.state === this.states.connected || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && auth_default.isTokenErr(indicated.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason)));\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.notifyState()\",\n      \"new state: \" + state + (retryImmediately ? \"; will retry connection immediately\" : \"\")\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.checkSuspendTimer(indicated.state);\n    if (state === \"suspended\" || state === \"connected\") {\n      this.disconnectedRetryCount = 0;\n    }\n    if (this.state.terminal)\n      return;\n    const newState = this.states[indicated.state];\n    let retryDelay = newState.retryDelay;\n    if (newState.state === \"disconnected\") {\n      this.disconnectedRetryCount++;\n      retryDelay = getRetryTime(newState.retryDelay, this.disconnectedRetryCount);\n    }\n    const change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      retryDelay,\n      indicated.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    if (retryImmediately) {\n      const autoReconnect = () => {\n        if (this.state === this.states.disconnected) {\n          this.lastAutoReconnectAttempt = Date.now();\n          this.requestState({ state: \"connecting\" });\n        }\n      };\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\n      if (sinceLast && sinceLast < 1e3) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.notifyState()\",\n          \"Last reconnect attempt was only \" + sinceLast + \"ms ago, waiting another \" + (1e3 - sinceLast) + \"ms before trying again\"\n        );\n        setTimeout(autoReconnect, 1e3 - sinceLast);\n      } else {\n        Platform.Config.nextTick(autoReconnect);\n      }\n    } else if (state === \"disconnected\" || state === \"suspended\") {\n      this.startRetryTimer(retryDelay);\n    }\n    if (state === \"disconnected\" && !retryImmediately || state === \"suspended\" || newState.terminal) {\n      Platform.Config.nextTick(() => {\n        this.disconnectAllTransports();\n      });\n    }\n    if (state == \"connected\" && !this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.notifyState()\",\n        \"Broken invariant: attempted to go into connected state, but there is no active protocol\"\n      );\n    }\n    this.enactStateChange(change);\n    if (this.state.sendEvents) {\n      this.sendQueuedMessages();\n    } else if (!this.state.queueEvents) {\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n      this.failQueuedMessages(change.reason);\n    }\n  }\n  requestState(request) {\n    var _a2, _b;\n    const state = request.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.requestState()\",\n      \"requested state: \" + state + \"; current state: \" + this.state.state\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.checkSuspendTimer(state);\n    if (state == \"connecting\" && this.state.state == \"connected\")\n      return;\n    if (state == \"closing\" && this.state.state == \"closed\")\n      return;\n    const newState = this.states[state], change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      null,\n      request.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    this.enactStateChange(change);\n    if (state == \"connecting\") {\n      Platform.Config.nextTick(() => {\n        this.startConnect();\n      });\n    }\n    if (state == \"closing\") {\n      this.closeImpl();\n    }\n  }\n  startConnect() {\n    if (this.state !== this.states.connecting) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startConnect()\",\n        \"Must be in connecting state to connect, but was \" + this.state.state\n      );\n      return;\n    }\n    const auth = this.realtime.auth;\n    const connectCount = ++this.connectCounter;\n    const connect = () => {\n      this.checkConnectionStateFreshness();\n      this.getTransportParams((transportParams) => {\n        if (transportParams.mode === \"recover\" && transportParams.options.recover) {\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n          if (recoveryContext) {\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n          }\n        }\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        this.connectImpl(transportParams, connectCount);\n      });\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.startConnect()\", \"starting connection\");\n    this.startSuspendTimer();\n    this.startTransitionTimer(this.states.connecting);\n    if (auth.method === \"basic\") {\n      connect();\n    } else {\n      const authCb = (err) => {\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        if (err) {\n          this.actOnErrorFromAuthorize(err);\n        } else {\n          connect();\n        }\n      };\n      if (this.errorReason && auth_default.isTokenErr(this.errorReason)) {\n        whenPromiseSettles(auth._forceNewToken(null, null), authCb);\n      } else {\n        whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\n      }\n    }\n  }\n  /*\n   * there are, at most, two transports available with which a connection may\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\n   * comet in nodejs). web_socket is always preferred, and the base transport is\n   * only used in case web_socket connectivity appears to be unavailable.\n   *\n   * connectImpl begins the transport selection process by checking which transports\n   * are available, and if there is a cached preference. It then defers to the\n   * transport-specific connect methods: connectWs and connectBase.\n   *\n   * It is also responsible for invalidating the cache in the case that a base\n   * transport preference is stored but web socket connectivity is now available.\n   *\n   * handling of the case where we need to failover from web_socket to the base\n   * transport is implemented in the connectWs method.\n   */\n  connectImpl(transportParams, connectCount) {\n    const state = this.state.state;\n    if (state !== this.states.connecting.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.connectImpl()\",\n        \"Must be in connecting state to connect, but was \" + state\n      );\n      return;\n    }\n    const transportPreference = this.getTransportPreference();\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\n      this.checkWsConnectivity().then(() => {\n        this.unpersistTransportPreference();\n        if (this.state === this.states.connecting) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.connectImpl():\",\n            \"web socket connectivity available, cancelling connection attempt with \" + this.baseTransport\n          );\n          this.disconnectAllTransports();\n          this.connectWs(transportParams, ++this.connectCounter);\n        }\n      }).catch(noop2);\n    }\n    if (transportPreference && transportPreference === this.baseTransport || this.baseTransport && !this.webSocketTransportAvailable) {\n      this.connectBase(transportParams, connectCount);\n    } else {\n      this.connectWs(transportParams, connectCount);\n    }\n  }\n  /*\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\n   *   connectivity check fails, we give up the connection sequence entirely and\n   *   transition to disconnected. if the websocket connectivity check fails then\n   *   we assume no ws connectivity and failover to base transport. in the case that\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\n   *   and, if unsuccessful, ultimately transition to disconnected.\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\n   *   connectivity check is still pending then we assume that there is an issue\n   *   with the transport and fallback to base transport.\n   */\n  connectWs(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectWs()\");\n    this.wsCheckResult = null;\n    this.abandonedWebSocket = false;\n    this.startWebSocketSlowTimer();\n    this.startWebSocketGiveUpTimer(transportParams);\n    this.tryTransportWithFallbacks(\"web_socket\", transportParams, true, connectCount, () => {\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\n    });\n  }\n  connectBase(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectBase()\");\n    if (this.baseTransport) {\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\n    } else {\n      this.notifyState({\n        state: \"disconnected\",\n        error: new ErrorInfo(\"No transports left to try\", 8e4, 404)\n      });\n    }\n  }\n  tryTransportWithFallbacks(transportName, transportParams, ws, connectCount, shouldContinue) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.tryTransportWithFallbacks()\",\n      transportName\n    );\n    const giveUp = (err) => {\n      this.notifyState({ state: this.states.connecting.failState, error: err });\n    };\n    const candidateHosts = this.domains.slice();\n    const hostAttemptCb = (fatal, transport) => {\n      if (connectCount !== this.connectCounter) {\n        return;\n      }\n      if (!shouldContinue()) {\n        if (transport) {\n          transport.dispose();\n        }\n        return;\n      }\n      if (!transport && !fatal) {\n        tryFallbackHosts();\n      }\n    };\n    const host = candidateHosts.shift();\n    if (!host) {\n      giveUp(new ErrorInfo(\"Unable to connect (no available host)\", 80003, 404));\n      return;\n    }\n    transportParams.host = host;\n    const tryFallbackHosts = () => {\n      if (!candidateHosts.length) {\n        giveUp(new ErrorInfo(\"Unable to connect (and no more fallback hosts to try)\", 80003, 404));\n        return;\n      }\n      if (!this.realtime.http.checkConnectivity) {\n        giveUp(new PartialErrorInfo(\"Internal error: Http.checkConnectivity not set\", null, 500));\n        return;\n      }\n      whenPromiseSettles(\n        this.realtime.http.checkConnectivity(),\n        (err, connectivity) => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (!shouldContinue()) {\n            return;\n          }\n          if (err) {\n            giveUp(err);\n            return;\n          }\n          if (!connectivity) {\n            giveUp(new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404));\n            return;\n          }\n          transportParams.host = arrPopRandomElement(candidateHosts);\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\n        }\n      );\n    };\n    if (this.forceFallbackHost && candidateHosts.length) {\n      this.forceFallbackHost = false;\n      tryFallbackHosts();\n      return;\n    }\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\n  }\n  closeImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.closeImpl()\", \"closing connection\");\n    this.cancelSuspendTimer();\n    this.startTransitionTimer(this.states.closing);\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.close();\n    }\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().close();\n    }\n    this.notifyState({ state: \"closed\" });\n  }\n  onAuthUpdated(tokenDetails, callback) {\n    var _a2;\n    switch (this.state.state) {\n      case \"connected\": {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Sending AUTH message on active transport\"\n        );\n        const activeTransport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n        if (activeTransport && activeTransport.onAuthUpdated) {\n          activeTransport.onAuthUpdated(tokenDetails);\n        }\n        const authMsg = fromValues({\n          action: actions.AUTH,\n          auth: {\n            accessToken: tokenDetails.token\n          }\n        });\n        this.send(authMsg);\n        const successListener = () => {\n          this.off(failureListener);\n          callback(null, tokenDetails);\n        };\n        const failureListener = (stateChange) => {\n          if (stateChange.current === \"failed\") {\n            this.off(successListener);\n            this.off(failureListener);\n            callback(stateChange.reason || this.getStateError());\n          }\n        };\n        this.once(\"connectiondetails\", successListener);\n        this.on(\"connectionstate\", failureListener);\n        break;\n      }\n      case \"connecting\":\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Aborting current connection attempts in order to start again with the new auth details\"\n        );\n        this.disconnectAllTransports();\n      default: {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Connection state is \" + this.state.state + \"; waiting until either connected or failed\"\n        );\n        const listener = (stateChange) => {\n          switch (stateChange.current) {\n            case \"connected\":\n              this.off(listener);\n              callback(null, tokenDetails);\n              break;\n            case \"failed\":\n            case \"closed\":\n            case \"suspended\":\n              this.off(listener);\n              callback(stateChange.reason || this.getStateError());\n              break;\n            default:\n              break;\n          }\n        };\n        this.on(\"connectionstate\", listener);\n        if (this.state.state === \"connecting\") {\n          this.startConnect();\n        } else {\n          this.requestState({ state: \"connecting\" });\n        }\n      }\n    }\n  }\n  disconnectAllTransports() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.disconnectAllTransports()\",\n      \"Disconnecting all transports\"\n    );\n    this.connectCounter++;\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.proposedTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting proposed transport: \" + this.pendingTransport\n      );\n      this.proposedTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().disconnect();\n    }\n  }\n  /******************\n   * event queueing\n   ******************/\n  send(msg, queueEvent, callback) {\n    callback = callback || noop2;\n    const state = this.state;\n    if (state.sendEvents) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", \"sending event\");\n      this.sendImpl(new PendingMessage(msg, callback));\n      return;\n    }\n    const shouldQueue = queueEvent && state.queueEvents;\n    if (!shouldQueue) {\n      const err = \"rejecting event, queueEvent was \" + queueEvent + \", state was \" + state.state;\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", err);\n      callback(this.errorReason || new ErrorInfo(err, 9e4, 400));\n      return;\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.send()\",\n        \"queueing msg; \" + stringify(\n          msg,\n          this.realtime._RealtimePresence,\n          this.realtime._Annotations,\n          this.realtime._liveObjectsPlugin\n        )\n      );\n    }\n    this.queue(msg, callback);\n  }\n  sendImpl(pendingMessage) {\n    const msg = pendingMessage.message;\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n      msg.msgSerial = this.msgSerial++;\n    }\n    try {\n      this.activeProtocol.send(pendingMessage);\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.sendImpl()\",\n        \"Unexpected exception in transport.send(): \" + e.stack\n      );\n    }\n  }\n  queue(msg, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.queue()\", \"queueing event\");\n    this.queuedMessages.push(new PendingMessage(msg, callback));\n  }\n  sendQueuedMessages() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.sendQueuedMessages()\",\n      \"sending \" + this.queuedMessages.count() + \" queued messages\"\n    );\n    let pendingMessage;\n    while (pendingMessage = this.queuedMessages.shift())\n      this.sendImpl(pendingMessage);\n  }\n  queuePendingMessages(pendingMessages) {\n    if (pendingMessages && pendingMessages.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.queuePendingMessages()\",\n        \"queueing \" + pendingMessages.length + \" pending messages\"\n      );\n      this.queuedMessages.prepend(pendingMessages);\n    }\n  }\n  failQueuedMessages(err) {\n    const numQueued = this.queuedMessages.count();\n    if (numQueued > 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.failQueuedMessages()\",\n        \"failing \" + numQueued + \" queued messages, err = \" + inspectError(err)\n      );\n      this.queuedMessages.completeAllMessages(err);\n    }\n  }\n  onChannelMessage(message, transport) {\n    this.pendingChannelMessagesState.queue.push({ message, transport });\n    if (!this.pendingChannelMessagesState.isProcessing) {\n      this.processNextPendingChannelMessage();\n    }\n  }\n  processNextPendingChannelMessage() {\n    if (this.pendingChannelMessagesState.queue.length > 0) {\n      this.pendingChannelMessagesState.isProcessing = true;\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift();\n      this.processChannelMessage(pendingChannelMessage.message).catch((err) => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.processNextPendingChannelMessage() received error \",\n          err\n        );\n      }).finally(() => {\n        this.pendingChannelMessagesState.isProcessing = false;\n        this.processNextPendingChannelMessage();\n      });\n    }\n  }\n  async processChannelMessage(message) {\n    await this.realtime.channels.processChannelMessage(message);\n  }\n  async ping() {\n    var _a2;\n    if (this.state.state !== \"connected\") {\n      throw new ErrorInfo(\"Unable to ping service; not connected\", 4e4, 400);\n    }\n    const transport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n    if (!transport) {\n      throw this.getStateError();\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.ping()\", \"transport = \" + transport);\n    const pingStart = Date.now();\n    const id = cheapRandStr();\n    return withTimeoutAsync(\n      new Promise((resolve) => {\n        const onHeartbeat = (responseId) => {\n          if (responseId === id) {\n            transport.off(\"heartbeat\", onHeartbeat);\n            resolve(Date.now() - pingStart);\n          }\n        };\n        transport.on(\"heartbeat\", onHeartbeat);\n        transport.ping(id);\n      }),\n      this.options.timeouts.realtimeRequestTimeout,\n      \"Timeout waiting for heartbeat response\"\n    );\n  }\n  abort(error) {\n    this.activeProtocol.getTransport().fail(error);\n  }\n  getTransportPreference() {\n    var _a2, _b;\n    return this.transportPreference || haveWebStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.get) == null ? void 0 : _b.call(_a2, transportPreferenceName));\n  }\n  persistTransportPreference(transport) {\n    var _a2, _b;\n    this.transportPreference = transport.shortName;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(_a2, transportPreferenceName, transport.shortName);\n    }\n  }\n  unpersistTransportPreference() {\n    var _a2, _b;\n    this.transportPreference = null;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, transportPreferenceName);\n    }\n  }\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n   * server returns 403. */\n  actOnErrorFromAuthorize(err) {\n    if (err.code === 40171) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.code === 40102) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.statusCode === HttpStatusCodes_default.Forbidden) {\n      const msg = \"Client configured authentication provider returned 403; failing the connection\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.actOnErrorFromAuthorize()\", msg);\n      this.notifyState({ state: \"failed\", error: new ErrorInfo(msg, 80019, 403, err) });\n    } else {\n      const msg = \"Client configured authentication provider request failed\";\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.actOnErrorFromAuthorize\", msg);\n      this.notifyState({ state: this.state.failState, error: new ErrorInfo(msg, 80019, 401, err) });\n    }\n  }\n  onConnectionDetailsUpdate(connectionDetails, transport) {\n    if (!connectionDetails) {\n      return;\n    }\n    this.connectionDetails = connectionDetails;\n    if (connectionDetails.maxMessageSize) {\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\n    }\n    const clientId = connectionDetails.clientId;\n    if (clientId) {\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\n      if (err) {\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.onConnectionDetailsUpdate()\", err.message);\n        transport.fail(err);\n        return;\n      }\n    }\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\n    if (connectionStateTtl) {\n      this.connectionStateTtl = connectionStateTtl;\n    }\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\n    this.emit(\"connectiondetails\", connectionDetails);\n  }\n  checkWsConnectivity() {\n    const wsConnectivityCheckUrl = this.options.wsConnectivityCheckUrl || defaults_default.wsConnectivityCheckUrl;\n    const ws = new Platform.Config.WebSocket(wsConnectivityCheckUrl);\n    return new Promise((resolve, reject) => {\n      let finished = false;\n      ws.onopen = () => {\n        if (!finished) {\n          finished = true;\n          resolve();\n          ws.close();\n        }\n      };\n      ws.onclose = ws.onerror = () => {\n        if (!finished) {\n          finished = true;\n          reject();\n        }\n      };\n    });\n  }\n  sessionRecoveryName() {\n    return this.options.recoveryKeyStorageName || \"ably-connection-recovery\";\n  }\n  getSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.getSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n  setSessionRecoverData(value) {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.setSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName(), value));\n  }\n  clearSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.removeSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n};\nvar connectionmanager_default = ConnectionManager;\n\n// src/common/lib/client/connection.ts\nvar Connection = class extends eventemitter_default {\n  constructor(ably, options) {\n    super(ably.logger);\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    this.ably = ably;\n    this.connectionManager = new connectionmanager_default(ably, options);\n    this.state = this.connectionManager.state.state;\n    this.key = void 0;\n    this.id = void 0;\n    this.errorReason = null;\n    this.connectionManager.on(\"connectionstate\", (stateChange) => {\n      const state = this.state = stateChange.current;\n      Platform.Config.nextTick(() => {\n        this.emit(state, stateChange);\n      });\n    });\n    this.connectionManager.on(\"update\", (stateChange) => {\n      Platform.Config.nextTick(() => {\n        this.emit(\"update\", stateChange);\n      });\n    });\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.connect()\", \"\");\n    this.connectionManager.requestState({ state: \"connecting\" });\n  }\n  async ping() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.ping()\", \"\");\n    return this.connectionManager.ping();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.close()\", \"connectionKey = \" + this.key);\n    this.connectionManager.requestState({ state: \"closing\" });\n  }\n  get recoveryKey() {\n    this.logger.deprecationWarning(\n      \"The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.\"\n    );\n    return this.createRecoveryKey();\n  }\n  createRecoveryKey() {\n    return this.connectionManager.createRecoveryKey();\n  }\n};\nvar connection_default = Connection;\n\n// src/common/lib/client/baserealtime.ts\nvar _BaseRealtime = class _BaseRealtime extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    var _a2, _b, _c, _d;\n    super(defaults_default.objectifyOptions(options, false, \"BaseRealtime\", logger_default.defaultLogger));\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime()\", \"\");\n    if (typeof EdgeRuntime === \"string\") {\n      throw new ErrorInfo(\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime. If you are running Vercel Edge functions, please replace your \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API instead of the Realtime API. If you are server-rendering your application in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\" to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\n        4e4,\n        400\n      );\n    }\n    this._additionalTransportImplementations = _BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\n    this._RealtimePresence = (_b = (_a2 = this.options.plugins) == null ? void 0 : _a2.RealtimePresence) != null ? _b : null;\n    this._liveObjectsPlugin = (_d = (_c = this.options.plugins) == null ? void 0 : _c.LiveObjects) != null ? _d : null;\n    this.connection = new connection_default(this, this.options);\n    this._channels = new Channels2(this);\n    if (this.options.autoConnect !== false)\n      this.connect();\n  }\n  static transportImplementationsFromPlugins(plugins) {\n    const transports = {};\n    if (plugins == null ? void 0 : plugins.WebSocketTransport) {\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\n    }\n    if (plugins == null ? void 0 : plugins.XHRPolling) {\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\n    }\n    return transports;\n  }\n  get channels() {\n    return this._channels;\n  }\n  get clientId() {\n    return this.auth.clientId;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.connect()\", \"\");\n    this.connection.connect();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.close()\", \"\");\n    this.connection.close();\n  }\n};\n// internal API to make EventEmitter usable in other SDKs\n_BaseRealtime.EventEmitter = eventemitter_default;\nvar BaseRealtime = _BaseRealtime;\nvar Channels2 = class extends eventemitter_default {\n  constructor(realtime) {\n    super(realtime.logger);\n    this.realtime = realtime;\n    this.all = /* @__PURE__ */ Object.create(null);\n    realtime.connection.connectionManager.on(\"transport.active\", () => {\n      this.onTransportActive();\n    });\n  }\n  channelSerials() {\n    let serials = {};\n    for (const name of keysArray(this.all, true)) {\n      const channel = this.all[name];\n      if (channel.properties.channelSerial) {\n        serials[name] = channel.properties.channelSerial;\n      }\n    }\n    return serials;\n  }\n  // recoverChannels gets the given channels and sets their channel serials.\n  recoverChannels(channelSerials) {\n    for (const name of keysArray(channelSerials, true)) {\n      const channel = this.get(name);\n      channel.properties.channelSerial = channelSerials[name];\n    }\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\n  async processChannelMessage(msg) {\n    const channelName = msg.channel;\n    if (channelName === void 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event unspecified channel, action = \" + msg.action\n      );\n      return;\n    }\n    const channel = this.all[channelName];\n    if (!channel) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event for non-existent channel: \" + channelName\n      );\n      return;\n    }\n    await channel.processMessage(msg);\n  }\n  /* called when a transport becomes connected; reattempt attach/detach\n   * for channels that are attaching or detaching. */\n  onTransportActive() {\n    for (const channelName in this.all) {\n      const channel = this.all[channelName];\n      if (channel.state === \"attaching\" || channel.state === \"detaching\") {\n        channel.checkPendingState();\n      } else if (channel.state === \"suspended\") {\n        channel._attach(false, null);\n      } else if (channel.state === \"attached\") {\n        channel.requestState(\"attaching\");\n      }\n    }\n  }\n  /* Connection interruptions (ie when the connection will no longer queue\n   * events) imply connection state changes for any channel which is either\n   * attached, pending, or will attempt to become attached in the future */\n  propogateConnectionInterruption(connectionState, reason) {\n    const connectionStateToChannelState = {\n      closing: \"detached\",\n      closed: \"detached\",\n      failed: \"failed\",\n      suspended: \"suspended\"\n    };\n    const fromChannelStates = [\"attaching\", \"attached\", \"detaching\", \"suspended\"];\n    const toChannelState = connectionStateToChannelState[connectionState];\n    for (const channelId in this.all) {\n      const channel = this.all[channelId];\n      if (fromChannelStates.includes(channel.state)) {\n        channel.notifyState(toChannelState, reason);\n      }\n    }\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      channel = this.all[name] = new realtimechannel_default(this.realtime, name, channelOptions);\n    } else if (channelOptions) {\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n        throw new ErrorInfo(\n          \"Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.\",\n          4e4,\n          400\n        );\n      }\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  getDerived(name, deriveOptions, channelOptions) {\n    if (deriveOptions.filter) {\n      const filter = toBase64(deriveOptions.filter);\n      const match = matchDerivedChannel(name);\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\n    }\n    return this.get(name, channelOptions);\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    name = String(name);\n    const channel = this.all[name];\n    if (!channel) {\n      return;\n    }\n    const releaseErr = channel.getReleaseErr();\n    if (releaseErr) {\n      throw releaseErr;\n    }\n    delete this.all[name];\n  }\n};\nvar baserealtime_default = BaseRealtime;\n\n// src/common/lib/client/presencemap.ts\nfunction newerThan(item, existing) {\n  if (item.isSynthesized() || existing.isSynthesized()) {\n    return item.timestamp >= existing.timestamp;\n  }\n  const itemOrderings = item.parseId(), existingOrderings = existing.parseId();\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n    return itemOrderings.index > existingOrderings.index;\n  } else {\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\n  }\n}\nvar PresenceMap = class extends eventemitter_default {\n  constructor(presence, memberKey, newer = newerThan) {\n    super(presence.logger);\n    this.presence = presence;\n    this.map = /* @__PURE__ */ Object.create(null);\n    this.syncInProgress = false;\n    this.residualMembers = null;\n    this.memberKey = memberKey;\n    this.newerThan = newer;\n  }\n  get(key) {\n    return this.map[key];\n  }\n  getClient(clientId) {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.clientId == clientId && item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  list(params) {\n    const map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action === \"absent\")\n        continue;\n      if (clientId && clientId != item.clientId)\n        continue;\n      if (connectionId && connectionId != item.connectionId)\n        continue;\n      result.push(item);\n    }\n    return result;\n  }\n  put(item) {\n    if (item.action === \"enter\" || item.action === \"update\") {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"present\";\n    }\n    const map = this.map, key = this.memberKey(item);\n    if (this.residualMembers)\n      delete this.residualMembers[key];\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    map[key] = item;\n    return true;\n  }\n  values() {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  remove(item) {\n    const map = this.map, key = this.memberKey(item);\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    if (this.syncInProgress) {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"absent\";\n      map[key] = item;\n    } else {\n      delete map[key];\n    }\n    return !!existingItem;\n  }\n  startSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.startSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!this.syncInProgress) {\n      this.residualMembers = copy(map);\n      this.setInProgress(true);\n    }\n  }\n  endSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.endSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (syncInProgress) {\n      for (const memberKey in map) {\n        const entry = map[memberKey];\n        if (entry.action === \"absent\") {\n          delete map[memberKey];\n        }\n      }\n      this.presence._synthesizeLeaves(valuesArray(this.residualMembers));\n      for (const memberKey in this.residualMembers) {\n        delete map[memberKey];\n      }\n      this.residualMembers = null;\n      this.setInProgress(false);\n    }\n    this.emit(\"sync\");\n  }\n  async waitSync() {\n    const syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.waitSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!syncInProgress) {\n      return;\n    }\n    await this.once(\"sync\");\n  }\n  clear() {\n    this.map = {};\n    this.setInProgress(false);\n    this.residualMembers = null;\n  }\n  setInProgress(inProgress) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"PresenceMap.setInProgress()\", \"inProgress = \" + inProgress);\n    this.syncInProgress = inProgress;\n    this.presence.syncComplete = !inProgress;\n  }\n};\n\n// src/common/lib/client/realtimepresence.ts\nfunction getClientId(realtimePresence) {\n  return realtimePresence.channel.client.auth.clientId;\n}\nfunction isAnonymousOrWildcard(realtimePresence) {\n  const realtime = realtimePresence.channel.client;\n  const clientId = realtime.auth.clientId;\n  return (!clientId || clientId === \"*\") && realtime.connection.state === \"connected\";\n}\nvar RealtimePresence = class extends eventemitter_default {\n  constructor(channel) {\n    super(channel.logger);\n    this.channel = channel;\n    this.syncComplete = false;\n    this.members = new PresenceMap(this, (item) => item.clientId + \":\" + item.connectionId);\n    this._myMembers = new PresenceMap(this, (item) => item.clientId);\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.pendingPresence = [];\n  }\n  async enter(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to enter a presence channel\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"enter\");\n  }\n  async update(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to update presence data\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"update\");\n  }\n  async enterClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"enter\");\n  }\n  async updateClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"update\");\n  }\n  async _enterOrUpdateClient(id, clientId, data, action) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.\" + action + \"Client()\",\n      \"channel = \" + channel.name + \", id = \" + id + \", client = \" + (clientId || \"(implicit) \" + getClientId(this))\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = action;\n    if (id) {\n      presence.id = id;\n    }\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"initialized\":\n      case \"detached\":\n        channel.attach();\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      default: {\n        const err = new PartialErrorInfo(\n          \"Unable to \" + action + \" presence channel while in \" + channel.state + \" state\",\n          90001\n        );\n        err.code = 90001;\n        throw err;\n      }\n    }\n  }\n  async leave(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must have been specified to enter or leave a presence channel\", 40012, 400);\n    }\n    return this.leaveClient(void 0, data);\n  }\n  async leaveClient(clientId, data) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.leaveClient()\",\n      \"leaving; channel = \" + this.channel.name + \", client = \" + clientId\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = \"leave\";\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      case \"initialized\":\n      case \"failed\": {\n        throw new PartialErrorInfo(\"Unable to leave presence channel (incompatible state)\", 90001);\n      }\n      default:\n        throw channel.invalidStateError();\n    }\n  }\n  async get(params) {\n    const waitForSync = !params || (\"waitForSync\" in params ? params.waitForSync : true);\n    function toMessages(members2) {\n      return params ? members2.list(params) : members2.values();\n    }\n    if (this.channel.state === \"suspended\") {\n      if (waitForSync) {\n        throw ErrorInfo.fromValues({\n          statusCode: 400,\n          code: 91005,\n          message: \"Presence state is out of sync due to channel being in the SUSPENDED state\"\n        });\n      }\n      return toMessages(this.members);\n    }\n    await this.channel.ensureAttached();\n    const members = this.members;\n    if (waitForSync) {\n      await members.waitSync();\n    }\n    return toMessages(this.members);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimePresence.history()\", \"channel = \" + this.name);\n    const restMixin = this.channel.client.rest.presenceMixin;\n    if (params && params.untilAttach) {\n      if (this.channel.state === \"attached\") {\n        delete params.untilAttach;\n        params.from_serial = this.channel.properties.attachSerial;\n      } else {\n        throw new ErrorInfo(\n          \"option untilAttach requires the channel to be attached, was: \" + this.channel.state,\n          4e4,\n          400\n        );\n      }\n    }\n    return restMixin.history(this, params);\n  }\n  setPresence(presenceSet, isSync, syncChannelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.setPresence()\",\n      \"received presence for \" + presenceSet.length + \" participants; syncChannelSerial = \" + syncChannelSerial\n    );\n    let syncCursor, match;\n    const members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;\n    if (isSync) {\n      this.members.startSync();\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n        syncCursor = match[1];\n      }\n    }\n    for (let presence of presenceSet) {\n      switch (presence.action) {\n        case \"leave\":\n          if (members.remove(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\n            myMembers.remove(presence);\n          }\n          break;\n        case \"enter\":\n        case \"present\":\n        case \"update\":\n          if (members.put(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId) {\n            myMembers.put(presence);\n          }\n          break;\n      }\n    }\n    if (isSync && !syncCursor) {\n      members.endSync();\n      this.channel.syncChannelSerial = null;\n    }\n    for (let i = 0; i < broadcastMessages.length; i++) {\n      const presence = broadcastMessages[i];\n      this.subscriptions.emit(presence.action, presence);\n    }\n  }\n  onAttached(hasPresence) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimePresence.onAttached()\",\n      \"channel = \" + this.channel.name + \", hasPresence = \" + hasPresence\n    );\n    if (hasPresence) {\n      this.members.startSync();\n    } else {\n      this._synthesizeLeaves(this.members.values());\n      this.members.clear();\n    }\n    this._ensureMyMembersPresent();\n    const pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;\n    if (pendingPresCount) {\n      this.pendingPresence = [];\n      const presenceArray = [];\n      const multicaster = multicaster_default.create(this.logger);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence.onAttached\",\n        \"sending \" + pendingPresCount + \" queued presence messages\"\n      );\n      for (let i = 0; i < pendingPresCount; i++) {\n        const event = pendingPresence[i];\n        presenceArray.push(event.presence);\n        multicaster.push(event.callback);\n      }\n      this.channel.sendPresence(presenceArray).then(() => multicaster()).catch((err) => multicaster(err));\n    }\n  }\n  actOnChannelState(state, hasPresence, err) {\n    switch (state) {\n      case \"attached\":\n        this.onAttached(hasPresence);\n        break;\n      case \"detached\":\n      case \"failed\":\n        this._clearMyMembers();\n        this.members.clear();\n      case \"suspended\":\n        this.failPendingPresence(err);\n        break;\n    }\n  }\n  failPendingPresence(err) {\n    if (this.pendingPresence.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.failPendingPresence\",\n        \"channel; name = \" + this.channel.name + \", err = \" + inspectError(err)\n      );\n      for (let i = 0; i < this.pendingPresence.length; i++)\n        try {\n          this.pendingPresence[i].callback(err);\n        } catch (e) {\n        }\n      this.pendingPresence = [];\n    }\n  }\n  _clearMyMembers() {\n    this._myMembers.clear();\n  }\n  _ensureMyMembersPresent() {\n    const myMembers = this._myMembers;\n    const connId = this.channel.connectionManager.connectionId;\n    for (const memberKey in myMembers.map) {\n      const entry = myMembers.map[memberKey];\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence._ensureMyMembersPresent()\",\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set'\n      );\n      const id = entry.connectionId === connId ? entry.id : void 0;\n      this._enterOrUpdateClient(id, entry.clientId, entry.data, \"enter\").catch((err) => {\n        const wrappedErr = new ErrorInfo(\"Presence auto re-enter failed\", 91004, 400, err);\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"RealtimePresence._ensureMyMembersPresent()\",\n          \"Presence auto re-enter failed; reason = \" + inspectError(err)\n        );\n        const change = new channelstatechange_default(this.channel.state, this.channel.state, true, false, wrappedErr);\n        this.channel.emit(\"update\", change);\n      });\n    }\n  }\n  _synthesizeLeaves(items) {\n    const subscriptions = this.subscriptions;\n    items.forEach(function(item) {\n      const presence = presencemessage_default.fromValues({\n        action: \"leave\",\n        connectionId: item.connectionId,\n        clientId: item.clientId,\n        data: item.data,\n        encoding: item.encoding,\n        timestamp: Date.now()\n      });\n      subscriptions.emit(\"leave\", presence);\n    });\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n};\nvar realtimepresence_default = RealtimePresence;\n\n// src/common/lib/transport/websockettransport.ts\nvar shortName = TransportNames.WebSocket;\nfunction isNodeWebSocket(ws) {\n  return !!ws.on;\n}\nvar WebSocketTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName;\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\n    this.wsHost = params.host;\n  }\n  static isAvailable() {\n    return !!Platform.Config.WebSocket;\n  }\n  createWebSocket(uri, connectParams) {\n    this.uri = uri + toQueryString(connectParams);\n    return new Platform.Config.WebSocket(this.uri);\n  }\n  toString() {\n    return \"WebSocketTransport; uri=\" + this.uri;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const self2 = this, params = this.params, options = params.options;\n    const wsScheme = options.tls ? \"wss://\" : \"ws://\";\n    const wsUri = wsScheme + this.wsHost + \":\" + defaults_default.getPort(options) + \"/\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"uri: \" + wsUri);\n    whenPromiseSettles(\n      this.auth.getAuthParams(),\n      function(err, authParams) {\n        if (self2.isDisposed) {\n          return;\n        }\n        let paramStr = \"\";\n        for (const param in authParams)\n          paramStr += \" \" + param + \": \" + authParams[param] + \";\";\n        logger_default.logAction(\n          self2.logger,\n          logger_default.LOG_MINOR,\n          \"WebSocketTransport.connect()\",\n          \"authParams:\" + paramStr + \" err: \" + err\n        );\n        if (err) {\n          self2.disconnect(err);\n          return;\n        }\n        const connectParams = params.getConnectParams(authParams);\n        try {\n          const wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);\n          wsConnection.binaryType = Platform.Config.binaryType;\n          wsConnection.onopen = function() {\n            self2.onWsOpen();\n          };\n          wsConnection.onclose = function(ev) {\n            self2.onWsClose(ev);\n          };\n          wsConnection.onmessage = function(ev) {\n            self2.onWsData(ev.data);\n          };\n          wsConnection.onerror = function(ev) {\n            self2.onWsError(ev);\n          };\n          if (isNodeWebSocket(wsConnection)) {\n            wsConnection.on(\"ping\", function() {\n              self2.onActivity();\n            });\n          }\n        } catch (e) {\n          logger_default.logAction(\n            self2.logger,\n            logger_default.LOG_ERROR,\n            \"WebSocketTransport.connect()\",\n            \"Unexpected exception creating websocket: err = \" + (e.stack || e.message)\n          );\n          self2.disconnect(e);\n        }\n      }\n    );\n  }\n  send(message) {\n    const wsConnection = this.wsConnection;\n    if (!wsConnection) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", \"No socket connection\");\n      return;\n    }\n    try {\n      wsConnection.send(\n        serialize2(message, this.connectionManager.realtime._MsgPack, this.params.format)\n      );\n    } catch (e) {\n      const msg = \"Exception from ws connection when trying to send: \" + inspectError(e);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", msg);\n      this.finish(\"disconnected\", new ErrorInfo(msg, 5e4, 500));\n    }\n  }\n  onWsData(data) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"WebSocketTransport.onWsData()\",\n      \"data received; length = \" + data.length + \"; type = \" + typeof data\n    );\n    try {\n      this.onProtocolMessage(\n        deserialize(\n          data,\n          this.connectionManager.realtime._MsgPack,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations,\n          this.connectionManager.realtime._liveObjectsPlugin,\n          this.format\n        )\n      );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"WebSocketTransport.onWsData()\",\n        \"Unexpected exception handing channel message: \" + e.stack\n      );\n    }\n  }\n  onWsOpen() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsOpen()\", \"opened WebSocket\");\n    this.emit(\"preconnect\");\n  }\n  onWsClose(ev) {\n    let wasClean, code;\n    if (typeof ev == \"object\") {\n      code = ev.code;\n      wasClean = ev.wasClean || code === 1e3;\n    } else {\n      code = ev;\n      wasClean = code == 1e3;\n    }\n    delete this.wsConnection;\n    if (wasClean) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", \"Cleanly closed WebSocket\");\n      const err = new ErrorInfo(\"Websocket closed\", 80003, 400);\n      this.finish(\"disconnected\", err);\n    } else {\n      const msg = \"Unclean disconnection of WebSocket ; code = \" + code, err = new ErrorInfo(msg, 80003, 400);\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", msg);\n      this.finish(\"disconnected\", err);\n    }\n    this.emit(\"disposed\");\n  }\n  onWsError(err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"WebSocketTransport.onError()\",\n      \"Error from WebSocket: \" + err.message\n    );\n    Platform.Config.nextTick(() => {\n      this.disconnect(Error(err.message));\n    });\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.dispose()\", \"\");\n    this.isDisposed = true;\n    const wsConnection = this.wsConnection;\n    if (wsConnection) {\n      wsConnection.onmessage = function() {\n      };\n      delete this.wsConnection;\n      Platform.Config.nextTick(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"WebSocketTransport.dispose()\", \"closing websocket\");\n        if (!wsConnection) {\n          throw new Error(\"WebSocketTransport.dispose(): wsConnection is not defined\");\n        }\n        wsConnection.close();\n      });\n    }\n  }\n};\nvar websockettransport_default = WebSocketTransport;\n\n// src/common/lib/client/filteredsubscriptions.ts\nvar FilteredSubscriptions = class {\n  static subscribeFilter(channel, filter, listener) {\n    const filteredListener = (m) => {\n      var _a2, _b, _c, _d, _e, _f;\n      const mapping = {\n        name: m.name,\n        refTimeserial: (_b = (_a2 = m.extras) == null ? void 0 : _a2.ref) == null ? void 0 : _b.timeserial,\n        refType: (_d = (_c = m.extras) == null ? void 0 : _c.ref) == null ? void 0 : _d.type,\n        isRef: !!((_f = (_e = m.extras) == null ? void 0 : _e.ref) == null ? void 0 : _f.timeserial),\n        clientId: m.clientId\n      };\n      if (Object.entries(filter).find(\n        ([key, value]) => value !== void 0 ? mapping[key] !== value : false\n      )) {\n        return;\n      }\n      listener(m);\n    };\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\n    channel.subscriptions.on(filteredListener);\n  }\n  // Adds a new filtered subscription\n  static addFilteredSubscription(channel, filter, realListener, filteredListener) {\n    var _a2;\n    if (!channel.filteredSubscriptions) {\n      channel.filteredSubscriptions = /* @__PURE__ */ new Map();\n    }\n    if (channel.filteredSubscriptions.has(realListener)) {\n      const realListenerMap = channel.filteredSubscriptions.get(realListener);\n      realListenerMap.set(filter, ((_a2 = realListenerMap == null ? void 0 : realListenerMap.get(filter)) == null ? void 0 : _a2.concat(filteredListener)) || [filteredListener]);\n    } else {\n      channel.filteredSubscriptions.set(\n        realListener,\n        /* @__PURE__ */ new Map([[filter, [filteredListener]]])\n      );\n    }\n  }\n  static getAndDeleteFilteredSubscriptions(channel, filter, realListener) {\n    if (!channel.filteredSubscriptions) {\n      return [];\n    }\n    if (!realListener && filter) {\n      return Array.from(channel.filteredSubscriptions.entries()).map(([key, filterMaps]) => {\n        var _a2;\n        let listenerMaps = filterMaps.get(filter);\n        filterMaps.delete(filter);\n        if (filterMaps.size === 0) {\n          (_a2 = channel.filteredSubscriptions) == null ? void 0 : _a2.delete(key);\n        }\n        return listenerMaps;\n      }).reduce(\n        (prev, cur) => cur ? prev.concat(...cur) : prev,\n        []\n      );\n    }\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\n      return [];\n    }\n    const realListenerMap = channel.filteredSubscriptions.get(realListener);\n    if (!filter) {\n      const listeners2 = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\n      channel.filteredSubscriptions.delete(realListener);\n      return listeners2;\n    }\n    let listeners = realListenerMap.get(filter);\n    realListenerMap.delete(filter);\n    return listeners || [];\n  }\n};\n\n// src/common/lib/client/defaultrealtime.ts\nvar _DefaultRealtime = class _DefaultRealtime extends baserealtime_default {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2;\n    const MsgPack = _DefaultRealtime._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRealtime._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Realtime\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRealtime.Crypto) != null ? _a2 : void 0,\n        MsgPack,\n        RealtimePresence: {\n          RealtimePresence: realtimepresence_default,\n          PresenceMessage: presencemessage_default,\n          WirePresenceMessage\n        },\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        },\n        WebSocketTransport: websockettransport_default,\n        MessageInteractions: FilteredSubscriptions\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRealtime.Utils = utils_exports;\n_DefaultRealtime.ConnectionManager = connectionmanager_default;\n_DefaultRealtime.ProtocolMessage = protocolmessage_default;\n_DefaultRealtime._Crypto = null;\n_DefaultRealtime.Message = DefaultMessage;\n_DefaultRealtime.PresenceMessage = DefaultPresenceMessage;\n_DefaultRealtime.Annotation = DefaultAnnotation;\n_DefaultRealtime._MsgPack = null;\n// Used by tests\n_DefaultRealtime._Http = Http;\n_DefaultRealtime._PresenceMap = PresenceMap;\n_DefaultRealtime._MessageEncoding = MessageEncoding;\nvar DefaultRealtime = _DefaultRealtime;\n\n// src/platform/nodejs/lib/util/bufferutils.ts\nvar import_crypto = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar BufferUtils = class {\n  constructor() {\n    this.base64CharSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    this.hexCharSet = \"0123456789abcdef\";\n  }\n  base64Decode(string) {\n    return Buffer.from(string, \"base64\");\n  }\n  base64Encode(buffer) {\n    return this.toBuffer(buffer).toString(\"base64\");\n  }\n  base64UrlEncode(buffer) {\n    return this.toBuffer(buffer).toString(\"base64url\");\n  }\n  areBuffersEqual(buffer1, buffer2) {\n    if (!buffer1 || !buffer2)\n      return false;\n    return this.toBuffer(buffer1).compare(this.toBuffer(buffer2)) == 0;\n  }\n  byteLength(buffer) {\n    return buffer.byteLength;\n  }\n  hexDecode(string) {\n    return Buffer.from(string, \"hex\");\n  }\n  hexEncode(buffer) {\n    return this.toBuffer(buffer).toString(\"hex\");\n  }\n  /* In node, BufferUtils methods that return binary objects return a Buffer\n   * for historical reasons; the browser equivalents return ArrayBuffers */\n  isBuffer(buffer) {\n    return Buffer.isBuffer(buffer) || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n  }\n  toArrayBuffer(buffer) {\n    const nodeBuffer = this.toBuffer(buffer);\n    return nodeBuffer.buffer.slice(nodeBuffer.byteOffset, nodeBuffer.byteOffset + nodeBuffer.byteLength);\n  }\n  toBuffer(buffer) {\n    if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return Buffer.from(buffer);\n    }\n    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  }\n  arrayBufferViewToBuffer(arrayBufferView) {\n    return this.toBuffer(arrayBufferView);\n  }\n  utf8Decode(buffer) {\n    if (!this.isBuffer(buffer)) {\n      throw new Error(\"Expected input of utf8Decode to be a buffer, arraybuffer, or view\");\n    }\n    return this.toBuffer(buffer).toString(\"utf8\");\n  }\n  utf8Encode(string) {\n    return Buffer.from(string, \"utf8\");\n  }\n  concat(buffers) {\n    return Buffer.concat(buffers.map((x) => this.toBuffer(x)));\n  }\n  sha256(message) {\n    const messageBuffer = this.toBuffer(message);\n    return import_crypto.default.createHash(\"SHA256\").update(messageBuffer).digest();\n  }\n  hmacSha256(message, key) {\n    const messageBuffer = this.toBuffer(message);\n    const keyBuffer = this.toBuffer(key);\n    return import_crypto.default.createHmac(\"SHA256\", keyBuffer).update(messageBuffer).digest();\n  }\n};\nvar bufferutils_default = new BufferUtils();\n\n// src/platform/nodejs/lib/util/crypto.ts\nvar import_crypto2 = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_util = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar createCryptoClass = function(bufferUtils) {\n  var DEFAULT_ALGORITHM = \"aes\";\n  var DEFAULT_KEYLENGTH = 256;\n  var DEFAULT_MODE = \"cbc\";\n  var DEFAULT_BLOCKLENGTH = 16;\n  async function generateRandom(bytes) {\n    return import_util.default.promisify(import_crypto2.default.randomBytes)(bytes);\n  }\n  function getPaddedLength(plaintextLength) {\n    return plaintextLength + DEFAULT_BLOCKLENGTH & -DEFAULT_BLOCKLENGTH;\n  }\n  function validateCipherParams(params) {\n    if (params.algorithm === \"aes\" && params.mode === \"cbc\") {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        \"Unsupported key length \" + params.keyLength + \" for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)\"\n      );\n    }\n  }\n  function normaliseBase64(string) {\n    return string.replace(\"_\", \"/\").replace(\"-\", \"+\");\n  }\n  function filledBuffer(length, value) {\n    var result = Buffer.alloc(length);\n    result.fill(value);\n    return result;\n  }\n  var pkcs5Padding = [filledBuffer(16, 16)];\n  for (var i = 1; i <= 16; i++)\n    pkcs5Padding.push(filledBuffer(i, i));\n  class CipherParams {\n    constructor(algorithm, keyLength, mode, key) {\n      this.algorithm = algorithm;\n      this.keyLength = keyLength;\n      this.mode = mode;\n      this.key = key;\n      this.iv = null;\n    }\n  }\n  function isInstCipherParams(params) {\n    return !!(params.algorithm && params.key && params.keyLength && params.mode);\n  }\n  class Crypto2 {\n    /**\n     * Obtain a complete CipherParams instance from the provided params, filling\n     * in any not provided with default values, calculating a keyLength from\n     * the supplied key, and validating the result.\n     * @param params an object containing at a minimum a `key` key with value the\n     * key, as either a binary or a base64-encoded string.\n     * May optionally also contain: algorithm (defaults to AES),\n     * mode (defaults to 'cbc')\n     */\n    static getDefaultParams(params) {\n      var key;\n      if (!params.key) {\n        throw new Error(\"Crypto.getDefaultParams: a key is required\");\n      }\n      if (typeof params.key === \"string\") {\n        key = bufferUtils.base64Decode(normaliseBase64(params.key));\n      } else if (params.key instanceof ArrayBuffer) {\n        key = Buffer.from(params.key);\n      } else {\n        key = params.key;\n      }\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n      var keyLength = key.length * 8;\n      var mode = params.mode || DEFAULT_MODE;\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n        throw new Error(\n          \"Crypto.getDefaultParams: a keyLength of \" + params.keyLength + \" was specified, but the key actually has length \" + cipherParams.keyLength\n        );\n      }\n      validateCipherParams(cipherParams);\n      return cipherParams;\n    }\n    /**\n     * Generate a random encryption key from the supplied keylength (or the\n     * default keyLength if none supplied) as a Buffer\n     * @param keyLength (optional) the required keyLength in bits\n     */\n    static async generateRandomKey(keyLength) {\n      try {\n        return generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8);\n      } catch (err) {\n        throw new ErrorInfo(\"Failed to generate random key: \" + err.message, 500, 5e4, err);\n      }\n    }\n    /**\n     * Internal; get a ChannelCipher instance based on the given cipherParams\n     * @param params either a CipherParams instance or some subset of its\n     * fields that includes a key\n     */\n    static getCipher(params, logger) {\n      var _a2;\n      var cipherParams = isInstCipherParams(params) ? params : this.getDefaultParams(params);\n      return {\n        cipherParams,\n        cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null, logger)\n      };\n    }\n  }\n  Crypto2.CipherParams = CipherParams;\n  Crypto2;\n  class CBCCipher {\n    constructor(params, iv, logger) {\n      this.logger = logger;\n      this.encryptCipher = null;\n      this.algorithm = params.algorithm + \"-\" + String(params.keyLength) + \"-\" + params.mode;\n      this.key = params.key;\n      this.iv = iv;\n    }\n    async encrypt(plaintext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.encrypt()\", \"\");\n      const iv = await this.getIv();\n      if (!this.encryptCipher) {\n        this.encryptCipher = import_crypto2.default.createCipheriv(this.algorithm, this.key, iv);\n      }\n      var plaintextBuffer = bufferUtils.toBuffer(plaintext);\n      var plaintextLength = plaintextBuffer.length, paddedLength = getPaddedLength(plaintextLength);\n      var cipherOut = this.encryptCipher.update(\n        Buffer.concat([plaintextBuffer, pkcs5Padding[paddedLength - plaintextLength]])\n      );\n      var ciphertext = Buffer.concat([iv, cipherOut]);\n      return ciphertext;\n    }\n    async decrypt(ciphertext) {\n      var decryptCipher = import_crypto2.default.createDecipheriv(this.algorithm, this.key, ciphertext.slice(0, DEFAULT_BLOCKLENGTH)), plaintext = decryptCipher.update(ciphertext.slice(DEFAULT_BLOCKLENGTH)), final = decryptCipher.final();\n      if (final && final.length)\n        plaintext = Buffer.concat([plaintext, final]);\n      return plaintext;\n    }\n    async getIv() {\n      if (this.iv) {\n        var iv = this.iv;\n        this.iv = null;\n        return iv;\n      }\n      var randomBlock = await generateRandom(DEFAULT_BLOCKLENGTH);\n      if (!this.encryptCipher) {\n        return randomBlock;\n      } else {\n        return this.encryptCipher.update(randomBlock);\n      }\n    }\n  }\n  return Crypto2;\n};\n\n// src/platform/nodejs/lib/util/http.ts\nvar import_got = __toESM(__webpack_require__(/*! got */ \"(ssr)/./node_modules/.pnpm/got@11.8.6/node_modules/got/dist/source/index.js\"));\nvar import_http5 = __toESM(__webpack_require__(/*! http */ \"http\"));\nvar import_https = __toESM(__webpack_require__(/*! https */ \"https\"));\nvar globalAgentPool = [];\nvar _a;\nvar Http2 = (_a = class {\n  constructor(client) {\n    this.agent = null;\n    this.supportsAuthHeaders = true;\n    this.supportsLinkHeaders = true;\n    this.checkConnectivity = async () => {\n      var _a2, _b, _c, _d, _e;\n      if ((_a2 = this.client) == null ? void 0 : _a2.options.disableConnectivityCheck) {\n        return true;\n      }\n      const connectivityCheckUrl = ((_b = this.client) == null ? void 0 : _b.options.connectivityCheckUrl) || defaults_default.connectivityCheckUrl;\n      const connectivityCheckParams = (_d = (_c = this.client) == null ? void 0 : _c.options.connectivityCheckParams) != null ? _d : null;\n      const connectivityUrlIsDefault = !((_e = this.client) == null ? void 0 : _e.options.connectivityCheckUrl);\n      const { error, statusCode, body } = await this.doUri(\n        HttpMethods_default.Get,\n        connectivityCheckUrl,\n        null,\n        null,\n        connectivityCheckParams\n      );\n      if (!error && !connectivityUrlIsDefault) {\n        return isSuccessCode(statusCode);\n      }\n      return !error && (body == null ? void 0 : body.toString().trim()) === \"yes\";\n    };\n    this.client = client != null ? client : null;\n  }\n  async doUri(method, uri, headers, body, params) {\n    var _a2;\n    const agentOptions = this.client && this.client.options.restAgentOptions || defaults_default.restAgentOptions;\n    const doOptions = { headers: headers || void 0, responseType: \"buffer\" };\n    if (!this.agent) {\n      const persistedAgent = (_a2 = globalAgentPool.find((x) => shallowEquals(agentOptions, x.options))) == null ? void 0 : _a2.agents;\n      if (persistedAgent) {\n        this.agent = persistedAgent;\n      } else {\n        this.agent = {\n          http: new import_http5.default.Agent(agentOptions),\n          https: new import_https.default.Agent(agentOptions)\n        };\n        globalAgentPool.push({\n          options: agentOptions,\n          agents: this.agent\n        });\n      }\n    }\n    if (body) {\n      doOptions.body = body;\n    }\n    if (params)\n      doOptions.searchParams = params;\n    doOptions.agent = this.agent;\n    doOptions.url = uri;\n    doOptions.timeout = {\n      request: (this.client && this.client.options.timeouts || defaults_default.TIMEOUTS).httpRequestTimeout\n    };\n    doOptions.retry = { limit: 0 };\n    try {\n      const res = await import_got.default[method](doOptions);\n      return this._handler(null, res, res.body);\n    } catch (err) {\n      if (err instanceof import_got.default.HTTPError) {\n        return this._handler(null, err.response, err.response.body);\n      }\n      return this._handler(err);\n    }\n  }\n  shouldFallback(err) {\n    const { code, statusCode } = err;\n    return code === \"ENETUNREACH\" || code === \"EHOSTUNREACH\" || code === \"EHOSTDOWN\" || code === \"ETIMEDOUT\" || code === \"ESOCKETTIMEDOUT\" || code === \"ENOTFOUND\" || code === \"ECONNRESET\" || code === \"ECONNREFUSED\" || statusCode >= 500 && statusCode <= 504;\n  }\n  _handler(err, response, body) {\n    var _a2;\n    if (err) {\n      return { error: err };\n    }\n    const statusCode = response.statusCode, headers = response.headers;\n    if (statusCode >= 300) {\n      switch (headers[\"content-type\"]) {\n        case \"application/json\":\n          body = JSON.parse(body);\n          break;\n        case \"application/x-msgpack\":\n          if (!((_a2 = this.client) == null ? void 0 : _a2._MsgPack)) {\n            return { error: createMissingPluginError(\"MsgPack\") };\n          }\n          body = this.client._MsgPack.decode(body);\n          break;\n      }\n      const error = body.error ? ErrorInfo.fromValues(body.error) : new ErrorInfo(\n        headers[\"x-ably-errormessage\"] || \"Error response received from server: \" + statusCode + \" body was: \" + Platform.Config.inspect(body),\n        Number(headers[\"x-ably-errorcode\"]),\n        statusCode\n      );\n      return { error, body, headers, unpacked: true, statusCode };\n    }\n    return { error: null, body, headers, unpacked: false, statusCode };\n  }\n}, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);\nvar http_default = Http2;\n\n// src/platform/nodejs/config.ts\nvar import_crypto3 = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_ws = __toESM(__webpack_require__(/*! ws */ \"(ssr)/./node_modules/.pnpm/ws@8.19.0/node_modules/ws/index.js\"));\nvar import_util2 = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar Config = {\n  agent: \"nodejs/\" + process.versions.node,\n  logTimestamps: true,\n  userAgent: null,\n  binaryType: \"nodebuffer\",\n  WebSocket: import_ws.default,\n  useProtocolHeartbeats: false,\n  supportsBinary: true,\n  preferBinary: true,\n  nextTick: process.nextTick,\n  inspect: import_util2.default.inspect,\n  stringByteSize: Buffer.byteLength,\n  inherits: import_util2.default.inherits,\n  addEventListener: null,\n  getRandomArrayBuffer: async function(byteLength) {\n    return import_util2.default.promisify(import_crypto3.default.randomBytes)(byteLength);\n  }\n};\nvar config_default = Config;\n\n// src/common/constants/XHRStates.ts\nvar XHRStates = /* @__PURE__ */ ((XHRStates2) => {\n  XHRStates2[XHRStates2[\"REQ_SEND\"] = 0] = \"REQ_SEND\";\n  XHRStates2[XHRStates2[\"REQ_RECV\"] = 1] = \"REQ_RECV\";\n  XHRStates2[XHRStates2[\"REQ_RECV_POLL\"] = 2] = \"REQ_RECV_POLL\";\n  XHRStates2[XHRStates2[\"REQ_RECV_STREAM\"] = 3] = \"REQ_RECV_STREAM\";\n  return XHRStates2;\n})(XHRStates || {});\nvar XHRStates_default = XHRStates;\n\n// src/common/lib/transport/comettransport.ts\nfunction shouldBeErrorAction(err) {\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n  if (err.code) {\n    if (auth_default.isTokenErr(err))\n      return false;\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code))\n      return true;\n    return err.code >= 4e4 && err.code < 5e4;\n  } else {\n    return false;\n  }\n}\nfunction protocolMessageFromRawError(err) {\n  if (shouldBeErrorAction(err)) {\n    return [fromValues({ action: actions.ERROR, error: err })];\n  } else {\n    return [fromValues({ action: actions.DISCONNECTED, error: err })];\n  }\n}\nvar CometTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(\n      connectionManager,\n      auth,\n      params,\n      /* binary not supported for comet so force JSON protocol */\n      true\n    );\n    /* Historical comment, back from when we supported JSONP:\n     *\n     * > For comet, we could do the auth update by aborting the current recv and\n     * > starting a new one with the new token, that'd be sufficient for realtime.\n     * > Problem is JSONP - you can't cancel truly abort a recv once started. So\n     * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\n     * > comet transports the same and do it for all of them. So we send the AUTH\n     * > instead, and don't need to abort the recv\n     *\n     * Now that weâ€™ve dropped JSONP support, we may be able to revisit the above;\n     * see https://github.com/ably/ably-js/issues/1214.\n     */\n    this.onAuthUpdated = (tokenDetails) => {\n      this.authParams = { access_token: tokenDetails.token };\n    };\n    this.stream = \"stream\" in params ? params.stream : true;\n    this.sendRequest = null;\n    this.recvRequest = null;\n    this.pendingCallback = null;\n    this.pendingItems = null;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const params = this.params;\n    const options = params.options;\n    const host = params.host || options.primaryDomain;\n    const port = defaults_default.getPort(options);\n    const cometScheme = options.tls ? \"https://\" : \"http://\";\n    this.baseUri = cometScheme + host + \":\" + port + \"/comet/\";\n    const connectUri = this.baseUri + \"connect\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"uri: \" + connectUri);\n    whenPromiseSettles(this.auth.getAuthParams(), (err, authParams) => {\n      if (err) {\n        this.disconnect(err);\n        return;\n      }\n      if (this.isDisposed) {\n        return;\n      }\n      this.authParams = authParams;\n      const connectParams = this.params.getConnectParams(authParams);\n      if (\"stream\" in connectParams)\n        this.stream = connectParams.stream;\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"CometTransport.connect()\",\n        \"connectParams:\" + toQueryString(connectParams)\n      );\n      let preconnected = false;\n      const connectRequest = this.recvRequest = this.createRequest(\n        connectUri,\n        null,\n        connectParams,\n        null,\n        this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV\n      );\n      connectRequest.on(\"data\", (data) => {\n        if (!this.recvRequest) {\n          return;\n        }\n        if (!preconnected) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onData(data);\n      });\n      connectRequest.on(\"complete\", (err2) => {\n        if (!this.recvRequest) {\n          err2 = err2 || new ErrorInfo(\"Request cancelled\", 80003, 400);\n        }\n        this.recvRequest = null;\n        if (!preconnected && !err2) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onActivity();\n        if (err2) {\n          if (err2.code) {\n            this.onData(protocolMessageFromRawError(err2));\n          } else {\n            this.disconnect(err2);\n          }\n          return;\n        }\n        Platform.Config.nextTick(() => {\n          this.recv();\n        });\n      });\n      connectRequest.exec();\n    });\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestClose()\");\n    this._requestCloseOrDisconnect(true);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestDisconnect()\");\n    this._requestCloseOrDisconnect(false);\n  }\n  _requestCloseOrDisconnect(closing) {\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n    if (closeOrDisconnectUri) {\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_default.REQ_SEND);\n      request.on(\"complete\", (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"CometTransport.request\" + (closing ? \"Close()\" : \"Disconnect()\"),\n            \"request returned err = \" + inspectError(err)\n          );\n          this.finish(\"disconnected\", err);\n        }\n      });\n      request.exec();\n    }\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"\");\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      if (this.recvRequest) {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"aborting recv request\");\n        this.recvRequest.abort();\n        this.recvRequest = null;\n      }\n      this.finish(\"disconnected\", connectionerrors_default.disconnected());\n      Platform.Config.nextTick(() => {\n        this.emit(\"disposed\");\n      });\n    }\n  }\n  onConnect(message) {\n    var _a2;\n    if (this.isDisposed) {\n      return;\n    }\n    const connectionStr = (_a2 = message.connectionDetails) == null ? void 0 : _a2.connectionKey;\n    transport_default.prototype.onConnect.call(this, message);\n    const baseConnectionUri = this.baseUri + connectionStr;\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CometTransport.onConnect()\", \"baseUri = \" + baseConnectionUri);\n    this.sendUri = baseConnectionUri + \"/send\";\n    this.recvUri = baseConnectionUri + \"/recv\";\n    this.closeUri = baseConnectionUri + \"/close\";\n    this.disconnectUri = baseConnectionUri + \"/disconnect\";\n  }\n  send(message) {\n    if (this.sendRequest) {\n      this.pendingItems = this.pendingItems || [];\n      this.pendingItems.push(message);\n      return;\n    }\n    const pendingItems = this.pendingItems || [];\n    pendingItems.push(message);\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendAnyPending() {\n    const pendingItems = this.pendingItems;\n    if (!pendingItems) {\n      return;\n    }\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendItems(items) {\n    const sendRequest = this.sendRequest = this.createRequest(\n      this.sendUri,\n      null,\n      this.authParams,\n      this.encodeRequest(items),\n      XHRStates_default.REQ_SEND\n    );\n    sendRequest.on(\"complete\", (err, data) => {\n      if (err)\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"CometTransport.sendItems()\",\n          \"on complete: err = \" + inspectError(err)\n        );\n      this.sendRequest = null;\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      if (data) {\n        this.onData(data);\n      }\n      if (this.pendingItems) {\n        Platform.Config.nextTick(() => {\n          if (!this.sendRequest) {\n            this.sendAnyPending();\n          }\n        });\n      }\n    });\n    sendRequest.exec();\n  }\n  recv() {\n    if (this.recvRequest)\n      return;\n    if (!this.isConnected)\n      return;\n    const recvRequest = this.recvRequest = this.createRequest(\n      this.recvUri,\n      null,\n      this.authParams,\n      null,\n      this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV_POLL\n    );\n    recvRequest.on(\"data\", (data) => {\n      this.onData(data);\n    });\n    recvRequest.on(\"complete\", (err) => {\n      this.recvRequest = null;\n      this.onActivity();\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      Platform.Config.nextTick(() => {\n        this.recv();\n      });\n    });\n    recvRequest.exec();\n  }\n  onData(responseData) {\n    try {\n      const items = this.decodeResponse(responseData);\n      if (items && items.length)\n        for (let i = 0; i < items.length; i++)\n          this.onProtocolMessage(\n            fromDeserialized(\n              items[i],\n              this.connectionManager.realtime._RealtimePresence,\n              this.connectionManager.realtime._Annotations,\n              this.connectionManager.realtime._liveObjectsPlugin\n            )\n          );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"CometTransport.onData()\",\n        \"Unexpected exception handing channel event: \" + e.stack\n      );\n    }\n  }\n  encodeRequest(requestItems) {\n    return JSON.stringify(requestItems);\n  }\n  decodeResponse(responseData) {\n    if (typeof responseData == \"string\")\n      return JSON.parse(responseData);\n    return responseData;\n  }\n};\nvar comettransport_default = CometTransport;\n\n// src/platform/nodejs/lib/transport/nodecomettransport.js\nvar import_http6 = __toESM(__webpack_require__(/*! http */ \"http\"));\nvar import_https2 = __toESM(__webpack_require__(/*! https */ \"https\"));\nvar import_url = __toESM(__webpack_require__(/*! url */ \"url\"));\nvar import_util3 = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar noop3 = function() {\n};\nvar shortName2 = TransportNames.Comet;\nvar NodeCometTransport = class extends comettransport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.httpAgent = null;\n    this.httpsAgent = null;\n    this.pendingRequests = 0;\n    this.shortName = shortName2;\n  }\n  static isAvailable() {\n    return true;\n  }\n  toString() {\n    return \"NodeCometTransport; uri=\" + this.baseUri + \"; isConnected=\" + this.isConnected + \"; format=\" + this.format + \"; stream=\" + this.stream;\n  }\n  getAgent(tls) {\n    var prop = tls ? \"httpsAgent\" : \"httpAgent\", agent2 = this[prop];\n    if (!agent2)\n      agent2 = this[prop] = new (tls ? import_https2.default : import_http6.default).Agent({ keepAlive: true });\n    return agent2;\n  }\n  dispose() {\n    var self2 = this;\n    this.onceNoPending(function() {\n      if (self2.httpAgent)\n        self2.httpAgent.destroy();\n      if (self2.httpsAgent)\n        self2.httpsAgent.destroy();\n    });\n    comettransport_default.prototype.dispose.call(this);\n  }\n  /* valid in non-streaming mode only, or data only contains last update */\n  request(uri, params, body, requestMode, callback) {\n    var req = this.createRequest(uri, params, body, requestMode);\n    req.once(\"complete\", callback);\n    req.exec();\n    return req;\n  }\n  createRequest(uri, headers, params, body, requestMode) {\n    return new Request(uri, headers, params, body, requestMode, this.format, this.timeouts, this);\n  }\n  addPending() {\n    ++this.pendingRequests;\n  }\n  removePending() {\n    if (--this.pendingRequests <= 0) {\n      this.emit(\"nopending\");\n    }\n  }\n  onceNoPending(listener) {\n    if (this.pendingRequests == 0) {\n      listener();\n      return;\n    }\n    this.once(\"nopending\", listener);\n  }\n};\nvar Request = class extends eventemitter_default {\n  constructor(uri, headers, params, body, requestMode, format, timeouts, transport) {\n    super(transport.logger);\n    if (typeof uri == \"string\")\n      uri = import_url.default.parse(uri);\n    var tls = uri.protocol == \"https:\";\n    this.client = tls ? import_https2.default : import_http6.default;\n    this.requestMode = requestMode;\n    this.timeouts = timeouts;\n    this.transport = transport;\n    this.requestComplete = false;\n    this.req = this.res = null;\n    var method = \"GET\", contentType = format == \"msgpack\" ? \"application/x-msgpack\" : \"application/json\";\n    headers = headers ? mixin({}, headers) : {};\n    headers[\"accept\"] = contentType;\n    if (body) {\n      method = \"POST\";\n      if (!Buffer.isBuffer(body)) {\n        if (typeof body == \"object\")\n          body = JSON.stringify(body);\n        body = Buffer.from(body);\n      }\n      this.body = body;\n      headers[\"Content-Length\"] = body.length;\n      headers[\"Content-Type\"] = contentType;\n    }\n    var requestOptions = this.requestOptions = {\n      hostname: uri.hostname,\n      port: uri.port,\n      path: uri.path + toQueryString(params),\n      method,\n      headers\n    };\n    if (transport)\n      requestOptions.agent = transport.getAgent(tls);\n  }\n  exec() {\n    var timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, self2 = this;\n    var timer = this.timer = setTimeout(function() {\n      self2.abort();\n    }, timeout), req = this.req = this.client.request(this.requestOptions);\n    req.on(\n      \"error\",\n      this.onReqError = function(err) {\n        err = new PartialErrorInfo(\"Request error: \" + err.message, null, 400);\n        clearTimeout(timer);\n        self2.timer = null;\n        self2.complete(err);\n      }\n    );\n    req.on(\"response\", function(res) {\n      clearTimeout(timer);\n      self2.timer = null;\n      var statusCode = res.statusCode;\n      if (statusCode == HttpStatusCodes_default.NoContent) {\n        res.resume();\n        self2.complete();\n        return;\n      }\n      res.on(\n        \"error\",\n        self2.onResError = function(err) {\n          err = new PartialErrorInfo(\"Response error: \" + err.message, null, 400);\n          self2.complete(err);\n        }\n      );\n      self2.res = res;\n      if (self2.requestMode == XHRStates_default.REQ_RECV_STREAM && statusCode < 400) {\n        self2.readStream();\n      } else {\n        self2.readFully();\n      }\n    });\n    if (this.transport)\n      this.transport.addPending();\n    req.end(this.body);\n  }\n  readStream() {\n    var res = this.res, self2 = this;\n    this.chunks = [];\n    this.streamComplete = false;\n    function onChunk(chunk) {\n      try {\n        chunk = JSON.parse(chunk);\n      } catch (e) {\n        var msg = \"Malformed response body from server: \" + e.message;\n        logger_default.logAction(self2.logger, logger_default.LOG_ERROR, \"NodeCometTransport.Request.readStream()\", msg);\n        self2.complete(new PartialErrorInfo(msg, null, 400));\n        return;\n      }\n      self2.emit(\"data\", chunk);\n    }\n    res.on(\n      \"data\",\n      this.ondata = function(data) {\n        var newChunks = String(data).split(\"\\n\"), chunks = self2.chunks;\n        if (newChunks.length > 1 && chunks.length > 0) {\n          chunks.push(newChunks.shift());\n          self2.chunks = [];\n          onChunk(chunks.join(\"\"));\n        }\n        var trailingNewChunk = newChunks.pop();\n        if (trailingNewChunk.length) {\n          self2.chunks.push(trailingNewChunk);\n        }\n        newChunks.map(onChunk);\n      }\n    );\n    res.on(\"end\", function() {\n      self2.streamComplete = true;\n      process.nextTick(function() {\n        self2.complete();\n      });\n    });\n  }\n  readFully() {\n    var res = this.res, chunks = [], self2 = this;\n    res.on(\"data\", function(chunk) {\n      chunks.push(chunk);\n    });\n    res.on(\"end\", function() {\n      process.nextTick(function() {\n        var body = Buffer.concat(chunks), statusCode = res.statusCode;\n        try {\n          body = JSON.parse(String(body));\n        } catch (e) {\n          var msg = \"Malformed response body from server: \" + e.message;\n          logger_default.logAction(self2.logger, logger_default.LOG_ERROR, \"NodeCometTransport.Request.readFully()\", msg);\n          self2.complete(new PartialErrorInfo(msg, null, 400));\n          return;\n        }\n        if (statusCode < 400 || Array.isArray(body)) {\n          self2.complete(null, body);\n          return;\n        }\n        var err = body.error && ErrorInfo.fromValues(body.error);\n        if (!err) {\n          err = new PartialErrorInfo(\n            \"Error response received from server: \" + statusCode + \", body was: \" + import_util3.default.inspect(body),\n            null,\n            statusCode\n          );\n        }\n        self2.complete(err);\n      });\n    });\n  }\n  complete(err, body) {\n    if (!this.requestComplete) {\n      this.requestComplete = true;\n      if (body)\n        this.emit(\"data\", body);\n      this.emit(\"complete\", err, body);\n      if (err) {\n        if (this.ondata && !this.streamComplete) {\n          if (this.ondata && this.res)\n            this.res.removeListener(\"data\", this.ondata);\n        }\n      }\n      if (this.transport) {\n        this.transport.removePending();\n      }\n    }\n  }\n  abort() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"NodeCometTransport.Request.abort()\", \"\");\n    var timer = this.timer;\n    if (timer) {\n      clearTimeout(timer);\n      this.timer = null;\n    }\n    var req = this.req;\n    if (req) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"NodeCometTransport.Request.abort()\", \"aborting request\");\n      req.removeListener(\"error\", this.onReqError);\n      req.on(\"error\", noop3);\n      req.abort();\n      this.req = null;\n    }\n    this.complete({ statusCode: 400, code: 80003, message: \"Cancelled\" });\n  }\n};\nvar nodecomettransport_default = NodeCometTransport;\n\n// src/platform/nodejs/lib/transport/index.ts\nvar transport_default2 = {\n  order: [TransportNames.Comet],\n  bundledImplementations: {\n    [TransportNames.WebSocket]: websockettransport_default,\n    [TransportNames.Comet]: nodecomettransport_default\n  }\n};\n\n// src/platform/nodejs/lib/util/defaults.ts\nvar Defaults2 = {\n  connectivityCheckUrl: \"https://internet-up.ably-realtime.com/is-the-internet-up.txt\",\n  wsConnectivityCheckUrl: \"wss://ws-up.ably-realtime.com\",\n  /* Note: order matters here: the base transport is the leftmost one in the\n   * intersection of baseTransportOrder and the transports clientOption that's supported. */\n  defaultTransports: [TransportNames.WebSocket],\n  restAgentOptions: { maxSockets: 40, keepAlive: true }\n};\nvar defaults_default2 = Defaults2;\n\n// src/platform/nodejs/index.ts\nvar msgpack = require_msgpack();\nvar Crypto = createCryptoClass(bufferutils_default);\nPlatform.Crypto = Crypto;\nPlatform.BufferUtils = bufferutils_default;\nPlatform.Http = http_default;\nPlatform.Config = config_default;\nPlatform.Transports = transport_default2;\nPlatform.WebStorage = null;\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\n  clientClass.Crypto = Crypto;\n  clientClass._MsgPack = msgpack;\n}\nlogger_default.initLogHandlers();\nPlatform.Defaults = getDefaults(defaults_default2);\nif (Platform.Config.agent) {\n  Platform.Defaults.agent += \" \" + Platform.Config.agent;\n}\nmodule.exports = {\n  ErrorInfo,\n  Rest: DefaultRest,\n  Realtime: DefaultRealtime,\n  msgpack: null,\n  makeProtocolMessageFromDeserialized: makeFromDeserializedWithDependencies\n};\nif (typeof module.exports == \"object\" && typeof exports == \"object\") {\n  var __cp = (to, from, except, desc) => {\n    if ((from && typeof from === \"object\") || typeof from === \"function\") {\n      for (let key of Object.getOwnPropertyNames(from)) {\n        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)\n        Object.defineProperty(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,\n        });\n      }\n    }\n    return to;\n  };\n  module.exports = __cp(module.exports, exports);\n}\nreturn module.exports;\n}))\n//# sourceMappingURL=ably-node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWJseUAyLjE3LjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvYWJseS9idWlsZC9hYmx5LW5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBdUQ7QUFDL0QseUJBQXlCLG1CQUFPLENBQUMseUVBQUksR0FBRyxtQkFBTyxDQUFDLHdGQUFLO0FBQ3JELE1BQU0sS0FBSyxFQU1OO0FBQ0wsR0FBRztBQUNIO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsK0JBQStCLHNCQUFzQixnQkFBZ0I7QUFDbEwsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsa0JBQWtCLG1DQUFtQyxPQUFPO0FBQ3ZJO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxrQkFBa0Isc0NBQXNDLE9BQU87QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsa0JBQWtCLHNDQUFzQyxPQUFPO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGtCQUFrQixzQ0FBc0MsT0FBTztBQUMxSTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLHlEQUF5RCxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEseUNBQXlDLFFBQVEsdUNBQXVDLFFBQVEsZ0JBQWdCLFFBQVE7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVUsY0FBYyxRQUFRLGtDQUFrQyxRQUFRLHVDQUF1QyxRQUFRLGdCQUFnQixRQUFRO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb1FBQW9RLHdCQUF3QjtBQUM1UjtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtQkFBbUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsY0FBYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsWUFBWTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQixHQUFHLEdBQUcsWUFBWSxPQUFPO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCLGlHQUFpRyx1QkFBdUI7QUFDcEwsa0VBQWtFLHNCQUFzQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCLCtDQUErQztBQUM3RixzRUFBc0Usc0JBQXNCO0FBQzVGO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLHVCQUF1QixpREFBaUQ7QUFDL0Ysc0VBQXNFLHNCQUFzQjtBQUM1RjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUIseUNBQXlDLGlEQUFpRDtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxvQkFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtFQUFrRSxJQUFJO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtFQUFrRSxJQUFJO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSw0Q0FBNEM7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLDJCQUEyQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsMkJBQTJCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwrS0FBK0sscUJBQXFCLGVBQWUscUVBQXFFLGNBQWM7QUFDdFM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0IsNkJBQTZCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0Q7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0NBQXNDLDhDQUE4Qyx1Q0FBdUM7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseURBQXlELDJCQUEyQiwwQkFBMEIsb0JBQW9CO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4Riw2Q0FBNkM7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSxxREFBcUQsa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5REFBeUQsMkJBQTJCLDBCQUEwQixvQkFBb0I7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUsd0RBQXdELGtCQUFrQjtBQUN6RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQStDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU8sbUNBQW1DLFlBQVk7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLHlCQUF5QixVQUFVLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixRQUFRO0FBQ1IscUJBQXFCO0FBQ3JCLFFBQVE7QUFDUixxQkFBcUI7QUFDckI7QUFDQSxNQUFNO0FBQ04sbUJBQW1CO0FBQ25CLE1BQU07QUFDTixtQkFBbUI7QUFDbkIsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQixNQUFNO0FBQ04sbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0oscUJBQXFCLGVBQWU7QUFDNUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYSwwQkFBMEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVSxtRUFBbUU7QUFDN0U7QUFDQSwwQ0FBMEMsYUFBYSxzQkFBc0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQXVDO0FBQzlEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVDQUF1Qyw4Q0FBOEMsdUNBQXVDO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3TEFBd0wsUUFBUTtBQUNoTTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdMQUF3TCxRQUFRO0FBQ2hNO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsTUFBTSxPQUFPLFdBQVcsZ0JBQWdCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEVBQThFLDJCQUEyQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxtQ0FBbUMsK0RBQStELG1DQUFtQztBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLHlCQUF5QjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZSxHQUFHLGdCQUFnQjtBQUNsRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLE1BQU07QUFDOUc7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLG1CQUFtQiwrQ0FBK0M7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVEsNElBQTRJO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFDQUFxQyxDQUFVO0FBQ2hFO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixNQUFNLE9BQU8sV0FBVyxnQkFBZ0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGdCQUFnQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLGdCQUFnQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRDQUE0QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMENBQTBDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpS0FBaUs7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0pBQStKO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RCxxQ0FBcUMsNEJBQTRCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDREQUE0RDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdCQUFnQiw2RkFBNkY7QUFDN0csZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWiwrQkFBK0IsMENBQTBDO0FBQ3pFO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsaUNBQWlDLGtFQUFrRTtBQUNuRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCx5Q0FBeUM7QUFDeEs7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCLG1FQUFtRTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0NBQXNDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFxRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RCxNQUFNO0FBQ04seUJBQXlCLDZCQUE2QjtBQUN0RCxNQUFNO0FBQ04sMkVBQTJFO0FBQzNFO0FBQ0EseUJBQXlCLDZEQUE2RDtBQUN0RixNQUFNO0FBQ047QUFDQTtBQUNBLHlCQUF5Qix5RUFBeUU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxFQUFFLHFCQUFxQixHQUFHLGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLHNCQUFRO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLGtCQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsd0ZBQUs7QUFDdEMsMkJBQTJCLG1CQUFPLENBQUMsa0JBQU07QUFDekMsMkJBQTJCLG1CQUFPLENBQUMsb0JBQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLHNCQUFRO0FBQzdDLHdCQUF3QixtQkFBTyxDQUFDLHlFQUFJO0FBQ3BDLDJCQUEyQixtQkFBTyxDQUFDLGtCQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUNBQW1DO0FBQzVELElBQUk7QUFDSix5QkFBeUIsMENBQTBDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6Qyw0QkFBNEIsbUJBQU8sQ0FBQyxvQkFBTztBQUMzQyx5QkFBeUIsbUJBQU8sQ0FBQyxnQkFBSztBQUN0QywyQkFBMkIsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCLHNDQUFzQyw0QkFBNEI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsaUJBQWlCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21jcC1jaGVzcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9hYmx5QDIuMTcuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9hYmx5L2J1aWxkL2FibHktbm9kZS5qcz85OTZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMTUtMjAyMiBBYmx5IFJlYWwtdGltZSBMdGQgKGFibHkuY29tKVxuXG5BYmx5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4xNy4xXG5odHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzXG5cblJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5jZSB2Mi4wKi8oZnVuY3Rpb24gKGcsIGYpIHtcbiAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZihyZXF1aXJlKCd3cycpLCByZXF1aXJlKCdnb3QnKSk7XG4gICAgfSBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoWyd3cycsICdnb3QnXSwgZik7XG4gICAgfSBlbHNlIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzKSB7XG4gICAgICBleHBvcnRzW1wiQWJseVwiXSA9IGYocmVxdWlyZSgnd3MnKSwgcmVxdWlyZSgnZ290JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnW1wiQWJseVwiXSA9IGYoZ1tcIndzXCJdLCBnW1wiZ290XCJdKTtcbiAgICB9XG4gIH0odGhpcywgKF9fZGEsIF9fZGIpID0+IHtcbnZhciBleHBvcnRzID0ge307XG52YXIgbW9kdWxlID0geyBleHBvcnRzIH07XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fYXdhaXQgPSBmdW5jdGlvbihwcm9taXNlLCBpc1lpZWxkU3Rhcikge1xuICB0aGlzWzBdID0gcHJvbWlzZTtcbiAgdGhpc1sxXSA9IGlzWWllbGRTdGFyO1xufTtcbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICB2YXIgcmVzdW1lID0gKGssIHYsIHllcywgbm8pID0+IHtcbiAgICB0cnkge1xuICAgICAgdmFyIHggPSBnZW5lcmF0b3Jba10odiksIGlzQXdhaXQgPSAodiA9IHgudmFsdWUpIGluc3RhbmNlb2YgX19hd2FpdCwgZG9uZSA9IHguZG9uZTtcbiAgICAgIFByb21pc2UucmVzb2x2ZShpc0F3YWl0ID8gdlswXSA6IHYpLnRoZW4oKHkpID0+IGlzQXdhaXQgPyByZXN1bWUoayA9PT0gXCJyZXR1cm5cIiA/IGsgOiBcIm5leHRcIiwgdlsxXSA/IHsgZG9uZTogeS5kb25lLCB2YWx1ZTogeS52YWx1ZSB9IDogeSwgeWVzLCBubykgOiB5ZXMoeyB2YWx1ZTogeSwgZG9uZSB9KSkuY2F0Y2goKGUpID0+IHJlc3VtZShcInRocm93XCIsIGUsIHllcywgbm8pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBubyhlKTtcbiAgICB9XG4gIH07XG4gIHZhciBtZXRob2QgPSAoaykgPT4gaXRba10gPSAoeCkgPT4gbmV3IFByb21pc2UoKHllcywgbm8pID0+IHJlc3VtZShrLCB4LCB5ZXMsIG5vKSk7XG4gIHZhciBpdCA9IHt9O1xuICByZXR1cm4gZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpLCBpdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiBpdCwgbWV0aG9kKFwibmV4dFwiKSwgbWV0aG9kKFwidGhyb3dcIiksIG1ldGhvZChcInJldHVyblwiKSwgaXQ7XG59O1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9mcm9tLmpzXG52YXIgcmVxdWlyZV9mcm9tID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvZnJvbS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICB2YXIgdmVyc2lvbjIgPSAoKHByb2Nlc3MgfHwge30pLnZlcnNpb24gfHwgXCJ2MC4wLjBcIikuc2xpY2UoMSkuc3BsaXQoXCIuXCIpWzBdO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IE51bWJlcih2ZXJzaW9uMikgPCA2ID8gZnVuY3Rpb24gZnJvbShzb3VyY2UsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcjIoc291cmNlLCBlbmNvZGluZyk7XG4gICAgfSA6IGZ1bmN0aW9uIGZyb20oc291cmNlLCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIEJ1ZmZlcjIuZnJvbShzb3VyY2UsIGVuY29kaW5nKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvdG8uanNcbnZhciByZXF1aXJlX3RvID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvdG8uanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvdXJjZSwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBzb3VyY2UudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9pcy5qc1xudmFyIHJlcXVpcmVfaXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9pcy5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIyLmlzQnVmZmVyKGJ1ZmZlcik7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL3N1YmFycmF5LmpzXG52YXIgcmVxdWlyZV9zdWJhcnJheSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL3N1YmFycmF5LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihzb3VyY2UsIGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiA/IHNvdXJjZS5zbGljZShmcm9tKSA6IHNvdXJjZS5zbGljZShmcm9tLCB0byk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL2pvaW4uanNcbnZhciByZXF1aXJlX2pvaW4gPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9qb2luLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgQnVmZmVyMiA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldHMsIGhpbnQpIHtcbiAgICAgIHJldHVybiBoaW50ICE9PSB2b2lkIDAgPyBCdWZmZXIyLmNvbmNhdCh0YXJnZXRzLCBoaW50KSA6IEJ1ZmZlcjIuY29uY2F0KHRhcmdldHMpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9jb3B5LmpzXG52YXIgcmVxdWlyZV9jb3B5ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvY29weS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gY29weTI7XG4gICAgZnVuY3Rpb24gY29weTIoc291cmNlLCB0YXJnZXQsIHRhcmdldF9zdGFydCwgc291cmNlX3N0YXJ0LCBzb3VyY2VfZW5kKSB7XG4gICAgICByZXR1cm4gc291cmNlLmNvcHkodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHNvdXJjZV9zdGFydCwgc291cmNlX2VuZCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvY3JlYXRlLmpzXG52YXIgcmVxdWlyZV9jcmVhdGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9jcmVhdGUuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciBCdWZmZXIyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgdmFyIHZlcnNpb24yID0gKChwcm9jZXNzIHx8IHt9KS52ZXJzaW9uIHx8IFwidjAuMC4wXCIpLnNsaWNlKDEpLnNwbGl0KFwiLlwiKVswXTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBOdW1iZXIodmVyc2lvbjIpIDwgNiA/IGZ1bmN0aW9uIGNyZWF0ZShzaXplKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcjIoc2l6ZSk7XG4gICAgfSA6IGZ1bmN0aW9uIGNyZWF0ZShzaXplKSB7XG4gICAgICByZXR1cm4gQnVmZmVyMi5hbGxvYyhzaXplKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvcmVhZC5qc1xudmFyIHJlcXVpcmVfcmVhZCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL3JlYWQuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciBwcm90byA9IHt9O1xuICAgIHZhciByZXggPSAvcmVhZC4rLztcbiAgICB2YXIgYnVpbGRGbjtcbiAgICBidWlsZEZuID0gZnVuY3Rpb24oa2V5Mikge1xuICAgICAgdmFyIGNvZGUgPSBcInJldHVybiBidWYuXCIgKyBrZXkyICsgXCIoXCIgKyBbXCJhXCIsIFwiYlwiLCBcImNcIl0uam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oW1wiYnVmXCIsIFwiYVwiLCBcImJcIiwgXCJjXCJdLCBjb2RlKTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHByb3RvO1xuICAgIGZvciAoa2V5IGluIEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgIGlmIChyZXgudGVzdChrZXkpKSB7XG4gICAgICAgIHByb3RvW2tleV0gPSBidWlsZEZuKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy93cml0ZS5qc1xudmFyIHJlcXVpcmVfd3JpdGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy93cml0ZS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICB2YXIgcHJvdG8gPSB7fTtcbiAgICB2YXIgcmV4ID0gL3dyaXRlLisvO1xuICAgIHZhciBidWlsZEZuO1xuICAgIGJ1aWxkRm4gPSBmdW5jdGlvbihrZXkyKSB7XG4gICAgICB2YXIgY29kZSA9IFwicmV0dXJuIGJ1Zi5cIiArIGtleTIgKyBcIihcIiArIFtcImFcIiwgXCJiXCIsIFwiY1wiXS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihbXCJidWZcIiwgXCJhXCIsIFwiYlwiLCBcImNcIl0sIGNvZGUpO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcHJvdG87XG4gICAgZm9yIChrZXkgaW4gQnVmZmVyMi5wcm90b3R5cGUpIHtcbiAgICAgIGlmIChyZXgudGVzdChrZXkpKSB7XG4gICAgICAgIHByb3RvW2tleV0gPSBidWlsZEZuKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfYm9wcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL2luZGV4LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgcHJvdG8gPSB7fTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwcm90bztcbiAgICBwcm90by5mcm9tID0gcmVxdWlyZV9mcm9tKCk7XG4gICAgcHJvdG8udG8gPSByZXF1aXJlX3RvKCk7XG4gICAgcHJvdG8uaXMgPSByZXF1aXJlX2lzKCk7XG4gICAgcHJvdG8uc3ViYXJyYXkgPSByZXF1aXJlX3N1YmFycmF5KCk7XG4gICAgcHJvdG8uam9pbiA9IHJlcXVpcmVfam9pbigpO1xuICAgIHByb3RvLmNvcHkgPSByZXF1aXJlX2NvcHkoKTtcbiAgICBwcm90by5jcmVhdGUgPSByZXF1aXJlX2NyZWF0ZSgpO1xuICAgIG1peChyZXF1aXJlX3JlYWQoKSwgcHJvdG8pO1xuICAgIG1peChyZXF1aXJlX3dyaXRlKCksIHByb3RvKTtcbiAgICBmdW5jdGlvbiBtaXgoZnJvbSwgaW50bykge1xuICAgICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgICAgaW50b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AYWJseS9tc2dwYWNrLWpzL21zZ3BhY2suanNcbnZhciByZXF1aXJlX21zZ3BhY2sgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQGFibHkvbXNncGFjay1qcy9tc2dwYWNrLmpzXCIoZXhwb3J0czIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYm9wcyA9IHJlcXVpcmVfYm9wcygpO1xuICAgIGV4cG9ydHMyLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBzcGFyc2UpIHtcbiAgICAgIHZhciBzaXplID0gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgaWYgKHNpemUgPT0gMClcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHZhciBidWZmZXIgPSBib3BzLmNyZWF0ZShzaXplKTtcbiAgICAgIGVuY29kZTIodmFsdWUsIGJ1ZmZlciwgMCwgc3BhcnNlKTtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfTtcbiAgICBleHBvcnRzMi5kZWNvZGUgPSBkZWNvZGUyO1xuICAgIHZhciBTSF9MXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpO1xuICAgIHZhciBTSF9SXzMyID0gMSAvIFNIX0xfMzI7XG4gICAgZnVuY3Rpb24gcmVhZEludDY0QkUoYnVmLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkSW50MzJCRShvZmZzZXQgKyAwKSAqIFNIX0xfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVUludDY0QkUoYnVmLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgMCkgKiBTSF9MXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICAgIGlmICh2YWwgPCA5MjIzMzcyMDM2ODU0Nzc2ZTMpIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJCRShNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpLCBvZmZzZXQpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKDIxNDc0ODM2NDcsIG9mZnNldCk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKDQyOTQ5NjcyOTUsIG9mZnNldCArIDQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVVJbnQ2NEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICAgIGlmICh2YWwgPCAxODQ0Njc0NDA3MzcwOTU1MmUzKSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKE1hdGguZmxvb3IodmFsICogU0hfUl8zMiksIG9mZnNldCk7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoNDI5NDk2NzI5NSwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoNDI5NDk2NzI5NSwgb2Zmc2V0ICsgNCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIERlY29kZXIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgRGVjb2Rlci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoICogMiA+IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIG1lc3NhZ2VwYWNrIGRldGVjdGVkOiBidWZmZXIgc2l6ZSB3YXMgJHt0aGlzLmJ1ZmZlckxlbmd0aH0sIGJ1dCByZWZlcmVuY2VkIGEgbWFwIG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2UoKTtcbiAgICAgICAgdmFsdWVba2V5XSA9IHRoaXMucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIERlY29kZXIucHJvdG90eXBlLmJpbiA9IERlY29kZXIucHJvdG90eXBlLmJ1ZiA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIG1lc3NhZ2VwYWNrIGRldGVjdGVkOiBidWZmZXIgc2l6ZSB3YXMgJHt0aGlzLmJ1ZmZlckxlbmd0aH0sIGJ1dCByZWZlcmVuY2VkIGEgYmluYXJ5IG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBib3BzLnN1YmFycmF5KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgRGVjb2Rlci5wcm90b3R5cGUuc3RyID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID4gdGhpcy5idWZmZXJMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYWxmb3JtZWQgbWVzc2FnZXBhY2sgZGV0ZWN0ZWQ6IGJ1ZmZlciBzaXplIHdhcyAke3RoaXMuYnVmZmVyTGVuZ3RofSwgYnV0IHJlZmVyZW5jZWQgYSBzdHJpbmcgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGJvcHMudG8oYm9wcy5zdWJhcnJheSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgbGVuZ3RoKSk7XG4gICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIG1lc3NhZ2VwYWNrIGRldGVjdGVkOiBidWZmZXIgc2l6ZSB3YXMgJHt0aGlzLmJ1ZmZlckxlbmd0aH0sIGJ1dCByZWZlcmVuY2VkIGFuIGFycmF5IG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSB0aGlzLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLmJ1ZmZlclt0aGlzLm9mZnNldF07XG4gICAgICB2YXIgdmFsdWUsIGxlbmd0aCwgZXh0VHlwZTtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWFsZm9ybWVkIG1lc3NhZ2VwYWNrIChyZWZlcmVuY2VkIG9mZnNldCBpcyBvdXRzaWRlIGJ1ZmZlcilcIik7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAxMjgpID09PSAwKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjQwKSA9PT0gMTI4KSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAxNTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyNDApID09PSAxNDQpIHtcbiAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDE1O1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjI0KSA9PT0gMTYwKSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAzMTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyMjQpID09PSAyMjQpIHtcbiAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDE5MjpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDE5NDpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAxOTU6XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAxOTY6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTc6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTg6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTk6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDIpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDMpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcbiAgICAgICAgY2FzZSAyMDE6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDUpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDY7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcbiAgICAgICAgY2FzZSAyMDI6XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRGbG9hdEJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwMzpcbiAgICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZERvdWJsZUJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuYnVmZmVyW3RoaXMub2Zmc2V0ICsgMV07XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA1OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA2OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA3OlxuICAgICAgICAgIHZhbHVlID0gcmVhZFVJbnQ2NEJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwODpcbiAgICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZEludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA5OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMTA6XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRJbnQzMkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMTpcbiAgICAgICAgICB2YWx1ZSA9IHJlYWRJbnQ2NEJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMjpcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAyKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiBleHRUeXBlID09PSAwICYmIHZhbHVlID09PSAwID8gdm9pZCAwIDogW2V4dFR5cGUsIHZhbHVlXTtcbiAgICAgICAgY2FzZSAyMTM6XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbigyKV07XG4gICAgICAgIGNhc2UgMjE0OlxuICAgICAgICAgIGV4dFR5cGUgPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiBbZXh0VHlwZSwgdGhpcy5iaW4oNCldO1xuICAgICAgICBjYXNlIDIxNTpcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gW2V4dFR5cGUsIHRoaXMuYmluKDgpXTtcbiAgICAgICAgY2FzZSAyMTY6XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbigxNildO1xuICAgICAgICBjYXNlIDIxNzpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxODpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxOTpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MzJCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIyMDpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjIxOlxuICAgICAgICAgIGxlbmd0aCA9IGJvcHMucmVhZFVJbnQzMkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjI6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjM6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSAweFwiICsgdHlwZS50b1N0cmluZygxNikpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZGVjb2RlMihidWZmZXIpIHtcbiAgICAgIHZhciBkZWNvZGVyID0gbmV3IERlY29kZXIoYnVmZmVyKTtcbiAgICAgIHZhciB2YWx1ZSA9IGRlY29kZXIucGFyc2UoKTtcbiAgICAgIGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGJ1ZmZlci5sZW5ndGggLSBkZWNvZGVyLm9mZnNldCArIFwiIHRyYWlsaW5nIGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB2YWwgPSB2YWx1ZVtlXSwgdHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgICAgIHJldHVybiAoIXNwYXJzZSB8fCB2YWwgIT09IHZvaWQgMCAmJiB2YWwgIT09IG51bGwpICYmIChcImZ1bmN0aW9uXCIgIT09IHR5cGUgfHwgISF2YWwudG9KU09OKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUyKHZhbHVlLCBidWZmZXIsIG9mZnNldCwgc3BhcnNlLCBpc01hcEVsZW1lbnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdmFyIGxlbmd0aCwgc2l6ZTtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gYm9wcy5mcm9tKHZhbHVlKTtcbiAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IGxlbmd0aCB8IDE2MDtcbiAgICAgICAgICBib3BzLmNvcHkodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDEgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjE3O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50OChidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDIpO1xuICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjE4O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MTZCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDMpO1xuICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMTk7XG4gICAgICAgICAgYm9wcy53cml0ZVVJbnQzMkJFKGJ1ZmZlciwgbGVuZ3RoLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICBib3BzLmNvcHkodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0ICsgNSk7XG4gICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChib3BzLmlzKHZhbHVlKSkge1xuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDE5NjtcbiAgICAgICAgICBib3BzLndyaXRlVUludDgoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIGJvcHMuY29weSh2YWx1ZSwgYnVmZmVyLCBvZmZzZXQgKyAyKTtcbiAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDE5NztcbiAgICAgICAgICBib3BzLndyaXRlVUludDE2QkUoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIGJvcHMuY29weSh2YWx1ZSwgYnVmZmVyLCBvZmZzZXQgKyAzKTtcbiAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMTk4O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MzJCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDUpO1xuICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDM7XG4gICAgICAgICAgYm9wcy53cml0ZURvdWJsZUJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMTI4KSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA8IDI1Nikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDQ7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPCA2NTUzNikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDU7XG4gICAgICAgICAgICBib3BzLndyaXRlVUludDE2QkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gICAgICAgICAgICBib3BzLndyaXRlVUludDMyQkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMTg0NDY3NDQwNzM3MDk1NTJlMykge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDc7XG4gICAgICAgICAgICB3cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnIDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMzIpIHtcbiAgICAgICAgICBib3BzLndyaXRlSW50OChidWZmZXIsIHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMTI4KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDg7XG4gICAgICAgICAgYm9wcy53cml0ZUludDgoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IC0zMjc2OCkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjA5O1xuICAgICAgICAgIGJvcHMud3JpdGVJbnQxNkJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMjE0NzQ4MzY0OCkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjEwO1xuICAgICAgICAgIGJvcHMud3JpdGVJbnQzMkJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtOTIyMzM3MjAzNjg1NDc3NmUzKSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMTE7XG4gICAgICAgICAgd3JpdGVJbnQ2NEJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gc21hbGwgLTB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChzcGFyc2UgJiYgaXNNYXBFbGVtZW50KVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIxMjtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gMDtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDJdID0gMDtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNwYXJzZSAmJiBpc01hcEVsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMTkyO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlID8gMTk1IDogMTk0O1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG4gICAgICAgIHJldHVybiBlbmNvZGUyKHZhbHVlLnRvSlNPTigpLCBidWZmZXIsIG9mZnNldCwgc3BhcnNlKTtcbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHNpemUgPSAwO1xuICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gbGVuZ3RoIHwgKGlzQXJyYXkgPyAxNDQgOiAxMjgpO1xuICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSBpc0FycmF5ID8gMjIwIDogMjIyO1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MTZCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgc2l6ZSA9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gaXNBcnJheSA/IDIyMSA6IDIyMztcbiAgICAgICAgICBib3BzLndyaXRlVUludDMyQkUoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHNpemUgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSArPSBlbmNvZGUyKHZhbHVlW2ldLCBidWZmZXIsIG9mZnNldCArIHNpemUsIHNwYXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgc2l6ZSArPSBlbmNvZGUyKGtleSwgYnVmZmVyLCBvZmZzZXQgKyBzaXplKTtcbiAgICAgICAgICAgIHNpemUgKz0gZW5jb2RlMih2YWx1ZVtrZXldLCBidWZmZXIsIG9mZnNldCArIHNpemUsIHNwYXJzZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIiArIHR5cGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaXplb2YodmFsdWUsIHNwYXJzZSwgaXNNYXBFbGVtZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHZhciBsZW5ndGgsIHNpemU7XG4gICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsZW5ndGggPSBib3BzLmZyb20odmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIDEgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChib3BzLmlzKHZhbHVlKSkge1xuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDI1NilcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDY1NTM2KVxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5NilcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDE4NDQ2NzQ0MDczNzA5NTUyZTMpXG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZyAweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPj0gLTMyKVxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAodmFsdWUgPj0gLTEyOClcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgaWYgKHZhbHVlID49IC0zMjc2OClcbiAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KVxuICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICBpZiAodmFsdWUgPj0gLTkyMjMzNzIwMzY4NTQ3NzZlMylcbiAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHNwYXJzZSAmJiBpc01hcEVsZW1lbnQgPyAwIDogMTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gc3BhcnNlICYmIGlzTWFwRWxlbWVudCA/IDAgOiAzO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcbiAgICAgICAgcmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHNpemUgPSAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSArPSBzaXplb2YodmFsdWVbaV0sIHNwYXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSk7XG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBzaXplICs9IHNpemVvZihrZXkpICsgc2l6ZW9mKHZhbHVlW2tleV0sIHNwYXJzZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgICAgIHJldHVybiAxICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICByZXR1cm4gMyArIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgICByZXR1cm4gNSArIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgb3Igb2JqZWN0IHRvbyBsb25nIDB4XCIgKyBsZW5ndGgudG9TdHJpbmcoMTYpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgdHlwZSk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gc3JjL2NvbW1vbi9wbGF0Zm9ybS50c1xudmFyIFBsYXRmb3JtID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIudHNcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG5mdW5jdGlvbiBwYWQodGltZVNlZ21lbnQsIHRocmVlKSB7XG4gIHJldHVybiBgJHt0aW1lU2VnbWVudH1gLnBhZFN0YXJ0KHRocmVlID8gMyA6IDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZXIobG9nZ2VyKSB7XG4gIHJldHVybiBQbGF0Zm9ybS5Db25maWcubG9nVGltZXN0YW1wcyA/IGZ1bmN0aW9uKG1zZykge1xuICAgIGNvbnN0IHRpbWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBsb2dnZXIoXG4gICAgICBwYWQodGltZS5nZXRIb3VycygpKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0TWludXRlcygpKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0U2Vjb25kcygpKSArIFwiLlwiICsgcGFkKHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIDEpICsgXCIgXCIgKyBtc2dcbiAgICApO1xuICB9IDogZnVuY3Rpb24obXNnKSB7XG4gICAgbG9nZ2VyKG1zZyk7XG4gIH07XG59XG52YXIgZ2V0RGVmYXVsdExvZ2dlcnMgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIGxldCBjb25zb2xlTG9nZ2VyO1xuICBsZXQgZXJyb3JMb2dnZXI7XG4gIGlmICh0eXBlb2YgKChfYTIgPSBnbG9iYWxPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbE9iamVjdC5jb25zb2xlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvZykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGVMb2dnZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICAgIGVycm9yTG9nZ2VyID0gY29uc29sZS53YXJuID8gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH0gOiBjb25zb2xlTG9nZ2VyO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGVMb2dnZXIgPSBlcnJvckxvZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIFtjb25zb2xlTG9nZ2VyLCBlcnJvckxvZ2dlcl0ubWFwKGdldEhhbmRsZXIpO1xufTtcbnZhciBfTG9nZ2VyID0gY2xhc3MgX0xvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVwcmVjYXRlZCA9IChkZXNjcmlwdGlvbiwgbXNnKSA9PiB7XG4gICAgICB0aGlzLmRlcHJlY2F0aW9uV2FybmluZyhgJHtkZXNjcmlwdGlvbn0gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uICR7bXNnfWApO1xuICAgIH07XG4gICAgLyogV2hlcmUgYSBsb2dnaW5nIG9wZXJhdGlvbiBpcyBleHBlbnNpdmUsIHN1Y2ggYXMgc2VyaWFsaXNhdGlvbiBvZiBkYXRhLCB1c2Ugc2hvdWxkTG9nIHdpbGwgcHJldmVudFxuICAgICAgdGhlIG9iamVjdCBiZWluZyBzZXJpYWxpc2VkIGlmIHRoZSBsb2cgbGV2ZWwgd2lsbCBub3Qgb3V0cHV0IHRoZSBtZXNzYWdlICovXG4gICAgdGhpcy5zaG91bGRMb2cgPSAobGV2ZWwpID0+IHtcbiAgICAgIHJldHVybiBsZXZlbCA8PSB0aGlzLmxvZ0xldmVsO1xuICAgIH07XG4gICAgdGhpcy5zZXRMb2cgPSAobGV2ZWwsIGhhbmRsZXIpID0+IHtcbiAgICAgIGlmIChsZXZlbCAhPT0gdm9pZCAwKVxuICAgICAgICB0aGlzLmxvZ0xldmVsID0gbGV2ZWw7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gdm9pZCAwKVxuICAgICAgICB0aGlzLmxvZ0hhbmRsZXIgPSB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfTtcbiAgICB0aGlzLmxvZ0xldmVsID0gX0xvZ2dlci5kZWZhdWx0TG9nTGV2ZWw7XG4gICAgdGhpcy5sb2dIYW5kbGVyID0gX0xvZ2dlci5kZWZhdWx0TG9nSGFuZGxlcjtcbiAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IF9Mb2dnZXIuZGVmYXVsdExvZ0Vycm9ySGFuZGxlcjtcbiAgfVxuICBzdGF0aWMgaW5pdExvZ0hhbmRsZXJzKCkge1xuICAgIGNvbnN0IFtsb2dIYW5kbGVyLCBsb2dFcnJvckhhbmRsZXJdID0gZ2V0RGVmYXVsdExvZ2dlcnMoKTtcbiAgICB0aGlzLmRlZmF1bHRMb2dIYW5kbGVyID0gbG9nSGFuZGxlcjtcbiAgICB0aGlzLmRlZmF1bHRMb2dFcnJvckhhbmRsZXIgPSBsb2dFcnJvckhhbmRsZXI7XG4gICAgdGhpcy5kZWZhdWx0TG9nZ2VyID0gbmV3IF9Mb2dnZXIoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgdG8gdGhpcyBtZXRob2QgYXJlIG5ldmVyIHN0cmlwcGVkIGJ5IHRoZSBgc3RyaXBMb2dzYCBlc2J1aWxkIHBsdWdpbi4gVXNlIGl0IGZvciBsb2cgc3RhdGVtZW50cyB0aGF0IHlvdSB3aXNoIHRvIGFsd2F5cyBiZSBpbmNsdWRlZCBpbiB0aGUgbW9kdWxhciB2YXJpYW50IG9mIHRoZSBTREsuXG4gICAqL1xuICBzdGF0aWMgbG9nQWN0aW9uTm9TdHJpcChsb2dnZXIsIGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICBsb2dnZXIubG9nQWN0aW9uKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICB9XG4gIGxvZ0FjdGlvbihsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9nKGxldmVsKSkge1xuICAgICAgKGxldmVsID09PSAxIC8qIEVycm9yICovID8gdGhpcy5sb2dFcnJvckhhbmRsZXIgOiB0aGlzLmxvZ0hhbmRsZXIpKFwiQWJseTogXCIgKyBhY3Rpb24gKyBcIjogXCIgKyBtZXNzYWdlLCBsZXZlbCk7XG4gICAgfVxuICB9XG4gIHJlbmFtZWRDbGllbnRPcHRpb24ob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nKFxuICAgICAgYFRoZSBcXGAke29sZE5hbWV9XFxgIGNsaWVudCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGAke25ld05hbWV9XFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgXFxgJHtuZXdOYW1lfVxcYCBpbnN0ZWFkLiBcXGAke29sZE5hbWV9XFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLmBcbiAgICApO1xuICB9XG4gIHJlbmFtZWRNZXRob2QoY2xhc3NOYW1lLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBgXFxgJHtjbGFzc05hbWV9XFxgXFx1MjAxOXMgXFxgJHtvbGROYW1lfVxcYCBtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGAke25ld05hbWV9XFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgXFxgJHtuZXdOYW1lfVxcYCBpbnN0ZWFkLiBcXGAke29sZE5hbWV9XFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLmBcbiAgICApO1xuICB9XG4gIGRlcHJlY2F0aW9uV2FybmluZyhtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9nKDEgLyogRXJyb3IgKi8pKSB7XG4gICAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlcihgQWJseTogRGVwcmVjYXRpb24gd2FybmluZyAtICR7bWVzc2FnZX1gLCAxIC8qIEVycm9yICovKTtcbiAgICB9XG4gIH1cbn07XG5fTG9nZ2VyLmRlZmF1bHRMb2dMZXZlbCA9IDEgLyogRXJyb3IgKi87XG4vLyBwdWJsaWMgY29uc3RhbnRzXG5fTG9nZ2VyLkxPR19OT05FID0gMCAvKiBOb25lICovO1xuX0xvZ2dlci5MT0dfRVJST1IgPSAxIC8qIEVycm9yICovO1xuX0xvZ2dlci5MT0dfTUFKT1IgPSAyIC8qIE1ham9yICovO1xuX0xvZ2dlci5MT0dfTUlOT1IgPSAzIC8qIE1pbm9yICovO1xuX0xvZ2dlci5MT0dfTUlDUk8gPSA0IC8qIE1pY3JvICovO1xuLyogcHVibGljIHN0YXRpYyBmdW5jdGlvbnMgKi9cbi8qKlxuICogSW4gdGhlIG1vZHVsYXIgdmFyaWFudCBvZiB0aGUgU0RLLCB0aGUgYHN0cmlwTG9nc2AgZXNidWlsZCBwbHVnaW4gc3RyaXBzIG91dCBhbGwgY2FsbHMgdG8gdGhpcyBtZXRob2QgKHdoZW4gaW52b2tlZCBhcyBgTG9nZ2VyLmxvZ0FjdGlvbiguLi4pYCkgZXhjZXB0IHdoZW4gY2FsbGVkIHdpdGggbGV2ZWwgYExvZ2dlci5MT0dfRVJST1JgLiBJZiB5b3Ugd2lzaCBmb3IgYSBsb2cgc3RhdGVtZW50IHRvIG5ldmVyIGJlIHN0cmlwcGVkLCB1c2UgdGhlIHtAbGluayBsb2dBY3Rpb25Ob1N0cmlwfSBtZXRob2QgaW5zdGVhZC5cbiAqXG4gKiBUaGUgYWZvcmVtZW50aW9uZWQgcGx1Z2luIGV4cGVjdHMgYGxldmVsYCB0byBiZSBhbiBleHByZXNzaW9uIG9mIHRoZSBmb3JtIGBMb2dnZXIuTE9HXypgOyB0aGF0IGlzLCB5b3UgY2Fu4oCZdCBkeW5hbWljYWxseSBzcGVjaWZ5IHRoZSBsb2cgbGV2ZWwuXG4gKi9cbl9Mb2dnZXIubG9nQWN0aW9uID0gKGxvZ2dlciwgbGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkgPT4ge1xuICBfTG9nZ2VyLmxvZ0FjdGlvbk5vU3RyaXAobG9nZ2VyLCBsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKTtcbn07XG52YXIgTG9nZ2VyID0gX0xvZ2dlcjtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExvZ2dlcjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC91dGlscy50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgRm9ybWF0OiAoKSA9PiBGb3JtYXQsXG4gIGFsbFNhbWU6ICgpID0+IGFsbFNhbWUsXG4gIGFsbFRvTG93ZXJDYXNlOiAoKSA9PiBhbGxUb0xvd2VyQ2FzZSxcbiAgYWxsVG9VcHBlckNhc2U6ICgpID0+IGFsbFRvVXBwZXJDYXNlLFxuICBhcnJDaG9vc2VOOiAoKSA9PiBhcnJDaG9vc2VOLFxuICBhcnJEZWxldGVWYWx1ZTogKCkgPT4gYXJyRGVsZXRlVmFsdWUsXG4gIGFyckVxdWFsczogKCkgPT4gYXJyRXF1YWxzLFxuICBhcnJJbnRlcnNlY3Q6ICgpID0+IGFyckludGVyc2VjdCxcbiAgYXJySW50ZXJzZWN0T2I6ICgpID0+IGFyckludGVyc2VjdE9iLFxuICBhcnJQb3BSYW5kb21FbGVtZW50OiAoKSA9PiBhcnJQb3BSYW5kb21FbGVtZW50LFxuICBhcnJXaXRob3V0VmFsdWU6ICgpID0+IGFycldpdGhvdXRWYWx1ZSxcbiAgY2hlYXBSYW5kU3RyOiAoKSA9PiBjaGVhcFJhbmRTdHIsXG4gIGNvbnRhaW5zVmFsdWU6ICgpID0+IGNvbnRhaW5zVmFsdWUsXG4gIGNvcHk6ICgpID0+IGNvcHksXG4gIGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcjogKCkgPT4gY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yLFxuICBkYXRhU2l6ZUJ5dGVzOiAoKSA9PiBkYXRhU2l6ZUJ5dGVzLFxuICBkZWNvZGVCb2R5OiAoKSA9PiBkZWNvZGVCb2R5LFxuICBlbmNvZGVCb2R5OiAoKSA9PiBlbmNvZGVCb2R5LFxuICBlbnN1cmVBcnJheTogKCkgPT4gZW5zdXJlQXJyYXksXG4gIGZvckluT3duTm9uTnVsbFByb3BlcnRpZXM6ICgpID0+IGZvckluT3duTm9uTnVsbFByb3BlcnRpZXMsXG4gIGdldEJhY2tvZmZDb2VmZmljaWVudDogKCkgPT4gZ2V0QmFja29mZkNvZWZmaWNpZW50LFxuICBnZXRHbG9iYWxPYmplY3Q6ICgpID0+IGdldEdsb2JhbE9iamVjdCxcbiAgZ2V0Sml0dGVyQ29lZmZpY2llbnQ6ICgpID0+IGdldEppdHRlckNvZWZmaWNpZW50LFxuICBnZXRSZXRyeVRpbWU6ICgpID0+IGdldFJldHJ5VGltZSxcbiAgaW5oZXJpdHM6ICgpID0+IGluaGVyaXRzLFxuICBpbnNwZWN0Qm9keTogKCkgPT4gaW5zcGVjdEJvZHksXG4gIGluc3BlY3RFcnJvcjogKCkgPT4gaW5zcGVjdEVycm9yLFxuICBpbnRlcnNlY3Q6ICgpID0+IGludGVyc2VjdCxcbiAgaXNFbXB0eTogKCkgPT4gaXNFbXB0eSxcbiAgaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm86ICgpID0+IGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvLFxuICBpc05pbDogKCkgPT4gaXNOaWwsXG4gIGlzT2JqZWN0OiAoKSA9PiBpc09iamVjdCxcbiAga2V5c0FycmF5OiAoKSA9PiBrZXlzQXJyYXksXG4gIGxpc3RlbmVyVG9Bc3luY0l0ZXJhdG9yOiAoKSA9PiBsaXN0ZW5lclRvQXN5bmNJdGVyYXRvcixcbiAgbWF0Y2hEZXJpdmVkQ2hhbm5lbDogKCkgPT4gbWF0Y2hEZXJpdmVkQ2hhbm5lbCxcbiAgbWl4aW46ICgpID0+IG1peGluLFxuICBwYXJzZVF1ZXJ5U3RyaW5nOiAoKSA9PiBwYXJzZVF1ZXJ5U3RyaW5nLFxuICBwcm90b3R5cGljYWxDbG9uZTogKCkgPT4gcHJvdG90eXBpY2FsQ2xvbmUsXG4gIHJhbmRvbVN0cmluZzogKCkgPT4gcmFuZG9tU3RyaW5nLFxuICBzaGFsbG93Q2xvbmU6ICgpID0+IHNoYWxsb3dDbG9uZSxcbiAgc2hhbGxvd0VxdWFsczogKCkgPT4gc2hhbGxvd0VxdWFscyxcbiAgc3RyaW5naWZ5VmFsdWVzOiAoKSA9PiBzdHJpbmdpZnlWYWx1ZXMsXG4gIHRocm93TWlzc2luZ1BsdWdpbkVycm9yOiAoKSA9PiB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcixcbiAgdG9CYXNlNjQ6ICgpID0+IHRvQmFzZTY0LFxuICB0b1F1ZXJ5U3RyaW5nOiAoKSA9PiB0b1F1ZXJ5U3RyaW5nLFxuICB2YWx1ZXNBcnJheTogKCkgPT4gdmFsdWVzQXJyYXksXG4gIHdoZW5Qcm9taXNlU2V0dGxlczogKCkgPT4gd2hlblByb21pc2VTZXR0bGVzLFxuICB3aXRoVGltZW91dEFzeW5jOiAoKSA9PiB3aXRoVGltZW91dEFzeW5jXG59KTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZXJyb3JpbmZvLnRzXG5mdW5jdGlvbiB0b1N0cmluZyhlcnIpIHtcbiAgbGV0IHJlc3VsdCA9IFwiW1wiICsgZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChlcnIubWVzc2FnZSlcbiAgICByZXN1bHQgKz0gXCI6IFwiICsgZXJyLm1lc3NhZ2U7XG4gIGlmIChlcnIuc3RhdHVzQ29kZSlcbiAgICByZXN1bHQgKz0gXCI7IHN0YXR1c0NvZGU9XCIgKyBlcnIuc3RhdHVzQ29kZTtcbiAgaWYgKGVyci5jb2RlKVxuICAgIHJlc3VsdCArPSBcIjsgY29kZT1cIiArIGVyci5jb2RlO1xuICBpZiAoZXJyLmNhdXNlKVxuICAgIHJlc3VsdCArPSBcIjsgY2F1c2U9XCIgKyBpbnNwZWN0RXJyb3IoZXJyLmNhdXNlKTtcbiAgaWYgKGVyci5ocmVmICYmICEoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5kZXhPZihcImhlbHAuYWJseS5pb1wiKSA+IC0xKSlcbiAgICByZXN1bHQgKz0gXCI7IHNlZSBcIiArIGVyci5ocmVmICsgXCIgXCI7XG4gIHJlc3VsdCArPSBcIl1cIjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBFcnJvckluZm8gPSBjbGFzcyBfRXJyb3JJbmZvIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX0Vycm9ySW5mby5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUgfSA9IHZhbHVlcztcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNvZGUgIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHN0YXR1c0NvZGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9ySW5mby5mcm9tVmFsdWVzKCk6IGludmFsaWQgdmFsdWVzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KHZhbHVlcykpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKG5ldyBfRXJyb3JJbmZvKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpLCB2YWx1ZXMpO1xuICAgIGlmIChyZXN1bHQuY29kZSAmJiAhcmVzdWx0LmhyZWYpIHtcbiAgICAgIHJlc3VsdC5ocmVmID0gXCJodHRwczovL2hlbHAuYWJseS5pby9lcnJvci9cIiArIHJlc3VsdC5jb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xudmFyIFBhcnRpYWxFcnJvckluZm8gPSBjbGFzcyBfUGFydGlhbEVycm9ySW5mbyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBpZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIF9QYXJ0aWFsRXJyb3JJbmZvLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSB9ID0gdmFsdWVzO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIiB8fCAhaXNOaWwoY29kZSkgJiYgdHlwZW9mIGNvZGUgIT09IFwibnVtYmVyXCIgfHwgIWlzTmlsKHN0YXR1c0NvZGUpICYmIHR5cGVvZiBzdGF0dXNDb2RlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJ0aWFsRXJyb3JJbmZvLmZyb21WYWx1ZXMoKTogaW52YWxpZCB2YWx1ZXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QodmFsdWVzKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24obmV3IF9QYXJ0aWFsRXJyb3JJbmZvKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpLCB2YWx1ZXMpO1xuICAgIGlmIChyZXN1bHQuY29kZSAmJiAhcmVzdWx0LmhyZWYpIHtcbiAgICAgIHJlc3VsdC5ocmVmID0gXCJodHRwczovL2hlbHAuYWJseS5pby9lcnJvci9cIiArIHJlc3VsdC5jb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL3V0aWxzLnRzXG5mdW5jdGlvbiByYW5kb21Qb3NuKGFyck9yU3RyKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnJPclN0ci5sZW5ndGgpO1xufVxuZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCAuLi5hcmdzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3NbaV07XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBjb3B5KHNyYykge1xuICByZXR1cm4gbWl4aW4oe30sIHNyYyk7XG59XG5mdW5jdGlvbiBlbnN1cmVBcnJheShvYmopIHtcbiAgaWYgKGlzTmlsKG9iaikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmV0dXJuIFtvYmpdO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qob2IpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYikgPT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkob2IpIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc05pbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBPYmplY3QoKTtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKVxuICAgIHJlc3VsdFtwcm9wXSA9IG9iW3Byb3BdO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcHJvdG90eXBpY2FsQ2xvbmUob2IsIG93blByb3BlcnRpZXMpIHtcbiAgY2xhc3MgRiB7XG4gIH1cbiAgRi5wcm90b3R5cGUgPSBvYjtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEYoKTtcbiAgaWYgKG93blByb3BlcnRpZXMpXG4gICAgbWl4aW4ocmVzdWx0LCBvd25Qcm9wZXJ0aWVzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBpZiAoUGxhdGZvcm0uQ29uZmlnLmluaGVyaXRzKSB7XG4gICAgUGxhdGZvcm0uQ29uZmlnLmluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICBjdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwaWNhbENsb25lKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IGN0b3IgfSk7XG59O1xuZnVuY3Rpb24gY29udGFpbnNWYWx1ZShvYiwgdmFsKSB7XG4gIGZvciAoY29uc3QgaSBpbiBvYikge1xuICAgIGlmIChvYltpXSA9PSB2YWwpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3QoYXJyLCBvYikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYikgPyBhcnJJbnRlcnNlY3QoYXJyLCBvYikgOiBhcnJJbnRlcnNlY3RPYihhcnIsIG9iKTtcbn1cbmZ1bmN0aW9uIGFyckludGVyc2VjdChhcnIxLCBhcnIyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZW1iZXIgPSBhcnIxW2ldO1xuICAgIGlmIChhcnIyLmluZGV4T2YobWVtYmVyKSAhPSAtMSlcbiAgICAgIHJlc3VsdC5wdXNoKG1lbWJlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFyckludGVyc2VjdE9iKGFyciwgb2IpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWVtYmVyID0gYXJyW2ldO1xuICAgIGlmIChtZW1iZXIgaW4gb2IpXG4gICAgICByZXN1bHQucHVzaChtZW1iZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhcnJEZWxldGVWYWx1ZShhcnIsIHZhbCkge1xuICBjb25zdCBpZHggPSBhcnIuaW5kZXhPZih2YWwpO1xuICBjb25zdCByZXMgPSBpZHggIT0gLTE7XG4gIGlmIChyZXMpXG4gICAgYXJyLnNwbGljZShpZHgsIDEpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYXJyV2l0aG91dFZhbHVlKGFyciwgdmFsKSB7XG4gIGNvbnN0IG5ld0FyciA9IGFyci5zbGljZSgpO1xuICBhcnJEZWxldGVWYWx1ZShuZXdBcnIsIHZhbCk7XG4gIHJldHVybiBuZXdBcnI7XG59XG5mdW5jdGlvbiBrZXlzQXJyYXkob2IsIG93bk9ubHkpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYikge1xuICAgIGlmIChvd25Pbmx5ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKVxuICAgICAgY29udGludWU7XG4gICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbHVlc0FycmF5KG9iLCBvd25Pbmx5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpIHtcbiAgICBpZiAob3duT25seSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHJlc3VsdC5wdXNoKG9iW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyhvYiwgZm4pIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkgJiYgb2JbcHJvcF0pIHtcbiAgICAgIGZuKHByb3ApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWxsU2FtZShhcnIsIHByb3ApIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBmaXJzdCA9IGFyclswXVtwcm9wXTtcbiAgcmV0dXJuIGFyci5ldmVyeShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bcHJvcF0gPT09IGZpcnN0O1xuICB9KTtcbn1cbnZhciBGb3JtYXQgPSAvKiBAX19QVVJFX18gKi8gKChGb3JtYXQyKSA9PiB7XG4gIEZvcm1hdDJbXCJtc2dwYWNrXCJdID0gXCJtc2dwYWNrXCI7XG4gIEZvcm1hdDJbXCJqc29uXCJdID0gXCJqc29uXCI7XG4gIHJldHVybiBGb3JtYXQyO1xufSkoRm9ybWF0IHx8IHt9KTtcbmZ1bmN0aW9uIGFyclBvcFJhbmRvbUVsZW1lbnQoYXJyKSB7XG4gIHJldHVybiBhcnIuc3BsaWNlKHJhbmRvbVBvc24oYXJyKSwgMSlbMF07XG59XG5mdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBpZiAocGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKVxuICAgICAgcGFydHMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA/IFwiP1wiICsgcGFydHMuam9pbihcIiZcIikgOiBcIlwiO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWVzKHBhcmFtcykge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHBhcmFtcykubWFwKChbaywgdl0pID0+IFtrLCBTdHJpbmcodildKSk7XG59XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5KSB7XG4gIGxldCBtYXRjaDtcbiAgY29uc3Qgc2VhcmNoID0gLyhbXj8mPV0rKT0/KFteJl0qKS9nO1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgd2hpbGUgKG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpKVxuICAgIHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsyXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlcnIpIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnIgPT0gXCJvYmplY3RcIiAmJiBlcnIgIT09IG51bGwgJiYgKGVyciBpbnN0YW5jZW9mIEVycm9ySW5mbyB8fCBlcnIgaW5zdGFuY2VvZiBQYXJ0aWFsRXJyb3JJbmZvKTtcbn1cbmZ1bmN0aW9uIGluc3BlY3RFcnJvcihlcnIpIHtcbiAgdmFyIF9hMiwgX2I7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCAoKF9hMiA9IGVyciA9PSBudWxsID8gdm9pZCAwIDogZXJyLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm5hbWUpID09PSBcIkVycm9ySW5mb1wiIHx8ICgoX2IgPSBlcnIgPT0gbnVsbCA/IHZvaWQgMCA6IGVyci5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSBcIlBhcnRpYWxFcnJvckluZm9cIilcbiAgICByZXR1cm4gZXJyLnRvU3RyaW5nKCk7XG4gIHJldHVybiBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChlcnIpO1xufVxuZnVuY3Rpb24gaW5zcGVjdEJvZHkoYm9keSkge1xuICBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGJvZHkpO1xuICB9XG59XG5mdW5jdGlvbiBkYXRhU2l6ZUJ5dGVzKGRhdGEpIHtcbiAgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJ5dGVMZW5ndGgoZGF0YSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5zdHJpbmdCeXRlU2l6ZShkYXRhKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gODtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBFeHBlY3RlZCBpbnB1dCBvZiBVdGlscy5kYXRhU2l6ZUJ5dGVzIHRvIGJlIGEgc3RyaW5nLCBhIG51bWJlciwgYSBib29sZWFuIG9yIGEgYnVmZmVyLCBidXQgd2FzOiAke3R5cGVvZiBkYXRhfWBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNoZWFwUmFuZFN0cigpIHtcbiAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XG59XG52YXIgcmFuZG9tU3RyaW5nID0gYXN5bmMgKG51bUJ5dGVzKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IFBsYXRmb3JtLkNvbmZpZy5nZXRSYW5kb21BcnJheUJ1ZmZlcihudW1CeXRlcyk7XG4gIHJldHVybiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoYnVmZmVyKTtcbn07XG5mdW5jdGlvbiBhcnJDaG9vc2VOKGFyciwgbikge1xuICBjb25zdCBudW1JdGVtcyA9IE1hdGgubWluKG4sIGFyci5sZW5ndGgpLCBtdXRhYmxlQXJyID0gYXJyLnNsaWNlKCksIHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUl0ZW1zOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChhcnJQb3BSYW5kb21FbGVtZW50KG11dGFibGVBcnIpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2hlblByb21pc2VTZXR0bGVzKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gIHByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soZXJyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09IFwibXNncGFja1wiKSB7XG4gICAgaWYgKCFNc2dQYWNrKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgfVxuICAgIHJldHVybiBNc2dQYWNrLmRlY29kZShib2R5KTtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZShTdHJpbmcoYm9keSkpO1xufVxuZnVuY3Rpb24gZW5jb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PSBcIm1zZ3BhY2tcIikge1xuICAgIGlmICghTXNnUGFjaykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTXNnUGFjay5lbmNvZGUoYm9keSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJvZHkpO1xufVxuZnVuY3Rpb24gYWxsVG9Mb3dlckNhc2UoYXJyKSB7XG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWxsVG9VcHBlckNhc2UoYXJyKSB7XG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QmFja29mZkNvZWZmaWNpZW50KGNvdW50KSB7XG4gIHJldHVybiBNYXRoLm1pbigoY291bnQgKyAyKSAvIDMsIDIpO1xufVxuZnVuY3Rpb24gZ2V0Sml0dGVyQ29lZmZpY2llbnQoKSB7XG4gIHJldHVybiAxIC0gTWF0aC5yYW5kb20oKSAqIDAuMjtcbn1cbmZ1bmN0aW9uIGdldFJldHJ5VGltZShpbml0aWFsVGltZW91dCwgcmV0cnlBdHRlbXB0KSB7XG4gIHJldHVybiBpbml0aWFsVGltZW91dCAqIGdldEJhY2tvZmZDb2VmZmljaWVudChyZXRyeUF0dGVtcHQpICogZ2V0Sml0dGVyQ29lZmZpY2llbnQoKTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbE9iamVjdCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbHMoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkuZXZlcnkoKGtleSkgPT4gc291cmNlW2tleV0gPT09IHRhcmdldFtrZXldKSAmJiBPYmplY3Qua2V5cyh0YXJnZXQpLmV2ZXJ5KChrZXkpID0+IHRhcmdldFtrZXldID09PSBzb3VyY2Vba2V5XSk7XG59XG5mdW5jdGlvbiBtYXRjaERlcml2ZWRDaGFubmVsKG5hbWUpIHtcbiAgY29uc3QgcmVnZXggPSAvXihcXFsoW14/XSopKD86KC4qKSlcXF0pPyguKykkLztcbiAgY29uc3QgbWF0Y2ggPSBuYW1lLm1hdGNoKHJlZ2V4KTtcbiAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gubGVuZ3RoIHx8IG1hdGNoLmxlbmd0aCA8IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwicmVnZXggbWF0Y2ggZmFpbGVkXCIsIDQwMCwgNDAwMTApO1xuICB9XG4gIGlmIChtYXRjaFsyXSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oYGNhbm5vdCB1c2UgYSBkZXJpdmVkIG9wdGlvbiB3aXRoIGEgJHttYXRjaFsyXX0gY2hhbm5lbGAsIDQwMCwgNDAwMTApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcXVhbGlmaWVyUGFyYW06IG1hdGNoWzNdIHx8IFwiXCIsXG4gICAgY2hhbm5lbE5hbWU6IG1hdGNoWzRdXG4gIH07XG59XG5mdW5jdGlvbiB0b0Jhc2U2NChzdHIpIHtcbiAgY29uc3QgYnVmZmVyVXRpbHMgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscztcbiAgY29uc3QgdGV4dEJ1ZmZlciA9IGJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoc3RyKTtcbiAgcmV0dXJuIGJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSh0ZXh0QnVmZmVyKTtcbn1cbmZ1bmN0aW9uIGFyckVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbih2YWwsIGkpIHtcbiAgICByZXR1cm4gdmFsID09PSBiW2ldO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcihwbHVnaW5OYW1lKSB7XG4gIHJldHVybiBuZXcgRXJyb3JJbmZvKGAke3BsdWdpbk5hbWV9IHBsdWdpbiBub3QgcHJvdmlkZWRgLCA0MDAxOSwgNDAwKTtcbn1cbmZ1bmN0aW9uIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKHBsdWdpbk5hbWUpIHtcbiAgdGhyb3cgY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKHBsdWdpbk5hbWUpO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aFRpbWVvdXRBc3luYyhwcm9taXNlLCB0aW1lb3V0ID0gNWUzLCBlcnIgPSBcIlRpbWVvdXQgZXhwaXJlZFwiKSB7XG4gIGNvbnN0IGUgPSBuZXcgRXJyb3JJbmZvKGVyciwgNWU0LCA1MDApO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QoZSksIHRpbWVvdXQpKV0pO1xufVxuZnVuY3Rpb24gbGlzdGVuZXJUb0FzeW5jSXRlcmF0b3IocmVnaXN0ZXJMaXN0ZW5lcikge1xuICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGV2ZW50UXVldWUgPSBbXTtcbiAgICBsZXQgcmVzb2x2ZU5leHQgPSBudWxsO1xuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyMiA9IHJlZ2lzdGVyTGlzdGVuZXIoKGV2ZW50KSA9PiB7XG4gICAgICBpZiAocmVzb2x2ZU5leHQpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZSA9IHJlc29sdmVOZXh0O1xuICAgICAgICByZXNvbHZlTmV4dCA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnRRdWV1ZS5wdXNoKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGV2ZW50UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHlpZWxkIGV2ZW50UXVldWUuc2hpZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZU5leHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJDb25jdXJyZW50IG5leHQoKSBjYWxscyBhcmUgbm90IHN1cHBvcnRlZFwiLCA0ZTQsIDQwMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV2ZW50ID0geWllbGQgbmV3IF9fYXdhaXQobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVOZXh0ID0gcmVzb2x2ZTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIyKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gcGFja2FnZS5qc29uXG52YXIgdmVyc2lvbiA9IFwiMi4xNy4xXCI7XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvZGVmYXVsdHMudHNcbnZhciBhZ2VudCA9IFwiYWJseS1qcy9cIiArIHZlcnNpb247XG52YXIgRGVmYXVsdHMgPSB7XG4gIEVORFBPSU5UOiBcIm1haW5cIixcbiAgRU5WSVJPTk1FTlQ6IFwiXCIsXG4gIFJFU1RfSE9TVDogXCJyZXN0LmFibHkuaW9cIixcbiAgUkVBTFRJTUVfSE9TVDogXCJyZWFsdGltZS5hYmx5LmlvXCIsXG4gIEZBTExCQUNLX0hPU1RTOiBbXG4gICAgXCJtYWluLmEuZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIm1haW4uYi5mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwibWFpbi5jLmZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgXCJtYWluLmQuZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIm1haW4uZS5mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiXG4gIF0sXG4gIFBPUlQ6IDgwLFxuICBUTFNfUE9SVDogNDQzLFxuICBUSU1FT1VUUzoge1xuICAgIC8qIERvY3VtZW50ZWQgYXMgb3B0aW9ucyBwYXJhbXM6ICovXG4gICAgZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0OiAxNWUzLFxuICAgIHN1c3BlbmRlZFJldHJ5VGltZW91dDogM2U0LFxuICAgIC8qIFVuZG9jdW1lbnRlZCwgYnV0IHBhcnQgb2YgdGhlIGFwaSBhbmQgY2FuIGJlIHVzZWQgYnkgY3VzdG9tZXJzOiAqL1xuICAgIGh0dHBSZXF1ZXN0VGltZW91dDogMWU0LFxuICAgIGh0dHBNYXhSZXRyeUR1cmF0aW9uOiAxNWUzLFxuICAgIGNoYW5uZWxSZXRyeVRpbWVvdXQ6IDE1ZTMsXG4gICAgZmFsbGJhY2tSZXRyeVRpbWVvdXQ6IDZlNSxcbiAgICAvKiBGb3IgaW50ZXJuYWwgLyB0ZXN0IHVzZSBvbmx5OiAqL1xuICAgIGNvbm5lY3Rpb25TdGF0ZVR0bDogMTJlNCxcbiAgICByZWFsdGltZVJlcXVlc3RUaW1lb3V0OiAxZTQsXG4gICAgcmVjdlRpbWVvdXQ6IDllNCxcbiAgICB3ZWJTb2NrZXRDb25uZWN0VGltZW91dDogMWU0LFxuICAgIHdlYlNvY2tldFNsb3dUaW1lb3V0OiA0ZTNcbiAgfSxcbiAgaHR0cE1heFJldHJ5Q291bnQ6IDMsXG4gIG1heE1lc3NhZ2VTaXplOiA2NTUzNixcbiAgdmVyc2lvbixcbiAgcHJvdG9jb2xWZXJzaW9uOiA1LFxuICBhZ2VudCxcbiAgZ2V0UG9ydCxcbiAgZ2V0SHR0cFNjaGVtZSxcbiAgZ2V0UHJpbWFyeURvbWFpbkZyb21FbmRwb2ludCxcbiAgZ2V0RW5kcG9pbnRGYWxsYmFja0hvc3RzLFxuICBnZXRGYWxsYmFja0hvc3RzLFxuICBnZXRIb3N0cyxcbiAgY2hlY2tIb3N0LFxuICBvYmplY3RpZnlPcHRpb25zLFxuICBub3JtYWxpc2VPcHRpb25zLFxuICBkZWZhdWx0R2V0SGVhZGVycyxcbiAgZGVmYXVsdFBvc3RIZWFkZXJzXG59O1xuZnVuY3Rpb24gZ2V0UG9ydChvcHRpb25zLCB0bHMpIHtcbiAgcmV0dXJuIHRscyB8fCBvcHRpb25zLnRscyA/IG9wdGlvbnMudGxzUG9ydCA6IG9wdGlvbnMucG9ydDtcbn1cbmZ1bmN0aW9uIGdldEh0dHBTY2hlbWUob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy50bHMgPyBcImh0dHBzOi8vXCIgOiBcImh0dHA6Ly9cIjtcbn1cbmZ1bmN0aW9uIGlzRnFkbklwT3JMb2NhbGhvc3QoZW5kcG9pbnQpIHtcbiAgcmV0dXJuIGVuZHBvaW50LmluY2x1ZGVzKFwiLlwiKSB8fCBlbmRwb2ludC5pbmNsdWRlcyhcIjo6XCIpIHx8IGVuZHBvaW50ID09PSBcImxvY2FsaG9zdFwiO1xufVxuZnVuY3Rpb24gZ2V0UHJpbWFyeURvbWFpbkZyb21FbmRwb2ludChlbmRwb2ludCkge1xuICBpZiAoaXNGcWRuSXBPckxvY2FsaG9zdChlbmRwb2ludCkpXG4gICAgcmV0dXJuIGVuZHBvaW50O1xuICBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aChcIm5vbnByb2Q6XCIpKSB7XG4gICAgY29uc3Qgcm91dGluZ1BvbGljeUlkID0gZW5kcG9pbnQucmVwbGFjZShcIm5vbnByb2Q6XCIsIFwiXCIpO1xuICAgIHJldHVybiBgJHtyb3V0aW5nUG9saWN5SWR9LnJlYWx0aW1lLmFibHktbm9ucHJvZC5uZXRgO1xuICB9XG4gIHJldHVybiBgJHtlbmRwb2ludH0ucmVhbHRpbWUuYWJseS5uZXRgO1xufVxuZnVuY3Rpb24gZ2V0RW5kcG9pbnRGYWxsYmFja0hvc3RzKGVuZHBvaW50KSB7XG4gIGlmIChpc0ZxZG5JcE9yTG9jYWxob3N0KGVuZHBvaW50KSlcbiAgICByZXR1cm4gW107XG4gIGlmIChlbmRwb2ludC5zdGFydHNXaXRoKFwibm9ucHJvZDpcIikpIHtcbiAgICBjb25zdCByb3V0aW5nUG9saWN5SWQgPSBlbmRwb2ludC5yZXBsYWNlKFwibm9ucHJvZDpcIiwgXCJcIik7XG4gICAgcmV0dXJuIGVuZHBvaW50RmFsbGJhY2tzKHJvdXRpbmdQb2xpY3lJZCwgXCJhYmx5LXJlYWx0aW1lLW5vbnByb2QuY29tXCIpO1xuICB9XG4gIHJldHVybiBlbmRwb2ludEZhbGxiYWNrcyhlbmRwb2ludCwgXCJhYmx5LXJlYWx0aW1lLmNvbVwiKTtcbn1cbmZ1bmN0aW9uIGVuZHBvaW50RmFsbGJhY2tzKHJvdXRpbmdQb2xpY3lJZCwgZG9tYWluKSB7XG4gIHJldHVybiBbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiXS5tYXAoKGlkKSA9PiBgJHtyb3V0aW5nUG9saWN5SWR9LiR7aWR9LmZhbGxiYWNrLiR7ZG9tYWlufWApO1xufVxuZnVuY3Rpb24gZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSB7XG4gIGNvbnN0IGZhbGxiYWNrSG9zdHMgPSBvcHRpb25zLmZhbGxiYWNrSG9zdHMsIGh0dHBNYXhSZXRyeUNvdW50ID0gdHlwZW9mIG9wdGlvbnMuaHR0cE1heFJldHJ5Q291bnQgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50IDogRGVmYXVsdHMuaHR0cE1heFJldHJ5Q291bnQ7XG4gIHJldHVybiBmYWxsYmFja0hvc3RzID8gYXJyQ2hvb3NlTihmYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCkgOiBbXTtcbn1cbmZ1bmN0aW9uIGdldEhvc3RzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtvcHRpb25zLnByaW1hcnlEb21haW5dLmNvbmNhdChnZXRGYWxsYmFja0hvc3RzKG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0KSB7XG4gIGlmICh0eXBlb2YgaG9zdCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJob3N0IG11c3QgYmUgYSBzdHJpbmc7IHdhcyBhIFwiICsgdHlwZW9mIGhvc3QsIDRlNCwgNDAwKTtcbiAgfVxuICBpZiAoIWhvc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImhvc3QgbXVzdCBub3QgYmUgemVyby1sZW5ndGhcIiwgNGU0LCA0MDApO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0cyhvcHRpb25zKSB7XG4gIGNvbnN0IHRpbWVvdXRzID0ge307XG4gIGZvciAoY29uc3QgcHJvcCBpbiBEZWZhdWx0cy5USU1FT1VUUykge1xuICAgIHRpbWVvdXRzW3Byb3BdID0gb3B0aW9uc1twcm9wXSB8fCBEZWZhdWx0cy5USU1FT1VUU1twcm9wXTtcbiAgfVxuICByZXR1cm4gdGltZW91dHM7XG59XG5mdW5jdGlvbiBnZXRBZ2VudFN0cmluZyhvcHRpb25zKSB7XG4gIGxldCBhZ2VudFN0ciA9IERlZmF1bHRzLmFnZW50O1xuICBpZiAob3B0aW9ucy5hZ2VudHMpIHtcbiAgICBmb3IgKHZhciBhZ2VudDIgaW4gb3B0aW9ucy5hZ2VudHMpIHtcbiAgICAgIGFnZW50U3RyICs9IFwiIFwiICsgYWdlbnQyICsgXCIvXCIgKyBvcHRpb25zLmFnZW50c1thZ2VudDJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWdlbnRTdHI7XG59XG5mdW5jdGlvbiBvYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIGFsbG93S2V5T3JUb2tlbiwgc291cmNlRm9yRXJyb3JNZXNzYWdlLCBsb2dnZXIsIG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBjb25zdCBtc2cgPSBhbGxvd0tleU9yVG9rZW4gPyBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBlaXRoZXIgYSBjbGllbnQgb3B0aW9ucyBvYmplY3QsIGFuIEFibHkgQVBJIGtleSwgb3IgYW4gQWJseSBUb2tlbmAgOiBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGNsaWVudCBvcHRpb25zIG9iamVjdGA7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG4gIGxldCBvcHRpb25zT2JqO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob3B0aW9ucy5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xuICAgICAgaWYgKCFhbGxvd0tleU9yVG9rZW4pIHtcbiAgICAgICAgY29uc3QgbXNnID0gYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBqdXN0IGFuIEFibHkgVG9rZW47IHlvdSBtdXN0IHByb3ZpZGUgYSBjbGllbnQgb3B0aW9ucyBvYmplY3Qgd2l0aCBhIFxcYHBsdWdpbnNcXGAgcHJvcGVydHkuIChTZXQgdGhpcyBBYmx5IFRva2VuIGFzIHRoZSBvYmplY3RcXHUyMDE5cyBcXGB0b2tlblxcYCBwcm9wZXJ0eS4pYDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNPYmogPSB7IHRva2VuOiBvcHRpb25zIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYWxsb3dLZXlPclRva2VuKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGAke3NvdXJjZUZvckVycm9yTWVzc2FnZX0gY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGgganVzdCBhbiBBYmx5IEFQSSBrZXk7IHlvdSBtdXN0IHByb3ZpZGUgYSBjbGllbnQgb3B0aW9ucyBvYmplY3Qgd2l0aCBhIFxcYHBsdWdpbnNcXGAgcHJvcGVydHkuIChTZXQgdGhpcyBBYmx5IEFQSSBrZXkgYXMgdGhlIG9iamVjdFxcdTIwMTlzIFxcYGtleVxcYCBwcm9wZXJ0eS4pYDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNPYmogPSB7IGtleTogb3B0aW9ucyB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zT2JqID0gb3B0aW9ucztcbiAgfVxuICBpZiAobW9kdWxhclBsdWdpbnNUb0luY2x1ZGUpIHtcbiAgICBvcHRpb25zT2JqID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9uc09iaiksIHsgcGx1Z2luczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSwgb3B0aW9uc09iai5wbHVnaW5zKSB9KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc09iajtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZDbGllbnRPcHRpb25zQXJlVmFsaWQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5lbmRwb2ludCAmJiAob3B0aW9ucy5lbnZpcm9ubWVudCB8fCBvcHRpb25zLnJlc3RIb3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0KSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIlRoZSBgZW5kcG9pbnRgIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgZW52aXJvbm1lbnRgLCBgcmVzdEhvc3RgLCBvciBgcmVhbHRpbWVIb3N0YCBvcHRpb25zLlwiLFxuICAgICAgNDAxMDYsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG4gIGlmIChvcHRpb25zLmVudmlyb25tZW50ICYmIChvcHRpb25zLnJlc3RIb3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0KSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIlRoZSBgZW52aXJvbm1lbnRgIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgcmVzdEhvc3RgLCBvciBgcmVhbHRpbWVIb3N0YCBvcHRpb25zLlwiLFxuICAgICAgNDAxMDYsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpc2VPcHRpb25zKG9wdGlvbnMsIE1zZ1BhY2ssIGxvZ2dlcikge1xuICBjb25zdCBsb2dnZXJUb1VzZSA9IGxvZ2dlciAhPSBudWxsID8gbG9nZ2VyIDogbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcjtcbiAgaWYgKG9wdGlvbnMuZW52aXJvbm1lbnQpIHtcbiAgICBsb2dnZXJUb1VzZS5kZXByZWNhdGVkKFwiVGhlIGBlbnZpcm9ubWVudGAgY2xpZW50IG9wdGlvblwiLCBcIlVzZSB0aGUgYGVuZHBvaW50YCBjbGllbnQgb3B0aW9uIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLnJlc3RIb3N0KSB7XG4gICAgbG9nZ2VyVG9Vc2UuZGVwcmVjYXRlZChcIlRoZSBgcmVzdEhvc3RgIGNsaWVudCBvcHRpb25cIiwgXCJVc2UgdGhlIGBlbmRwb2ludGAgY2xpZW50IG9wdGlvbiBpbnN0ZWFkLlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZWFsdGltZUhvc3QpIHtcbiAgICBsb2dnZXJUb1VzZS5kZXByZWNhdGVkKFwiVGhlIGByZWFsdGltZUhvc3RgIGNsaWVudCBvcHRpb25cIiwgXCJVc2UgdGhlIGBlbmRwb2ludGAgY2xpZW50IG9wdGlvbiBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjaGVja0lmQ2xpZW50T3B0aW9uc0FyZVZhbGlkKG9wdGlvbnMpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlclRvVXNlLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zXCIsXG4gICAgICBcImNsb3NlT25VbmxvYWQgd2FzIHRydWUgYW5kIGEgc2Vzc2lvbiByZWNvdmVyeSBmdW5jdGlvbiB3YXMgc2V0IC0gdGhlc2UgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gdW5zZXR0aW5nIHRoZSBsYXR0ZXJcIlxuICAgICk7XG4gICAgb3B0aW9ucy5yZWNvdmVyID0gdm9pZCAwO1xuICB9XG4gIGlmICghKFwiY2xvc2VPblVubG9hZFwiIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID0gIW9wdGlvbnMucmVjb3ZlcjtcbiAgfVxuICBpZiAoIShcInF1ZXVlTWVzc2FnZXNcIiBpbiBvcHRpb25zKSlcbiAgICBvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSB0cnVlO1xuICBjb25zdCBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnQgfHwgRGVmYXVsdHMuRU5EUE9JTlQ7XG4gIGlmICghb3B0aW9ucy5mYWxsYmFja0hvc3RzICYmICFvcHRpb25zLnJlc3RIb3N0ICYmICFvcHRpb25zLnJlYWx0aW1lSG9zdCAmJiAhb3B0aW9ucy5wb3J0ICYmICFvcHRpb25zLnRsc1BvcnQpIHtcbiAgICBvcHRpb25zLmZhbGxiYWNrSG9zdHMgPSBnZXRFbmRwb2ludEZhbGxiYWNrSG9zdHMob3B0aW9ucy5lbnZpcm9ubWVudCB8fCBlbmRwb2ludCk7XG4gIH1cbiAgY29uc3QgcHJpbWFyeURvbWFpbkZyb21FbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQgJiYgYCR7b3B0aW9ucy5lbnZpcm9ubWVudH0ucmVhbHRpbWUuYWJseS5uZXRgO1xuICBjb25zdCBwcmltYXJ5RG9tYWluRnJvbUxlZ2FjeU9wdGlvbnMgPSBvcHRpb25zLnJlc3RIb3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0IHx8IHByaW1hcnlEb21haW5Gcm9tRW52aXJvbm1lbnQ7XG4gIGNvbnN0IHByaW1hcnlEb21haW4gPSBwcmltYXJ5RG9tYWluRnJvbUxlZ2FjeU9wdGlvbnMgfHwgZ2V0UHJpbWFyeURvbWFpbkZyb21FbmRwb2ludChlbmRwb2ludCk7XG4gIChvcHRpb25zLmZhbGxiYWNrSG9zdHMgfHwgW10pLmNvbmNhdChwcmltYXJ5RG9tYWluKS5mb3JFYWNoKGNoZWNrSG9zdCk7XG4gIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydCB8fCBEZWZhdWx0cy5QT1JUO1xuICBvcHRpb25zLnRsc1BvcnQgPSBvcHRpb25zLnRsc1BvcnQgfHwgRGVmYXVsdHMuVExTX1BPUlQ7XG4gIGlmICghKFwidGxzXCIgaW4gb3B0aW9ucykpXG4gICAgb3B0aW9ucy50bHMgPSB0cnVlO1xuICBjb25zdCB0aW1lb3V0cyA9IGdldFRpbWVvdXRzKG9wdGlvbnMpO1xuICBpZiAoTXNnUGFjaykge1xuICAgIGlmIChcInVzZUJpbmFyeVByb3RvY29sXCIgaW4gb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IFBsYXRmb3JtLkNvbmZpZy5zdXBwb3J0c0JpbmFyeSAmJiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gUGxhdGZvcm0uQ29uZmlnLnByZWZlckJpbmFyeTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKG9wdGlvbnMuY2xpZW50SWQpIHtcbiAgICBoZWFkZXJzW1wiWC1BYmx5LUNsaWVudElkXCJdID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUob3B0aW9ucy5jbGllbnRJZCkpO1xuICB9XG4gIGlmICghKFwiaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nXCIgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHRydWU7XG4gIH1cbiAgbGV0IGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gbnVsbDtcbiAgbGV0IGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgaWYgKG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwpIHtcbiAgICBsZXQgW3VyaSwgcXNdID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybC5zcGxpdChcIj9cIik7XG4gICAgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSBxcyA/IHBhcnNlUXVlcnlTdHJpbmcocXMpIDoge307XG4gICAgaWYgKHVyaS5pbmRleE9mKFwiOi8vXCIpID09PSAtMSkge1xuICAgICAgdXJpID0gXCJodHRwczovL1wiICsgdXJpO1xuICAgIH1cbiAgICBjb25uZWN0aXZpdHlDaGVja1VybCA9IHVyaTtcbiAgfVxuICBsZXQgd3NDb25uZWN0aXZpdHlDaGVja1VybCA9IG9wdGlvbnMud3NDb25uZWN0aXZpdHlDaGVja1VybDtcbiAgaWYgKHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgJiYgd3NDb25uZWN0aXZpdHlDaGVja1VybC5pbmRleE9mKFwiOi8vXCIpID09PSAtMSkge1xuICAgIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgPSBcIndzczovL1wiICsgd3NDb25uZWN0aXZpdHlDaGVja1VybDtcbiAgfVxuICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICBwcmltYXJ5RG9tYWluLFxuICAgIG1heE1lc3NhZ2VTaXplOiBvcHRpb25zLm1heE1lc3NhZ2VTaXplIHx8IERlZmF1bHRzLm1heE1lc3NhZ2VTaXplLFxuICAgIHRpbWVvdXRzLFxuICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zLFxuICAgIGNvbm5lY3Rpdml0eUNoZWNrVXJsLFxuICAgIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwsXG4gICAgaGVhZGVyc1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKENyeXB0bzIsIGxvZ2dlciwgb3B0aW9ucykge1xuICBjb25zdCBjaGFubmVsT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChjaGFubmVsT3B0aW9ucy5jaXBoZXIpIHtcbiAgICBpZiAoIUNyeXB0bzIpXG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIkNyeXB0b1wiKTtcbiAgICBjb25zdCBjaXBoZXIgPSBDcnlwdG8yLmdldENpcGhlcihjaGFubmVsT3B0aW9ucy5jaXBoZXIsIGxvZ2dlcik7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2lwaGVyID0gY2lwaGVyLmNpcGhlclBhcmFtcztcbiAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gY2lwaGVyLmNpcGhlcjtcbiAgfSBlbHNlIGlmIChcImNpcGhlclwiIGluIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2lwaGVyID0gdm9pZCAwO1xuICAgIGNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBudWxsO1xuICB9XG4gIHJldHVybiBjaGFubmVsT3B0aW9ucztcbn1cbnZhciBjb250ZW50VHlwZXMgPSB7XG4gIGpzb246IFwiYXBwbGljYXRpb24vanNvblwiLFxuICB4bWw6IFwiYXBwbGljYXRpb24veG1sXCIsXG4gIGh0bWw6IFwidGV4dC9odG1sXCIsXG4gIG1zZ3BhY2s6IFwiYXBwbGljYXRpb24veC1tc2dwYWNrXCIsXG4gIHRleHQ6IFwidGV4dC9wbGFpblwiXG59O1xudmFyIGRlZmF1bHRIZWFkZXJzT3B0aW9ucyA9IHtcbiAgZm9ybWF0OiBcImpzb25cIiAvKiBqc29uICovLFxuICBwcm90b2NvbFZlcnNpb246IERlZmF1bHRzLnByb3RvY29sVmVyc2lvblxufTtcbmZ1bmN0aW9uIGRlZmF1bHRHZXRIZWFkZXJzKG9wdGlvbnMsIHsgZm9ybWF0LCBwcm90b2NvbFZlcnNpb24gPSBkZWZhdWx0SGVhZGVyc09wdGlvbnMucHJvdG9jb2xWZXJzaW9uIH0gPSB7fSkge1xuICBjb25zdCBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0ICE9IG51bGwgPyBmb3JtYXQgOiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi9dO1xuICByZXR1cm4ge1xuICAgIGFjY2VwdCxcbiAgICBcIlgtQWJseS1WZXJzaW9uXCI6IHByb3RvY29sVmVyc2lvbi50b1N0cmluZygpLFxuICAgIFwiQWJseS1BZ2VudFwiOiBnZXRBZ2VudFN0cmluZyhvcHRpb25zKVxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdFBvc3RIZWFkZXJzKG9wdGlvbnMsIHsgZm9ybWF0LCBwcm90b2NvbFZlcnNpb24gPSBkZWZhdWx0SGVhZGVyc09wdGlvbnMucHJvdG9jb2xWZXJzaW9uIH0gPSB7fSkge1xuICBjb25zdCBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0ICE9IG51bGwgPyBmb3JtYXQgOiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi9dO1xuICBjb25zdCBjb250ZW50VHlwZSA9IGFjY2VwdDtcbiAgcmV0dXJuIHtcbiAgICBhY2NlcHQsXG4gICAgXCJjb250ZW50LXR5cGVcIjogY29udGVudFR5cGUsXG4gICAgXCJYLUFibHktVmVyc2lvblwiOiBwcm90b2NvbFZlcnNpb24udG9TdHJpbmcoKSxcbiAgICBcIkFibHktQWdlbnRcIjogZ2V0QWdlbnRTdHJpbmcob3B0aW9ucylcbiAgfTtcbn1cbnZhciBkZWZhdWx0c19kZWZhdWx0ID0gRGVmYXVsdHM7XG5mdW5jdGlvbiBnZXREZWZhdWx0cyhwbGF0Zm9ybURlZmF1bHRzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKERlZmF1bHRzLCBwbGF0Zm9ybURlZmF1bHRzKTtcbn1cblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9tdWx0aWNhc3Rlci50c1xudmFyIE11bHRpY2FzdGVyID0gY2xhc3MgX011bHRpY2FzdGVyIHtcbiAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlIHN0YXRpYyBNdWx0aWNhc3Rlci5jcmVhdGUgaW5zdGVhZFxuICBjb25zdHJ1Y3Rvcihsb2dnZXIsIG1lbWJlcnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzIHx8IFtdO1xuICB9XG4gIGNhbGwoZXJyLCByZXN1bHQpIHtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0aGlzLm1lbWJlcnMpIHtcbiAgICAgIGlmIChtZW1iZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZW1iZXIoZXJyLCByZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIk11bHRpY2FzdGVyIG11bHRpcGxlIGNhbGxiYWNrIGhhbmRsZXJcIixcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb246IFwiICsgZSArIFwiOyBzdGFjayA9IFwiICsgZS5zdGFja1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHVzaCguLi5hcmdzKSB7XG4gICAgdGhpcy5tZW1iZXJzLnB1c2goLi4uYXJncyk7XG4gIH1cbiAgY3JlYXRlUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wdXNoKChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlc29sdmVBbGwocmVzdWx0KSB7XG4gICAgdGhpcy5jYWxsKG51bGwsIHJlc3VsdCk7XG4gIH1cbiAgcmVqZWN0QWxsKGVycikge1xuICAgIHRoaXMuY2FsbChlcnIpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUobG9nZ2VyLCBtZW1iZXJzKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgX011bHRpY2FzdGVyKGxvZ2dlciwgbWVtYmVycyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKGVyciwgcmVzdWx0KSA9PiBpbnN0YW5jZS5jYWxsKGVyciwgcmVzdWx0KSwge1xuICAgICAgcHVzaDogKGZuKSA9PiBpbnN0YW5jZS5wdXNoKGZuKSxcbiAgICAgIGNyZWF0ZVByb21pc2U6ICgpID0+IGluc3RhbmNlLmNyZWF0ZVByb21pc2UoKSxcbiAgICAgIHJlc29sdmVBbGw6IChyZXN1bHQpID0+IGluc3RhbmNlLnJlc29sdmVBbGwocmVzdWx0KSxcbiAgICAgIHJlamVjdEFsbDogKGVycikgPT4gaW5zdGFuY2UucmVqZWN0QWxsKGVycilcbiAgICB9KTtcbiAgfVxufTtcbnZhciBtdWx0aWNhc3Rlcl9kZWZhdWx0ID0gTXVsdGljYXN0ZXI7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL0h0dHBNZXRob2RzLnRzXG52YXIgSHR0cE1ldGhvZHMgPSAvKiBAX19QVVJFX18gKi8gKChIdHRwTWV0aG9kczIpID0+IHtcbiAgSHR0cE1ldGhvZHMyW1wiR2V0XCJdID0gXCJnZXRcIjtcbiAgSHR0cE1ldGhvZHMyW1wiRGVsZXRlXCJdID0gXCJkZWxldGVcIjtcbiAgSHR0cE1ldGhvZHMyW1wiUG9zdFwiXSA9IFwicG9zdFwiO1xuICBIdHRwTWV0aG9kczJbXCJQdXRcIl0gPSBcInB1dFwiO1xuICBIdHRwTWV0aG9kczJbXCJQYXRjaFwiXSA9IFwicGF0Y2hcIjtcbiAgcmV0dXJuIEh0dHBNZXRob2RzMjtcbn0pKEh0dHBNZXRob2RzIHx8IHt9KTtcbnZhciBIdHRwTWV0aG9kc19kZWZhdWx0ID0gSHR0cE1ldGhvZHM7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL0h0dHBTdGF0dXNDb2Rlcy50c1xudmFyIEh0dHBTdGF0dXNDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKEh0dHBTdGF0dXNDb2RlczIpID0+IHtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiU3VjY2Vzc1wiXSA9IDIwMF0gPSBcIlN1Y2Nlc3NcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiTm9Db250ZW50XCJdID0gMjA0XSA9IFwiTm9Db250ZW50XCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIkJhZFJlcXVlc3RcIl0gPSA0MDBdID0gXCJCYWRSZXF1ZXN0XCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIlVuYXV0aG9yaXplZFwiXSA9IDQwMV0gPSBcIlVuYXV0aG9yaXplZFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJGb3JiaWRkZW5cIl0gPSA0MDNdID0gXCJGb3JiaWRkZW5cIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiUmVxdWVzdFRpbWVvdXRcIl0gPSA0MDhdID0gXCJSZXF1ZXN0VGltZW91dFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNTAwXSA9IFwiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiO1xuICByZXR1cm4gSHR0cFN0YXR1c0NvZGVzMjtcbn0pKEh0dHBTdGF0dXNDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBpc1N1Y2Nlc3NDb2RlKHN0YXR1c0NvZGUpIHtcbiAgcmV0dXJuIHN0YXR1c0NvZGUgPj0gMjAwIC8qIFN1Y2Nlc3MgKi8gJiYgc3RhdHVzQ29kZSA8IDQwMCAvKiBCYWRSZXF1ZXN0ICovO1xufVxudmFyIEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0ID0gSHR0cFN0YXR1c0NvZGVzO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYXV0aC50c1xudmFyIE1BWF9UT0tFTl9MRU5HVEggPSBNYXRoLnBvdygyLCAxNyk7XG5mdW5jdGlvbiByYW5kb20oKSB7XG4gIHJldHVybiAoXCIwMDAwMDBcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTYpKS5zbGljZSgtMTYpO1xufVxuZnVuY3Rpb24gaXNSZWFsdGltZShjbGllbnQpIHtcbiAgcmV0dXJuICEhY2xpZW50LmNvbm5lY3Rpb247XG59XG5mdW5jdGlvbiBub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpIHtcbiAgaWYgKCFpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlcnIpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvckluZm8oaW5zcGVjdEVycm9yKGVyciksIGVyci5jb2RlIHx8IDQwMTcwLCBlcnIuc3RhdHVzQ29kZSB8fCA0MDEpO1xuICB9XG4gIGlmICghZXJyLmNvZGUpIHtcbiAgICBpZiAoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xuICAgICAgZXJyLmNvZGUgPSA0MDMwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyLmNvZGUgPSA0MDE3MDtcbiAgICAgIGVyci5zdGF0dXNDb2RlID0gNDAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXJyO1xufVxudmFyIGhtYWMgPSAodGV4dCwga2V5KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlclV0aWxzID0gUGxhdGZvcm0uQnVmZmVyVXRpbHM7XG4gIGNvbnN0IHRleHRCdWZmZXIgPSBidWZmZXJVdGlscy51dGY4RW5jb2RlKHRleHQpO1xuICBjb25zdCBrZXlCdWZmZXIgPSBidWZmZXJVdGlscy51dGY4RW5jb2RlKGtleSk7XG4gIGNvbnN0IGRpZ2VzdCA9IGJ1ZmZlclV0aWxzLmhtYWNTaGEyNTYodGV4dEJ1ZmZlciwga2V5QnVmZmVyKTtcbiAgcmV0dXJuIGJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkaWdlc3QpO1xufTtcbmZ1bmN0aW9uIGMxNG4oY2FwYWJpbGl0eSkge1xuICBpZiAoIWNhcGFiaWxpdHkpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGlmICh0eXBlb2YgY2FwYWJpbGl0eSA9PSBcInN0cmluZ1wiKVxuICAgIGNhcGFiaWxpdHkgPSBKU09OLnBhcnNlKGNhcGFiaWxpdHkpO1xuICBjb25zdCBjMTRuQ2FwYWJpbGl0eSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBrZXlzID0ga2V5c0FycmF5KGNhcGFiaWxpdHksIHRydWUpO1xuICBpZiAoIWtleXMpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGtleXMuc29ydCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjMTRuQ2FwYWJpbGl0eVtrZXlzW2ldXSA9IGNhcGFiaWxpdHlba2V5c1tpXV0uc29ydCgpO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShjMTRuQ2FwYWJpbGl0eSk7XG59XG5mdW5jdGlvbiBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZChhdXRoT3B0aW9ucywgbG9nZ2VyKSB7XG4gIGlmIChhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFja1wiKTtcbiAgfSBlbHNlIGlmIChhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsXCIpO1xuICB9IGVsc2UgaWYgKGF1dGhPcHRpb25zLmtleSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZ1wiKTtcbiAgfSBlbHNlIGlmIChhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIHN1cHBsaWVkIHRva2VuIG9ubHlcIik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbXNnID0gXCJhdXRoT3B0aW9ucyBtdXN0IGluY2x1ZGUgdmFsaWQgYXV0aGVudGljYXRpb24gcGFyYW1ldGVyc1wiO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoKClcIiwgbXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gYmFzaWNBdXRoRm9yY2VkKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFwidXNlVG9rZW5BdXRoXCIgaW4gb3B0aW9ucyAmJiAhb3B0aW9ucy51c2VUb2tlbkF1dGg7XG59XG5mdW5jdGlvbiB1c2VUb2tlbkF1dGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy51c2VUb2tlbkF1dGggfHwgIWJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSAmJiAob3B0aW9ucy5hdXRoQ2FsbGJhY2sgfHwgb3B0aW9ucy5hdXRoVXJsIHx8IG9wdGlvbnMudG9rZW4gfHwgb3B0aW9ucy50b2tlbkRldGFpbHMpO1xufVxuZnVuY3Rpb24gbm9XYXlUb1JlbmV3KG9wdGlvbnMpIHtcbiAgcmV0dXJuICFvcHRpb25zLmtleSAmJiAhb3B0aW9ucy5hdXRoQ2FsbGJhY2sgJiYgIW9wdGlvbnMuYXV0aFVybDtcbn1cbnZhciB0cklkID0gMDtcbmZ1bmN0aW9uIGdldFRva2VuUmVxdWVzdElkKCkge1xuICByZXR1cm4gdHJJZCsrO1xufVxudmFyIEF1dGggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgb3B0aW9ucykge1xuICAgIC8vIFRoaXMgaW5pdGlhbGl6YXRpb24gaXMgYWx3YXlzIG92ZXJ3cml0dGVuIGFuZCBvbmx5IHVzZWQgdG8gcHJldmVudCBhIFR5cGVTY3JpcHQgY29tcGlsZXIgZXJyb3JcbiAgICB0aGlzLmF1dGhPcHRpb25zID0ge307XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy50b2tlblBhcmFtcyA9IG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zIHx8IHt9O1xuICAgIHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcbiAgICB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuICAgIGlmICh1c2VUb2tlbkF1dGgob3B0aW9ucykpIHtcbiAgICAgIGlmIChub1dheVRvUmVuZXcob3B0aW9ucykpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkF1dGgoKVwiLFxuICAgICAgICAgIFwiV2FybmluZzogbGlicmFyeSBpbml0aWFsaXplZCB3aXRoIGEgdG9rZW4gbGl0ZXJhbCB3aXRob3V0IGFueSB3YXkgdG8gcmVuZXcgdGhlIHRva2VuIHdoZW4gaXQgZXhwaXJlcyAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpLiBTZWUgaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvNDAxNzEgZm9yIGhlbHBcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyhvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcywgb3B0aW9ucyk7XG4gICAgICBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zLCB0aGlzLmxvZ2dlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghb3B0aW9ucy5rZXkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gXCJObyBhdXRoZW50aWNhdGlvbiBvcHRpb25zIHByb3ZpZGVkOyBuZWVkIG9uZSBvZjoga2V5LCBhdXRoVXJsLCBvciBhdXRoQ2FsbGJhY2sgKG9yIGZvciB0ZXN0aW5nIG9ubHksIHRva2VuIG9yIHRva2VuRGV0YWlscylcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aCgpXCIsIG1zZyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8obXNnLCA0MDE2MCwgNDAxKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcImFub255bW91cywgdXNpbmcgYmFzaWMgYXV0aFwiKTtcbiAgICAgIHRoaXMuX3NhdmVCYXNpY09wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBhc3luYyBhdXRob3JpemUodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhPcHRpb25zICYmIGF1dGhPcHRpb25zLmtleSAmJiB0aGlzLmF1dGhPcHRpb25zLmtleSAhPT0gYXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHVwZGF0ZSBhdXRoIG9wdGlvbnMgd2l0aCBpbmNvbXBhdGlibGUga2V5XCIsIDQwMTAyLCA0MDEpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHRva2VuRGV0YWlscyA9IGF3YWl0IHRoaXMuX2ZvcmNlTmV3VG9rZW4odG9rZW5QYXJhbXMgIT0gbnVsbCA/IHRva2VuUGFyYW1zIDogbnVsbCwgYXV0aE9wdGlvbnMgIT0gbnVsbCA/IGF1dGhPcHRpb25zIDogbnVsbCk7XG4gICAgICBpZiAoaXNSZWFsdGltZSh0aGlzLmNsaWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoXG4gICAgICAgICAgICB0b2tlbkRldGFpbHMsXG4gICAgICAgICAgICAoZXJyLCB0b2tlbkRldGFpbHMyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUodG9rZW5EZXRhaWxzMilcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbkRldGFpbHM7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5jbGllbnQuY29ubmVjdGlvbiAmJiBlcnIuc3RhdHVzQ29kZSA9PT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuRm9yYmlkZGVuKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgLyogRm9yIGludGVybmFsIHVzZSwgZWcgYnkgY29ubmVjdGlvbk1hbmFnZXIgLSB1c2VmdWwgd2hlbiB3YW50IHRvIGNhbGwgYmFja1xuICAgKiBhcyBzb29uIGFzIHdlIGhhdmUgdGhlIG5ldyB0b2tlbiwgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgaXQgdG8gdGFrZVxuICAgKiBlZmZlY3Qgb24gdGhlIGNvbm5lY3Rpb24gYXMgI2F1dGhvcml6ZSBkb2VzICovXG4gIGFzeW5jIF9mb3JjZU5ld1Rva2VuKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9zYXZlVG9rZW5PcHRpb25zKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucyk7XG4gICAgbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucywgdGhpcy5sb2dnZXIpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHModHJ1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRva2VuUGFyYW1zLnRpbWVzdGFtcDtcbiAgICAgIGRlbGV0ZSB0aGlzLmF1dGhPcHRpb25zLnF1ZXJ5VGltZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFRva2VuKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIGNvbnN0IHJlc29sdmVkQXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuICAgIGNvbnN0IHJlc29sdmVkVG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCBjb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuICAgIGxldCB0b2tlblJlcXVlc3RDYWxsYmFjaywgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFja1wiKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2s7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybFwiKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gKHBhcmFtcywgY2IpID0+IHtcbiAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBtaXhpbihcbiAgICAgICAgICB7IGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluXCIgfSxcbiAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhIZWFkZXJzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHVzZVBvc3QgPSByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhNZXRob2QgJiYgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoTWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwicG9zdFwiO1xuICAgICAgICBsZXQgcHJvdmlkZWRRc1BhcmFtcztcbiAgICAgICAgY29uc3QgcXVlcnlJZHggPSByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwuaW5kZXhPZihcIj9cIik7XG4gICAgICAgIGlmIChxdWVyeUlkeCA+IC0xKSB7XG4gICAgICAgICAgcHJvdmlkZWRRc1BhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKHF1ZXJ5SWR4KSk7XG4gICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKDAsIHF1ZXJ5SWR4KTtcbiAgICAgICAgICBpZiAoIXVzZVBvc3QpIHtcbiAgICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFBhcmFtcyA9IG1peGluKFxuICAgICAgICAgICAgICBwcm92aWRlZFFzUGFyYW1zLFxuICAgICAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhQYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGhQYXJhbXMgPSBtaXhpbih7fSwgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoUGFyYW1zIHx8IHt9LCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrID0gKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICAgIGxldCBib2R5ID0gKF9hMiA9IHJlc3VsdC5ib2R5KSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgICAgICAgICBsZXQgY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrXCIsXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnJvcilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlSGVhZGVyT3JIZWFkZXJzID0gKF9iID0gcmVzdWx0LmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pICE9IG51bGwgPyBfYiA6IG51bGw7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycykpIHtcbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycy5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlSGVhZGVyT3JIZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZDsgY29udGVudC10eXBlOiBcIiArIGNvbnRlbnRUeXBlICsgXCI7IGJvZHk6IFwiICsgaW5zcGVjdEJvZHkoYm9keSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGNiKHJlc3VsdC5lcnJvciwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQudW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkpXG4gICAgICAgICAgICBib2R5ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGNiKG5ldyBFcnJvckluZm8oXCJhdXRoVXJsIHJlc3BvbnNlIGlzIG1pc3NpbmcgYSBjb250ZW50LXR5cGUgaGVhZGVyXCIsIDQwMTcwLCA0MDEpLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QganNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID4gLTEsIHRleHQgPSBjb250ZW50VHlwZS5pbmRleE9mKFwidGV4dC9wbGFpblwiKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qd3RcIikgPiAtMTtcbiAgICAgICAgICBpZiAoIWpzb24gJiYgIXRleHQpIHtcbiAgICAgICAgICAgIGNiKFxuICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgIFwiYXV0aFVybCByZXNwb25kZWQgd2l0aCB1bmFjY2VwdGFibGUgY29udGVudC10eXBlIFwiICsgY29udGVudFR5cGUgKyBcIiwgc2hvdWxkIGJlIGVpdGhlciB0ZXh0L3BsYWluLCBhcHBsaWNhdGlvbi9qd3Qgb3IgYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID4gTUFYX1RPS0VOX0xFTkdUSCkge1xuICAgICAgICAgICAgICBjYihuZXcgRXJyb3JJbmZvKFwiYXV0aFVybCByZXNwb25zZSBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aFwiLCA0MDE3MCwgNDAxKSwgbnVsbCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjYihcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGVycm9yIHByb2Nlc3NpbmcgYXV0aFVSTCByZXNwb25zZTsgZXJyID0gXCIgKyBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNiKG51bGwsIGJvZHksIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2tcIixcbiAgICAgICAgICBcIlJlcXVlc3RpbmcgdG9rZW4gZnJvbSBcIiArIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCArIFwiOyBQYXJhbXM6IFwiICsgSlNPTi5zdHJpbmdpZnkoYXV0aFBhcmFtcykgKyBcIjsgbWV0aG9kOiBcIiArICh1c2VQb3N0ID8gXCJQT1NUXCIgOiBcIkdFVFwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodXNlUG9zdCkge1xuICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhdXRoSGVhZGVycyB8fCB7fTtcbiAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbiAgICAgICAgICBjb25zdCBib2R5ID0gdG9RdWVyeVN0cmluZyhhdXRoUGFyYW1zKS5zbGljZSgxKTtcbiAgICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgICAgICB0aGlzLmNsaWVudC5odHRwLmRvVXJpKFxuICAgICAgICAgICAgICBIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsXG4gICAgICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCxcbiAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgcHJvdmlkZWRRc1BhcmFtc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gYXV0aFVybFJlcXVlc3RDYWxsYmFjayhlcnIpIDogYXV0aFVybFJlcXVlc3RDYWxsYmFjayhyZXN1bHQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgICAgICB0aGlzLmNsaWVudC5odHRwLmRvVXJpKEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwsIGF1dGhIZWFkZXJzIHx8IHt9LCBudWxsLCBhdXRoUGFyYW1zKSxcbiAgICAgICAgICAgIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gYXV0aFVybFJlcXVlc3RDYWxsYmFjayhlcnIpIDogYXV0aFVybFJlcXVlc3RDYWxsYmFjayhyZXN1bHQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLFxuICAgICAgICBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nXCJcbiAgICAgICk7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IChwYXJhbXMsIGNiKSA9PiB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgICAgICB0aGlzLmNyZWF0ZVRva2VuUmVxdWVzdChwYXJhbXMsIHJlc29sdmVkQXV0aE9wdGlvbnMpLFxuICAgICAgICAgIChlcnIsIHJlc3VsdCkgPT4gY2IoZXJyLCByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IG51bGwpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBcIk5lZWQgYSBuZXcgdG9rZW4sIGJ1dCBhdXRoT3B0aW9ucyBkb2VzIG5vdCBpbmNsdWRlIGFueSB3YXkgdG8gcmVxdWVzdCBvbmUgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KVwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIkF1dGgoKVwiLFxuICAgICAgICBcImxpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwXCJcbiAgICAgICk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKG1zZywgNDAxNzEsIDQwMyk7XG4gICAgfVxuICAgIGlmIChcImNhcGFiaWxpdHlcIiBpbiByZXNvbHZlZFRva2VuUGFyYW1zKVxuICAgICAgcmVzb2x2ZWRUb2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bihcbiAgICAgICAgcmVzb2x2ZWRUb2tlblBhcmFtcy5jYXBhYmlsaXR5XG4gICAgICApO1xuICAgIGNvbnN0IHRva2VuUmVxdWVzdCA9IChzaWduZWRUb2tlblBhcmFtcywgdG9rZW5DYikgPT4ge1xuICAgICAgY29uc3Qga2V5TmFtZSA9IHNpZ25lZFRva2VuUGFyYW1zLmtleU5hbWUsIHBhdGggPSBcIi9rZXlzL1wiICsga2V5TmFtZSArIFwiL3JlcXVlc3RUb2tlblwiLCB0b2tlblVyaSA9IGZ1bmN0aW9uKGhvc3QpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5iYXNlVXJpKGhvc3QpICsgcGF0aDtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0OiBcImpzb25cIiAvKiBqc29uICovIH0pO1xuICAgICAgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpXG4gICAgICAgIG1peGluKHJlcXVlc3RIZWFkZXJzLCByZXNvbHZlZEF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnJlcXVlc3RUb2tlblwiLFxuICAgICAgICBcIlNlbmRpbmcgUE9TVCB0byBcIiArIHBhdGggKyBcIjsgVG9rZW4gcGFyYW1zOiBcIiArIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKVxuICAgICAgKTtcbiAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgICAgdGhpcy5jbGllbnQuaHR0cC5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIHRva2VuVXJpLCByZXF1ZXN0SGVhZGVycywgSlNPTi5zdHJpbmdpZnkoc2lnbmVkVG9rZW5QYXJhbXMpLCBudWxsKSxcbiAgICAgICAgKGVyciwgcmVzdWx0KSA9PiBlcnIgPyB0b2tlbkNiKGVycikgOiB0b2tlbkNiKHJlc3VsdC5lcnJvciwgcmVzdWx0LmJvZHksIHJlc3VsdC51bnBhY2tlZClcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSBmYWxzZSwgdGltZW91dExlbmd0aCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCwgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBtc2cgPSBcIlRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZW91dExlbmd0aCAvIDFlMyArIFwiIHNlY29uZHNcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBtc2cpO1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgIH0sIHRpbWVvdXRMZW5ndGgpO1xuICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2socmVzb2x2ZWRUb2tlblBhcmFtcywgKGVyciwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBjb250ZW50VHlwZSkgPT4ge1xuICAgICAgICBpZiAodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsZWFyVGltZW91dCh0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKClcIixcbiAgICAgICAgICAgIFwidG9rZW4gcmVxdWVzdCBzaWduaW5nIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlamVjdChub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJUb2tlbiBzdHJpbmcgaXMgZW1wdHlcIiwgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcIlRva2VuIHN0cmluZyBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCAod2FzIFwiICsgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCArIFwiIGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSBcInVuZGVmaW5lZFwiIHx8IHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVG9rZW4gc3RyaW5nIHdhcyBsaXRlcmFsIG51bGwvdW5kZWZpbmVkXCIsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlsc1swXSA9PT0gXCJ7XCIgJiYgIShjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vand0XCIpID4gLTEpKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJUb2tlbiB3YXMgZG91YmxlLWVuY29kZWQ7IG1ha2Ugc3VyZSB5b3UncmUgbm90IEpTT04tZW5jb2RpbmcgYW4gYWxyZWFkeSBlbmNvZGVkIHRva2VuIHJlcXVlc3Qgb3IgZGV0YWlsc1wiLFxuICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgdG9rZW46IHRva2VuUmVxdWVzdE9yRGV0YWlscyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzICE9PSBcIm9iamVjdFwiIHx8IHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IFwiRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZyBvciB0b2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0LCBidXQgZ290IGEgXCIgKyB0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgbXNnKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqZWN0U2l6ZSA9IEpTT04uc3RyaW5naWZ5KHRva2VuUmVxdWVzdE9yRGV0YWlscykubGVuZ3RoO1xuICAgICAgICBpZiAob2JqZWN0U2l6ZSA+IE1BWF9UT0tFTl9MRU5HVEggJiYgIXJlc29sdmVkQXV0aE9wdGlvbnMuc3VwcHJlc3NNYXhMZW5ndGhDaGVjaykge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgIFwiVG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCBleGNlZWRlZCBtYXggcGVybWl0dGVkIHN0cmluZ2lmaWVkIHNpemUgKHdhcyBcIiArIG9iamVjdFNpemUgKyBcIiBieXRlcylcIixcbiAgICAgICAgICAgICAgNDAxNzAsXG4gICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImlzc3VlZFwiIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykge1xuICAgICAgICAgIHJlc29sdmUodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJrZXlOYW1lXCIgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IFwiRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZywgdG9rZW4gcmVxdWVzdCBvYmplY3QsIG9yIHRva2VuIGRldGFpbHMgb2JqZWN0XCI7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBtc2cpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKG1zZywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0b2tlblJlcXVlc3QodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCAoZXJyMiwgdG9rZW5SZXNwb25zZSwgdW5wYWNrZWQpID0+IHtcbiAgICAgICAgICBpZiAoZXJyMikge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKClcIixcbiAgICAgICAgICAgICAgXCJ0b2tlbiByZXF1ZXN0IEFQSSBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlamVjdChub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIyKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdW5wYWNrZWQpXG4gICAgICAgICAgICB0b2tlblJlc3BvbnNlID0gSlNPTi5wYXJzZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLmdldFRva2VuKClcIiwgXCJ0b2tlbiByZWNlaXZlZFwiKTtcbiAgICAgICAgICByZXNvbHZlKHRva2VuUmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHNpZ24gYSB0b2tlbiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBOT1RFIHRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIHRoZSBrZXkgdmFsdWUgaXMgYXZhaWxhYmxlIGxvY2FsbHkuXG4gICAqIE90aGVyd2lzZSwgc2lnbmVkIHRva2VuIHJlcXVlc3RzIG11c3QgYmUgb2J0YWluZWQgZnJvbSB0aGUga2V5XG4gICAqIG93bmVyIChlaXRoZXIgdXNpbmcgdGhlIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgb3IgdXJsKS5cbiAgICpcbiAgICogQHBhcmFtIGF1dGhPcHRpb25zXG4gICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0IG9wdGlvbnM6XG4gICAqIC0ga2V5OiAgICAgICAgICAgdGhlIGtleSB0byB1c2UuIElmIG5vdCBzcGVjaWZpZWQsIGEga2V5IHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmdcbiAgICogICAgICAgICAgICAgICAgICB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG4gICAqXG4gICAqIC0gcXVlcnlUaW1lICAgICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgYWJseSBzeXN0ZW0gc2hvdWxkIGJlXG4gICAqICAgICAgICAgICAgICAgICAgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgdGltZSB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHlcbiAgICpcbiAgICogLSByZXF1ZXN0SGVhZGVycyAob3B0aW9uYWwsIHVuc3VwcG9ydGVkLCBmb3IgdGVzdGluZyBvbmx5KSBleHRyYSBoZWFkZXJzIHRvIGFkZCB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW4gcmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW5QYXJhbXNcbiAgICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XG4gICAqIC0gdHRsOiAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiB0aGUgdG9rZW4gaW4gbXMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXG4gICAqICAgICAgICAgICAgICAgICAgYSBkZWZhdWx0IG9mIDEgaG91ciBpcyBwcm92aWRlZC4gVGhlIG1heGltdW0gbGlmZXRpbWUgaXMgMjRob3VyczsgYW55IHJlcXVlc3RcbiAgICogICAgICAgICAgICAgICAgICBleGNlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXG4gICAqXG4gICAqIC0gY2FwYWJpbGl0eTogICAgKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxuICAgKiAgICAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICpcbiAgICogLSBjbGllbnRJZDogICAgICAob3B0aW9uYWwpIGEgY2xpZW50IElEIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlbjsgaWYgbm90XG4gICAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgKlxuICAgKiAtIHRpbWVzdGFtcDogICAgIChvcHRpb25hbCkgdGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGVwb2NoLiBJZiBub25lIGlzIHNwZWNpZmllZCxcbiAgICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRva2VuUmVxdWVzdCh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICBhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG4gICAgdG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCBjb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuICAgIGNvbnN0IGtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIk5vIGtleSBzcGVjaWZpZWRcIiwgNDAxMDEsIDQwMyk7XG4gICAgfVxuICAgIGNvbnN0IGtleVBhcnRzID0ga2V5LnNwbGl0KFwiOlwiKSwga2V5TmFtZSA9IGtleVBhcnRzWzBdLCBrZXlTZWNyZXQgPSBrZXlQYXJ0c1sxXTtcbiAgICBpZiAoIWtleVNlY3JldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIkludmFsaWQga2V5IHNwZWNpZmllZFwiLCA0MDEwMSwgNDAzKTtcbiAgICB9XG4gICAgaWYgKHRva2VuUGFyYW1zLmNsaWVudElkID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgY2FuXFx1MjAxOXQgYmUgYW4gZW1wdHkgc3RyaW5nXCIsIDQwMDEyLCA0MDApO1xuICAgIH1cbiAgICBpZiAoXCJjYXBhYmlsaXR5XCIgaW4gdG9rZW5QYXJhbXMpIHtcbiAgICAgIHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgPSBjMTRuKHRva2VuUGFyYW1zLmNhcGFiaWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gbWl4aW4oeyBrZXlOYW1lIH0sIHRva2VuUGFyYW1zKSwgY2xpZW50SWQgPSB0b2tlblBhcmFtcy5jbGllbnRJZCB8fCBcIlwiLCB0dGwgPSB0b2tlblBhcmFtcy50dGwgfHwgXCJcIiwgY2FwYWJpbGl0eSA9IHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgfHwgXCJcIjtcbiAgICBpZiAoIXJlcXVlc3QudGltZXN0YW1wKSB7XG4gICAgICByZXF1ZXN0LnRpbWVzdGFtcCA9IGF3YWl0IHRoaXMuX2dldFRpbWVzdGFtcChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5xdWVyeVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHJlcXVlc3Qubm9uY2UgfHwgKHJlcXVlc3Qubm9uY2UgPSByYW5kb20oKSksIHRpbWVzdGFtcCA9IHJlcXVlc3QudGltZXN0YW1wO1xuICAgIGNvbnN0IHNpZ25UZXh0ID0gcmVxdWVzdC5rZXlOYW1lICsgXCJcXG5cIiArIHR0bCArIFwiXFxuXCIgKyBjYXBhYmlsaXR5ICsgXCJcXG5cIiArIGNsaWVudElkICsgXCJcXG5cIiArIHRpbWVzdGFtcCArIFwiXFxuXCIgKyBub25jZSArIFwiXFxuXCI7XG4gICAgcmVxdWVzdC5tYWMgPSByZXF1ZXN0Lm1hYyB8fCBobWFjKHNpZ25UZXh0LCBrZXlTZWNyZXQpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGguZ2V0VG9rZW5SZXF1ZXN0KClcIiwgXCJnZW5lcmF0ZWQgc2lnbmVkIHJlcXVlc3RcIik7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYXV0aCBxdWVyeSBwYXJhbXMgdG8gdXNlIGZvciBhIHdlYnNvY2tldCBjb25uZWN0aW9uLFxuICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEF1dGhQYXJhbXMoKSB7XG4gICAgaWYgKHRoaXMubWV0aG9kID09IFwiYmFzaWNcIilcbiAgICAgIHJldHVybiB7IGtleTogdGhpcy5rZXkgfTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCB0b2tlbkRldGFpbHMgPSBhd2FpdCB0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSk7XG4gICAgICBpZiAoIXRva2VuRGV0YWlscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRoLmdldEF1dGhQYXJhbXMoKTogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIHJldHVybmVkIG5vIGVycm9yIG9yIHRva2VuRGV0YWlsc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGFjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VuIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyIHRvIHVzZSBmb3IgYSBSRVNUIG9yIGNvbWV0IHJlcXVlc3QsXG4gICAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0QXV0aEhlYWRlcnMoKSB7XG4gICAgaWYgKHRoaXMubWV0aG9kID09IFwiYmFzaWNcIikge1xuICAgICAgcmV0dXJuIHsgYXV0aG9yaXphdGlvbjogXCJCYXNpYyBcIiArIHRoaXMuYmFzaWNLZXkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG9rZW5EZXRhaWxzID0gYXdhaXQgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UpO1xuICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aC5nZXRBdXRoUGFyYW1zKCk6IF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyByZXR1cm5lZCBubyBlcnJvciBvciB0b2tlbkRldGFpbHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBhdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIiArIHRvQmFzZTY0KHRva2VuRGV0YWlscy50b2tlbikgfTtcbiAgICB9XG4gIH1cbiAgX3NhdmVCYXNpY09wdGlvbnMoYXV0aE9wdGlvbnMpIHtcbiAgICB0aGlzLm1ldGhvZCA9IFwiYmFzaWNcIjtcbiAgICB0aGlzLmtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICB0aGlzLmJhc2ljS2V5ID0gdG9CYXNlNjQoYXV0aE9wdGlvbnMua2V5KTtcbiAgICB0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwge307XG4gICAgaWYgKFwiY2xpZW50SWRcIiBpbiBhdXRoT3B0aW9ucykge1xuICAgICAgdGhpcy5fdXNlclNldENsaWVudElkKGF1dGhPcHRpb25zLmNsaWVudElkKTtcbiAgICB9XG4gIH1cbiAgX3NhdmVUb2tlbk9wdGlvbnModG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgdGhpcy5tZXRob2QgPSBcInRva2VuXCI7XG4gICAgaWYgKHRva2VuUGFyYW1zKSB7XG4gICAgICB0aGlzLnRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXM7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucykge1xuICAgICAgaWYgKGF1dGhPcHRpb25zLnRva2VuKSB7XG4gICAgICAgIGF1dGhPcHRpb25zLnRva2VuRGV0YWlscyA9IHR5cGVvZiBhdXRoT3B0aW9ucy50b2tlbiA9PT0gXCJzdHJpbmdcIiA/IHsgdG9rZW46IGF1dGhPcHRpb25zLnRva2VuIH0gOiBhdXRoT3B0aW9ucy50b2tlbjtcbiAgICAgIH1cbiAgICAgIGlmIChhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcbiAgICAgICAgdGhpcy50b2tlbkRldGFpbHMgPSBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHM7XG4gICAgICB9XG4gICAgICBpZiAoXCJjbGllbnRJZFwiIGluIGF1dGhPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnM7XG4gICAgfVxuICB9XG4gIC8qIEBwYXJhbSBmb3JjZVN1cGVyc2VkZTogZm9yY2UgYSBuZXcgdG9rZW4gcmVxdWVzdCBldmVuIGlmIHRoZXJlJ3Mgb25lIGluXG4gICAqIHByb2dyZXNzLCBtYWtpbmcgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIHdhaXQgZm9yIHRoZSBuZXcgb25lICovXG4gIGFzeW5jIF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmb3JjZVN1cGVyc2VkZSkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy50b2tlbkRldGFpbHM7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKHRva2VuLmNsaWVudElkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwiTWlzbWF0Y2ggYmV0d2VlbiBjbGllbnRJZCBpbiB0b2tlbiAoXCIgKyB0b2tlbi5jbGllbnRJZCArIFwiKSBhbmQgY3VycmVudCBjbGllbnRJZCAoXCIgKyB0aGlzLmNsaWVudElkICsgXCIpXCIsXG4gICAgICAgICAgNDAxMDIsXG4gICAgICAgICAgNDAzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2xpZW50LmlzVGltZU9mZnNldFNldCgpIHx8ICF0b2tlbi5leHBpcmVzIHx8IHRva2VuLmV4cGlyZXMgPj0gdGhpcy5jbGllbnQuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQXV0aC5nZXRUb2tlbigpXCIsXG4gICAgICAgICAgXCJ1c2luZyBjYWNoZWQgdG9rZW47IGV4cGlyZXMgPSBcIiArIHRva2VuLmV4cGlyZXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5nZXRUb2tlbigpXCIsIFwiZGVsZXRpbmcgZXhwaXJlZCB0b2tlblwiKTtcbiAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9ICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgfHwgKHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG11bHRpY2FzdGVyX2RlZmF1bHQuY3JlYXRlKHRoaXMubG9nZ2VyKSkpLmNyZWF0ZVByb21pc2UoKTtcbiAgICBpZiAodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgIT09IG51bGwgJiYgIWZvcmNlU3VwZXJzZWRlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5SZXF1ZXN0SWQgPSB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IGdldFRva2VuUmVxdWVzdElkKCk7XG4gICAgbGV0IHRva2VuUmVzcG9uc2UsIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdFRva2VuKHRoaXMudG9rZW5QYXJhbXMsIHRoaXMuYXV0aE9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2F1Z2h0RXJyb3IgPSBlcnI7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA+IHRva2VuUmVxdWVzdElkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoKVwiLFxuICAgICAgICBcIkRpc2NhcmRpbmcgdG9rZW4gcmVxdWVzdCByZXNwb25zZTsgb3ZlcnRha2VuIGJ5IG5ld2VyIG9uZVwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcbiAgICBjb25zdCBtdWx0aWNhc3RlciA9IHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdDtcbiAgICB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgbXVsdGljYXN0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11bHRpY2FzdGVyLnJlamVjdEFsbChjYXVnaHRFcnJvcik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgbXVsdGljYXN0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11bHRpY2FzdGVyLnJlc29sdmVBbGwodGhpcy50b2tlbkRldGFpbHMgPSB0b2tlblJlc3BvbnNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKiBVc2VyLXNldDogY2hlY2sgdHlwZXMsICcqJyBpcyBkaXNhbGxvd2VkLCB0aHJvdyBhbnkgZXJyb3JzICovXG4gIF91c2VyU2V0Q2xpZW50SWQoY2xpZW50SWQpIHtcbiAgICBpZiAoISh0eXBlb2YgY2xpZW50SWQgPT09IFwic3RyaW5nXCIgfHwgY2xpZW50SWQgPT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbFwiLCA0MDAxMiwgNDAwKTtcbiAgICB9IGVsc2UgaWYgKGNsaWVudElkID09PSBcIipcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgJ0NhblxcdTIwMTl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCBpbnN0YW50aWF0ZSB0aGUgbGlicmFyeSB3aXRoIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSksIG9yIGlmIGNhbGxpbmcgYXV0aG9yaXplKCksIHBhc3MgaXQgaW4gYXMgYSB0b2tlblBhcmFtOiBhdXRob3JpemUoe2NsaWVudElkOiBcIipcIn0sIGF1dGhPcHRpb25zKScsXG4gICAgICAgIDQwMDEyLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcbiAgICAgIGlmIChlcnIpXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgLyogQWJseS1zZXQ6IG5vIHR5cGVjaGVja2luZywgJyonIGlzIGFsbG93ZWQgYnV0IG5vdCBzZXQgb24gdGhpcy5jbGllbnRJZCksIHJldHVybiBlcnJvcnMgdG8gdGhlIGNhbGxlciAqL1xuICBfdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpIHtcbiAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKGNsaWVudElkKSkge1xuICAgICAgY29uc3QgbXNnID0gXCJVbmV4cGVjdGVkIGNsaWVudElkIG1pc21hdGNoOiBjbGllbnQgaGFzIFwiICsgdGhpcy5jbGllbnRJZCArIFwiLCByZXF1ZXN0ZWQgXCIgKyBjbGllbnRJZDtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckluZm8obXNnLCA0MDEwMiwgNDAxKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKClcIiwgbXNnKTtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xpZW50SWQgPSB0aGlzLnRva2VuUGFyYW1zLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbkNsaWVudElkKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuY2xpZW50SWQgJiYgdGhpcy5jbGllbnRJZCAhPT0gXCIqXCIgJiYgdG9rZW5DbGllbnRJZCAmJiB0b2tlbkNsaWVudElkICE9PSBcIipcIiAmJiB0aGlzLmNsaWVudElkICE9PSB0b2tlbkNsaWVudElkKTtcbiAgfVxuICBzdGF0aWMgaXNUb2tlbkVycihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlICYmIGVycm9yLmNvZGUgPj0gNDAxNDAgJiYgZXJyb3IuY29kZSA8IDQwMTUwO1xuICB9XG4gIHJldm9rZVRva2VucyhzcGVjaWZpZXJzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QucmV2b2tlVG9rZW5zKHNwZWNpZmllcnMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBCYXNlQ2xpZW50LmdldFRpbWVzdGFtcH0gYnV0IGFsc28gdGFrZXMgaW50byBhY2NvdW50IHtAbGluayBBdXRoLmF1dGhPcHRpb25zfVxuICAgKi9cbiAgYXN5bmMgX2dldFRpbWVzdGFtcChxdWVyeVRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZ2V0VGltZXN0YW1wKHF1ZXJ5VGltZSB8fCAhIXRoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lKTtcbiAgfVxufTtcbnZhciBhdXRoX2RlZmF1bHQgPSBBdXRoO1xuXG4vLyBzcmMvY29tbW9uL3R5cGVzL2h0dHAudHNcbmZ1bmN0aW9uIHBhcmFtU3RyaW5nKHBhcmFtcykge1xuICBjb25zdCBwYXJhbVBhaXJzID0gW107XG4gIGlmIChwYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IG5lZWRsZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtUGFpcnMucHVzaChuZWVkbGUgKyBcIj1cIiArIHBhcmFtc1tuZWVkbGVdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtUGFpcnMuam9pbihcIiZcIik7XG59XG5mdW5jdGlvbiBhcHBlbmRpbmdQYXJhbXModXJpLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHVyaSArIChwYXJhbXMgPyBcIj9cIiA6IFwiXCIpICsgcGFyYW1TdHJpbmcocGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGxvZ1Jlc3VsdChyZXN1bHQsIG1ldGhvZCwgdXJpLCBwYXJhbXMsIGxvZ2dlcikge1xuICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiSHR0cC5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQgRXJyb3I7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSArIFwiOyBFcnJvcjogXCIgKyBpbnNwZWN0RXJyb3IocmVzdWx0LmVycm9yKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiSHR0cC5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQ7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSArIFwiOyBIZWFkZXJzOiBcIiArIHBhcmFtU3RyaW5nKHJlc3VsdC5oZWFkZXJzKSArIFwiOyBTdGF0dXNDb2RlOiBcIiArIHJlc3VsdC5zdGF0dXNDb2RlICsgXCI7IEJvZHlcIiArIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihyZXN1bHQuYm9keSkgPyBcIiAoQmFzZTY0KTogXCIgKyBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUocmVzdWx0LmJvZHkpIDogXCI6IFwiICsgcmVzdWx0LmJvZHkpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbG9nUmVxdWVzdChtZXRob2QsIHVyaSwgYm9keSwgcGFyYW1zLCBsb2dnZXIpIHtcbiAgaWYgKGxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkh0dHAuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlNlbmRpbmc7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSArIFwiOyBCb2R5XCIgKyAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkgPyBcIiAoQmFzZTY0KTogXCIgKyBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoYm9keSkgOiBcIjogXCIgKyBib2R5KVxuICAgICk7XG4gIH1cbn1cbnZhciBIdHRwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnBsYXRmb3JtSHR0cCA9IG5ldyBQbGF0Zm9ybS5IdHRwKGNsaWVudCk7XG4gICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IHRoaXMucGxhdGZvcm1IdHRwLmNoZWNrQ29ubmVjdGl2aXR5ID8gKCkgPT4gdGhpcy5wbGF0Zm9ybUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKSA6IHZvaWQgMDtcbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EyID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9nZ2VyKSAhPSBudWxsID8gX2IgOiBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyO1xuICB9XG4gIGdldCBzdXBwb3J0c0F1dGhIZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXRmb3JtSHR0cC5zdXBwb3J0c0F1dGhIZWFkZXJzO1xuICB9XG4gIGdldCBzdXBwb3J0c0xpbmtIZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXRmb3JtSHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzO1xuICB9XG4gIF9nZXRIb3N0cyhjbGllbnQpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gY2xpZW50LmNvbm5lY3Rpb24sIGNvbm5lY3Rpb25Ib3N0ID0gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmhvc3Q7XG4gICAgaWYgKGNvbm5lY3Rpb25Ib3N0KSB7XG4gICAgICByZXR1cm4gW2Nvbm5lY3Rpb25Ib3N0XS5jb25jYXQoZGVmYXVsdHNfZGVmYXVsdC5nZXRGYWxsYmFja0hvc3RzKGNsaWVudC5vcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0c19kZWZhdWx0LmdldEhvc3RzKGNsaWVudC5vcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBub3QgdGhyb3cgYW55IGVycm9yczsgcmF0aGVyLCBpdCB3aWxsIGNvbW11bmljYXRlIGFueSBlcnJvciBieSBwb3B1bGF0aW5nIHRoZSB7QGxpbmsgUmVxdWVzdFJlc3VsdC5lcnJvcn0gcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIHtAbGluayBSZXF1ZXN0UmVzdWx0fS5cbiAgICovXG4gIGFzeW5jIGRvKG1ldGhvZCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBFcnJvckluZm8oXCJodHRwLmRvIGNhbGxlZCB3aXRob3V0IGNsaWVudFwiLCA1ZTQsIDUwMCkgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVyaUZyb21Ib3N0ID0gdHlwZW9mIHBhdGggPT09IFwiZnVuY3Rpb25cIiA/IHBhdGggOiBmdW5jdGlvbihob3N0KSB7XG4gICAgICAgIHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7XG4gICAgICB9O1xuICAgICAgY29uc3QgY3VycmVudEZhbGxiYWNrID0gY2xpZW50Ll9jdXJyZW50RmFsbGJhY2s7XG4gICAgICBpZiAoY3VycmVudEZhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjdXJyZW50RmFsbGJhY2sudmFsaWRVbnRpbCA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRvVXJpKG1ldGhvZCwgdXJpRnJvbUhvc3QoY3VycmVudEZhbGxiYWNrLmhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IgJiYgdGhpcy5wbGF0Zm9ybUh0dHAuc2hvdWxkRmFsbGJhY2socmVzdWx0LmVycm9yKSkge1xuICAgICAgICAgICAgY2xpZW50Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG8obWV0aG9kLCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWVudC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaG9zdHMgPSB0aGlzLl9nZXRIb3N0cyhjbGllbnQpO1xuICAgICAgaWYgKGhvc3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb1VyaShtZXRob2QsIHVyaUZyb21Ib3N0KGhvc3RzWzBdKSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIGxldCB0cnlBSG9zdFN0YXJ0ZWRBdCA9IG51bGw7XG4gICAgICBjb25zdCB0cnlBSG9zdCA9IGFzeW5jIChjYW5kaWRhdGVIb3N0cywgcGVyc2lzdE9uU3VjY2VzcykgPT4ge1xuICAgICAgICBjb25zdCBob3N0ID0gY2FuZGlkYXRlSG9zdHMuc2hpZnQoKTtcbiAgICAgICAgdHJ5QUhvc3RTdGFydGVkQXQgPSB0cnlBSG9zdFN0YXJ0ZWRBdCAhPSBudWxsID8gdHJ5QUhvc3RTdGFydGVkQXQgOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kb1VyaShtZXRob2QsIHVyaUZyb21Ib3N0KGhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yICYmIHRoaXMucGxhdGZvcm1IdHRwLnNob3VsZEZhbGxiYWNrKHJlc3VsdC5lcnJvcikgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gdHJ5QUhvc3RTdGFydGVkQXQuZ2V0VGltZSgpO1xuICAgICAgICAgIGlmIChlbGFwc2VkVGltZSA+IGNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmh0dHBNYXhSZXRyeUR1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBgVGltZW91dCBmb3IgdHJ5aW5nIGZhbGxiYWNrIGhvc3RzIHJldHJpZXMuIFRvdGFsIGVsYXBzZWQgdGltZSBleGNlZWRlZCB0aGUgJHtjbGllbnQub3B0aW9ucy50aW1lb3V0cy5odHRwTWF4UmV0cnlEdXJhdGlvbn1tcyBsaW1pdGAsXG4gICAgICAgICAgICAgICAgNTAwMDMsXG4gICAgICAgICAgICAgICAgNTAwXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnlBSG9zdChjYW5kaWRhdGVIb3N0cywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcnNpc3RPblN1Y2Nlc3MpIHtcbiAgICAgICAgICBjbGllbnQuX2N1cnJlbnRGYWxsYmFjayA9IHtcbiAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICB2YWxpZFVudGlsOiBEYXRlLm5vdygpICsgY2xpZW50Lm9wdGlvbnMudGltZW91dHMuZmFsbGJhY2tSZXRyeVRpbWVvdXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyeUFIb3N0KGhvc3RzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgRXJyb3JJbmZvKGBVbmV4cGVjdGVkIGVycm9yIGluIEh0dHAuZG86ICR7aW5zcGVjdEVycm9yKGVycil9YCwgNTAwLCA1ZTQpIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIG5vdCB0aHJvdyBhbnkgZXJyb3JzOyByYXRoZXIsIGl0IHdpbGwgY29tbXVuaWNhdGUgYW55IGVycm9yIGJ5IHBvcHVsYXRpbmcgdGhlIHtAbGluayBSZXF1ZXN0UmVzdWx0LmVycm9yfSBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQge0BsaW5rIFJlcXVlc3RSZXN1bHR9LlxuICAgKi9cbiAgYXN5bmMgZG9VcmkobWV0aG9kLCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBsb2dSZXF1ZXN0KG1ldGhvZCwgdXJpLCBib2R5LCBwYXJhbXMsIHRoaXMubG9nZ2VyKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGxhdGZvcm1IdHRwLmRvVXJpKG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgIGxvZ1Jlc3VsdChyZXN1bHQsIG1ldGhvZCwgdXJpLCBwYXJhbXMsIHRoaXMubG9nZ2VyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogbmV3IEVycm9ySW5mbyhgVW5leHBlY3RlZCBlcnJvciBpbiBIdHRwLmRvVXJpOiAke2luc3BlY3RFcnJvcihlcnIpfWAsIDUwMCwgNWU0KSB9O1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9ldmVudGVtaXR0ZXIudHNcbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsb2dnZXIsIGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICBsaXN0ZW5lci5hcHBseShldmVudFRoaXMsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJFdmVudEVtaXR0ZXIuZW1pdCgpXCIsXG4gICAgICBcIlVuZXhwZWN0ZWQgbGlzdGVuZXIgZXhjZXB0aW9uOiBcIiArIGUgKyBcIjsgc3RhY2sgPSBcIiArIChlICYmIGUuc3RhY2spXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodGFyZ2V0TGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnRGaWx0ZXIpIHtcbiAgbGV0IGxpc3RlbmVycztcbiAgbGV0IGluZGV4O1xuICBsZXQgZXZlbnROYW1lO1xuICBmb3IgKGxldCB0YXJnZXRMaXN0ZW5lcnNJbmRleCA9IDA7IHRhcmdldExpc3RlbmVyc0luZGV4IDwgdGFyZ2V0TGlzdGVuZXJzLmxlbmd0aDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXgrKykge1xuICAgIGxpc3RlbmVycyA9IHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF07XG4gICAgaWYgKGV2ZW50RmlsdGVyKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbZXZlbnRGaWx0ZXJdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICB3aGlsZSAoKGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRGaWx0ZXIgJiYgbGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0TGlzdGVuZXJzW3RhcmdldExpc3RlbmVyc0luZGV4XVtldmVudEZpbHRlcl07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0ZW5lcnMpKSB7XG4gICAgICBmb3IgKGV2ZW50TmFtZSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsaXN0ZW5lcnMsIGV2ZW50TmFtZSkgJiYgQXJyYXkuaXNBcnJheShsaXN0ZW5lcnNbZXZlbnROYW1lXSkpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcihbbGlzdGVuZXJzXSwgbGlzdGVuZXIsIGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBFdmVudEVtaXR0ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuYW55ID0gW107XG4gICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICB0aGlzLmV2ZW50c09uY2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBvbiguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGFyZ3NbMF07XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5hbnkucHVzaChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBbZXZlbnQsIGxpc3RlbmVyXSA9IGFyZ3M7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOaWwoZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBldmVudC5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgKHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtdKTtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvZmYoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAwIHx8IGlzTmlsKGFyZ3NbMF0pICYmIGlzTmlsKGFyZ3NbMV0pKSB7XG4gICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgICAgdGhpcy5ldmVudHNPbmNlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IGFyZ3M7XG4gICAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgICBsZXQgZXZlbnQgPSBudWxsO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSB8fCAhc2Vjb25kQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBmaXJzdEFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZmlyc3RBcmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czpcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICAgIFtldmVudCwgbGlzdGVuZXJdID0gW2ZpcnN0QXJnLCBzZWNvbmRBcmddO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXIgJiYgaXNOaWwoZXZlbnQpKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5hbnksIHRoaXMuZXZlbnRzLCB0aGlzLmFueU9uY2UsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBldmVudC5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBldmVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czpcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5ldmVudHMsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyLCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF07XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50OyBleGNsdWRlcyBvbmNlIGV2ZW50c1xuICAgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQsIG9yIG5vbmUgZm9yICdhbnknXG4gICAqIEByZXR1cm4gYXJyYXkgb2YgZXZlbnRzLCBvciBudWxsIGlmIG5vbmVcbiAgICovXG4gIGxpc3RlbmVycyhldmVudCkge1xuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgaWYgKHRoaXMuZXZlbnRzT25jZVtldmVudF0pXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5ldmVudHNPbmNlW2V2ZW50XSk7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aCA/IGxpc3RlbmVycyA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFueS5sZW5ndGggPyB0aGlzLmFueSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgYW4gZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAgICovXG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBldmVudFRoaXMgPSB7IGV2ZW50IH07XG4gICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgaWYgKHRoaXMuYW55T25jZS5sZW5ndGgpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnlPbmNlKTtcbiAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbnkubGVuZ3RoKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55KTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzT25jZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgaWYgKGV2ZW50c09uY2VMaXN0ZW5lcnMpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzT25jZUxpc3RlbmVycyk7XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzTGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgIGlmIChldmVudHNMaXN0ZW5lcnMpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzTGlzdGVuZXJzKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBjYWxsTGlzdGVuZXIodGhpcy5sb2dnZXIsIGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG4gIG9uY2UoLi4uYXJncykge1xuICAgIGNvbnN0IGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGFyZ0NvdW50ID09PSAwIHx8IGFyZ0NvdW50ID09PSAxICYmIHR5cGVvZiBhcmdzWzBdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLm9uY2UoZXZlbnQsIHJlc29sdmUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IGFyZ3M7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLmFueU9uY2UucHVzaChmaXJzdEFyZyk7XG4gICAgfSBlbHNlIGlmIChpc05pbChmaXJzdEFyZykpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFueU9uY2UucHVzaChzZWNvbmRBcmcpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdEFyZykpIHtcbiAgICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICAgIGNvbnN0IGxpc3RlbmVyV3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBpbm5lckFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBmaXJzdEFyZy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHNlbGYyLm9mZihldmVudE5hbWUsIGxpc3RlbmVyV3JhcHBlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vjb25kQXJnLmFwcGx5KHRoaXMsIGlubmVyQXJncyk7XG4gICAgICB9O1xuICAgICAgZmlyc3RBcmcuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgc2VsZjIub24oZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddIHx8ICh0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddID0gW10pO1xuICAgICAgaWYgKHNlY29uZEFyZykge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXJzLnB1c2goc2Vjb25kQXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgYSBzaW5nbGUgb2NjdXJyZW5jZSBvZiBhIHN0YXRlIGV2ZW50IGFuZCBmaXJlIGltbWVkaWF0ZWx5IGlmIGN1cnJlbnRTdGF0ZSBtYXRjaGVzIHRhcmdldFN0YXRlXG4gICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gICAqIEBwYXJhbSBjdXJyZW50U3RhdGUgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBvYmplY3RcbiAgICovXG4gIGFzeW5jIHdoZW5TdGF0ZSh0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRTdGF0ZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY3VycmVudFN0YXRlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3aGVuU3RhdGUgcmVxdWlyZXMgYSB2YWxpZCBzdGF0ZSBTdHJpbmcgYXJndW1lbnRcIik7XG4gICAgfVxuICAgIGlmICh0YXJnZXRTdGF0ZSA9PT0gY3VycmVudFN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub25jZSh0YXJnZXRTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xudmFyIGV2ZW50ZW1pdHRlcl9kZWZhdWx0ID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wcm90b2NvbG1lc3NhZ2Vjb21tb24udHNcbnZhciBhY3Rpb25zID0ge1xuICBIRUFSVEJFQVQ6IDAsXG4gIEFDSzogMSxcbiAgTkFDSzogMixcbiAgQ09OTkVDVDogMyxcbiAgQ09OTkVDVEVEOiA0LFxuICBESVNDT05ORUNUOiA1LFxuICBESVNDT05ORUNURUQ6IDYsXG4gIENMT1NFOiA3LFxuICBDTE9TRUQ6IDgsXG4gIEVSUk9SOiA5LFxuICBBVFRBQ0g6IDEwLFxuICBBVFRBQ0hFRDogMTEsXG4gIERFVEFDSDogMTIsXG4gIERFVEFDSEVEOiAxMyxcbiAgUFJFU0VOQ0U6IDE0LFxuICBNRVNTQUdFOiAxNSxcbiAgU1lOQzogMTYsXG4gIEFVVEg6IDE3LFxuICBBQ1RJVkFURTogMTgsXG4gIE9CSkVDVDogMTksXG4gIE9CSkVDVF9TWU5DOiAyMCxcbiAgQU5OT1RBVElPTjogMjFcbn07XG52YXIgQWN0aW9uTmFtZSA9IFtdO1xuT2JqZWN0LmtleXMoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIEFjdGlvbk5hbWVbYWN0aW9uc1tuYW1lXV0gPSBuYW1lO1xufSk7XG52YXIgZmxhZ3MgPSB7XG4gIC8qIENoYW5uZWwgYXR0YWNoIHN0YXRlIGZsYWdzICovXG4gIEhBU19QUkVTRU5DRTogMSA8PCAwLFxuICBIQVNfQkFDS0xPRzogMSA8PCAxLFxuICBSRVNVTUVEOiAxIDw8IDIsXG4gIFRSQU5TSUVOVDogMSA8PCA0LFxuICBBVFRBQ0hfUkVTVU1FOiAxIDw8IDUsXG4gIEhBU19PQkpFQ1RTOiAxIDw8IDcsXG4gIC8qIENoYW5uZWwgbW9kZSBmbGFncyAqL1xuICBQUkVTRU5DRTogMSA8PCAxNixcbiAgUFVCTElTSDogMSA8PCAxNyxcbiAgU1VCU0NSSUJFOiAxIDw8IDE4LFxuICBQUkVTRU5DRV9TVUJTQ1JJQkU6IDEgPDwgMTksXG4gIEFOTk9UQVRJT05fUFVCTElTSDogMSA8PCAyMSxcbiAgQU5OT1RBVElPTl9TVUJTQ1JJQkU6IDEgPDwgMjIsXG4gIE9CSkVDVF9TVUJTQ1JJQkU6IDEgPDwgMjQsXG4gIE9CSkVDVF9QVUJMSVNIOiAxIDw8IDI1XG59O1xudmFyIGZsYWdOYW1lcyA9IE9iamVjdC5rZXlzKGZsYWdzKTtcbmZsYWdzLk1PREVfQUxMID0gZmxhZ3MuUFJFU0VOQ0UgfCBmbGFncy5QVUJMSVNIIHwgZmxhZ3MuU1VCU0NSSUJFIHwgZmxhZ3MuUFJFU0VOQ0VfU1VCU0NSSUJFIHwgZmxhZ3MuQU5OT1RBVElPTl9QVUJMSVNIIHwgZmxhZ3MuQU5OT1RBVElPTl9TVUJTQ1JJQkUgfCBmbGFncy5PQkpFQ1RfU1VCU0NSSUJFIHwgZmxhZ3MuT0JKRUNUX1BVQkxJU0g7XG52YXIgY2hhbm5lbE1vZGVzID0gW1xuICBcIlBSRVNFTkNFXCIsXG4gIFwiUFVCTElTSFwiLFxuICBcIlNVQlNDUklCRVwiLFxuICBcIlBSRVNFTkNFX1NVQlNDUklCRVwiLFxuICBcIkFOTk9UQVRJT05fUFVCTElTSFwiLFxuICBcIkFOTk9UQVRJT05fU1VCU0NSSUJFXCIsXG4gIFwiT0JKRUNUX1NVQlNDUklCRVwiLFxuICBcIk9CSkVDVF9QVUJMSVNIXCJcbl07XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2Jhc2VtZXNzYWdlLnRzXG5mdW5jdGlvbiBub3JtYWxpc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgaWYgKCFjb250ZXh0IHx8ICFjb250ZXh0LmNoYW5uZWxPcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5uZWxPcHRpb25zOiBjb250ZXh0LFxuICAgICAgcGx1Z2luczoge30sXG4gICAgICBiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMoQ3J5cHRvMiwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2lwaGVyKSB7XG4gICAgaWYgKCFDcnlwdG8yKVxuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJDcnlwdG9cIik7XG4gICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvMi5nZXRDaXBoZXIob3B0aW9ucy5jaXBoZXIsIGxvZ2dlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpcGhlcjogY2lwaGVyLmNpcGhlclBhcmFtcyxcbiAgICAgIGNoYW5uZWxDaXBoZXI6IGNpcGhlci5jaXBoZXJcbiAgICB9O1xuICB9XG4gIHJldHVybiBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG59XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KG1zZywgY2lwaGVyT3B0aW9ucykge1xuICBjb25zdCB7IGRhdGEsIGVuY29kaW5nIH0gPSBhd2FpdCBlbmNyeXB0RGF0YShtc2cuZGF0YSwgbXNnLmVuY29kaW5nLCBjaXBoZXJPcHRpb25zKTtcbiAgbXNnLmRhdGEgPSBkYXRhO1xuICBtc2cuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIG1zZztcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHREYXRhKGRhdGEsIGVuY29kaW5nLCBjaXBoZXJPcHRpb25zKSB7XG4gIGxldCBjaXBoZXIgPSBjaXBoZXJPcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gIGxldCBkYXRhVG9FbmNyeXB0ID0gZGF0YTtcbiAgbGV0IGZpbmFsRW5jb2RpbmcgPSBlbmNvZGluZyA/IGVuY29kaW5nICsgXCIvXCIgOiBcIlwiO1xuICBpZiAoIVBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGFUb0VuY3J5cHQpKSB7XG4gICAgZGF0YVRvRW5jcnlwdCA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoU3RyaW5nKGRhdGFUb0VuY3J5cHQpKTtcbiAgICBmaW5hbEVuY29kaW5nID0gZmluYWxFbmNvZGluZyArIFwidXRmLTgvXCI7XG4gIH1cbiAgY29uc3QgY2lwaGVydGV4dCA9IGF3YWl0IGNpcGhlci5lbmNyeXB0KGRhdGFUb0VuY3J5cHQpO1xuICBmaW5hbEVuY29kaW5nID0gZmluYWxFbmNvZGluZyArIFwiY2lwaGVyK1wiICsgY2lwaGVyLmFsZ29yaXRobTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBjaXBoZXJ0ZXh0LFxuICAgIGVuY29kaW5nOiBmaW5hbEVuY29kaW5nXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBlbmNvZGUobXNnLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZGF0YSwgZW5jb2RpbmcgfSA9IGVuY29kZURhdGEobXNnLmRhdGEsIG1zZy5lbmNvZGluZyk7XG4gIG1zZy5kYXRhID0gZGF0YTtcbiAgbXNnLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5jaXBoZXIpIHtcbiAgICByZXR1cm4gZW5jcnlwdChtc2csIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtc2c7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZURhdGEoZGF0YSwgZW5jb2RpbmcpIHtcbiAgY29uc3QgbmF0aXZlRGF0YVR5cGUgPSB0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiIHx8IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwO1xuICBpZiAobmF0aXZlRGF0YVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGVuY29kaW5nXG4gICAgfTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YSkgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyA/IGVuY29kaW5nICsgXCIvanNvblwiIDogXCJqc29uXCJcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvckluZm8oXCJEYXRhIHR5cGUgaXMgdW5zdXBwb3J0ZWRcIiwgNDAwMTMsIDQwMCk7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNvZGUobWVzc2FnZSwgaW5wdXRDb250ZXh0KSB7XG4gIGNvbnN0IHsgZGF0YSwgZW5jb2RpbmcsIGVycm9yIH0gPSBhd2FpdCBkZWNvZGVEYXRhKG1lc3NhZ2UuZGF0YSwgbWVzc2FnZS5lbmNvZGluZywgaW5wdXRDb250ZXh0KTtcbiAgbWVzc2FnZS5kYXRhID0gZGF0YTtcbiAgbWVzc2FnZS5lbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlRGF0YShkYXRhLCBlbmNvZGluZywgaW5wdXRDb250ZXh0KSB7XG4gIGNvbnN0IGNvbnRleHQgPSBub3JtYWxpc2VDb250ZXh0KGlucHV0Q29udGV4dCk7XG4gIGxldCBsYXN0UGF5bG9hZCA9IGRhdGE7XG4gIGxldCBkZWNvZGVkRGF0YSA9IGRhdGE7XG4gIGxldCBmaW5hbEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGxldCBkZWNvZGluZ0Vycm9yO1xuICBpZiAoZW5jb2RpbmcpIHtcbiAgICBjb25zdCB4Zm9ybXMgPSBlbmNvZGluZy5zcGxpdChcIi9cIik7XG4gICAgbGV0IGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4O1xuICAgIGxldCBlbmNvZGluZ3NUb1Byb2Nlc3MgPSB4Zm9ybXMubGVuZ3RoO1xuICAgIGxldCB4Zm9ybSA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICgobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPSBlbmNvZGluZ3NUb1Byb2Nlc3MpID4gMCkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHhmb3Jtc1stLWVuY29kaW5nc1RvUHJvY2Vzc10ubWF0Y2goLyhbLVxcd10rKShcXCsoW1xcdy1dKykpPy8pO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB4Zm9ybSA9IG1hdGNoWzFdO1xuICAgICAgICBzd2l0Y2ggKHhmb3JtKSB7XG4gICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjREZWNvZGUoU3RyaW5nKGRlY29kZWREYXRhKSk7XG4gICAgICAgICAgICBpZiAobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPT0geGZvcm1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICBsYXN0UGF5bG9hZCA9IGRlY29kZWREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgICAgICBkZWNvZGVkRGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhEZWNvZGUoZGVjb2RlZERhdGEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgIGRlY29kZWREYXRhID0gSlNPTi5wYXJzZShkZWNvZGVkRGF0YSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiY2lwaGVyXCI6XG4gICAgICAgICAgICBpZiAoY29udGV4dC5jaGFubmVsT3B0aW9ucyAhPSBudWxsICYmIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2lwaGVyICYmIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcikge1xuICAgICAgICAgICAgICBjb25zdCB4Zm9ybUFsZ29yaXRobSA9IG1hdGNoWzNdLCBjaXBoZXIgPSBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gICAgICAgICAgICAgIGlmICh4Zm9ybUFsZ29yaXRobSAhPSBjaXBoZXIuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZSB3aXRoIGdpdmVuIGNpcGhlcjsgaW5jb21wYXRpYmxlIGNpcGhlciBwYXJhbXNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBhd2FpdCBjaXBoZXIuZGVjcnlwdChkZWNvZGVkRGF0YSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZTsgbm90IGFuIGVuY3J5cHRlZCBjaGFubmVsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ2Y2RpZmZcIjpcbiAgICAgICAgICAgIGlmICghY29udGV4dC5wbHVnaW5zIHx8ICFjb250ZXh0LnBsdWdpbnMudmNkaWZmKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJNaXNzaW5nIFZjZGlmZiBkZWNvZGVyIChodHRwczovL2dpdGh1Yi5jb20vYWJseS1mb3Jrcy92Y2RpZmYtZGVjb2RlcilcIiwgNDAwMTksIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcIkRlbHRhIGRlY29kaW5nIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyIChuZWVkIEFycmF5QnVmZmVyICYgVWludDhBcnJheSlcIixcbiAgICAgICAgICAgICAgICA0MDAyMCxcbiAgICAgICAgICAgICAgICA0MDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxldCBkZWx0YUJhc2UgPSBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlbHRhQmFzZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGRlbHRhQmFzZSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkZWx0YUJhc2VCdWZmZXIgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy50b0J1ZmZlcihkZWx0YUJhc2UpO1xuICAgICAgICAgICAgICBkZWNvZGVkRGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRlY29kZWREYXRhKTtcbiAgICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy5hcnJheUJ1ZmZlclZpZXdUb0J1ZmZlcihcbiAgICAgICAgICAgICAgICBjb250ZXh0LnBsdWdpbnMudmNkaWZmLmRlY29kZShkZWNvZGVkRGF0YSwgZGVsdGFCYXNlQnVmZmVyKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsYXN0UGF5bG9hZCA9IGRlY29kZWREYXRhO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVmNkaWZmIGRlbHRhIGRlY29kZSBmYWlsZWQgd2l0aCBcIiArIGUsIDQwMDE4LCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgZGVjb2RpbmdFcnJvciA9IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGBFcnJvciBwcm9jZXNzaW5nIHRoZSAke3hmb3JtfSBlbmNvZGluZywgZGVjb2RlciByZXR1cm5lZCBcXHUyMDE4JHtlcnIubWVzc2FnZX1cXHUyMDE5YCxcbiAgICAgICAgZXJyLmNvZGUgfHwgNDAwMTMsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZmluYWxFbmNvZGluZyA9IGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4IDw9IDAgPyBudWxsIDogeGZvcm1zLnNsaWNlKDAsIGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4KS5qb2luKFwiL1wiKTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlY29kaW5nRXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGRlY29kaW5nRXJyb3IsXG4gICAgICBkYXRhOiBkZWNvZGVkRGF0YSxcbiAgICAgIGVuY29kaW5nOiBmaW5hbEVuY29kaW5nXG4gICAgfTtcbiAgfVxuICBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkID0gbGFzdFBheWxvYWQ7XG4gIHJldHVybiB7XG4gICAgZGF0YTogZGVjb2RlZERhdGEsXG4gICAgZW5jb2Rpbmc6IGZpbmFsRW5jb2RpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHdpcmVUb0pTT04oLi4uYXJncykge1xuICBjb25zdCBmb3JtYXQgPSBhcmdzLmxlbmd0aCA+IDAgPyBcImpzb25cIiAvKiBqc29uICovIDogXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLztcbiAgY29uc3QgeyBkYXRhLCBlbmNvZGluZyB9ID0gZW5jb2RlRGF0YUZvcldpcmUodGhpcy5kYXRhLCB0aGlzLmVuY29kaW5nLCBmb3JtYXQpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgeyBlbmNvZGluZywgZGF0YSB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZURhdGFGb3JXaXJlKGRhdGEsIGVuY29kaW5nLCBmb3JtYXQpIHtcbiAgaWYgKCFkYXRhIHx8ICFQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZW5jb2RpbmdcbiAgICB9O1xuICB9XG4gIGlmIChmb3JtYXQgPT09IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogUGxhdGZvcm0uQnVmZmVyVXRpbHMudG9CdWZmZXIoZGF0YSksXG4gICAgICBlbmNvZGluZ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoZGF0YSksXG4gICAgZW5jb2Rpbmc6IGVuY29kaW5nID8gZW5jb2RpbmcgKyBcIi9iYXNlNjRcIiA6IFwiYmFzZTY0XCJcbiAgfTtcbn1cbnZhciBNZXNzYWdlRW5jb2RpbmcgPSB7XG4gIGVuY3J5cHREYXRhLFxuICBlbmNvZGVEYXRhLFxuICBlbmNvZGVEYXRhRm9yV2lyZSxcbiAgZGVjb2RlRGF0YVxufTtcbmZ1bmN0aW9uIHBvcHVsYXRlRmllbGRzRnJvbVBhcmVudChwYXJlbnQpIHtcbiAgY29uc3QgeyBpZCwgY29ubmVjdGlvbklkLCB0aW1lc3RhbXAgfSA9IHBhcmVudDtcbiAgbGV0IG1zZ3M7XG4gIHN3aXRjaCAocGFyZW50LmFjdGlvbikge1xuICAgIGNhc2UgYWN0aW9ucy5NRVNTQUdFOiB7XG4gICAgICBtc2dzID0gcGFyZW50Lm1lc3NhZ2VzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgYWN0aW9ucy5QUkVTRU5DRTpcbiAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgIG1zZ3MgPSBwYXJlbnQucHJlc2VuY2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFjdGlvbnMuQU5OT1RBVElPTjpcbiAgICAgIG1zZ3MgPSBwYXJlbnQuYW5ub3RhdGlvbnM7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFjdGlvbnMuT0JKRUNUOlxuICAgIGNhc2UgYWN0aW9ucy5PQkpFQ1RfU1lOQzpcbiAgICAgIG1zZ3MgPSBwYXJlbnQuc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuZXhwZWN0ZWQgYWN0aW9uIFwiICsgcGFyZW50LmFjdGlvbiwgNGU0LCA0MDApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbXNncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1zZyA9IG1zZ3NbaV07XG4gICAgaWYgKCFtc2cuY29ubmVjdGlvbklkKSB7XG4gICAgICBtc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgIH1cbiAgICBpZiAoIW1zZy50aW1lc3RhbXApIHtcbiAgICAgIG1zZy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgfVxuICAgIGlmIChpZCAmJiAhbXNnLmlkKSB7XG4gICAgICBtc2cuaWQgPSBpZCArIFwiOlwiICsgaTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN0ck1zZyhtLCBjbHMpIHtcbiAgbGV0IHJlc3VsdCA9IFwiW1wiICsgY2xzO1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gbSkge1xuICAgIGlmIChhdHRyID09PSBcImRhdGFcIikge1xuICAgICAgaWYgKHR5cGVvZiBtLmRhdGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQgKz0gXCI7IGRhdGE9XCIgKyBtLmRhdGE7XG4gICAgICB9IGVsc2UgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKG0uZGF0YSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhIChidWZmZXIpPVwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKG0uZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtLmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhIChqc29uKT1cIiArIEpTT04uc3RyaW5naWZ5KG0uZGF0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyICYmIChhdHRyID09PSBcImV4dHJhc1wiIHx8IGF0dHIgPT09IFwib3BlcmF0aW9uXCIpKSB7XG4gICAgICByZXN1bHQgKz0gXCI7IFwiICsgYXR0ciArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkobVthdHRyXSk7XG4gICAgfSBlbHNlIGlmIChhdHRyID09PSBcInZlcnNpb25cIikge1xuICAgICAgcmVzdWx0ICs9IFwiOyB2ZXJzaW9uPVwiICsgSlNPTi5zdHJpbmdpZnkobVthdHRyXSk7XG4gICAgfSBlbHNlIGlmIChhdHRyID09PSBcImFubm90YXRpb25zXCIpIHtcbiAgICAgIHJlc3VsdCArPSBcIjsgYW5ub3RhdGlvbnM9XCIgKyBKU09OLnN0cmluZ2lmeShtW2F0dHJdKTtcbiAgICB9IGVsc2UgaWYgKG1bYXR0cl0gIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0ICs9IFwiOyBcIiArIGF0dHIgKyBcIj1cIiArIG1bYXR0cl07XG4gICAgfVxuICB9XG4gIHJlc3VsdCArPSBcIl1cIjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBCYXNlTWVzc2FnZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9iYXNlY2xpZW50LnRzXG52YXIgQmFzZUNsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIFRoZXNlIGV4cG9ydHMgYXJlIGZvciB1c2UgYnkgVU1EIHBsdWdpbnM7IHJlYXNvbiBiZWluZyBzbyB0aGF0IGNvbnN0cnVjdG9ycyBhbmQgc3RhdGljIG1ldGhvZHMgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRoZXNlIHBsdWdpbnMgd2l0aG91dCBuZWVkaW5nIHRvIGltcG9ydCB0aGUgY2xhc3NlcyBkaXJlY3RseSBhbmQgcmVzdWx0IGluIHRoZSBjbGFzcyBleGlzdGluZyBpbiBib3RoIHRoZSBwbHVnaW4gYW5kIHRoZSBjb3JlIGxpYnJhcnkuXG4gICAgICovXG4gICAgdGhpcy5QbGF0Zm9ybSA9IFBsYXRmb3JtO1xuICAgIHRoaXMuRXJyb3JJbmZvID0gRXJyb3JJbmZvO1xuICAgIHRoaXMuTG9nZ2VyID0gbG9nZ2VyX2RlZmF1bHQ7XG4gICAgdGhpcy5EZWZhdWx0cyA9IGRlZmF1bHRzX2RlZmF1bHQ7XG4gICAgdGhpcy5VdGlscyA9IHV0aWxzX2V4cG9ydHM7XG4gICAgdGhpcy5FdmVudEVtaXR0ZXIgPSBldmVudGVtaXR0ZXJfZGVmYXVsdDtcbiAgICB0aGlzLk1lc3NhZ2VFbmNvZGluZyA9IE1lc3NhZ2VFbmNvZGluZztcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qO1xuICAgIHRoaXMuX2FkZGl0aW9uYWxIVFRQUmVxdWVzdEltcGxlbWVudGF0aW9ucyA9IChfYTIgPSBvcHRpb25zLnBsdWdpbnMpICE9IG51bGwgPyBfYTIgOiBudWxsO1xuICAgIHRoaXMubG9nZ2VyID0gbmV3IGxvZ2dlcl9kZWZhdWx0KCk7XG4gICAgdGhpcy5sb2dnZXIuc2V0TG9nKG9wdGlvbnMubG9nTGV2ZWwsIG9wdGlvbnMubG9nSGFuZGxlcik7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkJhc2VDbGllbnQoKVwiLFxuICAgICAgXCJpbml0aWFsaXplZCB3aXRoIGNsaWVudE9wdGlvbnMgXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChvcHRpb25zKVxuICAgICk7XG4gICAgdGhpcy5fTXNnUGFjayA9IChfYyA9IChfYiA9IG9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLk1zZ1BhY2spICE9IG51bGwgPyBfYyA6IG51bGw7XG4gICAgY29uc3Qgbm9ybWFsT3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IGRlZmF1bHRzX2RlZmF1bHQubm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zLCB0aGlzLl9Nc2dQYWNrLCB0aGlzLmxvZ2dlcik7XG4gICAgaWYgKG5vcm1hbE9wdGlvbnMua2V5KSB7XG4gICAgICBjb25zdCBrZXlNYXRjaCA9IG5vcm1hbE9wdGlvbnMua2V5Lm1hdGNoKC9eKFteOlxcc10rKTooW146Llxcc10rKSQvKTtcbiAgICAgIGlmICgha2V5TWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbXNnID0gXCJpbnZhbGlkIGtleSBwYXJhbWV0ZXJcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQmFzZUNsaWVudCgpXCIsIG1zZyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8obXNnLCA0MDQwMCwgNDA0KTtcbiAgICAgIH1cbiAgICAgIG5vcm1hbE9wdGlvbnMua2V5TmFtZSA9IGtleU1hdGNoWzFdO1xuICAgICAgbm9ybWFsT3B0aW9ucy5rZXlTZWNyZXQgPSBrZXlNYXRjaFsyXTtcbiAgICB9XG4gICAgaWYgKFwiY2xpZW50SWRcIiBpbiBub3JtYWxPcHRpb25zKSB7XG4gICAgICBpZiAoISh0eXBlb2Ygbm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gXCJzdHJpbmdcIiB8fCBub3JtYWxPcHRpb25zLmNsaWVudElkID09PSBudWxsKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGxcIiwgNDAwMTIsIDQwMCk7XG4gICAgICBlbHNlIGlmIChub3JtYWxPcHRpb25zLmNsaWVudElkID09PSBcIipcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAnQ2FuXFx1MjAxOXQgdXNlIFwiKlwiIGFzIGEgY2xpZW50SWQgYXMgdGhhdCBzdHJpbmcgaXMgcmVzZXJ2ZWQuIChUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgdG9rZW4gcmVxdWVzdCBiZWhhdmlvdXIgdG8gdXNlIGEgd2lsZGNhcmQgY2xpZW50SWQsIHVzZSB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pJyxcbiAgICAgICAgICA0MDAxMixcbiAgICAgICAgICA0MDBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQmFzZUNsaWVudCgpXCIsIFwic3RhcnRlZDsgdmVyc2lvbiA9IFwiICsgZGVmYXVsdHNfZGVmYXVsdC52ZXJzaW9uKTtcbiAgICB0aGlzLl9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuc2VydmVyVGltZU9mZnNldCA9IG51bGw7XG4gICAgdGhpcy5odHRwID0gbmV3IEh0dHAodGhpcyk7XG4gICAgdGhpcy5hdXRoID0gbmV3IGF1dGhfZGVmYXVsdCh0aGlzLCBub3JtYWxPcHRpb25zKTtcbiAgICB0aGlzLl9yZXN0ID0gKChfZCA9IG9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLlJlc3QpID8gbmV3IG9wdGlvbnMucGx1Z2lucy5SZXN0KHRoaXMpIDogbnVsbDtcbiAgICB0aGlzLl9DcnlwdG8gPSAoX2YgPSAoX2UgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5DcnlwdG8pICE9IG51bGwgPyBfZiA6IG51bGw7XG4gICAgdGhpcy5fX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucyA9IChfaCA9IChfZyA9IG9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLk1lc3NhZ2VJbnRlcmFjdGlvbnMpICE9IG51bGwgPyBfaCA6IG51bGw7XG4gICAgdGhpcy5fQW5ub3RhdGlvbnMgPSAoX2ogPSAoX2kgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfaS5Bbm5vdGF0aW9ucykgIT0gbnVsbCA/IF9qIDogbnVsbDtcbiAgfVxuICBnZXQgcmVzdCgpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3QpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUmVzdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3Q7XG4gIH1cbiAgZ2V0IF9GaWx0ZXJlZFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLl9fRmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1lc3NhZ2VJbnRlcmFjdGlvbnNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fRmlsdGVyZWRTdWJzY3JpcHRpb25zO1xuICB9XG4gIGdldCBjaGFubmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LmNoYW5uZWxzO1xuICB9XG4gIGdldCBwdXNoKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3QucHVzaDtcbiAgfVxuICAvKiogUlNIOCAqL1xuICBkZXZpY2UoKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoISgoX2EyID0gdGhpcy5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkgfHwgIXRoaXMucHVzaC5Mb2NhbERldmljZSkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RldmljZSkge1xuICAgICAgdGhpcy5fZGV2aWNlID0gdGhpcy5wdXNoLkxvY2FsRGV2aWNlLmxvYWQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kZXZpY2U7XG4gIH1cbiAgYmFzZVVyaShob3N0KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzX2RlZmF1bHQuZ2V0SHR0cFNjaGVtZSh0aGlzLm9wdGlvbnMpICsgaG9zdCArIFwiOlwiICsgZGVmYXVsdHNfZGVmYXVsdC5nZXRQb3J0KHRoaXMub3B0aW9ucywgZmFsc2UpO1xuICB9XG4gIGFzeW5jIHN0YXRzKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlc3Quc3RhdHMocGFyYW1zKTtcbiAgfVxuICBhc3luYyB0aW1lKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlc3QudGltZShwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QobWV0aG9kLCBwYXRoLCB2ZXJzaW9uMiwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5yZXF1ZXN0KG1ldGhvZCwgcGF0aCwgdmVyc2lvbjIsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycyk7XG4gIH1cbiAgYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5iYXRjaFB1Ymxpc2goc3BlY09yU3BlY3MpO1xuICB9XG4gIGJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LmJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpO1xuICB9XG4gIHNldExvZyhsb2dPcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIuc2V0TG9nKGxvZ09wdGlvbnMubGV2ZWwsIGxvZ09wdGlvbnMuaGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB0aW1lIGJhc2VkIG9uIHRoZSBsb2NhbCBjbG9jayxcbiAgICogb3IgaWYgdGhlIG9wdGlvbiBxdWVyeVRpbWUgaXMgdHJ1ZSwgcmV0dXJuIHRoZSBzZXJ2ZXIgdGltZS5cbiAgICogVGhlIHNlcnZlciB0aW1lIG9mZnNldCBmcm9tIHRoZSBsb2NhbCB0aW1lIGlzIHN0b3JlZCBzbyB0aGF0XG4gICAqIG9ubHkgb25lIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIHRpbWUgaXMgZXZlciBuZWVkZWRcbiAgICovXG4gIGFzeW5jIGdldFRpbWVzdGFtcChxdWVyeVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNUaW1lT2Zmc2V0U2V0KCkgJiYgcXVlcnlUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCk7XG4gIH1cbiAgZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCkgKyAodGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0IHx8IDApO1xuICB9XG4gIGlzVGltZU9mZnNldFNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ICE9PSBudWxsO1xuICB9XG59O1xuQmFzZUNsaWVudC5QbGF0Zm9ybSA9IFBsYXRmb3JtO1xudmFyIGJhc2VjbGllbnRfZGVmYXVsdCA9IEJhc2VDbGllbnQ7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2RldmljZWRldGFpbHMudHNcbnZhciBEZXZpY2VEZXRhaWxzID0gY2xhc3MgX0RldmljZURldGFpbHMge1xuICB0b0pTT04oKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRldmljZVNlY3JldDogdGhpcy5kZXZpY2VTZWNyZXQsXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIGZvcm1GYWN0b3I6IHRoaXMuZm9ybUZhY3RvcixcbiAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICBkZXZpY2VJZGVudGl0eVRva2VuOiB0aGlzLmRldmljZUlkZW50aXR5VG9rZW4sXG4gICAgICBwdXNoOiB7XG4gICAgICAgIHJlY2lwaWVudDogKF9hMiA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZWNpcGllbnQsXG4gICAgICAgIHN0YXRlOiAoX2IgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zdGF0ZSxcbiAgICAgICAgZXJyb3I6IChfYyA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmVycm9yXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICAgIGxldCByZXN1bHQgPSBcIltEZXZpY2VEZXRhaWxzXCI7XG4gICAgaWYgKHRoaXMuaWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGlkPVwiICsgdGhpcy5pZDtcbiAgICBpZiAodGhpcy5wbGF0Zm9ybSlcbiAgICAgIHJlc3VsdCArPSBcIjsgcGxhdGZvcm09XCIgKyB0aGlzLnBsYXRmb3JtO1xuICAgIGlmICh0aGlzLmZvcm1GYWN0b3IpXG4gICAgICByZXN1bHQgKz0gXCI7IGZvcm1GYWN0b3I9XCIgKyB0aGlzLmZvcm1GYWN0b3I7XG4gICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGNsaWVudElkPVwiICsgdGhpcy5jbGllbnRJZDtcbiAgICBpZiAodGhpcy5tZXRhZGF0YSlcbiAgICAgIHJlc3VsdCArPSBcIjsgbWV0YWRhdGE9XCIgKyB0aGlzLm1ldGFkYXRhO1xuICAgIGlmICh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pXG4gICAgICByZXN1bHQgKz0gXCI7IGRldmljZUlkZW50aXR5VG9rZW49XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pO1xuICAgIGlmICgoX2EyID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlY2lwaWVudClcbiAgICAgIHJlc3VsdCArPSBcIjsgcHVzaC5yZWNpcGllbnQ9XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2gucmVjaXBpZW50KTtcbiAgICBpZiAoKF9iID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc3RhdGUpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2guc3RhdGU9XCIgKyB0aGlzLnB1c2guc3RhdGU7XG4gICAgaWYgKChfYyA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmVycm9yKVxuICAgICAgcmVzdWx0ICs9IFwiOyBwdXNoLmVycm9yPVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLmVycm9yKTtcbiAgICBpZiAoKF9kID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2QubWV0YWRhdGEpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2gubWV0YWRhdGE9XCIgKyB0aGlzLnB1c2gubWV0YWRhdGE7XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIHRvUmVxdWVzdEJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgfVxuICBzdGF0aWMgZnJvbVJlc3BvbnNlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBib2R5ID0gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgICAgcmV0dXJuIF9EZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheShib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9EZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMoYm9keSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHZhbHVlcy5lcnJvciA9IHZhbHVlcy5lcnJvciAmJiBFcnJvckluZm8uZnJvbVZhbHVlcyh2YWx1ZXMuZXJyb3IpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfRGV2aWNlRGV0YWlscygpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tTG9jYWxEZXZpY2UoZGV2aWNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9EZXZpY2VEZXRhaWxzKCksIGRldmljZSk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICBjb25zdCBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgcmVzdWx0W2ldID0gX0RldmljZURldGFpbHMuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgZGV2aWNlZGV0YWlsc19kZWZhdWx0ID0gRGV2aWNlRGV0YWlscztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc291cmNlLnRzXG5hc3luYyBmdW5jdGlvbiB3aXRoQXV0aERldGFpbHMoY2xpZW50LCBoZWFkZXJzLCBwYXJhbXMsIG9wQ2FsbGJhY2spIHtcbiAgaWYgKGNsaWVudC5odHRwLnN1cHBvcnRzQXV0aEhlYWRlcnMpIHtcbiAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IGNsaWVudC5hdXRoLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgcmV0dXJuIG9wQ2FsbGJhY2sobWl4aW4oYXV0aEhlYWRlcnMsIGhlYWRlcnMpLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGF1dGhQYXJhbXMgPSBhd2FpdCBjbGllbnQuYXV0aC5nZXRBdXRoUGFyYW1zKCk7XG4gICAgcmV0dXJuIG9wQ2FsbGJhY2soaGVhZGVycywgbWl4aW4oYXV0aFBhcmFtcywgcGFyYW1zKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuZW52ZWxvcGUocmVzdWx0LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgaWYgKHJlc3VsdC5lcnIgJiYgIXJlc3VsdC5ib2R5KSB7XG4gICAgcmV0dXJuIHsgZXJyOiByZXN1bHQuZXJyIH07XG4gIH1cbiAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdC5Ob0NvbnRlbnQpIHtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVzdWx0KSwgeyBib2R5OiBbXSwgdW5wYWNrZWQ6IHRydWUgfSk7XG4gIH1cbiAgbGV0IGJvZHkgPSByZXN1bHQuYm9keTtcbiAgaWYgKCFyZXN1bHQudW5wYWNrZWQpIHtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBlcnI6IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKGluc3BlY3RFcnJvcihlKSwgbnVsbCkgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFib2R5KSB7XG4gICAgcmV0dXJuIHsgZXJyOiBuZXcgUGFydGlhbEVycm9ySW5mbyhcInVuZW52ZWxvcGUoKTogUmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nXCIsIG51bGwpIH07XG4gIH1cbiAgY29uc3QgeyBzdGF0dXNDb2RlOiB3cmFwcGVkU3RhdHVzQ29kZSwgcmVzcG9uc2UsIGhlYWRlcnM6IHdyYXBwZWRIZWFkZXJzIH0gPSBib2R5O1xuICBpZiAod3JhcHBlZFN0YXR1c0NvZGUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCByZXN1bHQpLCB7IGJvZHksIHVucGFja2VkOiB0cnVlIH0pO1xuICB9XG4gIGlmICh3cmFwcGVkU3RhdHVzQ29kZSA8IDIwMCB8fCB3cmFwcGVkU3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICBsZXQgd3JhcHBlZEVyciA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLmVycm9yIHx8IHJlc3VsdC5lcnI7XG4gICAgaWYgKCF3cmFwcGVkRXJyKSB7XG4gICAgICB3cmFwcGVkRXJyID0gbmV3IEVycm9yKFwiRXJyb3IgaW4gdW5lbnZlbG9waW5nIFwiICsgYm9keSk7XG4gICAgICB3cmFwcGVkRXJyLnN0YXR1c0NvZGUgPSB3cmFwcGVkU3RhdHVzQ29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyOiB3cmFwcGVkRXJyLCBib2R5OiByZXNwb25zZSwgaGVhZGVyczogd3JhcHBlZEhlYWRlcnMsIHVucGFja2VkOiB0cnVlLCBzdGF0dXNDb2RlOiB3cmFwcGVkU3RhdHVzQ29kZSB9O1xuICB9XG4gIHJldHVybiB7IGVycjogcmVzdWx0LmVyciwgYm9keTogcmVzcG9uc2UsIGhlYWRlcnM6IHdyYXBwZWRIZWFkZXJzLCB1bnBhY2tlZDogdHJ1ZSwgc3RhdHVzQ29kZTogd3JhcHBlZFN0YXR1c0NvZGUgfTtcbn1cbmZ1bmN0aW9uIGxvZ1Jlc3VsdDIocmVzdWx0LCBtZXRob2QsIHBhdGgsIHBhcmFtcywgbG9nZ2VyKSB7XG4gIGlmIChyZXN1bHQuZXJyKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQgRXJyb3I7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHBhdGgsIHBhcmFtcykgKyBcIjsgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnIpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJSZWNlaXZlZDsgXCIgKyBhcHBlbmRpbmdQYXJhbXMocGF0aCwgcGFyYW1zKSArIFwiOyBIZWFkZXJzOiBcIiArIHBhcmFtU3RyaW5nKHJlc3VsdC5oZWFkZXJzKSArIFwiOyBTdGF0dXNDb2RlOiBcIiArIHJlc3VsdC5zdGF0dXNDb2RlICsgXCI7IEJvZHk6IFwiICsgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKHJlc3VsdC5ib2R5KSA/IFwiIChCYXNlNjQpOiBcIiArIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShyZXN1bHQuYm9keSkgOiBcIjogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChyZXN1bHQuYm9keSkpXG4gICAgKTtcbiAgfVxufVxudmFyIFJlc291cmNlID0gY2xhc3MgX1Jlc291cmNlIHtcbiAgc3RhdGljIGFzeW5jIGdldChjbGllbnQsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBjbGllbnQsIHBhdGgsIG51bGwsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IgIT0gbnVsbCA/IHRocm93RXJyb3IgOiBmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlbGV0ZShjbGllbnQsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuRGVsZXRlLCBjbGllbnQsIHBhdGgsIG51bGwsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBwb3N0KGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBwYXRjaChjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuUGF0Y2gsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHB1dChjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuUHV0LCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkbyhtZXRob2QsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIGlmIChlbnZlbG9wZSkge1xuICAgICAgKHBhcmFtcyA9IHBhcmFtcyB8fCB7fSlbXCJlbnZlbG9wZVwiXSA9IGVudmVsb3BlO1xuICAgIH1cbiAgICBjb25zdCBsb2dnZXIgPSBjbGllbnQubG9nZ2VyO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGRvUmVxdWVzdChoZWFkZXJzMiwgcGFyYW1zMikge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmIChsb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgbGV0IGRlY29kZWRCb2R5ID0gYm9keTtcbiAgICAgICAgaWYgKCgoX2EyID0gaGVhZGVyczJbXCJjb250ZW50LXR5cGVcIl0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaW5kZXhPZihcIm1zZ3BhY2tcIikpID4gMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWNsaWVudC5fTXNnUGFjaykge1xuICAgICAgICAgICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQm9keSA9IGNsaWVudC5fTXNnUGFjay5kZWNvZGUoYm9keSk7XG4gICAgICAgICAgfSBjYXRjaCAoZGVjb2RlRXJyKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgICAgICAgICBcIlNlbmRpbmcgTXNnUGFjayBEZWNvZGluZyBFcnJvcjogXCIgKyBpbnNwZWN0RXJyb3IoZGVjb2RlRXJyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgICAgICBcIlNlbmRpbmc7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHBhdGgsIHBhcmFtczIpICsgXCI7IEJvZHk6IFwiICsgZGVjb2RlZEJvZHlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGh0dHBSZXN1bHQgPSBhd2FpdCBjbGllbnQuaHR0cC5kbyhtZXRob2QsIHBhdGgsIGhlYWRlcnMyLCBib2R5LCBwYXJhbXMyKTtcbiAgICAgIGlmIChodHRwUmVzdWx0LmVycm9yICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKGh0dHBSZXN1bHQuZXJyb3IpKSB7XG4gICAgICAgIGF3YWl0IGNsaWVudC5hdXRoLmF1dGhvcml6ZShudWxsLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHdpdGhBdXRoRGV0YWlscyhjbGllbnQsIGhlYWRlcnMyLCBwYXJhbXMyLCBkb1JlcXVlc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyOiBodHRwUmVzdWx0LmVycm9yLFxuICAgICAgICBib2R5OiBodHRwUmVzdWx0LmJvZHksXG4gICAgICAgIGhlYWRlcnM6IGh0dHBSZXN1bHQuaGVhZGVycyxcbiAgICAgICAgdW5wYWNrZWQ6IGh0dHBSZXN1bHQudW5wYWNrZWQsXG4gICAgICAgIHN0YXR1c0NvZGU6IGh0dHBSZXN1bHQuc3RhdHVzQ29kZVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHdpdGhBdXRoRGV0YWlscyhjbGllbnQsIGhlYWRlcnMsIHBhcmFtcywgZG9SZXF1ZXN0KTtcbiAgICBpZiAoZW52ZWxvcGUpIHtcbiAgICAgIHJlc3VsdCA9IHVuZW52ZWxvcGUocmVzdWx0LCBjbGllbnQuX01zZ1BhY2ssIGVudmVsb3BlKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgbG9nUmVzdWx0MihyZXN1bHQsIG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBsb2dnZXIpO1xuICAgIH1cbiAgICBpZiAodGhyb3dFcnJvcikge1xuICAgICAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdCk7XG4gICAgICAgIGRlbGV0ZSByZXNwb25zZS5lcnI7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciByZXNvdXJjZV9kZWZhdWx0ID0gUmVzb3VyY2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9wYWdpbmF0ZWRyZXNvdXJjZS50c1xuZnVuY3Rpb24gZ2V0UmVsUGFyYW1zKGxpbmtVcmwpIHtcbiAgY29uc3QgdXJsTWF0Y2ggPSBsaW5rVXJsLm1hdGNoKC9eXFwuXFwvKFxcdyspXFw/KC4qKSQvKTtcbiAgcmV0dXJuIHVybE1hdGNoICYmIHVybE1hdGNoWzJdICYmIHBhcnNlUXVlcnlTdHJpbmcodXJsTWF0Y2hbMl0pO1xufVxuZnVuY3Rpb24gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKSB7XG4gIGlmICh0eXBlb2YgbGlua0hlYWRlciA9PSBcInN0cmluZ1wiKVxuICAgIGxpbmtIZWFkZXIgPSBsaW5rSGVhZGVyLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgcmVsUGFyYW1zID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlua0hlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmtNYXRjaCA9IGxpbmtIZWFkZXJbaV0ubWF0Y2goL15cXHMqPCguKyk+O1xccypyZWw9XCIoXFx3KylcIiQvKTtcbiAgICBpZiAobGlua01hdGNoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBnZXRSZWxQYXJhbXMobGlua01hdGNoWzFdKTtcbiAgICAgIGlmIChwYXJhbXMpXG4gICAgICAgIHJlbFBhcmFtc1tsaW5rTWF0Y2hbMl1dID0gcGFyYW1zO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVsUGFyYW1zO1xufVxuZnVuY3Rpb24gcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHVzZUhQUikge1xuICByZXR1cm4gISh1c2VIUFIgJiYgKGJvZHkgfHwgdHlwZW9mIGVyci5jb2RlID09PSBcIm51bWJlclwiKSk7XG59XG52YXIgUGFnaW5hdGVkUmVzb3VyY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGJvZHlIYW5kbGVyLCB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlICE9IG51bGwgPyBlbnZlbG9wZSA6IG51bGw7XG4gICAgdGhpcy5ib2R5SGFuZGxlciA9IGJvZHlIYW5kbGVyO1xuICAgIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlIHx8IGZhbHNlO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5nZXQodGhpcy5jbGllbnQsIHRoaXMucGF0aCwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZGVsZXRlKHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIHBvc3QocGFyYW1zLCBib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIHB1dChwYXJhbXMsIGJvZHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnB1dCh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBwYXRjaChwYXJhbXMsIGJvZHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBhdGNoKHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIGhhbmRsZVBhZ2UocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5lcnIgJiYgcmV0dXJuRXJyT25seShyZXN1bHQuZXJyLCByZXN1bHQuYm9keSwgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiUGFnaW5hdGVkUmVzb3VyY2UuaGFuZGxlUGFnZSgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBlcnJvciBnZXR0aW5nIHJlc291cmNlOiBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihyZXN1bHQuZXJyKVxuICAgICAgKTtcbiAgICAgIHRocm93IHJlc3VsdC5lcnI7XG4gICAgfVxuICAgIGxldCBpdGVtcywgbGlua0hlYWRlciwgcmVsUGFyYW1zO1xuICAgIHRyeSB7XG4gICAgICBpdGVtcyA9IHJlc3VsdC5zdGF0dXNDb2RlID09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0Lk5vQ29udGVudCA/IFtdIDogYXdhaXQgdGhpcy5ib2R5SGFuZGxlcihyZXN1bHQuYm9keSwgcmVzdWx0LmhlYWRlcnMgfHwge30sIHJlc3VsdC51bnBhY2tlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgcmVzdWx0LmVyciB8fCBlO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmhlYWRlcnMgJiYgKGxpbmtIZWFkZXIgPSByZXN1bHQuaGVhZGVyc1tcIkxpbmtcIl0gfHwgcmVzdWx0LmhlYWRlcnNbXCJsaW5rXCJdKSkge1xuICAgICAgcmVsUGFyYW1zID0gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbmV3IEh0dHBQYWdpbmF0ZWRSZXNwb25zZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIHJlc3VsdC5oZWFkZXJzIHx8IHt9LFxuICAgICAgICByZXN1bHQuc3RhdHVzQ29kZSxcbiAgICAgICAgcmVsUGFyYW1zLFxuICAgICAgICByZXN1bHQuZXJyXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBhZ2luYXRlZFJlc3VsdCh0aGlzLCBpdGVtcywgcmVsUGFyYW1zKTtcbiAgICB9XG4gIH1cbn07XG52YXIgUGFnaW5hdGVkUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcykge1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgdGhpcy5fcmVsUGFyYW1zID0gcmVsUGFyYW1zO1xuICB9XG4gIGFzeW5jIGZpcnN0KCkge1xuICAgIGlmICh0aGlzLmhhc0ZpcnN0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLl9yZWxQYXJhbXMuZmlyc3QpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiTm8gbGluayB0byB0aGUgZmlyc3QgcGFnZSBvZiByZXN1bHRzXCIsIDQwNDAwLCA0MDQpO1xuICB9XG4gIGFzeW5jIGN1cnJlbnQoKSB7XG4gICAgaWYgKHRoaXMuaGFzQ3VycmVudCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5fcmVsUGFyYW1zLmN1cnJlbnQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiTm8gbGluayB0byB0aGUgY3VycmVudCBwYWdlIG9mIHJlc3VsdHNcIiwgNDA0MDAsIDQwNCk7XG4gIH1cbiAgYXN5bmMgbmV4dCgpIHtcbiAgICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLl9yZWxQYXJhbXMubmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhc0ZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxQYXJhbXMgIT0gbnVsbCAmJiBcImZpcnN0XCIgaW4gdGhpcy5fcmVsUGFyYW1zO1xuICB9XG4gIGhhc0N1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbFBhcmFtcyAhPSBudWxsICYmIFwiY3VycmVudFwiIGluIHRoaXMuX3JlbFBhcmFtcztcbiAgfVxuICBoYXNOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxQYXJhbXMgIT0gbnVsbCAmJiBcIm5leHRcIiBpbiB0aGlzLl9yZWxQYXJhbXM7XG4gIH1cbiAgaXNMYXN0KCkge1xuICAgIHJldHVybiAhdGhpcy5oYXNOZXh0KCk7XG4gIH1cbiAgLyogV2UgYXNzdW1lIHRoYXQgb25seSB0aGUgaW5pdGlhbCByZXF1ZXN0IGNhbiBiZSBhIFBPU1QsIGFuZCB0aGF0IGFjY2Vzc2luZ1xuICAgKiB0aGUgcmVzdCBvZiBhIG11bHRpcGFnZSBzZXQgb2YgcmVzdWx0cyBjYW4gYWx3YXlzIGJlIGRvbmUgd2l0aCBHRVQgKi9cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGNvbnN0IHJlcyA9IHRoaXMucmVzb3VyY2U7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5nZXQocmVzLmNsaWVudCwgcmVzLnBhdGgsIHJlcy5oZWFkZXJzLCBwYXJhbXMsIHJlcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiByZXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG59O1xudmFyIEh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgUGFnaW5hdGVkUmVzdWx0IHtcbiAgY29uc3RydWN0b3IocmVzb3VyY2UsIGl0ZW1zLCBoZWFkZXJzLCBzdGF0dXNDb2RlLCByZWxQYXJhbXMsIGVycikge1xuICAgIHN1cGVyKHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3VjY2VzcyA9IHN0YXR1c0NvZGUgPCAzMDAgJiYgc3RhdHVzQ29kZSA+PSAyMDA7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVyciAmJiBlcnIuY29kZTtcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgc3VjY2VzczogdGhpcy5zdWNjZXNzLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgZXJyb3JDb2RlOiB0aGlzLmVycm9yQ29kZSxcbiAgICAgIGVycm9yTWVzc2FnZTogdGhpcy5lcnJvck1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xudmFyIHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQgPSBQYWdpbmF0ZWRSZXNvdXJjZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24udHNcbnZhciBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSBjbGFzcyBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24ge1xuICAvKipcbiAgICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLFxuICAgICAgZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG4gICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZFxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiW1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uXCI7XG4gICAgaWYgKHRoaXMuY2hhbm5lbClcbiAgICAgIHJlc3VsdCArPSBcIjsgY2hhbm5lbD1cIiArIHRoaXMuY2hhbm5lbDtcbiAgICBpZiAodGhpcy5kZXZpY2VJZClcbiAgICAgIHJlc3VsdCArPSBcIjsgZGV2aWNlSWQ9XCIgKyB0aGlzLmRldmljZUlkO1xuICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBjbGllbnRJZD1cIiArIHRoaXMuY2xpZW50SWQ7XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGZyb21SZXNwb25zZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgYm9keSA9IGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYm9keSkpIHtcbiAgICAgIHJldHVybiBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMoYm9keSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24oKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIGNvbnN0IGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICByZXN1bHRbaV0gPSBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5fUHVzaENoYW5uZWxTdWJzY3JpcHRpb24udG9SZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHk7XG52YXIgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb247XG52YXIgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdCA9IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcHVzaC50c1xudmFyIFB1c2ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHZhciBfYTI7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5hZG1pbiA9IG5ldyBBZG1pbihjbGllbnQpO1xuICAgIGlmIChQbGF0Zm9ybS5Db25maWcucHVzaCAmJiAoKF9hMiA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkpIHtcbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5BY3RpdmF0aW9uU3RhdGVNYWNoaW5lKGNsaWVudCk7XG4gICAgICB0aGlzLkxvY2FsRGV2aWNlID0gY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLmxvY2FsRGV2aWNlRmFjdG9yeShkZXZpY2VkZXRhaWxzX2RlZmF1bHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBhY3RpdmF0ZShyZWdpc3RlckNhbGxiYWNrLCB1cGRhdGVGYWlsZWRDYWxsYmFjaykge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoISgoX2EyID0gdGhpcy5jbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpKSB7XG4gICAgICAgIHJlamVjdChjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlTWFjaGluZSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIlRoaXMgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZCBhcyBhIHRhcmdldCBvZiBwdXNoIG5vdGlmaWNhdGlvbnNcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGVNYWNoaW5lLmFjdGl2YXRlZENhbGxiYWNrKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiQWN0aXZhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLmFjdGl2YXRlZENhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS51cGRhdGVGYWlsZWRDYWxsYmFjayA9IHVwZGF0ZUZhaWxlZENhbGxiYWNrO1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuaGFuZGxlRXZlbnQoXG4gICAgICAgIG5ldyB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5DYWxsZWRBY3RpdmF0ZSh0aGlzLnN0YXRlTWFjaGluZSwgcmVnaXN0ZXJDYWxsYmFjaylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGVhY3RpdmF0ZShkZXJlZ2lzdGVyQ2FsbGJhY2spIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKCEoKF9hMiA9IHRoaXMuY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5QdXNoKSkge1xuICAgICAgICByZWplY3QoY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJUaGlzIHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYSB0YXJnZXQgb2YgcHVzaCBub3RpZmljYXRpb25zXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlTWFjaGluZS5kZWFjdGl2YXRlZENhbGxiYWNrKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiRGVhY3RpdmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuZGVhY3RpdmF0ZWRDYWxsYmFjayA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuaGFuZGxlRXZlbnQoXG4gICAgICAgIG5ldyB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5DYWxsZWREZWFjdGl2YXRlKHRoaXMuc3RhdGVNYWNoaW5lLCBkZXJlZ2lzdGVyQ2FsbGJhY2spXG4gICAgICApO1xuICAgIH0pO1xuICB9XG59O1xudmFyIEFkbWluID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmRldmljZVJlZ2lzdHJhdGlvbnMgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9ucyhjbGllbnQpO1xuICAgIHRoaXMuY2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBuZXcgQ2hhbm5lbFN1YnNjcmlwdGlvbnMoY2xpZW50KTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlY2lwaWVudCwgcGF5bG9hZCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucyksIHBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IGJvZHkgPSBtaXhpbih7IHJlY2lwaWVudCB9LCBwYXlsb2FkKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChjbGllbnQsIFwiL3B1c2gvcHVibGlzaFwiLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCB0cnVlKTtcbiAgfVxufTtcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICBhc3luYyBzYXZlKGRldmljZSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGJvZHkgPSBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVZhbHVlcyhkZXZpY2UpO1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucyksIHBhcmFtcyA9IHt9O1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnB1dChcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UuaWQpLFxuICAgICAgcmVxdWVzdEJvZHksXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zLFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICByZXNwb25zZS51bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0KGRldmljZUlkT3JEZXRhaWxzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKSwgZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcbiAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSBcInN0cmluZ1wiIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNnZXQgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzXCIsXG4gICAgICAgIDRlNCxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB7fSxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gZGV2aWNlZGV0YWlsc19kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgcmVzcG9uc2UudW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICApO1xuICB9XG4gIGFzeW5jIGxpc3QocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KGNsaWVudCwgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zXCIsIGhlYWRlcnMsIGVudmVsb3BlLCBhc3luYyBmdW5jdGlvbihib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpIHtcbiAgICAgIHJldHVybiBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgICB1bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICAgKTtcbiAgICB9KS5nZXQocGFyYW1zKTtcbiAgfVxuICBhc3luYyByZW1vdmUoZGV2aWNlSWRPckRldGFpbHMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpLCBwYXJhbXMgPSB7fSwgZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcbiAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSBcInN0cmluZ1wiIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNyZW1vdmUgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzXCIsXG4gICAgICAgIDRlNCxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0W1wiZGVsZXRlXCJdKFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlV2hlcmUocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0W1wiZGVsZXRlXCJdKGNsaWVudCwgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zXCIsIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgdHJ1ZSk7XG4gIH1cbn07XG52YXIgQ2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBjbGFzcyBfQ2hhbm5lbFN1YnNjcmlwdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAvKiBDaGFubmVsU3Vic2NyaXB0aW9ucyBoYXZlIG5vIHVuaXF1ZSBpZDsgcmVtb3Zpbmcgb25lIGlzIGVxdWl2YWxlbnQgdG8gcmVtb3ZlV2hlcmUgYnkgaXRzIHByb3BlcnRpZXMgKi9cbiAgICB0aGlzLnJlbW92ZSA9IF9DaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmU7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgYXN5bmMgc2F2ZShzdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBib2R5ID0gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdC5mcm9tVmFsdWVzKHN1YnNjcmlwdGlvbik7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zKSwgcGFyYW1zID0ge307XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnNcIixcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgIHJlc3BvbnNlLnVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgKTtcbiAgfVxuICBhc3luYyBsaXN0KHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIFwiL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgcmV0dXJuIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgICB1bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICAgKTtcbiAgICB9KS5nZXQocGFyYW1zKTtcbiAgfVxuICBhc3luYyByZW1vdmVXaGVyZShwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHRbXCJkZWxldGVcIl0oY2xpZW50LCBcIi9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zXCIsIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgdHJ1ZSk7XG4gIH1cbiAgYXN5bmMgbGlzdENoYW5uZWxzKHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIFwiL3B1c2gvY2hhbm5lbHNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgY29uc3QgcGFyc2VkQm9keSA9ICF1bnBhY2tlZCAmJiBmb3JtYXQgPyBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KSA6IGJvZHk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZEJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFyc2VkQm9keVtpXSA9IFN0cmluZyhwYXJzZWRCb2R5W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRCb2R5O1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG59O1xudmFyIHB1c2hfZGVmYXVsdCA9IFB1c2g7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3ByZXNlbmNlbWVzc2FnZS50c1xudmFyIGFjdGlvbnMyID0gW1wiYWJzZW50XCIsIFwicHJlc2VudFwiLCBcImVudGVyXCIsIFwibGVhdmVcIiwgXCJ1cGRhdGVcIl07XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZChsb2dnZXIsIENyeXB0bzIsIGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhDcnlwdG8yLCBsb2dnZXIsIGlucHV0T3B0aW9ucyAhPSBudWxsID8gaW5wdXRPcHRpb25zIDogbnVsbCk7XG4gIGNvbnN0IHdwbSA9IFdpcmVQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgcmV0dXJuIHdwbS5kZWNvZGUob3B0aW9ucywgbG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkQXJyYXkobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIGZyb21FbmNvZGVkKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZChlbmNvZGVkLCBjaGFubmVsKSB7XG4gIHJldHVybiBXaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCkuZGVjb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGNoYW5uZWwubG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZEFycmF5KGVuY29kZWRBcnJheSwgY2hhbm5lbCkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkKGVuY29kZWQsIGNoYW5uZWwpO1xuICAgIH0pXG4gICk7XG59XG52YXIgUHJlc2VuY2VNZXNzYWdlID0gY2xhc3MgX1ByZXNlbmNlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgLyogUmV0dXJucyB3aGV0aGVyIHRoaXMgcHJlc2VuY2VNZXNzYWdlIGlzIHN5bnRoZXNpemVkLCBpLmUuIHdhcyBub3QgYWN0dWFsbHlcbiAgICogc2VudCBieSB0aGUgY29ubmVjdGlvbiAodXN1YWxseSBtZWFucyBhIGxlYXZlIGV2ZW50IHNlbnQgMTVzIGFmdGVyIGFcbiAgICogZGlzY29ubmVjdGlvbikuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2Ugc3ludGhlc2l6ZWQgbWVzc2FnZXMgY2Fubm90IGJlXG4gICAqIGNvbXBhcmVkIGZvciBuZXduZXNzIGJ5IGlkIGxleGljb2dyYXBoaWNhbGx5IC0gUlRQMmIxXG4gICAqL1xuICBpc1N5bnRoZXNpemVkKCkge1xuICAgIGlmICghdGhpcy5pZCB8fCAhdGhpcy5jb25uZWN0aW9uSWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcodGhpcy5jb25uZWN0aW9uSWQubGVuZ3RoLCAwKSAhPT0gdGhpcy5jb25uZWN0aW9uSWQ7XG4gIH1cbiAgLyogUlRQMmIyICovXG4gIHBhcnNlSWQoKSB7XG4gICAgaWYgKCF0aGlzLmlkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFyc2VJZCgpOiBQcmVzZW5jZSBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYW4gaWRcIik7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLmlkLnNwbGl0KFwiOlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29ubmVjdGlvbklkOiBwYXJ0c1swXSxcbiAgICAgIG1zZ1NlcmlhbDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIGluZGV4OiBwYXJzZUludChwYXJ0c1syXSwgMTApXG4gICAgfTtcbiAgfVxuICBhc3luYyBlbmNvZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFdpcmVQcmVzZW5jZU1lc3NhZ2UoKSwgdGhpcywge1xuICAgICAgYWN0aW9uOiBhY3Rpb25zMi5pbmRleE9mKHRoaXMuYWN0aW9uIHx8IFwicHJlc2VudFwiKVxuICAgIH0pO1xuICAgIHJldHVybiBlbmNvZGUocmVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1ByZXNlbmNlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9QcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgc3RhdGljIGZyb21EYXRhKGRhdGEpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9QcmVzZW5jZU1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gX1ByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHtcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiUHJlc2VuY2VNZXNzYWdlXCIpO1xuICB9XG59O1xudmFyIFdpcmVQcmVzZW5jZU1lc3NhZ2UgPSBjbGFzcyBfV2lyZVByZXNlbmNlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgdG9KU09OKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gd2lyZVRvSlNPTi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfV2lyZVByZXNlbmNlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9XaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXModikpO1xuICB9XG4gIGFzeW5jIGRlY29kZShjaGFubmVsT3B0aW9ucywgbG9nZ2VyKSB7XG4gICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbihuZXcgUHJlc2VuY2VNZXNzYWdlKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMpLCB7XG4gICAgICBhY3Rpb246IGFjdGlvbnMyW3RoaXMuYWN0aW9uXVxuICAgIH0pKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZGVjb2RlKHJlcywgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXaXJlUHJlc2VuY2VNZXNzYWdlLmRlY29kZSgpXCIsIGluc3BlY3RFcnJvcihlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIldpcmVQcmVzZW5jZU1lc3NhZ2VcIik7XG4gIH1cbn07XG52YXIgcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQgPSBQcmVzZW5jZU1lc3NhZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0cHJlc2VuY2UudHNcbnZhciBSZXN0UHJlc2VuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5sb2dnZXI7XG4gIH1cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RQcmVzZW5jZS5nZXQoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMuY2hhbm5lbC5uYW1lKTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNoYW5uZWwuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2hhbm5lbC5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy5jaGFubmVsLmNsaWVudC5yZXN0LnByZXNlbmNlTWl4aW4uYmFzZVBhdGgodGhpcyksXG4gICAgICBoZWFkZXJzLFxuICAgICAgZW52ZWxvcGUsXG4gICAgICBhc3luYyAoYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZEFycmF5KGRlY29kZWQsIHRoaXMuY2hhbm5lbCk7XG4gICAgICB9XG4gICAgKS5nZXQocGFyYW1zKTtcbiAgfVxuICBhc3luYyBoaXN0b3J5KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RQcmVzZW5jZS5oaXN0b3J5KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5jbGllbnQucmVzdC5wcmVzZW5jZU1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgfVxufTtcbnZhciByZXN0cHJlc2VuY2VfZGVmYXVsdCA9IFJlc3RQcmVzZW5jZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvbWVzc2FnZS50c1xudmFyIGFjdGlvbnMzID0gW1xuICBcIm1lc3NhZ2UuY3JlYXRlXCIsXG4gIFwibWVzc2FnZS51cGRhdGVcIixcbiAgXCJtZXNzYWdlLmRlbGV0ZVwiLFxuICBcIm1ldGFcIixcbiAgXCJtZXNzYWdlLnN1bW1hcnlcIixcbiAgXCJtZXNzYWdlLmFwcGVuZFwiXG5dO1xuZnVuY3Rpb24gc3RyaW5naWZ5QWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gYWN0aW9uczNbYWN0aW9uIHx8IDBdIHx8IFwidW5rbm93blwiO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZVNpemUobXNnKSB7XG4gIGxldCBzaXplID0gMDtcbiAgaWYgKG1zZy5uYW1lKSB7XG4gICAgc2l6ZSArPSBtc2cubmFtZS5sZW5ndGg7XG4gIH1cbiAgaWYgKG1zZy5jbGllbnRJZCkge1xuICAgIHNpemUgKz0gbXNnLmNsaWVudElkLmxlbmd0aDtcbiAgfVxuICBpZiAobXNnLmV4dHJhcykge1xuICAgIHNpemUgKz0gSlNPTi5zdHJpbmdpZnkobXNnLmV4dHJhcykubGVuZ3RoO1xuICB9XG4gIGlmIChtc2cuZGF0YSkge1xuICAgIHNpemUgKz0gZGF0YVNpemVCeXRlcyhtc2cuZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZDIobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkLCBpbnB1dE9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMoQ3J5cHRvMiwgbG9nZ2VyLCBpbnB1dE9wdGlvbnMgIT0gbnVsbCA/IGlucHV0T3B0aW9ucyA6IG51bGwpO1xuICBjb25zdCB3bSA9IFdpcmVNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XG4gIHJldHVybiB3bS5kZWNvZGUob3B0aW9ucywgbG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkQXJyYXkyKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHJldHVybiBmcm9tRW5jb2RlZDIobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkLCBvcHRpb25zKTtcbiAgICB9KVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gX2Zyb21FbmNvZGVkMihlbmNvZGVkLCBjaGFubmVsKSB7XG4gIGNvbnN0IHdtID0gV2lyZU1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgcmV0dXJuIHdtLmRlY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zLCBjaGFubmVsLmxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWRBcnJheTIoZW5jb2RlZEFycmF5LCBjaGFubmVsKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHJldHVybiBfZnJvbUVuY29kZWQyKGVuY29kZWQsIGNoYW5uZWwpO1xuICAgIH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBlbmNvZGVBcnJheShtZXNzYWdlcywgb3B0aW9ucykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiBtZXNzYWdlLmVuY29kZShvcHRpb25zKSkpO1xufVxudmFyIHNlcmlhbGl6ZSA9IGVuY29kZUJvZHk7XG5mdW5jdGlvbiBnZXRNZXNzYWdlc1NpemUobWVzc2FnZXMpIHtcbiAgbGV0IG1zZywgdG90YWwgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbXNnID0gbWVzc2FnZXNbaV07XG4gICAgdG90YWwgKz0gbXNnLnNpemUgfHwgKG1zZy5zaXplID0gZ2V0TWVzc2FnZVNpemUobXNnKSk7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufVxudmFyIE1lc3NhZ2UgPSBjbGFzcyBfTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgZXhwYW5kRmllbGRzKCkge1xuICAgIGlmICghdGhpcy52ZXJzaW9uKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSB7fTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnZlcnNpb24uc2VyaWFsICYmIHRoaXMuc2VyaWFsKSB7XG4gICAgICB0aGlzLnZlcnNpb24uc2VyaWFsID0gdGhpcy5zZXJpYWw7XG4gICAgfVxuICAgIGlmICghdGhpcy52ZXJzaW9uLnRpbWVzdGFtcCAmJiB0aGlzLnRpbWVzdGFtcCkge1xuICAgICAgdGhpcy52ZXJzaW9uLnRpbWVzdGFtcCA9IHRoaXMudGltZXN0YW1wO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbnMpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSB7XG4gICAgICAgIHN1bW1hcnk6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuYW5ub3RhdGlvbnMuc3VtbWFyeSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucy5zdW1tYXJ5ID0ge307XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25zICYmIHRoaXMuYW5ub3RhdGlvbnMuc3VtbWFyeSkge1xuICAgICAgZm9yIChjb25zdCBbdHlwZSwgc3VtbWFyeUVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmFubm90YXRpb25zLnN1bW1hcnkpKSB7XG4gICAgICAgIGlmICh0eXBlLmVuZHNXaXRoKFwiOmRpc3RpbmN0LnYxXCIpIHx8IHR5cGUuZW5kc1dpdGgoXCI6dW5pcXVlLnYxXCIpIHx8IHR5cGUuZW5kc1dpdGgoXCI6bXVsdGlwbGUudjFcIikpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFssIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyhzdW1tYXJ5RW50cnkpKSB7XG4gICAgICAgICAgICBpZiAoIWVudHJ5LmNsaXBwZWQpIHtcbiAgICAgICAgICAgICAgZW50cnkuY2xpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLmVuZHNXaXRoKFwiOmZsYWcudjFcIikpIHtcbiAgICAgICAgICBpZiAoIXN1bW1hcnlFbnRyeS5jbGlwcGVkKSB7XG4gICAgICAgICAgICBzdW1tYXJ5RW50cnkuY2xpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBlbmNvZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFdpcmVNZXNzYWdlKCksIHRoaXMsIHtcbiAgICAgIGFjdGlvbjogYWN0aW9uczMuaW5kZXhPZih0aGlzLmFjdGlvbiB8fCBcIm1lc3NhZ2UuY3JlYXRlXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuIGVuY29kZShyZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9NZXNzYWdlLmZyb21WYWx1ZXModikpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJNc2codGhpcywgXCJNZXNzYWdlXCIpO1xuICB9XG59O1xudmFyIFdpcmVNZXNzYWdlID0gY2xhc3MgX1dpcmVNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAvLyBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICB0b0pTT04oLi4uYXJncykge1xuICAgIHJldHVybiB3aXJlVG9KU09OLmNhbGwodGhpcywgLi4uYXJncyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9XaXJlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9XaXJlTWVzc2FnZS5mcm9tVmFsdWVzKHYpKTtcbiAgfVxuICAvLyBmb3IgY29udGV4dHMgd2hlcmUgc29tZSBkZWNvZGluZyBlcnJvcnMgbmVlZCB0byBiZSBoYW5kbGVkIHNwZWNpYWxseSBieSB0aGUgY2FsbGVyXG4gIGFzeW5jIGRlY29kZVdpdGhFcnIoaW5wdXRDb250ZXh0LCBsb2dnZXIpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBNZXNzYWdlKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMpLCB7XG4gICAgICBhY3Rpb246IHN0cmluZ2lmeUFjdGlvbih0aGlzLmFjdGlvbilcbiAgICB9KSk7XG4gICAgbGV0IGVycjtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZGVjb2RlKHJlcywgaW5wdXRDb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2lyZU1lc3NhZ2UuZGVjb2RlKClcIiwgaW5zcGVjdEVycm9yKGUpKTtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHJlcy5leHBhbmRGaWVsZHMoKTtcbiAgICByZXR1cm4geyBkZWNvZGVkOiByZXMsIGVyciB9O1xuICB9XG4gIGFzeW5jIGRlY29kZShpbnB1dENvbnRleHQsIGxvZ2dlcikge1xuICAgIGNvbnN0IHsgZGVjb2RlZCB9ID0gYXdhaXQgdGhpcy5kZWNvZGVXaXRoRXJyKGlucHV0Q29udGV4dCwgbG9nZ2VyKTtcbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiV2lyZU1lc3NhZ2VcIik7XG4gIH1cbn07XG52YXIgbWVzc2FnZV9kZWZhdWx0ID0gTWVzc2FnZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3RjaGFubmVsLnRzXG52YXIgTVNHX0lEX0VOVFJPUFlfQllURVMgPSA5O1xuZnVuY3Rpb24gYWxsRW1wdHlJZHMobWVzc2FnZXMpIHtcbiAgcmV0dXJuIG1lc3NhZ2VzLmV2ZXJ5KGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gIW1lc3NhZ2UuaWQ7XG4gIH0pO1xufVxudmFyIFJlc3RDaGFubmVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBudWxsO1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihjbGllbnQubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVzdENoYW5uZWwoKVwiLCBcInN0YXJ0ZWQ7IG5hbWUgPSBcIiArIG5hbWUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVzZW5jZSA9IG5ldyByZXN0cHJlc2VuY2VfZGVmYXVsdCh0aGlzKTtcbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IGNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIGNoYW5uZWxPcHRpb25zKTtcbiAgICBpZiAoKF9iID0gY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLlB1c2gpIHtcbiAgICAgIHRoaXMuX3B1c2ggPSBuZXcgY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLlB1c2hDaGFubmVsKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50Ll9Bbm5vdGF0aW9ucykge1xuICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBuZXcgY2xpZW50Ll9Bbm5vdGF0aW9ucy5SZXN0QW5ub3RhdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBhbm5vdGF0aW9ucygpIHtcbiAgICBpZiAoIXRoaXMuX2Fubm90YXRpb25zKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIkFubm90YXRpb25zXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnM7XG4gIH1cbiAgZ2V0IHB1c2goKSB7XG4gICAgaWYgKCF0aGlzLl9wdXNoKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlB1c2hcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdXNoO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBub3JtYWxpc2VDaGFubmVsT3B0aW9ucygoX2EyID0gdGhpcy5jbGllbnQuX0NyeXB0bykgIT0gbnVsbCA/IF9hMiA6IG51bGwsIHRoaXMubG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBoaXN0b3J5KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF0sIHNlY29uZCA9IGFyZ3NbMV07XG4gICAgbGV0IG1lc3NhZ2VzO1xuICAgIGxldCBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiB8fCBmaXJzdCA9PT0gbnVsbCkge1xuICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoeyBuYW1lOiBmaXJzdCwgZGF0YTogc2Vjb25kIH0pXTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChmaXJzdCkpIHtcbiAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKGZpcnN0KV07XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIG1lc3NhZ2VzID0gbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShmaXJzdCk7XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIlRoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0c1wiLFxuICAgICAgICA0MDAxMyxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBvcHRpb25zID0gY2xpZW50Lm9wdGlvbnMsIGZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gY2xpZW50Lm9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyAmJiBhbGxFbXB0eUlkcyhtZXNzYWdlcykpIHtcbiAgICAgIGNvbnN0IG1zZ0lkQmFzZSA9IGF3YWl0IHJhbmRvbVN0cmluZyhNU0dfSURfRU5UUk9QWV9CWVRFUyk7XG4gICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBtc2dJZEJhc2UgKyBcIjpcIiArIGluZGV4LnRvU3RyaW5nKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2VzID0gYXdhaXQgZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMpO1xuICAgIGNvbnN0IHNpemUgPSBnZXRNZXNzYWdlc1NpemUod2lyZU1lc3NhZ2VzKSwgbWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgIGlmIChzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGBNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKHdhcyAke3NpemV9IGJ5dGVzOyBsaW1pdCBpcyAke21heE1lc3NhZ2VTaXplfSBieXRlcylgLFxuICAgICAgICA0MDAwOSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVibGlzaChzZXJpYWxpemUod2lyZU1lc3NhZ2VzLCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCksIGhlYWRlcnMsIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgX3B1Ymxpc2gocmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi87XG4gICAgY29uc3QgeyBib2R5LCB1bnBhY2tlZCB9ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KFxuICAgICAgY2xpZW50LFxuICAgICAgY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmJhc2VQYXRoKHRoaXMpICsgXCIvbWVzc2FnZXNcIixcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCBkZWNvZGVkID0gKHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpKSB8fCB7fTtcbiAgICBkZWxldGUgZGVjb2RlZFtcImNoYW5uZWxcIl07XG4gICAgZGVsZXRlIGRlY29kZWRbXCJtZXNzYWdlSWRcIl07XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbiAgYXN5bmMgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5zdGF0dXModGhpcyk7XG4gIH1cbiAgYXN5bmMgZ2V0TWVzc2FnZShzZXJpYWxPck1lc3NhZ2UpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0Q2hhbm5lbC5nZXRNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5nZXRNZXNzYWdlKHRoaXMsIHNlcmlhbE9yTWVzc2FnZSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLnVwZGF0ZU1lc3NhZ2UoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnVwZGF0ZURlbGV0ZU1lc3NhZ2UodGhpcywgXCJtZXNzYWdlLnVwZGF0ZVwiLCBtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLmRlbGV0ZU1lc3NhZ2UoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnVwZGF0ZURlbGV0ZU1lc3NhZ2UodGhpcywgXCJtZXNzYWdlLmRlbGV0ZVwiLCBtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgYXBwZW5kTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLmFwcGVuZE1lc3NhZ2UoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnVwZGF0ZURlbGV0ZU1lc3NhZ2UodGhpcywgXCJtZXNzYWdlLmFwcGVuZFwiLCBtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZ2V0TWVzc2FnZVZlcnNpb25zKHNlcmlhbE9yTWVzc2FnZSwgcGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVzdENoYW5uZWwuZ2V0TWVzc2FnZVZlcnNpb25zKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5nZXRNZXNzYWdlVmVyc2lvbnModGhpcywgc2VyaWFsT3JNZXNzYWdlLCBwYXJhbXMpO1xuICB9XG59O1xudmFyIHJlc3RjaGFubmVsX2RlZmF1bHQgPSBSZXN0Q2hhbm5lbDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvc3RhdHMudHNcbnZhciBTdGF0cyA9IGNsYXNzIF9TdGF0cyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgIHRoaXMuZW50cmllcyA9IHZhbHVlcyAmJiB2YWx1ZXMuZW50cmllcyB8fCB2b2lkIDA7XG4gICAgdGhpcy5zY2hlbWEgPSB2YWx1ZXMgJiYgdmFsdWVzLnNjaGVtYSB8fCB2b2lkIDA7XG4gICAgdGhpcy5hcHBJZCA9IHZhbHVlcyAmJiB2YWx1ZXMuYXBwSWQgfHwgdm9pZCAwO1xuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IHZhbHVlcyAmJiB2YWx1ZXMuaW5Qcm9ncmVzcyB8fCB2b2lkIDA7XG4gICAgdGhpcy51bml0ID0gdmFsdWVzICYmIHZhbHVlcy51bml0IHx8IHZvaWQgMDtcbiAgICB0aGlzLmludGVydmFsSWQgPSB2YWx1ZXMgJiYgdmFsdWVzLmludGVydmFsSWQgfHwgdm9pZCAwO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgX1N0YXRzKHZhbHVlcyk7XG4gIH1cbn07XG52YXIgc3RhdHNfZGVmYXVsdCA9IFN0YXRzO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdGNoYW5uZWxtaXhpbi50c1xudmFyIFJlc3RDaGFubmVsTWl4aW4gPSBjbGFzcyB7XG4gIHN0YXRpYyBiYXNlUGF0aChjaGFubmVsKSB7XG4gICAgcmV0dXJuIFwiL2NoYW5uZWxzL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGNoYW5uZWwubmFtZSk7XG4gIH1cbiAgc3RhdGljIGhpc3RvcnkoY2hhbm5lbCwgcGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gY2hhbm5lbC5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gY2hhbm5lbC5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KGNsaWVudCwgdGhpcy5iYXNlUGF0aChjaGFubmVsKSArIFwiL21lc3NhZ2VzXCIsIGhlYWRlcnMsIGVudmVsb3BlLCBhc3luYyBmdW5jdGlvbihib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpIHtcbiAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgIHJldHVybiBfZnJvbUVuY29kZWRBcnJheTIoZGVjb2RlZCwgY2hhbm5lbCk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHN0YXR1cyhjaGFubmVsKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gY2hhbm5lbC5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjaGFubmVsLmNsaWVudC5vcHRpb25zKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KFxuICAgICAgY2hhbm5lbC5jbGllbnQsXG4gICAgICB0aGlzLmJhc2VQYXRoKGNoYW5uZWwpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgZm9ybWF0LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldE1lc3NhZ2UoY2hhbm5lbCwgc2VyaWFsT3JNZXNzYWdlKSB7XG4gICAgY29uc3Qgc2VyaWFsID0gdHlwZW9mIHNlcmlhbE9yTWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHNlcmlhbE9yTWVzc2FnZSA6IHNlcmlhbE9yTWVzc2FnZS5zZXJpYWw7XG4gICAgaWYgKCFzZXJpYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICdUaGlzIG1lc3NhZ2UgbGFja3MgYSBzZXJpYWwuIE1ha2Ugc3VyZSB5b3UgaGF2ZSBlbmFibGVkIFwiTWVzc2FnZSBhbm5vdGF0aW9ucywgdXBkYXRlcywgYW5kIGRlbGV0ZXNcIiBpbiBjaGFubmVsIHNldHRpbmdzIG9uIHlvdXIgZGFzaGJvYXJkLicsXG4gICAgICAgIDQwMDAzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IGNoYW5uZWwuY2xpZW50O1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi87XG4gICAgY29uc3QgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHsgYm9keSwgdW5wYWNrZWQgfSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChjaGFubmVsKSArIFwiL21lc3NhZ2VzL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNlcmlhbCksXG4gICAgICBoZWFkZXJzLFxuICAgICAge30sXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3QgZGVjb2RlZCA9IHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIHJldHVybiBfZnJvbUVuY29kZWQyKGRlY29kZWQsIGNoYW5uZWwpO1xuICB9XG4gIHN0YXRpYyBhc3luYyB1cGRhdGVEZWxldGVNZXNzYWdlKGNoYW5uZWwsIGFjdGlvbiwgbWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpIHtcbiAgICBpZiAoIW1lc3NhZ2Uuc2VyaWFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAnVGhpcyBtZXNzYWdlIGxhY2tzIGEgc2VyaWFsIGFuZCBjYW5ub3QgYmUgdXBkYXRlZC4gTWFrZSBzdXJlIHlvdSBoYXZlIGVuYWJsZWQgXCJNZXNzYWdlIGFubm90YXRpb25zLCB1cGRhdGVzLCBhbmQgZGVsZXRlc1wiIGluIGNoYW5uZWwgc2V0dGluZ3Mgb24geW91ciBkYXNoYm9hcmQuJyxcbiAgICAgICAgNDAwMDMsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gY2hhbm5lbC5jbGllbnQ7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlcXVlc3RNZXNzYWdlID0gbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMobWVzc2FnZSk7XG4gICAgcmVxdWVzdE1lc3NhZ2UuYWN0aW9uID0gYWN0aW9uO1xuICAgIHJlcXVlc3RNZXNzYWdlLnZlcnNpb24gPSBvcGVyYXRpb247XG4gICAgY29uc3QgZW5jb2RlZCA9IGF3YWl0IHJlcXVlc3RNZXNzYWdlLmVuY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zKTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHNlcmlhbGl6ZShlbmNvZGVkLCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlc291cmNlX2RlZmF1bHQucGF0Y2g7XG4gICAgY29uc3QgeyBib2R5LCB1bnBhY2tlZCB9ID0gYXdhaXQgbWV0aG9kKFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChjaGFubmVsKSArIFwiL21lc3NhZ2VzL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KG1lc3NhZ2Uuc2VyaWFsKSxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyB8fCB7fSxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgcmV0dXJuIGRlY29kZWQgfHwgeyB2ZXJzaW9uU2VyaWFsOiBudWxsIH07XG4gIH1cbiAgc3RhdGljIGdldE1lc3NhZ2VWZXJzaW9ucyhjaGFubmVsLCBzZXJpYWxPck1lc3NhZ2UsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlcmlhbCA9IHR5cGVvZiBzZXJpYWxPck1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBzZXJpYWxPck1lc3NhZ2UgOiBzZXJpYWxPck1lc3NhZ2Uuc2VyaWFsO1xuICAgIGlmICghc2VyaWFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAnVGhpcyBtZXNzYWdlIGxhY2tzIGEgc2VyaWFsLiBNYWtlIHN1cmUgeW91IGhhdmUgZW5hYmxlZCBcIk1lc3NhZ2UgYW5ub3RhdGlvbnMsIHVwZGF0ZXMsIGFuZCBkZWxldGVzXCIgaW4gY2hhbm5lbCBzZXR0aW5ncyBvbiB5b3VyIGRhc2hib2FyZC4nLFxuICAgICAgICA0MDAwMyxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBjaGFubmVsLmNsaWVudDtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovO1xuICAgIGNvbnN0IGVudmVsb3BlID0gY2hhbm5lbC5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLmJhc2VQYXRoKGNoYW5uZWwpICsgXCIvbWVzc2FnZXMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoc2VyaWFsKSArIFwiL3ZlcnNpb25zXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgZW52ZWxvcGUsXG4gICAgICBhc3luYyAoYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZEFycmF5MihkZWNvZGVkLCBjaGFubmVsKTtcbiAgICAgIH1cbiAgICApLmdldChwYXJhbXMgfHwge30pO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdHByZXNlbmNlbWl4aW4udHNcbnZhciBSZXN0UHJlc2VuY2VNaXhpbiA9IGNsYXNzIHtcbiAgc3RhdGljIGJhc2VQYXRoKHByZXNlbmNlKSB7XG4gICAgcmV0dXJuIFJlc3RDaGFubmVsTWl4aW4uYmFzZVBhdGgocHJlc2VuY2UuY2hhbm5lbCkgKyBcIi9wcmVzZW5jZVwiO1xuICB9XG4gIHN0YXRpYyBhc3luYyBoaXN0b3J5KHByZXNlbmNlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLmJhc2VQYXRoKHByZXNlbmNlKSArIFwiL2hpc3RvcnlcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnZlbG9wZSxcbiAgICAgIGFzeW5jIChib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpID0+IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgICAgICByZXR1cm4gX2Zyb21FbmNvZGVkQXJyYXkoZGVjb2RlZCwgcHJlc2VuY2UuY2hhbm5lbCk7XG4gICAgICB9XG4gICAgKS5nZXQocGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3QudHNcbnZhciBSZXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNoYW5uZWxNaXhpbiA9IFJlc3RDaGFubmVsTWl4aW47XG4gICAgdGhpcy5wcmVzZW5jZU1peGluID0gUmVzdFByZXNlbmNlTWl4aW47XG4gICAgLy8gZXhwb3NlZCBmb3IgcGx1Z2lucyBidXQgc2hvdWxkbid0IGJlIGJ1bmRsZWQgd2l0aCBtaW5pbWFsIHJlYWx0aW1lXG4gICAgdGhpcy5SZXNvdXJjZSA9IHJlc291cmNlX2RlZmF1bHQ7XG4gICAgdGhpcy5QYWdpbmF0ZWRSZXNvdXJjZSA9IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQ7XG4gICAgdGhpcy5EZXZpY2VEZXRhaWxzID0gZGV2aWNlZGV0YWlsc19kZWZhdWx0O1xuICAgIHRoaXMuUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0O1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcy5jbGllbnQpO1xuICAgIHRoaXMucHVzaCA9IG5ldyBwdXNoX2RlZmF1bHQodGhpcy5jbGllbnQpO1xuICB9XG4gIGFzeW5jIHN0YXRzKHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpLCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KHRoaXMuY2xpZW50LCBcIi9zdGF0c1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgKGJvZHksIF8sIHVucGFja2VkKSA9PiB7XG4gICAgICBjb25zdCBzdGF0c1ZhbHVlcyA9IHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRzVmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdGF0c1ZhbHVlc1tpXSA9IHN0YXRzX2RlZmF1bHQuZnJvbVZhbHVlcyhzdGF0c1ZhbHVlc1tpXSk7XG4gICAgICByZXR1cm4gc3RhdHNWYWx1ZXM7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgdGltZShwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdDogXCJqc29uXCIgLyoganNvbiAqLyB9KTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCB0aW1lVXJpID0gKGhvc3QpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5iYXNlVXJpKGhvc3QpICsgXCIvdGltZVwiO1xuICAgIH07XG4gICAgbGV0IHsgZXJyb3IsIGJvZHksIHVucGFja2VkIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5odHRwLmRvKFxuICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsXG4gICAgICB0aW1lVXJpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG51bGwsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICghdW5wYWNrZWQpXG4gICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICBjb25zdCB0aW1lID0gYm9keVswXTtcbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJJbnRlcm5hbCBlcnJvciAodW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIEdFVCAvdGltZSlcIiwgNWU0LCA1MDApO1xuICAgIH1cbiAgICB0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0ID0gdGltZSAtIERhdGUubm93KCk7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChtZXRob2QsIHBhdGgsIHZlcnNpb24yLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IFtlbmNvZGVyLCBkZWNvZGVyLCBmb3JtYXRdID0gKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQuX01zZ1BhY2spIHtcbiAgICAgICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLmNsaWVudC5fTXNnUGFjay5lbmNvZGUsIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLmRlY29kZSwgXCJtc2dwYWNrXCIgLyogbXNncGFjayAqL107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW0pTT04uc3RyaW5naWZ5LCBKU09OLnBhcnNlLCBcImpzb25cIiAvKiBqc29uICovXTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIGNvbnN0IGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb25zdCBfbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IF9tZXRob2QgPT0gXCJnZXRcIiA/IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQsIHByb3RvY29sVmVyc2lvbjogdmVyc2lvbjIgfSkgOiBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCwgcHJvdG9jb2xWZXJzaW9uOiB2ZXJzaW9uMiB9KTtcbiAgICBpZiAodHlwZW9mIGJvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJvZHkgPSAoX2EyID0gZW5jb2Rlcihib2R5KSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgfVxuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGN1c3RvbUhlYWRlcnMpIHtcbiAgICAgIG1peGluKGhlYWRlcnMsIGN1c3RvbUhlYWRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgdGhpcy5jbGllbnQsXG4gICAgICBwYXRoLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgZnVuY3Rpb24ocmVzYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVBcnJheSh1bnBhY2tlZCA/IHJlc2JvZHkgOiBkZWNvZGVyKHJlc2JvZHkpKTtcbiAgICAgIH0sXG4gICAgICAvKiB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2U6ICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAoIVBsYXRmb3JtLkh0dHAubWV0aG9kcy5pbmNsdWRlcyhfbWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuc3VwcG9ydGVkIG1ldGhvZCBcIiArIF9tZXRob2QsIDQwNTAwLCA0MDUpO1xuICAgIH1cbiAgICBpZiAoUGxhdGZvcm0uSHR0cC5tZXRob2RzV2l0aEJvZHkuaW5jbHVkZXMoX21ldGhvZCkpIHtcbiAgICAgIHJldHVybiBwYWdpbmF0ZWRSZXNvdXJjZVtfbWV0aG9kXShwYXJhbXMsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKSB7XG4gICAgbGV0IHJlcXVlc3RCb2R5RFRPO1xuICAgIGxldCBzaW5nbGVTcGVjTW9kZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjT3JTcGVjcykpIHtcbiAgICAgIHJlcXVlc3RCb2R5RFRPID0gc3BlY09yU3BlY3M7XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0Qm9keURUTyA9IFtzcGVjT3JTcGVjc107XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpO1xuICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QodGhpcy5jbGllbnQsIFwiL21lc3NhZ2VzXCIsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB7fSwgbnVsbCwgdHJ1ZSk7XG4gICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBpZiAoc2luZ2xlU3BlY01vZGUpIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHM7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpO1xuICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IGNoYW5uZWxzUGFyYW0gPSBjaGFubmVscy5qb2luKFwiLFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KHRoaXMuY2xpZW50LCBcIi9wcmVzZW5jZVwiLCBoZWFkZXJzLCB7IGNoYW5uZWxzOiBjaGFubmVsc1BhcmFtIH0sIG51bGwsIHRydWUpO1xuICAgIHJldHVybiByZXNwb25zZS51bnBhY2tlZCA/IHJlc3BvbnNlLmJvZHkgOiBkZWNvZGVCb2R5KHJlc3BvbnNlLmJvZHksIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICB9XG4gIGFzeW5jIHJldm9rZVRva2VucyhzcGVjaWZpZXJzLCBvcHRpb25zKSB7XG4gICAgaWYgKHVzZVRva2VuQXV0aCh0aGlzLmNsaWVudC5vcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIkNhbm5vdCByZXZva2UgdG9rZW5zIHdoZW4gdXNpbmcgdG9rZW4gYXV0aFwiLCA0MDE2MiwgNDAxKTtcbiAgICB9XG4gICAgY29uc3Qga2V5TmFtZSA9IHRoaXMuY2xpZW50Lm9wdGlvbnMua2V5TmFtZTtcbiAgICBsZXQgcmVzb2x2ZWRPcHRpb25zID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5RFRPID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgdGFyZ2V0czogc3BlY2lmaWVycy5tYXAoKHNwZWNpZmllcikgPT4gYCR7c3BlY2lmaWVyLnR5cGV9OiR7c3BlY2lmaWVyLnZhbHVlfWApXG4gICAgfSwgcmVzb2x2ZWRPcHRpb25zKTtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkocmVxdWVzdEJvZHlEVE8sIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KFxuICAgICAgdGhpcy5jbGllbnQsXG4gICAgICBgL2tleXMvJHtrZXlOYW1lfS9yZXZva2VUb2tlbnNgLFxuICAgICAgcmVxdWVzdEJvZHksXG4gICAgICBoZWFkZXJzLFxuICAgICAge30sXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnVucGFja2VkID8gcmVzcG9uc2UuYm9keSA6IGRlY29kZUJvZHkocmVzcG9uc2UuYm9keSwgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gIH1cbn07XG52YXIgQ2hhbm5lbHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuYWxsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZ2V0KG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICBsZXQgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgdGhpcy5hbGxbbmFtZV0gPSBjaGFubmVsID0gbmV3IHJlc3RjaGFubmVsX2RlZmF1bHQodGhpcy5jbGllbnQsIG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICBjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbm5lbDtcbiAgfVxuICAvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cbiAgICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cbiAgcmVsZWFzZShuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuYWxsW1N0cmluZyhuYW1lKV07XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9iYXNlcmVzdC50c1xudmFyIEJhc2VSZXN0ID0gY2xhc3MgZXh0ZW5kcyBiYXNlY2xpZW50X2RlZmF1bHQge1xuICAvKlxuICAgKiBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgb25seSBhY2NlcHRzIGFuIG9iamVjdCwgYnV0IHNpbmNlIHdlIHdhbnQgdG8gZW1pdCBhIGdvb2QgZXJyb3IgbWVzc2FnZSBpbiB0aGUgY2FzZSB3aGVyZSBhIG5vbi1UeXBlU2NyaXB0IHVzZXIgZG9lcyBvbmUgb2YgdGhlc2UgdGhpbmdzOlxuICAgKlxuICAgKiAxLiBwYXNzZXMgYSBzdHJpbmcgKHdoaWNoIGlzIHF1aXRlIGxpa2VseSBpZiB0aGV54oCZcmUgZS5nLiBtaWdyYXRpbmcgZnJvbSB0aGUgZGVmYXVsdCB2YXJpYW50IHRvIHRoZSBtb2R1bGFyIHZhcmlhbnQpXG4gICAqIDIuIHBhc3NlcyBubyBhcmd1bWVudCBhdCBhbGxcbiAgICpcbiAgICogdGVsbCB0aGUgY29tcGlsZXIgdGhhdCB0aGVzZSBjYXNlcyBhcmUgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIHRoZW0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIGZhbHNlLCBcIkJhc2VSZXN0XCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIHsgUmVzdCB9KSk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9tb2R1bGFycGx1Z2lucy50c1xudmFyIGFsbENvbW1vbk1vZHVsYXJQbHVnaW5zID0geyBSZXN0IH07XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2RlZmF1bHRtZXNzYWdlLnRzXG52YXIgRGVmYXVsdE1lc3NhZ2UgPSBjbGFzcyBleHRlbmRzIG1lc3NhZ2VfZGVmYXVsdCB7XG4gIHN0YXRpYyBhc3luYyBmcm9tRW5jb2RlZChlbmNvZGVkLCBpbnB1dE9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWQyKGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIFBsYXRmb3JtLkNyeXB0bywgZW5jb2RlZCwgaW5wdXRPcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWRBcnJheTIobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgUGxhdGZvcm0uQ3J5cHRvLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyh2YWx1ZXMpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZWZhdWx0cHJlc2VuY2VtZXNzYWdlLnRzXG52YXIgRGVmYXVsdFByZXNlbmNlTWVzc2FnZSA9IGNsYXNzIGV4dGVuZHMgcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQge1xuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWQoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkKGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIFBsYXRmb3JtLkNyeXB0bywgZW5jb2RlZCwgaW5wdXRPcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWRBcnJheShsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWRBcnJheSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXModmFsdWVzKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvYW5ub3RhdGlvbi50c1xudmFyIGFjdGlvbnM0ID0gW1wiYW5ub3RhdGlvbi5jcmVhdGVcIiwgXCJhbm5vdGF0aW9uLmRlbGV0ZVwiXTtcbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkMyhsb2dnZXIsIGVuY29kZWQsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2EgPSBXaXJlQW5ub3RhdGlvbi5mcm9tVmFsdWVzKGVuY29kZWQpO1xuICByZXR1cm4gd2EuZGVjb2RlKG9wdGlvbnMgfHwge30sIGxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZEFycmF5Myhsb2dnZXIsIGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gZnJvbUVuY29kZWQzKGxvZ2dlciwgZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZDMoZW5jb2RlZCwgY2hhbm5lbCkge1xuICByZXR1cm4gV2lyZUFubm90YXRpb24uZnJvbVZhbHVlcyhlbmNvZGVkKS5kZWNvZGUoY2hhbm5lbC5jaGFubmVsT3B0aW9ucywgY2hhbm5lbC5sb2dnZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gX2Zyb21FbmNvZGVkQXJyYXkzKGVuY29kZWRBcnJheSwgY2hhbm5lbCkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkMyhlbmNvZGVkLCBjaGFubmVsKTtcbiAgICB9KVxuICApO1xufVxudmFyIEFubm90YXRpb24gPSBjbGFzcyBfQW5ub3RhdGlvbiBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgYXN5bmMgZW5jb2RlKCkge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFdpcmVBbm5vdGF0aW9uKCksIHRoaXMsIHtcbiAgICAgIGFjdGlvbjogYWN0aW9uczQuaW5kZXhPZih0aGlzLmFjdGlvbiB8fCBcImFubm90YXRpb24uY3JlYXRlXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuIGVuY29kZShyZXMsIHt9KTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX0Fubm90YXRpb24oKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfQW5ub3RhdGlvbi5mcm9tVmFsdWVzKHYpKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiQW5ub3RhdGlvblwiKTtcbiAgfVxufTtcbnZhciBXaXJlQW5ub3RhdGlvbiA9IGNsYXNzIF9XaXJlQW5ub3RhdGlvbiBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgdG9KU09OKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gd2lyZVRvSlNPTi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfV2lyZUFubm90YXRpb24oKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfV2lyZUFubm90YXRpb24uZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgYXN5bmMgZGVjb2RlKGNoYW5uZWxPcHRpb25zLCBsb2dnZXIpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBBbm5vdGF0aW9uKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMpLCB7XG4gICAgICBhY3Rpb246IGFjdGlvbnM0W3RoaXMuYWN0aW9uXVxuICAgIH0pKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZGVjb2RlKHJlcywgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXaXJlQW5ub3RhdGlvbi5kZWNvZGUoKVwiLCBpbnNwZWN0RXJyb3IoZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJNc2codGhpcywgXCJXaXJlQW5ub3RhdGlvblwiKTtcbiAgfVxufTtcbnZhciBhbm5vdGF0aW9uX2RlZmF1bHQgPSBBbm5vdGF0aW9uO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZWZhdWx0YW5ub3RhdGlvbi50c1xudmFyIERlZmF1bHRBbm5vdGF0aW9uID0gY2xhc3MgZXh0ZW5kcyBhbm5vdGF0aW9uX2RlZmF1bHQge1xuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWQoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkMyhsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBlbmNvZGVkLCBpbnB1dE9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tRW5jb2RlZEFycmF5KGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZEFycmF5Myhsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBhbm5vdGF0aW9uX2RlZmF1bHQuZnJvbVZhbHVlcyh2YWx1ZXMpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdGFubm90YXRpb25zLnRzXG5mdW5jdGlvbiBzZXJpYWxGcm9tTXNnT3JTZXJpYWwobXNnT3JTZXJpYWwpIHtcbiAgbGV0IG1lc3NhZ2VTZXJpYWw7XG4gIHN3aXRjaCAodHlwZW9mIG1zZ09yU2VyaWFsKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgbWVzc2FnZVNlcmlhbCA9IG1zZ09yU2VyaWFsO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgbWVzc2FnZVNlcmlhbCA9IG1zZ09yU2VyaWFsLnNlcmlhbDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICghbWVzc2FnZVNlcmlhbCB8fCB0eXBlb2YgbWVzc2FnZVNlcmlhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIkZpcnN0IGFyZ3VtZW50IG9mIGFubm90YXRpb25zLnB1Ymxpc2goKSBtdXN0IGJlIGVpdGhlciBhIE1lc3NhZ2UgKG9yIGF0IGxlYXN0IGFuIG9iamVjdCB3aXRoIGEgc3RyaW5nIGBzZXJpYWxgIHByb3BlcnR5KSBvciBhIG1lc3NhZ2Ugc2VyaWFsIChzdHJpbmcpXCIsXG4gICAgICA0MDAwMyxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VTZXJpYWw7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RWYWxpZGF0ZUFubm90YXRpb24obXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgY29uc3QgbWVzc2FnZVNlcmlhbCA9IHNlcmlhbEZyb21Nc2dPclNlcmlhbChtc2dPclNlcmlhbCk7XG4gIGlmICghYW5ub3RhdGlvblZhbHVlcyB8fCB0eXBlb2YgYW5ub3RhdGlvblZhbHVlcyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIlNlY29uZCBhcmd1bWVudCBvZiBhbm5vdGF0aW9ucy5wdWJsaXNoKCkgbXVzdCBiZSBhbiBvYmplY3QgKHRoZSBpbnRlbmRlZCBhbm5vdGF0aW9uIHRvIHB1Ymxpc2gpXCIsXG4gICAgICA0MDAwMyxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgY29uc3QgYW5ub3RhdGlvbiA9IGFubm90YXRpb25fZGVmYXVsdC5mcm9tVmFsdWVzKGFubm90YXRpb25WYWx1ZXMpO1xuICBhbm5vdGF0aW9uLm1lc3NhZ2VTZXJpYWwgPSBtZXNzYWdlU2VyaWFsO1xuICBpZiAoIWFubm90YXRpb24uYWN0aW9uKSB7XG4gICAgYW5ub3RhdGlvbi5hY3Rpb24gPSBcImFubm90YXRpb24uY3JlYXRlXCI7XG4gIH1cbiAgcmV0dXJuIGFubm90YXRpb247XG59XG5mdW5jdGlvbiBiYXNlUGF0aEZvclNlcmlhbChjaGFubmVsLCBzZXJpYWwpIHtcbiAgcmV0dXJuIGNoYW5uZWwuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmJhc2VQYXRoKGNoYW5uZWwpICsgXCIvbWVzc2FnZXMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoc2VyaWFsKSArIFwiL2Fubm90YXRpb25zXCI7XG59XG52YXIgUmVzdEFubm90YXRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgfVxuICBhc3luYyBwdWJsaXNoKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKSB7XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IGNvbnN0cnVjdFZhbGlkYXRlQW5ub3RhdGlvbihtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcyk7XG4gICAgY29uc3Qgd2lyZUFubm90YXRpb24gPSBhd2FpdCBhbm5vdGF0aW9uLmVuY29kZSgpO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2hhbm5lbC5jbGllbnQsIG9wdGlvbnMgPSBjbGllbnQub3B0aW9ucywgZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpLCBwYXJhbXMgPSB7fTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoW3dpcmVBbm5vdGF0aW9uXSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIGNsaWVudCxcbiAgICAgIGJhc2VQYXRoRm9yU2VyaWFsKHRoaXMuY2hhbm5lbCwgYW5ub3RhdGlvbi5tZXNzYWdlU2VyaWFsKSxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuICBhc3luYyBkZWxldGUobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgICBhbm5vdGF0aW9uVmFsdWVzLmFjdGlvbiA9IFwiYW5ub3RhdGlvbi5kZWxldGVcIjtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKTtcbiAgfVxuICBhc3luYyBnZXQobXNnT3JTZXJpYWwsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2hhbm5lbC5jbGllbnQsIG1lc3NhZ2VTZXJpYWwgPSBzZXJpYWxGcm9tTXNnT3JTZXJpYWwobXNnT3JTZXJpYWwpLCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IGNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICBiYXNlUGF0aEZvclNlcmlhbCh0aGlzLmNoYW5uZWwsIG1lc3NhZ2VTZXJpYWwpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgKGJvZHksIF8sIHVucGFja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZEFycmF5MyhkZWNvZGVkLCB0aGlzLmNoYW5uZWwpO1xuICAgICAgfVxuICAgICkuZ2V0KHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcmVzdGFubm90YXRpb25zX2RlZmF1bHQgPSBSZXN0QW5ub3RhdGlvbnM7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3Byb3RvY29sbWVzc2FnZS50c1xudmFyIHNlcmlhbGl6ZTIgPSBlbmNvZGVCb2R5O1xuZnVuY3Rpb24gdG9TdHJpbmdBcnJheShhcnJheSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0udG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlsgXCIgKyByZXN1bHQuam9pbihcIiwgXCIpICsgXCIgXVwiO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCwgTXNnUGFjaywgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBhbm5vdGF0aW9uc1BsdWdpbiwgb2JqZWN0c1BsdWdpbiwgZm9ybWF0KSB7XG4gIGNvbnN0IGRlc2VyaWFsaXplZCA9IGRlY29kZUJvZHkoc2VyaWFsaXplZCwgTXNnUGFjaywgZm9ybWF0KTtcbiAgcmV0dXJuIGZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4sIGFubm90YXRpb25zUGx1Z2luLCBvYmplY3RzUGx1Z2luKTtcbn1cbmZ1bmN0aW9uIGZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4sIGFubm90YXRpb25zUGx1Z2luLCBvYmplY3RzUGx1Z2luKSB7XG4gIGxldCBlcnJvcjtcbiAgaWYgKGRlc2VyaWFsaXplZC5lcnJvcikge1xuICAgIGVycm9yID0gRXJyb3JJbmZvLmZyb21WYWx1ZXMoZGVzZXJpYWxpemVkLmVycm9yKTtcbiAgfVxuICBsZXQgbWVzc2FnZXM7XG4gIGlmIChkZXNlcmlhbGl6ZWQubWVzc2FnZXMpIHtcbiAgICBtZXNzYWdlcyA9IFdpcmVNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShkZXNlcmlhbGl6ZWQubWVzc2FnZXMpO1xuICB9XG4gIGxldCBwcmVzZW5jZTtcbiAgaWYgKHByZXNlbmNlTWVzc2FnZVBsdWdpbiAmJiBkZXNlcmlhbGl6ZWQucHJlc2VuY2UpIHtcbiAgICBwcmVzZW5jZSA9IHByZXNlbmNlTWVzc2FnZVBsdWdpbi5XaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShcbiAgICAgIGRlc2VyaWFsaXplZC5wcmVzZW5jZVxuICAgICk7XG4gIH1cbiAgbGV0IGFubm90YXRpb25zO1xuICBpZiAoYW5ub3RhdGlvbnNQbHVnaW4gJiYgZGVzZXJpYWxpemVkLmFubm90YXRpb25zKSB7XG4gICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9uc1BsdWdpbi5XaXJlQW5ub3RhdGlvbi5mcm9tVmFsdWVzQXJyYXkoXG4gICAgICBkZXNlcmlhbGl6ZWQuYW5ub3RhdGlvbnNcbiAgICApO1xuICB9XG4gIGxldCBzdGF0ZTtcbiAgaWYgKG9iamVjdHNQbHVnaW4gJiYgZGVzZXJpYWxpemVkLnN0YXRlKSB7XG4gICAgc3RhdGUgPSBvYmplY3RzUGx1Z2luLldpcmVPYmplY3RNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShcbiAgICAgIGRlc2VyaWFsaXplZC5zdGF0ZSxcbiAgICAgIHV0aWxzX2V4cG9ydHMsXG4gICAgICBNZXNzYWdlRW5jb2RpbmdcbiAgICApO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQcm90b2NvbE1lc3NhZ2UoKSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVzZXJpYWxpemVkKSwgeyBwcmVzZW5jZSwgbWVzc2FnZXMsIGFubm90YXRpb25zLCBzdGF0ZSwgZXJyb3IgfSkpO1xufVxuZnVuY3Rpb24gbWFrZUZyb21EZXNlcmlhbGl6ZWRXaXRoRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcykge1xuICByZXR1cm4gKGRlc2VyaWFsaXplZCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIGZyb21EZXNlcmlhbGl6ZWQoXG4gICAgICBkZXNlcmlhbGl6ZWQsXG4gICAgICB7XG4gICAgICAgIFByZXNlbmNlTWVzc2FnZTogcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQsXG4gICAgICAgIFdpcmVQcmVzZW5jZU1lc3NhZ2VcbiAgICAgIH0sXG4gICAgICB7IEFubm90YXRpb246IGFubm90YXRpb25fZGVmYXVsdCwgV2lyZUFubm90YXRpb24sIFJlYWx0aW1lQW5ub3RhdGlvbnM6IHJlYWx0aW1lYW5ub3RhdGlvbnNfZGVmYXVsdCwgUmVzdEFubm90YXRpb25zOiByZXN0YW5ub3RhdGlvbnNfZGVmYXVsdCB9LFxuICAgICAgKF9hMiA9IGRlcGVuZGVuY2llcyA9PSBudWxsID8gdm9pZCAwIDogZGVwZW5kZW5jaWVzLkxpdmVPYmplY3RzUGx1Z2luKSAhPSBudWxsID8gX2EyIDogbnVsbFxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tVmFsdWVzKHZhbHVlcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkobXNnLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4sIGFubm90YXRpb25zUGx1Z2luLCBvYmplY3RzUGx1Z2luKSB7XG4gIGxldCByZXN1bHQgPSBcIltQcm90b2NvbE1lc3NhZ2VcIjtcbiAgaWYgKG1zZy5hY3Rpb24gIT09IHZvaWQgMClcbiAgICByZXN1bHQgKz0gXCI7IGFjdGlvbj1cIiArIEFjdGlvbk5hbWVbbXNnLmFjdGlvbl0gfHwgbXNnLmFjdGlvbjtcbiAgY29uc3Qgc2ltcGxlQXR0cmlidXRlcyA9IFtcImlkXCIsIFwiY2hhbm5lbFwiLCBcImNoYW5uZWxTZXJpYWxcIiwgXCJjb25uZWN0aW9uSWRcIiwgXCJjb3VudFwiLCBcIm1zZ1NlcmlhbFwiLCBcInRpbWVzdGFtcFwiXTtcbiAgbGV0IGF0dHJpYnV0ZTtcbiAgZm9yIChsZXQgYXR0cmliSW5kZXggPSAwOyBhdHRyaWJJbmRleCA8IHNpbXBsZUF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyaWJJbmRleCsrKSB7XG4gICAgYXR0cmlidXRlID0gc2ltcGxlQXR0cmlidXRlc1thdHRyaWJJbmRleF07XG4gICAgaWYgKG1zZ1thdHRyaWJ1dGVdICE9PSB2b2lkIDApXG4gICAgICByZXN1bHQgKz0gXCI7IFwiICsgYXR0cmlidXRlICsgXCI9XCIgKyBtc2dbYXR0cmlidXRlXTtcbiAgfVxuICBpZiAobXNnLm1lc3NhZ2VzKVxuICAgIHJlc3VsdCArPSBcIjsgbWVzc2FnZXM9XCIgKyB0b1N0cmluZ0FycmF5KFdpcmVNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShtc2cubWVzc2FnZXMpKTtcbiAgaWYgKG1zZy5wcmVzZW5jZSAmJiBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4pXG4gICAgcmVzdWx0ICs9IFwiOyBwcmVzZW5jZT1cIiArIHRvU3RyaW5nQXJyYXkocHJlc2VuY2VNZXNzYWdlUGx1Z2luLldpcmVQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KG1zZy5wcmVzZW5jZSkpO1xuICBpZiAobXNnLmFubm90YXRpb25zICYmIGFubm90YXRpb25zUGx1Z2luKSB7XG4gICAgcmVzdWx0ICs9IFwiOyBhbm5vdGF0aW9ucz1cIiArIHRvU3RyaW5nQXJyYXkoYW5ub3RhdGlvbnNQbHVnaW4uV2lyZUFubm90YXRpb24uZnJvbVZhbHVlc0FycmF5KG1zZy5hbm5vdGF0aW9ucykpO1xuICB9XG4gIGlmIChtc2cuc3RhdGUgJiYgb2JqZWN0c1BsdWdpbikge1xuICAgIHJlc3VsdCArPSBcIjsgc3RhdGU9XCIgKyB0b1N0cmluZ0FycmF5KG9iamVjdHNQbHVnaW4uV2lyZU9iamVjdE1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KG1zZy5zdGF0ZSwgdXRpbHNfZXhwb3J0cywgTWVzc2FnZUVuY29kaW5nKSk7XG4gIH1cbiAgaWYgKG1zZy5lcnJvcilcbiAgICByZXN1bHQgKz0gXCI7IGVycm9yPVwiICsgRXJyb3JJbmZvLmZyb21WYWx1ZXMobXNnLmVycm9yKS50b1N0cmluZygpO1xuICBpZiAobXNnLmF1dGggJiYgbXNnLmF1dGguYWNjZXNzVG9rZW4pXG4gICAgcmVzdWx0ICs9IFwiOyB0b2tlbj1cIiArIG1zZy5hdXRoLmFjY2Vzc1Rva2VuO1xuICBpZiAobXNnLmZsYWdzKVxuICAgIHJlc3VsdCArPSBcIjsgZmxhZ3M9XCIgKyBmbGFnTmFtZXMuZmlsdGVyKG1zZy5oYXNGbGFnKS5qb2luKFwiLFwiKTtcbiAgaWYgKG1zZy5wYXJhbXMpIHtcbiAgICBsZXQgc3RyaW5naWZpZWRQYXJhbXMgPSBcIlwiO1xuICAgIGZvckluT3duTm9uTnVsbFByb3BlcnRpZXMobXNnLnBhcmFtcywgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgaWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyaW5naWZpZWRQYXJhbXMgKz0gXCI7IFwiO1xuICAgICAgfVxuICAgICAgc3RyaW5naWZpZWRQYXJhbXMgKz0gcHJvcCArIFwiPVwiICsgbXNnLnBhcmFtc1twcm9wXTtcbiAgICB9KTtcbiAgICBpZiAoc3RyaW5naWZpZWRQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0ICs9IFwiOyBwYXJhbXM9W1wiICsgc3RyaW5naWZpZWRQYXJhbXMgKyBcIl1cIjtcbiAgICB9XG4gIH1cbiAgcmVzdWx0ICs9IFwiXVwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFByb3RvY29sTWVzc2FnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYXNGbGFnID0gKGZsYWcpID0+IHtcbiAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIGZsYWdzW2ZsYWddKSA+IDA7XG4gICAgfTtcbiAgfVxuICBzZXRGbGFnKGZsYWcpIHtcbiAgICByZXR1cm4gdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBmbGFnc1tmbGFnXTtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyB8fCAwKSAmIGZsYWdzLk1PREVfQUxMO1xuICB9XG4gIGVuY29kZU1vZGVzVG9GbGFncyhtb2Rlcykge1xuICAgIG1vZGVzLmZvckVhY2goKG1vZGUpID0+IHRoaXMuc2V0RmxhZyhtb2RlKSk7XG4gIH1cbiAgZGVjb2RlTW9kZXNGcm9tRmxhZ3MoKSB7XG4gICAgY29uc3QgbW9kZXMgPSBbXTtcbiAgICBjaGFubmVsTW9kZXMuZm9yRWFjaCgobW9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzRmxhZyhtb2RlKSkge1xuICAgICAgICBtb2Rlcy5wdXNoKG1vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2Rlcy5sZW5ndGggPiAwID8gbW9kZXMgOiB2b2lkIDA7XG4gIH1cbn07XG52YXIgcHJvdG9jb2xtZXNzYWdlX2RlZmF1bHQgPSBQcm90b2NvbE1lc3NhZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jaGFubmVsc3RhdGVjaGFuZ2UudHNcbnZhciBDaGFubmVsU3RhdGVDaGFuZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBjdXJyZW50LCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pIHtcbiAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICBpZiAoY3VycmVudCA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICB0aGlzLnJlc3VtZWQgPSByZXN1bWVkO1xuICAgICAgdGhpcy5oYXNCYWNrbG9nID0gaGFzQmFja2xvZztcbiAgICB9XG4gICAgaWYgKHJlYXNvbilcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59O1xudmFyIGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0ID0gQ2hhbm5lbFN0YXRlQ2hhbmdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWVjaGFubmVsLnRzXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBcInBhcmFtc1wiIGluIG9wdGlvbnMgJiYgIWlzT2JqZWN0KG9wdGlvbnMucGFyYW1zKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKFwib3B0aW9ucy5wYXJhbXMgbXVzdCBiZSBhbiBvYmplY3RcIiwgNGU0LCA0MDApO1xuICB9XG4gIGlmIChvcHRpb25zICYmIFwibW9kZXNcIiBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMubW9kZXMpKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcIm9wdGlvbnMubW9kZXMgbXVzdCBiZSBhbiBhcnJheVwiLCA0ZTQsIDQwMCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5tb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudE1vZGUgPSBvcHRpb25zLm1vZGVzW2ldO1xuICAgICAgaWYgKCFjdXJyZW50TW9kZSB8fCB0eXBlb2YgY3VycmVudE1vZGUgIT09IFwic3RyaW5nXCIgfHwgIWNoYW5uZWxNb2Rlcy5pbmNsdWRlcyhTdHJpbmcucHJvdG90eXBlLnRvVXBwZXJDYXNlLmNhbGwoY3VycmVudE1vZGUpKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcIkludmFsaWQgY2hhbm5lbCBtb2RlOiBcIiArIGN1cnJlbnRNb2RlLCA0ZTQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgUmVhbHRpbWVDaGFubmVsID0gY2xhc3MgX1JlYWx0aW1lQ2hhbm5lbCBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgIHN1cGVyKGNsaWVudC5sb2dnZXIpO1xuICAgIHRoaXMuX2Fubm90YXRpb25zID0gbnVsbDtcbiAgICB0aGlzLl9tb2RlID0gMDtcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMuaGlzdG9yeSA9IGFzeW5jIGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgICBjb25zdCByZXN0TWl4aW4gPSB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbjtcbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkXCIsIDRlNCwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgXCJ1bnRpbEF0dGFjaCB3YXMgc3BlY2lmaWVkIGFuZCBjaGFubmVsIGlzIGF0dGFjaGVkLCBidXQgYXR0YWNoU2VyaWFsIGlzIG5vdCBkZWZpbmVkXCIsXG4gICAgICAgICAgICA0ZTQsXG4gICAgICAgICAgICA0MDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG4gICAgICAgIHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdE1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgICB9O1xuICAgIHRoaXMud2hlblN0YXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRlbWl0dGVyX2RlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lQ2hhbm5lbCgpXCIsIFwic3RhcnRlZDsgbmFtZSA9IFwiICsgbmFtZSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IGNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuX3ByZXNlbmNlID0gY2xpZW50Ll9SZWFsdGltZVByZXNlbmNlID8gbmV3IGNsaWVudC5fUmVhbHRpbWVQcmVzZW5jZS5SZWFsdGltZVByZXNlbmNlKHRoaXMpIDogbnVsbDtcbiAgICBpZiAoY2xpZW50Ll9Bbm5vdGF0aW9ucykge1xuICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBuZXcgY2xpZW50Ll9Bbm5vdGF0aW9ucy5SZWFsdGltZUFubm90YXRpb25zKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5zdGF0ZSA9IFwiaW5pdGlhbGl6ZWRcIjtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgYXR0YWNoU2VyaWFsOiB2b2lkIDAsXG4gICAgICBjaGFubmVsU2VyaWFsOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWNvZGluZ0NvbnRleHQgPSB7XG4gICAgICBjaGFubmVsT3B0aW9uczogdGhpcy5jaGFubmVsT3B0aW9ucyxcbiAgICAgIHBsdWdpbnM6IGNsaWVudC5vcHRpb25zLnBsdWdpbnMgfHwge30sXG4gICAgICBiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLl9sYXN0UGF5bG9hZCA9IHtcbiAgICAgIG1lc3NhZ2VJZDogbnVsbCxcbiAgICAgIHByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw6IG51bGwsXG4gICAgICBkZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcyA9IG5ldyBldmVudGVtaXR0ZXJfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gICAgaWYgKChfYiA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5QdXNoKSB7XG4gICAgICB0aGlzLl9wdXNoID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5QdXNoQ2hhbm5lbCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKChfYyA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5MaXZlT2JqZWN0cykge1xuICAgICAgdGhpcy5fb2JqZWN0ID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuTGl2ZU9iamVjdHMuUmVhbHRpbWVPYmplY3QodGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBwcmVzZW5jZSgpIHtcbiAgICBpZiAoIXRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlJlYWx0aW1lUHJlc2VuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmVzZW5jZTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLl9hbm5vdGF0aW9ucykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJBbm5vdGF0aW9uc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Fubm90YXRpb25zO1xuICB9XG4gIGdldCBwdXNoKCkge1xuICAgIGlmICghdGhpcy5fcHVzaCkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVzaDtcbiAgfVxuICAvKiogQHNwZWMgUlRMMjcgKi9cbiAgZ2V0IG9iamVjdCgpIHtcbiAgICBpZiAoIXRoaXMuX29iamVjdCkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJMaXZlT2JqZWN0c1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdDtcbiAgfVxuICBpbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2hhbm5lbCBvcGVyYXRpb24gZmFpbGVkIGFzIGNoYW5uZWwgc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlLFxuICAgICAgOTAwMDEsXG4gICAgICA0MDAsXG4gICAgICB0aGlzLmVycm9yUmVhc29uIHx8IHZvaWQgMFxuICAgICk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncykge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuICBhc3luYyBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgIGNvbnN0IGVyciA9IHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IHRoaXMuY2xpZW50Ll9DcnlwdG8pICE9IG51bGwgPyBfYTIgOiBudWxsLCB0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuX2RlY29kaW5nQ29udGV4dClcbiAgICAgIHRoaXMuX2RlY29kaW5nQ29udGV4dC5jaGFubmVsT3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgaWYgKHRoaXMuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMsIHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMpKSB7XG4gICAgICB0aGlzLmF0dGFjaEltcGwoKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLm9uY2UoXG4gICAgICAgICAgW1wiYXR0YWNoZWRcIiwgXCJ1cGRhdGVcIiwgXCJkZXRhY2hlZFwiLCBcImZhaWxlZFwiXSxcbiAgICAgICAgICBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdChzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMob3B0aW9ucywgcHJldk9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ZWRQYXJhbXMgPSBvbWl0QWdlbnQob3B0aW9ucy5wYXJhbXMpO1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbXMgPSBvbWl0QWdlbnQocHJldk9wdGlvbnMucGFyYW1zKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQYXJhbXMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoZXhpc3RpbmdQYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2hhbGxvd0VxdWFscyhleGlzdGluZ1BhcmFtcywgcmVxdWVzdGVkUGFyYW1zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZXMpIHtcbiAgICAgIGlmICghcHJldk9wdGlvbnMubW9kZXMgfHwgIWFyckVxdWFscyhvcHRpb25zLm1vZGVzLCBwcmV2T3B0aW9ucy5tb2RlcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF0sIHNlY29uZCA9IGFyZ3NbMV07XG4gICAgbGV0IG1lc3NhZ2VzO1xuICAgIGxldCBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiB8fCBmaXJzdCA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXNzYWdlcyA9IFttZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyh7IG5hbWU6IGZpcnN0LCBkYXRhOiBzZWNvbmQgfSldO1xuICAgICAgcGFyYW1zID0gYXJnc1syXTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpcnN0KSkge1xuICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoZmlyc3QpXTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpcnN0KSkge1xuICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlc0FycmF5KGZpcnN0KTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzXCIsXG4gICAgICAgIDQwMDEzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG1heE1lc3NhZ2VTaXplID0gdGhpcy5jbGllbnQub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICBjb25zdCB3aXJlTWVzc2FnZXMgPSBhd2FpdCBlbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucyk7XG4gICAgY29uc3Qgc2l6ZSA9IGdldE1lc3NhZ2VzU2l6ZSh3aXJlTWVzc2FnZXMpO1xuICAgIGlmIChzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGBNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKHdhcyAke3NpemV9IGJ5dGVzOyBsaW1pdCBpcyAke21heE1lc3NhZ2VTaXplfSBieXRlcylgLFxuICAgICAgICA0MDAwOSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnRocm93SWZVbnB1Ymxpc2hhYmxlU3RhdGUoKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKVwiLFxuICAgICAgXCJzZW5kaW5nIG1lc3NhZ2U7IGNoYW5uZWwgc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlICsgXCIsIG1lc3NhZ2UgY291bnQgPSBcIiArIHdpcmVNZXNzYWdlcy5sZW5ndGhcbiAgICApO1xuICAgIGNvbnN0IHBtID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuTUVTU0FHRSxcbiAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2VzOiB3aXJlTWVzc2FnZXMsXG4gICAgICBwYXJhbXM6IHBhcmFtcyA/IHN0cmluZ2lmeVZhbHVlcyhwYXJhbXMpIDogdm9pZCAwXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShwbSk7XG4gICAgcmV0dXJuIHJlcyB8fCB7IHNlcmlhbHM6IFtdIH07XG4gIH1cbiAgdGhyb3dJZlVucHVibGlzaGFibGVTdGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmYWlsZWRcIiB8fCB0aGlzLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICB0aHJvdyB0aGlzLmludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgfVxuICB9XG4gIG9uRXZlbnQobWVzc2FnZXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwub25FdmVudCgpXCIsIFwicmVjZWl2ZWQgbWVzc2FnZVwiKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tpXTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuZW1pdChtZXNzYWdlLm5hbWUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9hdHRhY2goZmFsc2UsIG51bGwsIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG4gIF9hdHRhY2goZm9yY2VSZWF0dGFjaCwgYXR0YWNoUmVhc29uLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5fYXR0YWNoKClcIixcbiAgICAgICAgICAgIFwiQ2hhbm5lbCBhdHRhY2ggZmFpbGVkOiBcIiArIGVyci50b1N0cmluZygpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgY2FsbGJhY2soY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImF0dGFjaGluZ1wiIHx8IGZvcmNlUmVhdHRhY2gpIHtcbiAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIsIGF0dGFjaFJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMub25jZShmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhudWxsLCBzdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soXG4gICAgICAgICAgICBzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGF0dGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gXCIgKyB0aGlzLmV2ZW50LCA5ZTQsIDUwMClcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICAgICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKG5ldyBFcnJvckluZm8oXCJBdHRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBkZXRhY2ggcmVxdWVzdFwiLCA5ZTQsIDQwOSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaEltcGwoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmF0dGFjaEltcGwoKVwiLCBcInNlbmRpbmcgQVRUQUNIIG1lc3NhZ2VcIik7XG4gICAgY29uc3QgYXR0YWNoTXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuQVRUQUNILFxuICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgcGFyYW1zOiB0aGlzLmNoYW5uZWxPcHRpb25zLnBhcmFtcyxcbiAgICAgIC8vIFJUTDRjMTogSW5jbHVkZXMgdGhlIGNoYW5uZWwgc2VyaWFsIHRvIHJlc3VtZSBmcm9tIGEgcHJldmlvdXMgbWVzc2FnZVxuICAgICAgLy8gb3IgYXR0YWNobWVudC5cbiAgICAgIGNoYW5uZWxTZXJpYWw6IHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpIHtcbiAgICAgIGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3MoYWxsVG9VcHBlckNhc2UodGhpcy5jaGFubmVsT3B0aW9ucy5tb2RlcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYXR0YWNoUmVzdW1lKSB7XG4gICAgICBhdHRhY2hNc2cuc2V0RmxhZyhcIkFUVEFDSF9SRVNVTUVcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG4gICAgICBhdHRhY2hNc2cuY2hhbm5lbFNlcmlhbCA9IHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw7XG4gICAgfVxuICAgIHRoaXMuc2VuZE1lc3NhZ2UoYXR0YWNoTXNnKS5jYXRjaChub29wKTtcbiAgfVxuICBhc3luYyBkZXRhY2goKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiZGV0YWNoZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gZGV0YWNoOyBjaGFubmVsIHN0YXRlID0gZmFpbGVkXCIsIDkwMDAxLCA0MDApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImRldGFjaGVkXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZShcImRldGFjaGluZ1wiKTtcbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLm9uY2UoZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGRldGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gXCIgKyB0aGlzLmV2ZW50LCA5ZTQsIDUwMClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJEZXRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBhdHRhY2ggcmVxdWVzdFwiLCA5ZTQsIDQwOSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoSW1wbCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwuZGV0YWNoKClcIiwgXCJzZW5kaW5nIERFVEFDSCBtZXNzYWdlXCIpO1xuICAgIGNvbnN0IG1zZyA9IGZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuREVUQUNILCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgdGhpcy5zZW5kTWVzc2FnZShtc2cpLmNhdGNoKG5vb3ApO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZSguLi5hcmdzKSB7XG4gICAgY29uc3QgW2V2ZW50LCBsaXN0ZW5lcl0gPSBfUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncyk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKHRoaXMuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICAgIGlmIChldmVudCAmJiB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICB0aGlzLmNsaWVudC5fRmlsdGVyZWRTdWJzY3JpcHRpb25zLnN1YnNjcmliZUZpbHRlcih0aGlzLCBldmVudCwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hhbm5lbE9wdGlvbnMuYXR0YWNoT25TdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHVuc3Vic2NyaWJlKC4uLmFyZ3MpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IFtldmVudCwgbGlzdGVuZXJdID0gX1JlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgIWxpc3RlbmVyIHx8ICgoX2EyID0gdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGFzKGxpc3RlbmVyKSkpIHtcbiAgICAgIHRoaXMuY2xpZW50Ll9GaWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcikuZm9yRWFjaCgobCkgPT4gdGhpcy5zdWJzY3JpcHRpb25zLm9mZihsKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBzeW5jKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgdGhyb3cgbmV3IFBhcnRpYWxFcnJvckluZm8oXCJVbmFibGUgdG8gc3luYyB0byBjaGFubmVsOyBub3QgYXR0YWNoZWRcIiwgNGU0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IHN5bmNNZXNzYWdlID0gZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5TWU5DLCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgaWYgKHRoaXMuc3luY0NoYW5uZWxTZXJpYWwpIHtcbiAgICAgIHN5bmNNZXNzYWdlLmNoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsO1xuICAgIH1cbiAgICBjb25uZWN0aW9uTWFuYWdlci5zZW5kKHN5bmNNZXNzYWdlKTtcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZShtc2cpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZW5kKG1zZywgdGhpcy5jbGllbnQub3B0aW9ucy5xdWV1ZU1lc3NhZ2VzLCAoZXJyLCBwdWJsaXNoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocHVibGlzaFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2VuZFByZXNlbmNlKHByZXNlbmNlKSB7XG4gICAgY29uc3QgbXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuUFJFU0VOQ0UsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBwcmVzZW5jZVxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UobXNnKTtcbiAgfVxuICBhc3luYyBzZW5kU3RhdGUob2JqZWN0TWVzc2FnZXMpIHtcbiAgICBjb25zdCBtc2cgPSBmcm9tVmFsdWVzKHtcbiAgICAgIGFjdGlvbjogYWN0aW9ucy5PQkpFQ1QsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBzdGF0ZTogb2JqZWN0TWVzc2FnZXNcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlKG1zZyk7XG4gIH1cbiAgLy8gQWNjZXNzIHRvIHRoaXMgbWV0aG9kIGlzIHN5bmNocm9uaXNlZCBieSBDb25uZWN0aW9uTWFuYWdlciNwcm9jZXNzQ2hhbm5lbE1lc3NhZ2UsIGluIG9yZGVyIHRvIHN5bmNocm9uaXNlIGFjY2VzcyB0byB0aGUgc3RhdGUgc3RvcmVkIGluIF9kZWNvZGluZ0NvbnRleHQuXG4gIGFzeW5jIHByb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuQVRUQUNIRUQgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuTUVTU0FHRSB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5QUkVTRU5DRSB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5PQkpFQ1QgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuQU5OT1RBVElPTikge1xuICAgICAgdGhpcy5zZXRDaGFubmVsU2VyaWFsKG1lc3NhZ2UuY2hhbm5lbFNlcmlhbCk7XG4gICAgfVxuICAgIGxldCBzeW5jQ2hhbm5lbFNlcmlhbCwgaXNTeW5jID0gZmFsc2U7XG4gICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgY2FzZSBhY3Rpb25zLkFUVEFDSEVEOiB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgIHRoaXMuX21vZGUgPSBtZXNzYWdlLmdldE1vZGUoKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBtZXNzYWdlLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgY29uc3QgbW9kZXNGcm9tRmxhZ3MgPSBtZXNzYWdlLmRlY29kZU1vZGVzRnJvbUZsYWdzKCk7XG4gICAgICAgIHRoaXMubW9kZXMgPSBtb2Rlc0Zyb21GbGFncyAmJiBhbGxUb0xvd2VyQ2FzZShtb2Rlc0Zyb21GbGFncykgfHwgdm9pZCAwO1xuICAgICAgICBjb25zdCByZXN1bWVkID0gbWVzc2FnZS5oYXNGbGFnKFwiUkVTVU1FRFwiKTtcbiAgICAgICAgY29uc3QgaGFzUHJlc2VuY2UgPSBtZXNzYWdlLmhhc0ZsYWcoXCJIQVNfUFJFU0VOQ0VcIik7XG4gICAgICAgIGNvbnN0IGhhc0JhY2tsb2cgPSBtZXNzYWdlLmhhc0ZsYWcoXCJIQVNfQkFDS0xPR1wiKTtcbiAgICAgICAgY29uc3QgaGFzT2JqZWN0cyA9IG1lc3NhZ2UuaGFzRmxhZyhcIkhBU19PQkpFQ1RTXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJlc2VuY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJlc2VuY2Uub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX29iamVjdC5vbkF0dGFjaGVkKGhhc09iamVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlX2RlZmF1bHQodGhpcy5zdGF0ZSwgdGhpcy5zdGF0ZSwgcmVzdW1lZCwgaGFzQmFja2xvZywgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMuZW1pdChcInVwZGF0ZVwiLCBjaGFuZ2UpO1xuICAgICAgICAgIGlmICghcmVzdW1lZCB8fCB0aGlzLmNoYW5uZWxPcHRpb25zLnVwZGF0ZU9uQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBjaGFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJhdHRhY2hlZFwiLCBtZXNzYWdlLmVycm9yLCByZXN1bWVkLCBoYXNQcmVzZW5jZSwgaGFzQmFja2xvZywgaGFzT2JqZWN0cyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuREVUQUNIRUQ6IHtcbiAgICAgICAgY29uc3QgZGV0YWNoRXJyID0gbWVzc2FnZS5lcnJvciA/IEVycm9ySW5mby5mcm9tVmFsdWVzKG1lc3NhZ2UuZXJyb3IpIDogbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgZGV0YWNoZWRcIiwgOTAwMDEsIDQwNCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImRldGFjaGVkXCIsIGRldGFjaEVycik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJzdXNwZW5kZWRcIiwgZGV0YWNoRXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIsIGRldGFjaEVycik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgICAgaXNTeW5jID0gdHJ1ZTtcbiAgICAgICAgc3luY0NoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICBpZiAoIW1lc3NhZ2UucHJlc2VuY2UpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuUFJFU0VOQ0U6IHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnByZXNlbmNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGVGaWVsZHNGcm9tUGFyZW50KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICAgICAgY29uc3QgcHJlc2VuY2VNZXNzYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgbWVzc2FnZS5wcmVzZW5jZS5tYXAoKHdwbSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gd3BtLmRlY29kZShvcHRpb25zLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fcHJlc2VuY2Uuc2V0UHJlc2VuY2UocHJlc2VuY2VNZXNzYWdlcywgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuT0JKRUNUOlxuICAgICAgY2FzZSBhY3Rpb25zLk9CSkVDVF9TWU5DOiB7XG4gICAgICAgIGlmICghdGhpcy5fb2JqZWN0IHx8ICFtZXNzYWdlLnN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlRmllbGRzRnJvbVBhcmVudChtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5nZXRBY3RpdmVUcmFuc3BvcnRGb3JtYXQoKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0TWVzc2FnZXMgPSBtZXNzYWdlLnN0YXRlLm1hcCgob20pID0+IG9tLmRlY29kZSh0aGlzLmNsaWVudCwgZm9ybWF0KSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5PQkpFQ1QpIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3QuaGFuZGxlT2JqZWN0TWVzc2FnZXMob2JqZWN0TWVzc2FnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29iamVjdC5oYW5kbGVPYmplY3RTeW5jTWVzc2FnZXMob2JqZWN0TWVzc2FnZXMsIG1lc3NhZ2UuY2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuTUVTU0FHRToge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgICAgICAnTWVzc2FnZSBcIicgKyBtZXNzYWdlLmlkICsgJ1wiIHNraXBwZWQgYXMgdGhpcyBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIiBzdGF0ZSBpcyBub3QgXCJhdHRhY2hlZFwiIChzdGF0ZSBpcyBcIicgKyB0aGlzLnN0YXRlICsgJ1wiKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGVGaWVsZHNGcm9tUGFyZW50KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gbWVzc2FnZS5tZXNzYWdlcywgZmlyc3RNZXNzYWdlID0gZW5jb2RlZFswXSwgbGFzdE1lc3NhZ2UgPSBlbmNvZGVkW2VuY29kZWQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChmaXJzdE1lc3NhZ2UuZXh0cmFzICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEgJiYgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YS5mcm9tICE9PSB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnRGVsdGEgbWVzc2FnZSBkZWNvZGUgZmFpbHVyZSAtIHByZXZpb3VzIG1lc3NhZ2Ugbm90IGF2YWlsYWJsZSBmb3IgbWVzc2FnZSBcIicgKyBtZXNzYWdlLmlkICsgJ1wiIG9uIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIuJztcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJSZWFsdGltZUNoYW5uZWwucHJvY2Vzc01lc3NhZ2UoKVwiLCBtc2cpO1xuICAgICAgICAgIHRoaXMuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KG5ldyBFcnJvckluZm8obXNnLCA0MDAxOCwgNDAwKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHsgZGVjb2RlZCwgZXJyIH0gPSBhd2FpdCBlbmNvZGVkW2ldLmRlY29kZVdpdGhFcnIodGhpcy5fZGVjb2RpbmdDb250ZXh0LCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgbWVzc2FnZXNbaV0gPSBkZWNvZGVkO1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA0MDAxODpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY2FzZSA0MDAxOTpcbiAgICAgICAgICAgICAgY2FzZSA0MDAyMTpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiZmFpbGVkXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQgPSBsYXN0TWVzc2FnZS5pZDtcbiAgICAgICAgdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgdGhpcy5vbkV2ZW50KG1lc3NhZ2VzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuQU5OT1RBVElPTjoge1xuICAgICAgICBwb3B1bGF0ZUZpZWxkc0Zyb21QYXJlbnQobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5fYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgKG1lc3NhZ2UuYW5ub3RhdGlvbnMgfHwgW10pLm1hcCgod3BtKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB3cG0uZGVjb2RlKG9wdGlvbnMsIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl9hbm5vdGF0aW9ucy5fcHJvY2Vzc0luY29taW5nKGFubm90YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgYWN0aW9ucy5FUlJPUjoge1xuICAgICAgICBjb25zdCBlcnIgPSBtZXNzYWdlLmVycm9yO1xuICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09IDgwMDE2KSB7XG4gICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJmYWlsZWRcIiwgRXJyb3JJbmZvLmZyb21WYWx1ZXMoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgICBcIlByb3RvY29sIGVycm9yOiB1bnJlY29nbmlzZWQgbWVzc2FnZSBhY3Rpb24gKFwiICsgbWVzc2FnZS5hY3Rpb24gKyBcIilcIlxuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBfc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgXCJTdGFydGluZyBkZWNvZGUgZmFpbHVyZSByZWNvdmVyeSBwcm9jZXNzLlwiXG4gICAgICApO1xuICAgICAgdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICB0aGlzLl9hdHRhY2godHJ1ZSwgcmVhc29uLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkF0dGFjaGVkKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwub25BdHRhY2hlZFwiLFxuICAgICAgXCJhY3RpdmF0aW5nIGNoYW5uZWw7IG5hbWUgPSBcIiArIHRoaXMubmFtZVxuICAgICk7XG4gIH1cbiAgbm90aWZ5U3RhdGUoc3RhdGUsIHJlYXNvbiwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2csIGhhc09iamVjdHMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLm5vdGlmeVN0YXRlXCIsXG4gICAgICBcIm5hbWUgPSBcIiArIHRoaXMubmFtZSArIFwiLCBjdXJyZW50IHN0YXRlID0gXCIgKyB0aGlzLnN0YXRlICsgXCIsIG5vdGlmeWluZyBzdGF0ZSBcIiArIHN0YXRlXG4gICAgKTtcbiAgICB0aGlzLmNsZWFyU3RhdGVUaW1lcigpO1xuICAgIGlmIChbXCJkZXRhY2hlZFwiLCBcInN1c3BlbmRlZFwiLCBcImZhaWxlZFwiXS5pbmNsdWRlcyhzdGF0ZSkpIHtcbiAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgdGhpcy5fcHJlc2VuY2UuYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc1ByZXNlbmNlLCByZWFzb24pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb2JqZWN0KSB7XG4gICAgICB0aGlzLl9vYmplY3QuYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc09iamVjdHMpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHJlYXNvbjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuc3RhdGUsIHN0YXRlLCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pO1xuICAgIGNvbnN0IGFjdGlvbiA9ICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIic7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YXRlICsgKHJlYXNvbiA/IFwiOyByZWFzb246IFwiICsgcmVhc29uIDogXCJcIik7XG4gICAgaWYgKHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYWN0aW9uLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSAhPT0gXCJhdHRhY2hpbmdcIiAmJiBzdGF0ZSAhPT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIHRoaXMub25BdHRhY2hlZCgpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImRldGFjaGluZ1wiIHx8IHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG4gICAgdGhpcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuICB9XG4gIHJlcXVlc3RTdGF0ZShzdGF0ZSwgcmVhc29uKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5yZXF1ZXN0U3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyBzdGF0ZVxuICAgICk7XG4gICAgdGhpcy5ub3RpZnlTdGF0ZShzdGF0ZSwgcmVhc29uKTtcbiAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gIH1cbiAgY2hlY2tQZW5kaW5nU3RhdGUoKSB7XG4gICAgY29uc3QgY21TdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGU7XG4gICAgaWYgKCFjbVN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgICAgXCJzZW5kRXZlbnRzIGlzIGZhbHNlOyBzdGF0ZSBpcyBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyB0aGlzLnN0YXRlXG4gICAgKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgICB0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuICAgICAgICB0aGlzLmRldGFjaEltcGwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRpbWVvdXRQZW5kaW5nU3RhdGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgYXR0YWNoIHRpbWVkIG91dFwiLCA5MDAwNywgNDA4KTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcInN1c3BlbmRlZFwiLCBlcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjoge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiQ2hhbm5lbCBkZXRhY2ggdGltZWQgb3V0XCIsIDkwMDA3LCA0MDgpO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiYXR0YWNoZWRcIiwgZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlVGltZXIpIHtcbiAgICAgIHRoaXMuc3RhdGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZUNoYW5uZWwuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nXCIsIFwidGltZXIgZXhwaXJlZFwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0UGVuZGluZ1N0YXRlKCk7XG4gICAgICB9LCB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBjbGVhclN0YXRlVGltZXIoKSB7XG4gICAgY29uc3Qgc3RhdGVUaW1lciA9IHRoaXMuc3RhdGVUaW1lcjtcbiAgICBpZiAoc3RhdGVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xuICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRSZXRyeVRpbWVyKCkge1xuICAgIGlmICh0aGlzLnJldHJ5VGltZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZXRyeUNvdW50Kys7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IGdldFJldHJ5VGltZSh0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmNoYW5uZWxSZXRyeVRpbWVvdXQsIHRoaXMucmV0cnlDb3VudCk7XG4gICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiAmJiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbCByZXRyeSB0aW1lciBleHBpcmVkXCIsXG4gICAgICAgICAgXCJhdHRlbXB0aW5nIGEgbmV3IGF0dGFjaFwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIpO1xuICAgICAgfVxuICAgIH0sIHJldHJ5RGVsYXkpO1xuICB9XG4gIGNhbmNlbFJldHJ5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKiBAcmV0dXJucyBudWxsIChpZiBjYW4gc2FmZWx5IGJlIHJlbGVhc2VkKSB8IEVycm9ySW5mbyAoaWYgY2Fubm90KSAqL1xuICBnZXRSZWxlYXNlRXJyKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzID09PSBcImluaXRpYWxpemVkXCIgfHwgcyA9PT0gXCJkZXRhY2hlZFwiIHx8IHMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2FuIG9ubHkgcmVsZWFzZSBhIGNoYW5uZWwgaW4gYSBzdGF0ZSB3aGVyZSB0aGVyZSBpcyBubyBwb3NzaWJpbGl0eSBvZiBmdXJ0aGVyIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyIGJlaW5nIHJlY2VpdmVkIChpbml0aWFsaXplZCwgZGV0YWNoZWQsIG9yIGZhaWxlZCk7IHdhcyBcIiArIHMsXG4gICAgICA5MDAwMSxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgc2V0Q2hhbm5lbFNlcmlhbChjaGFubmVsU2VyaWFsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5zZXRDaGFubmVsU2VyaWFsKClcIixcbiAgICAgIFwiVXBkYXRpbmcgY2hhbm5lbCBzZXJpYWw7IHNlcmlhbCA9IFwiICsgY2hhbm5lbFNlcmlhbCArIFwiOyBwcmV2aW91cyA9IFwiICsgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWxcbiAgICApO1xuICAgIGlmIChjaGFubmVsU2VyaWFsKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWw7XG4gICAgfVxuICB9XG4gIGFzeW5jIHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uc3RhdHVzKHRoaXMpO1xuICB9XG4gIGFzeW5jIGdldE1lc3NhZ2Uoc2VyaWFsT3JNZXNzYWdlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmdldE1lc3NhZ2UoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgY29uc3QgcmVzdE1peGluID0gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW47XG4gICAgcmV0dXJuIHJlc3RNaXhpbi5nZXRNZXNzYWdlKHRoaXMsIHNlcmlhbE9yTWVzc2FnZSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC51cGRhdGVNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbmRVcGRhdGUobWVzc2FnZSwgXCJtZXNzYWdlLnVwZGF0ZVwiLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5kZWxldGVNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbmRVcGRhdGUobWVzc2FnZSwgXCJtZXNzYWdlLmRlbGV0ZVwiLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgYXBwZW5kTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5hcHBlbmRNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbmRVcGRhdGUobWVzc2FnZSwgXCJtZXNzYWdlLmFwcGVuZFwiLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgc2VuZFVwZGF0ZShtZXNzYWdlLCBhY3Rpb24sIG9wZXJhdGlvbiwgcGFyYW1zKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgaWYgKCFtZXNzYWdlLnNlcmlhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgJ1RoaXMgbWVzc2FnZSBsYWNrcyBhIHNlcmlhbCBhbmQgY2Fubm90IGJlIHVwZGF0ZWQuIE1ha2Ugc3VyZSB5b3UgaGF2ZSBlbmFibGVkIFwiTWVzc2FnZSBhbm5vdGF0aW9ucywgdXBkYXRlcywgYW5kIGRlbGV0ZXNcIiBpbiBjaGFubmVsIHNldHRpbmdzIG9uIHlvdXIgZGFzaGJvYXJkLicsXG4gICAgICAgIDQwMDAzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMudGhyb3dJZlVucHVibGlzaGFibGVTdGF0ZSgpO1xuICAgIGNvbnN0IHVwZGF0ZURlbGV0ZU1zZyA9IG1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1lc3NhZ2UpLCB7XG4gICAgICBhY3Rpb24sXG4gICAgICB2ZXJzaW9uOiBvcGVyYXRpb25cbiAgICB9KSk7XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2UgPSBhd2FpdCB1cGRhdGVEZWxldGVNc2cuZW5jb2RlKHRoaXMuY2hhbm5lbE9wdGlvbnMpO1xuICAgIGNvbnN0IHBtID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuTUVTU0FHRSxcbiAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2VzOiBbd2lyZU1lc3NhZ2VdLFxuICAgICAgcGFyYW1zOiBwYXJhbXMgPyBzdHJpbmdpZnlWYWx1ZXMocGFyYW1zKSA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGNvbnN0IHB1Ymxpc2hSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UocG0pO1xuICAgIHJldHVybiB7IHZlcnNpb25TZXJpYWw6IChfYiA9IChfYTIgPSBwdWJsaXNoUmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHB1Ymxpc2hSZXNwb25zZS5zZXJpYWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyWzBdKSAhPSBudWxsID8gX2IgOiBudWxsIH07XG4gIH1cbiAgYXN5bmMgZ2V0TWVzc2FnZVZlcnNpb25zKHNlcmlhbE9yTWVzc2FnZSwgcGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmdldE1lc3NhZ2VWZXJzaW9ucygpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICBjb25zdCByZXN0TWl4aW4gPSB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbjtcbiAgICByZXR1cm4gcmVzdE1peGluLmdldE1lc3NhZ2VWZXJzaW9ucyh0aGlzLCBzZXJpYWxPck1lc3NhZ2UsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhlIGNoYW5uZWwgaXMgYXR0YWNoZWQsIGF0dGFjaGluZyBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciB1c2UgYnkgZmVhdHVyZXMgbGlrZSBQcmVzZW5jZSBvciBPYmplY3RzIHRoYXQgbmVlZCB0b1xuICAgKiBpbXBsaWNpdGx5IGF0dGFjaCB0aGUgY2hhbm5lbCB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYWxsZWQgKGUuZy4sIGBwcmVzZW5jZS5nZXQoKWAgcGVyIFJUUDExYixcbiAgICogb3IgYG9iamVjdHMuZ2V0KClgKS4gVGhpcyBndWFyYW50ZWVzIHRoYXQgdGhlIGNvcnJlc3BvbmRpbmcgc3luYyBzZXF1ZW5jZSB3aWxsIHN0YXJ0IGFuZFxuICAgKiB0aGF0IHRoZSBvcGVyYXRpb24gd2lsbCByZXNvbHZlIGZvciBjYWxsZXJzIGV2ZW4gaWYgdGhleSBkaWQgbm90IGV4cGxpY2l0bHkgYXR0YWNoIGJlZm9yZWhhbmQuXG4gICAqL1xuICBhc3luYyBlbnN1cmVBdHRhY2hlZCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgIGF3YWl0IHRoaXMuYXR0YWNoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3JJbmZvLmZyb21WYWx1ZXModGhpcy5pbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBvbWl0QWdlbnQoY2hhbm5lbFBhcmFtcykge1xuICBjb25zdCBfYTIgPSBjaGFubmVsUGFyYW1zIHx8IHt9LCB7IGFnZW50OiBfIH0gPSBfYTIsIHBhcmFtc1dpdGhvdXRBZ2VudCA9IF9fb2JqUmVzdChfYTIsIFtcImFnZW50XCJdKTtcbiAgcmV0dXJuIHBhcmFtc1dpdGhvdXRBZ2VudDtcbn1cbnZhciByZWFsdGltZWNoYW5uZWxfZGVmYXVsdCA9IFJlYWx0aW1lQ2hhbm5lbDtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lYW5ub3RhdGlvbnMudHNcbnZhciBSZWFsdGltZUFubm90YXRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICB0aGlzLmxvZ2dlciA9IGNoYW5uZWwubG9nZ2VyO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBldmVudGVtaXR0ZXJfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcykge1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gdGhpcy5jaGFubmVsLm5hbWU7XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IGNvbnN0cnVjdFZhbGlkYXRlQW5ub3RhdGlvbihtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcyk7XG4gICAgY29uc3Qgd2lyZUFubm90YXRpb24gPSBhd2FpdCBhbm5vdGF0aW9uLmVuY29kZSgpO1xuICAgIHRoaXMuY2hhbm5lbC50aHJvd0lmVW5wdWJsaXNoYWJsZVN0YXRlKCk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQW5ub3RhdGlvbnMucHVibGlzaCgpXCIsXG4gICAgICBcImNoYW5uZWxOYW1lID0gXCIgKyBjaGFubmVsTmFtZSArIFwiLCBzZW5kaW5nIGFubm90YXRpb24gd2l0aCBtZXNzYWdlU2VyaWFsID0gXCIgKyBhbm5vdGF0aW9uLm1lc3NhZ2VTZXJpYWwgKyBcIiwgdHlwZSA9IFwiICsgYW5ub3RhdGlvbi50eXBlXG4gICAgKTtcbiAgICBjb25zdCBwbSA9IGZyb21WYWx1ZXMoe1xuICAgICAgYWN0aW9uOiBhY3Rpb25zLkFOTk9UQVRJT04sXG4gICAgICBjaGFubmVsOiBjaGFubmVsTmFtZSxcbiAgICAgIGFubm90YXRpb25zOiBbd2lyZUFubm90YXRpb25dXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5jaGFubmVsLnNlbmRNZXNzYWdlKHBtKTtcbiAgfVxuICBhc3luYyBkZWxldGUobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgICBhbm5vdGF0aW9uVmFsdWVzLmFjdGlvbiA9IFwiYW5ub3RhdGlvbi5kZWxldGVcIjtcbiAgICBhd2FpdCB0aGlzLnB1Ymxpc2gobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIGlmICh0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnMuYXR0YWNoT25TdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBjaGFubmVsLmF0dGFjaCgpO1xuICAgIH1cbiAgICBpZiAoKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiICYmIHRoaXMuY2hhbm5lbC5fbW9kZSAmIGZsYWdzLkFOTk9UQVRJT05fU1VCU0NSSUJFKSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byBhZGQgYW4gYW5ub3RhdGlvbiBsaXN0ZW5lciwgYnV0IHlvdSBoYXZlbid0IHJlcXVlc3RlZCB0aGUgYW5ub3RhdGlvbl9zdWJzY3JpYmUgY2hhbm5lbCBtb2RlIGluIENoYW5uZWxPcHRpb25zLCBzbyB0aGlzIHdvbid0IGRvIGFueXRoaW5nICh3ZSBvbmx5IGRlbGl2ZXIgYW5ub3RhdGlvbnMgdG8gY2xpZW50cyB3aG8gaGF2ZSBleHBsaWNpdGx5IHJlcXVlc3RlZCB0aGVtKVwiLFxuICAgICAgICA5MzAwMSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB1bnN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBfcHJvY2Vzc0luY29taW5nKGFubm90YXRpb25zKSB7XG4gICAgZm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIGFubm90YXRpb25zKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZW1pdChhbm5vdGF0aW9uLnR5cGUgfHwgXCJcIiwgYW5ub3RhdGlvbik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldChtc2dPclNlcmlhbCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHJlc3Rhbm5vdGF0aW9uc19kZWZhdWx0LnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBtc2dPclNlcmlhbCwgcGFyYW1zKTtcbiAgfVxufTtcbnZhciByZWFsdGltZWFubm90YXRpb25zX2RlZmF1bHQgPSBSZWFsdGltZUFubm90YXRpb25zO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvZGVmYXVsdHJlc3QudHNcbnZhciBfRGVmYXVsdFJlc3QgPSBjbGFzcyBfRGVmYXVsdFJlc3QgZXh0ZW5kcyBCYXNlUmVzdCB7XG4gIC8vIFRoZSBwdWJsaWMgdHlwaW5ncyBkZWNsYXJlIHRoYXQgdGhpcyByZXF1aXJlcyBhbiBhcmd1bWVudCB0byBiZSBwYXNzZWQsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgbm90IHBhc3MgYW4gYXJndW1lbnQsIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhpcyBpcyBwb3NzaWJsZSBzbyB0aGF0IGl0IGZvcmNlcyB1cyB0byBoYW5kbGUgaXQuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBjb25zdCBNc2dQYWNrID0gX0RlZmF1bHRSZXN0Ll9Nc2dQYWNrO1xuICAgIGlmICghTXNnUGFjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGVmYXVsdFJlc3QuX01zZ1BhY2sgdG8gaGF2ZSBiZWVuIHNldFwiKTtcbiAgICB9XG4gICAgc3VwZXIoXG4gICAgICBkZWZhdWx0c19kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucywgdHJ1ZSwgXCJSZXN0XCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGFsbENvbW1vbk1vZHVsYXJQbHVnaW5zKSwge1xuICAgICAgICBDcnlwdG86IChfYTIgPSBfRGVmYXVsdFJlc3QuQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogdm9pZCAwLFxuICAgICAgICBNc2dQYWNrOiAoX2IgPSBfRGVmYXVsdFJlc3QuX01zZ1BhY2spICE9IG51bGwgPyBfYiA6IHZvaWQgMCxcbiAgICAgICAgQW5ub3RhdGlvbnM6IHtcbiAgICAgICAgICBBbm5vdGF0aW9uOiBhbm5vdGF0aW9uX2RlZmF1bHQsXG4gICAgICAgICAgV2lyZUFubm90YXRpb24sXG4gICAgICAgICAgUmVhbHRpbWVBbm5vdGF0aW9uczogcmVhbHRpbWVhbm5vdGF0aW9uc19kZWZhdWx0LFxuICAgICAgICAgIFJlc3RBbm5vdGF0aW9uczogcmVzdGFubm90YXRpb25zX2RlZmF1bHRcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IENyeXB0bygpIHtcbiAgICBpZiAodGhpcy5fQ3J5cHRvID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9DcnlwdG87XG4gIH1cbiAgc3RhdGljIHNldCBDcnlwdG8obmV3VmFsdWUpIHtcbiAgICB0aGlzLl9DcnlwdG8gPSBuZXdWYWx1ZTtcbiAgfVxufTtcbl9EZWZhdWx0UmVzdC5fQ3J5cHRvID0gbnVsbDtcbl9EZWZhdWx0UmVzdC5NZXNzYWdlID0gRGVmYXVsdE1lc3NhZ2U7XG5fRGVmYXVsdFJlc3QuUHJlc2VuY2VNZXNzYWdlID0gRGVmYXVsdFByZXNlbmNlTWVzc2FnZTtcbl9EZWZhdWx0UmVzdC5Bbm5vdGF0aW9uID0gRGVmYXVsdEFubm90YXRpb247XG5fRGVmYXVsdFJlc3QuX01zZ1BhY2sgPSBudWxsO1xuLy8gVXNlZCBieSB0ZXN0c1xuX0RlZmF1bHRSZXN0Ll9IdHRwID0gSHR0cDtcbnZhciBEZWZhdWx0UmVzdCA9IF9EZWZhdWx0UmVzdDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L21lc3NhZ2VxdWV1ZS50c1xudmFyIE1lc3NhZ2VRdWV1ZSA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICBzdXBlcihsb2dnZXIpO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgfVxuICBjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG4gIH1cbiAgcHVzaChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLnNoaWZ0KCk7XG4gIH1cbiAgbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1t0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGNvcHlBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuc2xpY2UoKTtcbiAgfVxuICBhcHBlbmQobWVzc2FnZXMpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2guYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuICB9XG4gIHByZXBlbmQobWVzc2FnZXMpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLnVuc2hpZnQuYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuICB9XG4gIC8qKlxuICAgKiBGb3IgYWxsIG1lc3NhZ2VzIHRhcmdldGVkIGJ5IHRoZSBzZWxlY3RvciwgY2FsbHMgdGhlaXIgY2FsbGJhY2sgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gRGVzY3JpYmVzIHdoaWNoIG1lc3NhZ2VzIHRvIHRhcmdldC4gJ2FsbCcgbWVhbnMgYWxsIG1lc3NhZ2VzIGluIHRoZSBxdWV1ZSAocmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXkgaGF2ZSBoYWQgYSBgbXNnU2VyaWFsYCBhc3NpZ25lZCk7IGBzZXJpYWxgIC8gYGNvdW50YCB0YXJnZXRzIGEgcmFuZ2Ugb2YgbWVzc2FnZXMgZGVzY3JpYmVkIGJ5IGFuIGBBQ0tgIG9yIGBOQUNLYCByZWNlaXZlZCBmcm9tIEFibHkgKHRoaXMgYXNzdW1lcyB0aGF0IGFsbCB0aGUgbWVzc2FnZXMgaW4gdGhlIHF1ZXVlIGhhdmUgaGFkIGEgYG1zZ1NlcmlhbGAgYXNzaWduZWQpLlxuICAgKi9cbiAgY29tcGxldGVNZXNzYWdlcyhzZWxlY3RvciwgZXJyLCByZXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKVwiLFxuICAgICAgc2VsZWN0b3IgPT0gXCJhbGxcIiA/IFwiKGFsbClcIiA6IFwic2VyaWFsID0gXCIgKyBzZWxlY3Rvci5zZXJpYWwgKyBcIjsgY291bnQgPSBcIiArIHNlbGVjdG9yLmNvdW50XG4gICAgKTtcbiAgICBlcnIgPSBlcnIgfHwgbnVsbDtcbiAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMubWVzc2FnZXM7XG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKTogY29tcGxldGVNZXNzYWdlcyBjYWxsZWQgb24gYW55IGVtcHR5IE1lc3NhZ2VRdWV1ZVwiKTtcbiAgICB9XG4gICAgbGV0IGNvbXBsZXRlTWVzc2FnZXMgPSBbXTtcbiAgICBpZiAoc2VsZWN0b3IgPT09IFwiYWxsXCIpIHtcbiAgICAgIGNvbXBsZXRlTWVzc2FnZXMgPSBtZXNzYWdlcy5zcGxpY2UoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gbWVzc2FnZXNbMF07XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTZXJpYWwgPSBmaXJzdC5tZXNzYWdlLm1zZ1NlcmlhbDtcbiAgICAgICAgY29uc3QgZW5kU2VyaWFsID0gc2VsZWN0b3Iuc2VyaWFsICsgc2VsZWN0b3IuY291bnQ7XG4gICAgICAgIGlmIChlbmRTZXJpYWwgPiBzdGFydFNlcmlhbCkge1xuICAgICAgICAgIGNvbXBsZXRlTWVzc2FnZXMgPSBtZXNzYWdlcy5zcGxpY2UoMCwgZW5kU2VyaWFsIC0gc3RhcnRTZXJpYWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcGxldGVNZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGNvbXBsZXRlTWVzc2FnZXNbaV07XG4gICAgICBjb25zdCBwdWJsaXNoUmVzcG9uc2UgPSByZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc1tpXTtcbiAgICAgIG1lc3NhZ2UuY2FsbGJhY2soZXJyLCBwdWJsaXNoUmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09IDApXG4gICAgICB0aGlzLmVtaXQoXCJpZGxlXCIpO1xuICB9XG4gIGNvbXBsZXRlQWxsTWVzc2FnZXMoZXJyKSB7XG4gICAgdGhpcy5jb21wbGV0ZU1lc3NhZ2VzKFwiYWxsXCIsIGVycik7XG4gIH1cbiAgcmVzZXRTZW5kQXR0ZW1wdGVkKCkge1xuICAgIGZvciAobGV0IG1zZyBvZiB0aGlzLm1lc3NhZ2VzKSB7XG4gICAgICBtc2cuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiTWVzc2FnZVF1ZXVlLmNsZWFyKClcIixcbiAgICAgIFwiY2xlYXJpbmcgXCIgKyB0aGlzLm1lc3NhZ2VzLmxlbmd0aCArIFwiIG1lc3NhZ2VzXCJcbiAgICApO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLmVtaXQoXCJpZGxlXCIpO1xuICB9XG59O1xudmFyIG1lc3NhZ2VxdWV1ZV9kZWZhdWx0ID0gTWVzc2FnZVF1ZXVlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvcHJvdG9jb2wudHNcbnZhciBQZW5kaW5nTWVzc2FnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLm1lcmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdGlvbiA9IG1lc3NhZ2UuYWN0aW9uO1xuICAgIHRoaXMuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuYWNrUmVxdWlyZWQgPSB0eXBlb2YgYWN0aW9uID09PSBcIm51bWJlclwiICYmIFthY3Rpb25zLk1FU1NBR0UsIGFjdGlvbnMuUFJFU0VOQ0UsIGFjdGlvbnMuQU5OT1RBVElPTiwgYWN0aW9ucy5PQkpFQ1RdLmluY2x1ZGVzKGFjdGlvbik7XG4gIH1cbn07XG52YXIgUHJvdG9jb2wgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgc3VwZXIodHJhbnNwb3J0LmxvZ2dlcik7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgbWVzc2FnZXF1ZXVlX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRyYW5zcG9ydC5vbihcImFja1wiLCAoc2VyaWFsLCBjb3VudCwgcmVzKSA9PiB7XG4gICAgICB0aGlzLm9uQWNrKHNlcmlhbCwgY291bnQsIHJlcyk7XG4gICAgfSk7XG4gICAgdHJhbnNwb3J0Lm9uKFwibmFja1wiLCAoc2VyaWFsLCBjb3VudCwgZXJyKSA9PiB7XG4gICAgICB0aGlzLm9uTmFjayhzZXJpYWwsIGNvdW50LCBlcnIpO1xuICAgIH0pO1xuICB9XG4gIG9uQWNrKHNlcmlhbCwgY291bnQsIHJlcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlByb3RvY29sLm9uQWNrKClcIiwgXCJzZXJpYWwgPSBcIiArIHNlcmlhbCArIFwiOyBjb3VudCA9IFwiICsgY291bnQpO1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoeyBzZXJpYWwsIGNvdW50IH0sIG51bGwsIHJlcyk7XG4gIH1cbiAgb25OYWNrKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJQcm90b2NvbC5vbk5hY2soKVwiLFxuICAgICAgXCJzZXJpYWwgPSBcIiArIHNlcmlhbCArIFwiOyBjb3VudCA9IFwiICsgY291bnQgKyBcIjsgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICk7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gc2VuZCBtZXNzYWdlOyBjaGFubmVsIG5vdCByZXNwb25kaW5nXCIsIDUwMDAxLCA1MDApO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHsgc2VyaWFsLCBjb3VudCB9LCBlcnIpO1xuICB9XG4gIG9uY2VJZGxlKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbWVzc2FnZVF1ZXVlID0gdGhpcy5tZXNzYWdlUXVldWU7XG4gICAgaWYgKG1lc3NhZ2VRdWV1ZS5jb3VudCgpID09PSAwKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXNzYWdlUXVldWUub25jZShcImlkbGVcIiwgbGlzdGVuZXIpO1xuICB9XG4gIHNlbmQocGVuZGluZ01lc3NhZ2UpIHtcbiAgICBpZiAocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQpIHtcbiAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gocGVuZGluZ01lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiUHJvdG9jb2wuc2VuZCgpXCIsXG4gICAgICAgIFwic2VuZGluZyBtc2c7IFwiICsgc3RyaW5naWZ5KFxuICAgICAgICAgIHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgICAgdGhpcy50cmFuc3BvcnQuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsXG4gICAgICAgICAgdGhpcy50cmFuc3BvcnQuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX0Fubm90YXRpb25zLFxuICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9saXZlT2JqZWN0c1BsdWdpblxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xuICB9XG4gIGdldFRyYW5zcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQ7XG4gIH1cbiAgZ2V0UGVuZGluZ01lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jb3B5QWxsKCk7XG4gIH1cbiAgY2xlYXJQZW5kaW5nTWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNsZWFyKCk7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0O1xuICAgIHRoaXMub25jZUlkbGUoZnVuY3Rpb24oKSB7XG4gICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHByb3RvY29sX2RlZmF1bHQgPSBQcm90b2NvbDtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZS50c1xudmFyIENvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJldmlvdXMsIGN1cnJlbnQsIHJldHJ5SW4sIHJlYXNvbikge1xuICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgIGlmIChyZXRyeUluKVxuICAgICAgdGhpcy5yZXRyeUluID0gcmV0cnlJbjtcbiAgICBpZiAocmVhc29uKVxuICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIH1cbn07XG52YXIgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQgPSBDb25uZWN0aW9uU3RhdGVDaGFuZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9uZXJyb3JzLnRzXG52YXIgQ29ubmVjdGlvbkVycm9yQ29kZXMgPSB7XG4gIERJU0NPTk5FQ1RFRDogODAwMDMsXG4gIFNVU1BFTkRFRDogODAwMDIsXG4gIEZBSUxFRDogOGU0LFxuICBDTE9TSU5HOiA4MDAxNyxcbiAgQ0xPU0VEOiA4MDAxNyxcbiAgVU5LTk9XTl9DT05ORUNUSU9OX0VSUjogNTAwMDIsXG4gIFVOS05PV05fQ0hBTk5FTF9FUlI6IDUwMDAxXG59O1xudmFyIENvbm5lY3Rpb25FcnJvcnMgPSB7XG4gIGRpc2Nvbm5lY3RlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5ESVNDT05ORUNURUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIHRvIHNlcnZlciB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZVwiXG4gIH0pLFxuICBzdXNwZW5kZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuU1VTUEVOREVELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdW5hdmFpbGFibGVcIlxuICB9KSxcbiAgZmFpbGVkOiAoKSA9PiBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG4gICAgc3RhdHVzQ29kZTogNDAwLFxuICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLkZBSUxFRCxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gZmFpbGVkIG9yIGRpc2Nvbm5lY3RlZCBieSBzZXJ2ZXJcIlxuICB9KSxcbiAgY2xvc2luZzogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TSU5HLFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBjbG9zaW5nXCJcbiAgfSksXG4gIGNsb3NlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TRUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIGNsb3NlZFwiXG4gIH0pLFxuICB1bmtub3duQ29ubmVjdGlvbkVycjogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvclwiXG4gIH0pLFxuICB1bmtub3duQ2hhbm5lbEVycjogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgY2hhbm5lbCBlcnJvclwiXG4gIH0pXG59O1xuZnVuY3Rpb24gaXNSZXRyaWFibGUoZXJyKSB7XG4gIGlmICghZXJyLnN0YXR1c0NvZGUgfHwgIWVyci5jb2RlIHx8IGVyci5zdGF0dXNDb2RlID49IDUwMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBPYmplY3QudmFsdWVzKENvbm5lY3Rpb25FcnJvckNvZGVzKS5pbmNsdWRlcyhlcnIuY29kZSk7XG59XG52YXIgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0ID0gQ29ubmVjdGlvbkVycm9ycztcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L3RyYW5zcG9ydC50c1xudmFyIGNsb3NlTWVzc2FnZSA9IGZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuQ0xPU0UgfSk7XG52YXIgZGlzY29ubmVjdE1lc3NhZ2UgPSBmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkRJU0NPTk5FQ1QgfSk7XG52YXIgVHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGZvcmNlSnNvblByb3RvY29sKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIubG9nZ2VyKTtcbiAgICBpZiAoZm9yY2VKc29uUHJvdG9jb2wpIHtcbiAgICAgIHBhcmFtcy5mb3JtYXQgPSB2b2lkIDA7XG4gICAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMudGltZW91dHMgPSBwYXJhbXMub3B0aW9ucy50aW1lb3V0cztcbiAgICB0aGlzLmZvcm1hdCA9IHBhcmFtcy5mb3JtYXQ7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgdGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVxdWVzdENsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKFwiY2xvc2VkXCIsIGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC5jbG9zZWQoKSk7XG4gIH1cbiAgZGlzY29ubmVjdChlcnIpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgfVxuICBmYWlsKGVycikge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKFwiZmFpbGVkXCIsIGVyciB8fCBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQuZmFpbGVkKCkpO1xuICB9XG4gIGZpbmlzaChldmVudCwgZXJyKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQoKF9hMiA9IHRoaXMuaWRsZVRpbWVyKSAhPSBudWxsID8gX2EyIDogdm9pZCAwKTtcbiAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCBlcnIpO1xuICAgIHRoaXMuZGlzcG9zZSgpO1xuICB9XG4gIG9uUHJvdG9jb2xNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgXCJyZWNlaXZlZCBvbiBcIiArIHRoaXMuc2hvcnROYW1lICsgXCI6IFwiICsgc3RyaW5naWZ5KFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Bbm5vdGF0aW9ucyxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9saXZlT2JqZWN0c1BsdWdpblxuICAgICAgICApICsgXCI7IGNvbm5lY3Rpb25JZCA9IFwiICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWRcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgIHN3aXRjaCAobWVzc2FnZS5hY3Rpb24pIHtcbiAgICAgIGNhc2UgYWN0aW9ucy5IRUFSVEJFQVQ6XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgICB0aGlzLnNob3J0TmFtZSArIFwiIGhlYXJ0YmVhdDsgY29ubmVjdGlvbklkID0gXCIgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVtaXQoXCJoZWFydGJlYXRcIiwgbWVzc2FnZS5pZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLkNPTk5FQ1RFRDpcbiAgICAgICAgdGhpcy5vbkNvbm5lY3QobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RlZFwiLCBtZXNzYWdlLmVycm9yLCBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscywgbWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLkNMT1NFRDpcbiAgICAgICAgdGhpcy5vbkNsb3NlKG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5ESVNDT05ORUNURUQ6XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0KG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5BQ0s6XG4gICAgICAgIHRoaXMuZW1pdChcImFja1wiLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5yZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5OQUNLOlxuICAgICAgICB0aGlzLmVtaXQoXCJuYWNrXCIsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50LCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5BQ1RJVkFURTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuQVVUSDpcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMuYXV0aC5hdXRob3JpemUoKSwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICAgICAgICBcIkFibHkgcmVxdWVzdGVkIHJlLWF1dGhlbnRpY2F0aW9uLCBidXQgdW5hYmxlIHRvIG9idGFpbiBhIG5ldyB0b2tlbjogXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5FUlJPUjpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIlRyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpXCIsXG4gICAgICAgICAgXCJyZWNlaXZlZCBlcnJvciBhY3Rpb247IGNvbm5lY3Rpb25JZCA9IFwiICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQgKyBcIjsgZXJyID0gXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChtZXNzYWdlLmVycm9yKSArIChtZXNzYWdlLmNoYW5uZWwgPyBcIiwgY2hhbm5lbDogXCIgKyBtZXNzYWdlLmNoYW5uZWwgOiBcIlwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAobWVzc2FnZS5jaGFubmVsID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLm9uRmF0YWxFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgIH1cbiAgfVxuICBvbkNvbm5lY3QobWVzc2FnZSkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIGlmICghbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0Lm9uQ29ubmVjdCgpOiBDb25uZWN0IG1lc3NhZ2UgcmVjaWV2ZWQgd2l0aG91dCBjb25uZWN0aW9uRGV0YWlsc1wiKTtcbiAgICB9XG4gICAgY29uc3QgbWF4UHJvbWlzZWRJZGxlID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG4gICAgaWYgKG1heFByb21pc2VkSWRsZSkge1xuICAgICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBtYXhQcm9taXNlZElkbGUgKyB0aGlzLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cbiAgb25EaXNjb25uZWN0KG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0Lm9uRGlzY29ubmVjdCgpXCIsIFwiZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyKTtcbiAgfVxuICBvbkZhdGFsRXJyb3IobWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQub25GYXRhbEVycm9yKClcIiwgXCJlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpKTtcbiAgICB0aGlzLmZpbmlzaChcImZhaWxlZFwiLCBlcnIpO1xuICB9XG4gIG9uQ2xvc2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQub25DbG9zZSgpXCIsIFwiZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgdGhpcy5maW5pc2goXCJjbG9zZWRcIiwgZXJyKTtcbiAgfVxuICByZXF1ZXN0Q2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpXCIsIFwiXCIpO1xuICAgIHRoaXMuc2VuZChjbG9zZU1lc3NhZ2UpO1xuICB9XG4gIHJlcXVlc3REaXNjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpXCIsIFwiXCIpO1xuICAgIHRoaXMuc2VuZChkaXNjb25uZWN0TWVzc2FnZSk7XG4gIH1cbiAgcGluZyhpZCkge1xuICAgIGNvbnN0IG1zZyA9IHsgYWN0aW9uOiBhY3Rpb25zLkhFQVJUQkVBVCB9O1xuICAgIGlmIChpZClcbiAgICAgIG1zZy5pZCA9IGlkO1xuICAgIHRoaXMuc2VuZChmcm9tVmFsdWVzKG1zZykpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIHRoaXMub2ZmKCk7XG4gIH1cbiAgb25BY3Rpdml0eSgpIHtcbiAgICBpZiAoIXRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEFjdGl2aXR5ID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5sYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRoaXMubWF4SWRsZUludGVydmFsICsgMTAwKTtcbiAgfVxuICBzZXRJZGxlVGltZXIodGltZW91dCkge1xuICAgIGlmICghdGhpcy5pZGxlVGltZXIpIHtcbiAgICAgIHRoaXMuaWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub25JZGxlVGltZXJFeHBpcmUoKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBvbklkbGVUaW1lckV4cGlyZSgpIHtcbiAgICBpZiAoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKCk6IGxhc3RBY3Rpdml0eS9tYXhJZGxlSW50ZXJ2YWwgbm90IHNldFwiKTtcbiAgICB9XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIGNvbnN0IHNpbmNlTGFzdCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICBjb25zdCB0aW1lUmVtYWluaW5nID0gdGhpcy5tYXhJZGxlSW50ZXJ2YWwgLSBzaW5jZUxhc3Q7XG4gICAgaWYgKHRpbWVSZW1haW5pbmcgPD0gMCkge1xuICAgICAgY29uc3QgbXNnID0gXCJObyBhY3Rpdml0eSBzZWVuIGZyb20gcmVhbHRpbWUgaW4gXCIgKyBzaW5jZUxhc3QgKyBcIm1zOyBhc3N1bWluZyBjb25uZWN0aW9uIGhhcyBkcm9wcGVkXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJUcmFuc3BvcnQub25JZGxlVGltZXJFeHBpcmUoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KG5ldyBFcnJvckluZm8obXNnLCA4MDAwMywgNDA4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRpbWVSZW1haW5pbmcgKyAxMDApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdHJ5Q29ubmVjdCh0cmFuc3BvcnRDdG9yLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRDdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgIGxldCB0cmFuc3BvcnRBdHRlbXB0VGltZXI7XG4gICAgY29uc3QgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zcG9ydEF0dGVtcHRUaW1lcik7XG4gICAgICBjYWxsYmFjayh7IGV2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCA9IGNvbm5lY3Rpb25NYW5hZ2VyLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICB0cmFuc3BvcnRBdHRlbXB0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRyYW5zcG9ydC5vZmYoW1wicHJlY29ubmVjdFwiLCBcImRpc2Nvbm5lY3RlZFwiLCBcImZhaWxlZFwiXSk7XG4gICAgICB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgZXJyb3JDYi5jYWxsKFxuICAgICAgICB7IGV2ZW50OiBcImRpc2Nvbm5lY3RlZFwiIH0sXG4gICAgICAgIG5ldyBFcnJvckluZm8oXCJUaW1lb3V0IHdhaXRpbmcgZm9yIHRyYW5zcG9ydCB0byBpbmRpY2F0ZSBpdHNlbGYgdmlhYmxlXCIsIDVlNCwgNTAwKVxuICAgICAgKTtcbiAgICB9LCByZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICB0cmFuc3BvcnQub24oW1wiZmFpbGVkXCIsIFwiZGlzY29ubmVjdGVkXCJdLCBlcnJvckNiKTtcbiAgICB0cmFuc3BvcnQub24oXCJwcmVjb25uZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJUcmFuc3BvcnQudHJ5Q29ubmVjdCgpXCIsXG4gICAgICAgIFwidmlhYmxlIHRyYW5zcG9ydCBcIiArIHRyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc3BvcnRBdHRlbXB0VGltZXIpO1xuICAgICAgdHJhbnNwb3J0Lm9mZihbXCJmYWlsZWRcIiwgXCJkaXNjb25uZWN0ZWRcIl0sIGVycm9yQ2IpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcbiAgICB9KTtcbiAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gIH1cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJpc0F2YWlsYWJsZSBub3QgaW1wbGVtZW50ZWQgZm9yIHRyYW5zcG9ydFwiLCA1ZTQsIDUwMCk7XG4gIH1cbn07XG52YXIgdHJhbnNwb3J0X2RlZmF1bHQgPSBUcmFuc3BvcnQ7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL1RyYW5zcG9ydE5hbWUudHNcbnZhciBUcmFuc3BvcnROYW1lcztcbigoVHJhbnNwb3J0TmFtZXMyKSA9PiB7XG4gIFRyYW5zcG9ydE5hbWVzMi5XZWJTb2NrZXQgPSBcIndlYl9zb2NrZXRcIjtcbiAgVHJhbnNwb3J0TmFtZXMyLkNvbWV0ID0gXCJjb21ldFwiO1xuICBUcmFuc3BvcnROYW1lczIuWGhyUG9sbGluZyA9IFwieGhyX3BvbGxpbmdcIjtcbn0pKFRyYW5zcG9ydE5hbWVzIHx8IChUcmFuc3BvcnROYW1lcyA9IHt9KSk7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9ubWFuYWdlci50c1xudmFyIGdsb2JhbE9iamVjdDIgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG52YXIgaGF2ZVdlYlN0b3JhZ2UgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiB0eXBlb2YgUGxhdGZvcm0uV2ViU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9jYWxTdXBwb3J0ZWQpO1xufTtcbnZhciBoYXZlU2Vzc2lvblN0b3JhZ2UgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiB0eXBlb2YgUGxhdGZvcm0uV2ViU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Vzc2lvblN1cHBvcnRlZCk7XG59O1xudmFyIG5vb3AyID0gZnVuY3Rpb24oKSB7XG59O1xudmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gXCJhYmx5LXRyYW5zcG9ydC1wcmVmZXJlbmNlXCI7XG5mdW5jdGlvbiBkZWNvZGVSZWNvdmVyeUtleShyZWNvdmVyeUtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJlY292ZXJ5S2V5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG52YXIgVHJhbnNwb3J0UGFyYW1zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBob3N0LCBtb2RlLCBjb25uZWN0aW9uS2V5KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbktleTtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgfVxuICBnZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBhdXRoUGFyYW1zID8gY29weShhdXRoUGFyYW1zKSA6IHt9O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgIGNhc2UgXCJyZXN1bWVcIjpcbiAgICAgICAgcGFyYW1zLnJlc3VtZSA9IHRoaXMuY29ubmVjdGlvbktleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVjb3ZlclwiOiB7XG4gICAgICAgIGNvbnN0IHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KG9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICBwYXJhbXMucmVjb3ZlciA9IHJlY292ZXJ5Q29udGV4dC5jb25uZWN0aW9uS2V5O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50SWQgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnRJZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZWNob01lc3NhZ2VzID09PSBmYWxzZSkge1xuICAgICAgcGFyYW1zLmVjaG8gPSBcImZhbHNlXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvcm1hdCAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmVhbSAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuc3RyZWFtID0gdGhpcy5zdHJlYW07XG4gICAgfVxuICAgIGlmICh0aGlzLmhlYXJ0YmVhdHMgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSB0aGlzLmhlYXJ0YmVhdHM7XG4gICAgfVxuICAgIHBhcmFtcy52ID0gZGVmYXVsdHNfZGVmYXVsdC5wcm90b2NvbFZlcnNpb247XG4gICAgcGFyYW1zLmFnZW50ID0gZ2V0QWdlbnRTdHJpbmcodGhpcy5vcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc3BvcnRQYXJhbXMgIT09IHZvaWQgMCkge1xuICAgICAgbWl4aW4ocGFyYW1zLCBvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiW21vZGU9XCIgKyB0aGlzLm1vZGU7XG4gICAgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgcmVzdWx0ICs9IFwiLGhvc3Q9XCIgKyB0aGlzLmhvc3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHJlc3VsdCArPSBcIixjb25uZWN0aW9uS2V5PVwiICsgdGhpcy5jb25uZWN0aW9uS2V5O1xuICAgIH1cbiAgICBpZiAodGhpcy5mb3JtYXQpIHtcbiAgICAgIHJlc3VsdCArPSBcIixmb3JtYXQ9XCIgKyB0aGlzLmZvcm1hdDtcbiAgICB9XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSBjbGFzcyBfQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHJlYWx0aW1lLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocmVhbHRpbWUubG9nZ2VyKTtcbiAgICB0aGlzLnN1cHBvcnRlZFRyYW5zcG9ydHMgPSB7fTtcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlID0geyBpc1Byb2Nlc3Npbmc6IGZhbHNlLCBxdWV1ZTogW10gfTtcbiAgICB0aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG4gICAgdGhpcy5pbml0VHJhbnNwb3J0cygpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY29uc3QgdGltZW91dHMgPSBvcHRpb25zLnRpbWVvdXRzO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUaW1lb3V0ID0gdGltZW91dHMud2ViU29ja2V0Q29ubmVjdFRpbWVvdXQgKyB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgIHRoaXMuc3RhdGVzID0ge1xuICAgICAgaW5pdGlhbGl6ZWQ6IHtcbiAgICAgICAgc3RhdGU6IFwiaW5pdGlhbGl6ZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIGNvbm5lY3Rpbmc6IHtcbiAgICAgICAgc3RhdGU6IFwiY29ubmVjdGluZ1wiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogY29ubmVjdGluZ1RpbWVvdXQsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZDoge1xuICAgICAgICBzdGF0ZTogXCJjb25uZWN0ZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHNlbmRFdmVudHM6IHRydWUsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZDoge1xuICAgICAgICBzdGF0ZTogXCJkaXNjb25uZWN0ZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLmRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICB9LFxuICAgICAgc3VzcGVuZGVkOiB7XG4gICAgICAgIHN0YXRlOiBcInN1c3BlbmRlZFwiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnN1c3BlbmRlZFJldHJ5VGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcInN1c3BlbmRlZFwiXG4gICAgICB9LFxuICAgICAgY2xvc2luZzoge1xuICAgICAgICBzdGF0ZTogXCJjbG9zaW5nXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcImNsb3NlZFwiXG4gICAgICB9LFxuICAgICAgY2xvc2VkOiB7IHN0YXRlOiBcImNsb3NlZFwiLCB0ZXJtaW5hbDogdHJ1ZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiBcImNsb3NlZFwiIH0sXG4gICAgICBmYWlsZWQ6IHsgc3RhdGU6IFwiZmFpbGVkXCIsIHRlcm1pbmFsOiB0cnVlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6IFwiZmFpbGVkXCIgfVxuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLmluaXRpYWxpemVkO1xuICAgIHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgIHRoaXMucXVldWVkTWVzc2FnZXMgPSBuZXcgbWVzc2FnZXF1ZXVlX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMubXNnU2VyaWFsID0gMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvbklkID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvbktleSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IHRpbWVvdXRzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnRzID0gaW50ZXJzZWN0KG9wdGlvbnMudHJhbnNwb3J0cyB8fCBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRUcmFuc3BvcnRzLCB0aGlzLnN1cHBvcnRlZFRyYW5zcG9ydHMpO1xuICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG4gICAgaWYgKHRoaXMudHJhbnNwb3J0cy5pbmNsdWRlcyhUcmFuc3BvcnROYW1lcy5XZWJTb2NrZXQpKSB7XG4gICAgICB0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXMoVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZykpIHtcbiAgICAgIHRoaXMuYmFzZVRyYW5zcG9ydCA9IFRyYW5zcG9ydE5hbWVzLlhoclBvbGxpbmc7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXMoVHJhbnNwb3J0TmFtZXMuQ29tZXQpKSB7XG4gICAgICB0aGlzLmJhc2VUcmFuc3BvcnQgPSBUcmFuc3BvcnROYW1lcy5Db21ldDtcbiAgICB9XG4gICAgdGhpcy5kb21haW5zID0gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0cyhvcHRpb25zKTtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbnVsbDtcbiAgICB0aGlzLmhvc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG4gICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgIHRoaXMuY29ubmVjdENvdW50ZXIgPSAwO1xuICAgIHRoaXMud3NDaGVja1Jlc3VsdCA9IG51bGw7XG4gICAgdGhpcy53ZWJTb2NrZXRTbG93VGltZXIgPSBudWxsO1xuICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBudWxsO1xuICAgIHRoaXMuYWJhbmRvbmVkV2ViU29ja2V0ID0gZmFsc2U7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLCBcInN0YXJ0ZWRcIik7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgIFwicmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbXCIgKyAob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFRyYW5zcG9ydHMpICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImF2YWlsYWJsZSB0cmFuc3BvcnRzID0gW1wiICsgdGhpcy50cmFuc3BvcnRzICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImh0dHAgZG9tYWlucyA9IFtcIiArIHRoaXMuZG9tYWlucyArIFwiXVwiXG4gICAgKTtcbiAgICBpZiAoIXRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwibm8gcmVxdWVzdGVkIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJyZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsIG1zZyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IFBsYXRmb3JtLkNvbmZpZy5hZGRFdmVudExpc3RlbmVyO1xuICAgIGlmIChhZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAoaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgdHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgdGhpcy5wZXJzaXN0Q29ubmVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgICAgICAgIFwiYmVmb3JldW5sb2FkIGV2ZW50IGhhcyB0cmlnZ2VyZWQgdGhlIGNvbm5lY3Rpb24gdG8gY2xvc2UgYXMgY2xvc2VPblVubG9hZCBpcyB0cnVlXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY2xvc2luZ1wiIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQgfHwgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zdXNwZW5kZWQpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIgXFx1MjAxOG9ubGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwicmVhdHRlbXB0aW5nIGNvbm5lY3Rpb25cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgKF9hMiA9IHRoaXMucGVuZGluZ1RyYW5zcG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vZmYoKTtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciBcXHUyMDE4b2ZmbGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwiZGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKioqKioqKioqKioqKioqKioqKipcbiAgICogdHJhbnNwb3J0IG1hbmFnZW1lbnRcbiAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgLy8gVXNlZCBieSB0ZXN0c1xuICBzdGF0aWMgc3VwcG9ydGVkVHJhbnNwb3J0cyhhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHsgc3VwcG9ydGVkVHJhbnNwb3J0czoge30gfTtcbiAgICB0aGlzLmluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpO1xuICAgIHJldHVybiBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHM7XG4gIH1cbiAgc3RhdGljIGluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpIHtcbiAgICBjb25zdCBpbXBsZW1lbnRhdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgUGxhdGZvcm0uVHJhbnNwb3J0cy5idW5kbGVkSW1wbGVtZW50YXRpb25zKSwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucyk7XG4gICAgW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldCwgLi4uUGxhdGZvcm0uVHJhbnNwb3J0cy5vcmRlcl0uZm9yRWFjaCgodHJhbnNwb3J0TmFtZSkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gaW1wbGVtZW50YXRpb25zW3RyYW5zcG9ydE5hbWVdO1xuICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0cmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHNbdHJhbnNwb3J0TmFtZV0gPSB0cmFuc3BvcnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW5pdFRyYW5zcG9ydHMoKSB7XG4gICAgX0Nvbm5lY3Rpb25NYW5hZ2VyLmluaXRUcmFuc3BvcnRzKHRoaXMucmVhbHRpbWUuX2FkZGl0aW9uYWxUcmFuc3BvcnRJbXBsZW1lbnRhdGlvbnMsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhob3N0LCBtb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc3BvcnRQYXJhbXModGhpcy5vcHRpb25zLCBob3N0LCBtb2RlLCB0aGlzLmNvbm5lY3Rpb25LZXkpO1xuICB9XG4gIGdldFRyYW5zcG9ydFBhcmFtcyhjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlY2lkZU1vZGUgPSAobW9kZUNiKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICAgIG1vZGVDYihcInJlc3VtZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVjb3ZlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWNvdmVyRm4gPSB0aGlzLm9wdGlvbnMucmVjb3ZlciwgbGFzdFNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uUmVjb3ZlckRhdGEoKSwgc2Vzc2lvblJlY292ZXJ5TmFtZSA9IHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpO1xuICAgICAgaWYgKGxhc3RTZXNzaW9uRGF0YSAmJiB0eXBlb2YgcmVjb3ZlckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpXCIsXG4gICAgICAgICAgXCJDYWxsaW5nIGNsaWVudE9wdGlvbnMtcHJvdmlkZWQgcmVjb3ZlciBmdW5jdGlvbiB3aXRoIGxhc3Qgc2Vzc2lvbiBkYXRhIChyZWNvdmVyeSBzY29wZTogXCIgKyBzZXNzaW9uUmVjb3ZlcnlOYW1lICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmVjb3ZlckZuKGxhc3RTZXNzaW9uRGF0YSwgKHNob3VsZFJlY292ZXIpID0+IHtcbiAgICAgICAgICBpZiAoc2hvdWxkUmVjb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XG4gICAgICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICB9O1xuICAgIGRlY2lkZU1vZGUoKG1vZGUpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydFBhcmFtcyA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKG51bGwsIG1vZGUpO1xuICAgICAgaWYgKG1vZGUgPT09IFwicmVjb3ZlclwiKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKVwiLFxuICAgICAgICAgIFwiVHJhbnNwb3J0IHJlY292ZXJ5IG1vZGUgPSByZWNvdmVyOyByZWNvdmVyeUtleSA9IFwiICsgdGhpcy5vcHRpb25zLnJlY292ZXJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkodGhpcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5tc2dTZXJpYWwgPSByZWNvdmVyeUNvbnRleHQubXNnU2VyaWFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKClcIixcbiAgICAgICAgICBcIlRyYW5zcG9ydCBwYXJhbXMgPSBcIiArIHRyYW5zcG9ydFBhcmFtcy50b1N0cmluZygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayh0cmFuc3BvcnRQYXJhbXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGNvbm5lY3QgdXNpbmcgYSBnaXZlbiB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgKiBAcGFyYW0gY2FuZGlkYXRlLCB0aGUgdHJhbnNwb3J0IHRvIHRyeVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpXCIsIFwidHJ5aW5nIFwiICsgY2FuZGlkYXRlKTtcbiAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0ID0gdHJhbnNwb3J0X2RlZmF1bHQudHJ5Q29ubmVjdChcbiAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNwb3J0c1tjYW5kaWRhdGVdLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMucmVhbHRpbWUuYXV0aCxcbiAgICAgIHRyYW5zcG9ydFBhcmFtcyxcbiAgICAgICh3cmFwcGVkRXJyLCB0cmFuc3BvcnQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2luZyB8fCBzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZmFpbGVkKSB7XG4gICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgICAgICBcImNvbm5lY3Rpb24gXCIgKyBzdGF0ZS5zdGF0ZSArIFwiIHdoaWxlIHdlIHdlcmUgYXR0ZW1wdGluZyB0aGUgdHJhbnNwb3J0OyBjbG9zaW5nIFwiICsgdHJhbnNwb3J0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBlZEVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KClcIixcbiAgICAgICAgICAgIFwidHJhbnNwb3J0IFwiICsgY2FuZGlkYXRlICsgXCIgXCIgKyB3cmFwcGVkRXJyLmV2ZW50ICsgXCIsIGVycjogXCIgKyB3cmFwcGVkRXJyLmVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih3cmFwcGVkRXJyLmVycm9yKSAmJiAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gd3JhcHBlZEVyci5lcnJvcjtcbiAgICAgICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLnJlYWx0aW1lLmF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCksIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXRyaWFibGUod3JhcHBlZEVyci5lcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgIFwidmlhYmxlIHRyYW5zcG9ydCBcIiArIGNhbmRpZGF0ZSArIFwiOyBzZXR0aW5nIHBlbmRpbmdcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGluZGljYXRlZCB0byBiZSB2aWFibGUsIGFuZCB0aGUgQ29ubmVjdGlvbk1hbmFnZXJcbiAgICogZXhwZWN0cyB0byBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCBhcyBzb29uIGFzIGl0IGlzIGNvbm5lY3RlZC5cbiAgICogQHBhcmFtIHRyYW5zcG9ydFxuICAgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG4gICAqL1xuICBzZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgY29uc3QgbW9kZSA9IHRyYW5zcG9ydFBhcmFtcy5tb2RlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFuc3BvcnRQZW5kaW5nKClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnQgKyBcIjsgbW9kZSA9IFwiICsgbW9kZVxuICAgICk7XG4gICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRyYW5zcG9ydC5vbmNlKFwiY29ubmVjdGVkXCIsIChlcnJvciwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgIGlmIChtb2RlID09PSBcInJlY292ZXJcIiAmJiB0aGlzLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnJlY292ZXI7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICB0cmFuc3BvcnQub24oW1wiZGlzY29ubmVjdGVkXCIsIFwiY2xvc2VkXCIsIFwiZmFpbGVkXCJdLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZjIuZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRoaXMuZXZlbnQsIGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnQucGVuZGluZ1wiLCB0cmFuc3BvcnQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsIGFuZCB0aGUgY29ubmVjdGlvbm1hbmFnZXIgZGVjaWRlcyB0aGF0XG4gICAqIGl0IHdpbGwgbm93IGJlIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGl0IGFjdGl2YXRlZFxuICAgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0IHRoZSB0cmFuc3BvcnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCB0aGUgaWQgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKi9cbiAgYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcInRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0XG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIiwgXCJlcnJvciA9IFwiICsgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbklkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25JZCA9ICBcIiArIGNvbm5lY3Rpb25JZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25EZXRhaWxzID0gIFwiICsgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbkRldGFpbHMpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydCk7XG4gICAgY29uc3QgZXhpc3RpbmdTdGF0ZSA9IHRoaXMuc3RhdGUsIGNvbm5lY3RlZFN0YXRlID0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcImN1cnJlbnQgc3RhdGUgPSBcIiArIGV4aXN0aW5nU3RhdGUuc3RhdGVcbiAgICApO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3Npbmcuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5mYWlsZWQuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGlzY29ubmVjdGluZyB0cmFuc3BvcnQgYW5kIGFiYW5kb25pbmdcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQ7XG4gICAgaWYgKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGVjbGluaW5nIHRvIGFjdGl2YXRlIHRyYW5zcG9ydCBcIiArIHRyYW5zcG9ydCArIFwiIHNpbmNlIGl0IGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIGNvbm5lY3RlZFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0FjdGl2ZVByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbDtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbmV3IHByb3RvY29sX2RlZmF1bHQodHJhbnNwb3J0KTtcbiAgICB0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG4gICAgY29uc3QgY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gICAgaWYgKGNvbm5lY3Rpb25LZXkgJiYgdGhpcy5jb25uZWN0aW9uS2V5ICE9IGNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCAhIWVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0cmFuc3BvcnQub24oXG4gICAgICAgIFwiY29ubmVjdGVkXCIsXG4gICAgICAgIChjb25uZWN0ZWRFcnIsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzMikgPT4ge1xuICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlsczIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfZGVmYXVsdChjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGNvbm5lY3RlZEVycikpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3I7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBlcnJvcikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGVkXCIsIGVycm9yIH0pO1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yIHx8IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5hY3RpdmVcIiwgdHJhbnNwb3J0KTtcbiAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgPiAwKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgICAgXCJQcmV2aW91cyBhY3RpdmUgcHJvdG9jb2wgKGZvciB0cmFuc3BvcnQgXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIiwgbmV3IG9uZSBpcyBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIikgZmluaXNoaW5nIHdpdGggXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgXCIgbWVzc2FnZXMgc3RpbGwgcGVuZGluZ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkFzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCB3YXMgYWxzbyB0aGUgdHJhbnNwb3J0IGZvciB0aGUgcHJldmlvdXMgYWN0aXZlIHByb3RvY29sOyB0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIjsgc3RhY2sgPSBcIiArIG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsIG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0FjdGl2ZVByb3RvY29sLmZpbmlzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBUaGlzIGNhbiBvY2N1clxuICAgKiBpbiBhbnkgdHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICovXG4gIGRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCBzdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBjdXJyZW50UHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sLCB3YXNBY3RpdmUgPSBjdXJyZW50UHJvdG9jb2wgJiYgY3VycmVudFByb3RvY29sLmdldFRyYW5zcG9ydCgpID09PSB0cmFuc3BvcnQsIHdhc1BlbmRpbmcgPSB0cmFuc3BvcnQgPT09IHRoaXMucGVuZGluZ1RyYW5zcG9ydCwgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IHRoaXMubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnRcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwic3RhdGUgPSBcIiArIHN0YXRlICsgKHdhc0FjdGl2ZSA/IFwiOyB3YXMgYWN0aXZlXCIgOiB3YXNQZW5kaW5nID8gXCI7IHdhcyBwZW5kaW5nXCIgOiBcIlwiKSArIChub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID8gXCJcIiA6IFwiOyBhbm90aGVyIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb25cIilcbiAgICApO1xuICAgIGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlKVxuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcInJlYXNvbiA9ICBcIiArIGVycm9yLm1lc3NhZ2VcbiAgICAgICk7XG4gICAgaWYgKHdhc0FjdGl2ZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcIkdldHRpbmcsIGNsZWFyaW5nLCBhbmQgcmVxdWV1aW5nIFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArIFwiIHBlbmRpbmcgbWVzc2FnZXNcIlxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcbiAgICAgIGN1cnJlbnRQcm90b2NvbC5jbGVhclBlbmRpbmdNZXNzYWdlcygpO1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbCA9IHRoaXMuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5pbmFjdGl2ZVwiLCB0cmFuc3BvcnQpO1xuICAgIGlmICh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiB8fCB3YXNBY3RpdmUgJiYgc3RhdGUgPT09IFwiZmFpbGVkXCIgfHwgc3RhdGUgPT09IFwiY2xvc2VkXCIgfHwgY3VycmVudFByb3RvY29sID09PSBudWxsICYmIHdhc1BlbmRpbmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiBlcnJvciAmJiBlcnJvci5zdGF0dXNDb2RlID4gNTAwICYmIHRoaXMuZG9tYWlucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICB0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlLCBlcnJvciwgcmV0cnlJbW1lZGlhdGVseTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3Q29ubmVjdGlvblN0YXRlID0gc3RhdGUgPT09IFwiZmFpbGVkXCIgJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoZXJyb3IpID8gXCJkaXNjb25uZWN0ZWRcIiA6IHN0YXRlO1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBuZXdDb25uZWN0aW9uU3RhdGUsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvKiBIZWxwZXIgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMgd2hpY2ggYXJlIHBlbmRpbmcsXG4gICAqIGhhdmUgYmVlbiBjb25uZWN0ZWQsIGFuZCBhcmUganVzdCB3YWl0aW5nIGZvciBvbmNlTm9QZW5kaW5nIHRvIGZpcmUgYmVmb3JlXG4gICAqIGJlaW5nIGFjdGl2YXRlZCAqL1xuICBub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5wZW5kaW5nVHJhbnNwb3J0IHx8ICF0aGlzLnBlbmRpbmdUcmFuc3BvcnQuaXNDb25uZWN0ZWQ7XG4gIH1cbiAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBoYXNDb25uZWN0aW9uRXJyb3IpIHtcbiAgICBjb25zdCBwcmV2Q29ubklkID0gdGhpcy5jb25uZWN0aW9uSWQsIGNvbm5JZENoYW5nZWQgPSBwcmV2Q29ubklkICYmIHByZXZDb25uSWQgIT09IGNvbm5lY3Rpb25JZCwgcmVjb3ZlckZhaWx1cmUgPSAhcHJldkNvbm5JZCAmJiBoYXNDb25uZWN0aW9uRXJyb3I7XG4gICAgaWYgKGNvbm5JZENoYW5nZWQgfHwgcmVjb3ZlckZhaWx1cmUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKVwiLCBcIlJlc2V0dGluZyBtc2dTZXJpYWxcIik7XG4gICAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnJlc2V0U2VuZEF0dGVtcHRlZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uSWQgIT09IGNvbm5lY3Rpb25JZCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKVwiLFxuICAgICAgICBcIk5ldyBjb25uZWN0aW9uSWQ7IHJlYXR0YWNoaW5nIGFueSBhdHRhY2hlZCBjaGFubmVsc1wiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvbktleTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmlkID0gdGhpcy5jb25uZWN0aW9uSWQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IHZvaWQgMDtcbiAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5yZXNldFNlbmRBdHRlbXB0ZWQoKTtcbiAgICB0aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcbiAgfVxuICBjcmVhdGVSZWNvdmVyeUtleSgpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG4gICAgICBtc2dTZXJpYWw6IHRoaXMubXNnU2VyaWFsLFxuICAgICAgY2hhbm5lbFNlcmlhbHM6IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuY2hhbm5lbFNlcmlhbHMoKVxuICAgIH0pO1xuICB9XG4gIGNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCkge1xuICAgIGlmICghdGhpcy5sYXN0QWN0aXZpdHkgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpbmNlTGFzdCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICBpZiAoc2luY2VMYXN0ID4gdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgKyB0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKClcIixcbiAgICAgICAgXCJMYXN0IGtub3duIGFjdGl2aXR5IGZyb20gcmVhbHRpbWUgd2FzIFwiICsgc2luY2VMYXN0ICsgXCJtcyBhZ287IGRpc2NhcmRpbmcgY29ubmVjdGlvbiBzdGF0ZVwiXG4gICAgICApO1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICAgIHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gXCJzdXNwZW5kZWRcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgKi9cbiAgcGVyc2lzdENvbm5lY3Rpb24oKSB7XG4gICAgaWYgKGhhdmVTZXNzaW9uU3RvcmFnZSgpKSB7XG4gICAgICBjb25zdCByZWNvdmVyeUtleSA9IHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgICAgIGlmIChyZWNvdmVyeUtleSkge1xuICAgICAgICB0aGlzLnNldFNlc3Npb25SZWNvdmVyRGF0YSh7XG4gICAgICAgICAgcmVjb3ZlcnlLZXksXG4gICAgICAgICAgZGlzY29ubmVjdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgbG9jYXRpb246IGdsb2JhbE9iamVjdDIubG9jYXRpb24sXG4gICAgICAgICAgY2xpZW50SWQ6IHRoaXMucmVhbHRpbWUuYXV0aC5jbGllbnRJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgKi9cbiAgdW5wZXJzaXN0Q29ubmVjdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCk7XG4gIH1cbiAgZ2V0QWN0aXZlVHJhbnNwb3J0Rm9ybWF0KCkge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIChfYTIgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYW5zcG9ydCgpLmZvcm1hdDtcbiAgfVxuICAvKioqKioqKioqKioqKioqKioqKioqXG4gICAqIHN0YXRlIG1hbmFnZW1lbnRcbiAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgZ2V0RXJyb3IoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3JSZWFzb24pIHtcbiAgICAgIGNvbnN0IG5ld0Vycm9yID0gUGFydGlhbEVycm9ySW5mby5mcm9tVmFsdWVzKHRoaXMuZXJyb3JSZWFzb24pO1xuICAgICAgbmV3RXJyb3IuY2F1c2UgPSB0aGlzLmVycm9yUmVhc29uO1xuICAgICAgcmV0dXJuIG5ld0Vycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZUVycm9yKCk7XG4gIH1cbiAgZ2V0U3RhdGVFcnJvcigpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbdGhpcy5zdGF0ZS5zdGF0ZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMik7XG4gIH1cbiAgYWN0aXZlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucXVldWVFdmVudHMgfHwgdGhpcy5zdGF0ZS5zZW5kRXZlbnRzO1xuICB9XG4gIGVuYWN0U3RhdGVDaGFuZ2Uoc3RhdGVDaGFuZ2UpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBcIkNvbm5lY3Rpb24gc3RhdGVcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gc3RhdGVDaGFuZ2UuY3VycmVudCArIChzdGF0ZUNoYW5nZS5yZWFzb24gPyBcIjsgcmVhc29uOiBcIiArIHN0YXRlQ2hhbmdlLnJlYXNvbiA6IFwiXCIpO1xuICAgIGlmIChzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSBcImZhaWxlZFwiKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYWN0aW9uLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5lbmFjdFN0YXRlQ2hhbmdlXCIsXG4gICAgICBcInNldHRpbmcgbmV3IHN0YXRlOiBcIiArIHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyBcIjsgcmVhc29uID0gXCIgKyAoc3RhdGVDaGFuZ2UucmVhc29uICYmIHN0YXRlQ2hhbmdlLnJlYXNvbi5tZXNzYWdlKVxuICAgICk7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVDaGFuZ2UuY3VycmVudF07XG4gICAgaWYgKHN0YXRlQ2hhbmdlLnJlYXNvbikge1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcbiAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcbiAgICB9XG4gICAgaWYgKG5ld1N0YXRlLnRlcm1pbmFsIHx8IG5ld1N0YXRlLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uc3RhdGVcIiwgc3RhdGVDaGFuZ2UpO1xuICB9XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIENvbm5lY3Rpb25NYW5hZ2VyIGNvbm5lY3Rpb24gbGlmZWN5Y2xlXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICBzdGFydFRyYW5zaXRpb25UaW1lcih0cmFuc2l0aW9uU3RhdGUpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKVwiLFxuICAgICAgXCJ0cmFuc2l0aW9uU3RhdGU6IFwiICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlXG4gICAgKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zdGFydFRyYW5zaXRpb25UaW1lcigpXCIsXG4gICAgICAgIFwiY2xlYXJpbmcgYWxyZWFkeS1ydW5uaW5nIHRpbWVyXCJcbiAgICAgICk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFwiICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlICsgXCIgdGltZXIgZXhwaXJlZFwiLFxuICAgICAgICAgIFwicmVxdWVzdGluZyBuZXcgc3RhdGU6IFwiICsgdHJhbnNpdGlvblN0YXRlLmZhaWxTdGF0ZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGUgfSk7XG4gICAgICB9XG4gICAgfSwgdHJhbnNpdGlvblN0YXRlLnJldHJ5RGVsYXkpO1xuICB9XG4gIGNhbmNlbFRyYW5zaXRpb25UaW1lcigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKVwiLCBcIlwiKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25UaW1lcik7XG4gICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0U3VzcGVuZFRpbWVyKCkge1xuICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnN1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3VzcGVuZFRpbWVyKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIHN1c3BlbmQgdGltZXIgZXhwaXJlZFwiLFxuICAgICAgICAgIFwicmVxdWVzdGluZyBuZXcgc3RhdGU6IHN1c3BlbmRlZFwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gXCJzdXNwZW5kZWRcIjtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcInN1c3BlbmRlZFwiIH0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsKTtcbiAgfVxuICBjaGVja1N1c3BlbmRUaW1lcihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAhPT0gXCJkaXNjb25uZWN0ZWRcIiAmJiBzdGF0ZSAhPT0gXCJzdXNwZW5kZWRcIiAmJiBzdGF0ZSAhPT0gXCJjb25uZWN0aW5nXCIpXG4gICAgICB0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xuICB9XG4gIGNhbmNlbFN1c3BlbmRUaW1lcigpIHtcbiAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gICAgaWYgKHRoaXMuc3VzcGVuZFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zdXNwZW5kVGltZXIpO1xuICAgICAgdGhpcy5zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFJldHJ5VGltZXIoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyIHJldHJ5IHRpbWVyIGV4cGlyZWRcIiwgXCJyZXRyeWluZ1wiKTtcbiAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH1cbiAgY2FuY2VsUmV0cnlUaW1lcigpIHtcbiAgICBpZiAodGhpcy5yZXRyeVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcbiAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0V2ViU29ja2V0U2xvd1RpbWVyKCkge1xuICAgIHRoaXMud2ViU29ja2V0U2xvd1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgXCJjaGVja2luZyBjb25uZWN0aXZpdHlcIlxuICAgICAgKTtcbiAgICAgIHRoaXMuY2hlY2tXc0Nvbm5lY3Rpdml0eSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgICBcIndzIGNvbm5lY3Rpdml0eSBjaGVjayBzdWNjZWVkZWRcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLndzQ2hlY2tSZXN1bHQgPSB0cnVlO1xuICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgICBcIndzIGNvbm5lY3Rpdml0eSBjaGVjayBmYWlsZWRcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLndzQ2hlY2tSZXN1bHQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSkge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXModGhpcy5yZWFsdGltZS5odHRwLmNoZWNrQ29ubmVjdGl2aXR5KCksIChlcnIsIGNvbm5lY3Rpdml0eSkgPT4ge1xuICAgICAgICAgIGlmIChlcnIgfHwgIWNvbm5lY3Rpdml0eSkge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgICAgIFwiaHR0cCBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHtcbiAgICAgICAgICAgICAgc3RhdGU6IFwiZGlzY29ubmVjdGVkXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGNvbm5lY3QgKG5ldHdvcmsgdW5yZWFjaGFibGUpXCIsIDgwMDAzLCA0MDQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgICAgIFwiaHR0cCBjb25uZWN0aXZpdHkgY2hlY2sgc3VjY2VlZGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dHMud2ViU29ja2V0U2xvd1RpbWVvdXQpO1xuICB9XG4gIGNhbmNlbFdlYlNvY2tldFNsb3dUaW1lcigpIHtcbiAgICBpZiAodGhpcy53ZWJTb2NrZXRTbG93VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndlYlNvY2tldFNsb3dUaW1lcik7XG4gICAgICB0aGlzLndlYlNvY2tldFNsb3dUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0V2ViU29ja2V0R2l2ZVVwVGltZXIodHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgdGhpcy53ZWJTb2NrZXRHaXZlVXBUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICBpZiAoIXRoaXMud3NDaGVja1Jlc3VsdCkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IGdpdmUgdXAgdGltZXJcIixcbiAgICAgICAgICBcIndlYnNvY2tldCBjb25uZWN0aW9uIHRvb2sgbW9yZSB0aGFuIDEwczsgXCIgKyAodGhpcy5iYXNlVHJhbnNwb3J0ID8gXCJ0cnlpbmcgYmFzZSB0cmFuc3BvcnRcIiA6IFwiXCIpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0aGlzLmJhc2VUcmFuc3BvcnQpIHtcbiAgICAgICAgICB0aGlzLmFiYW5kb25lZFdlYlNvY2tldCA9IHRydWU7XG4gICAgICAgICAgKF9hMiA9IHRoaXMucHJvcG9zZWRUcmFuc3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZGlzcG9zZSgpO1xuICAgICAgICAgIChfYiA9IHRoaXMucGVuZGluZ1RyYW5zcG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RCYXNlKHRyYW5zcG9ydFBhcmFtcywgKyt0aGlzLmNvbm5lY3RDb3VudGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IGdpdmUgdXAgdGltZXJcIixcbiAgICAgICAgICAgIFwid2Vic29ja2V0IGNvbm5lY3Rpdml0eSBhcHBlYXJzIHRvIGJlIHVuYXZhaWxhYmxlIGJ1dCBubyBvdGhlciB0cmFuc3BvcnRzIHRvIHRyeVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy53ZWJTb2NrZXRDb25uZWN0VGltZW91dCk7XG4gIH1cbiAgY2FuY2VsV2ViU29ja2V0R2l2ZVVwVGltZXIoKSB7XG4gICAgaWYgKHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyKTtcbiAgICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBub3RpZnlTdGF0ZShpbmRpY2F0ZWQpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBjb25zdCBzdGF0ZSA9IGluZGljYXRlZC5zdGF0ZTtcbiAgICBjb25zdCByZXRyeUltbWVkaWF0ZWx5ID0gc3RhdGUgPT09IFwiZGlzY29ubmVjdGVkXCIgJiYgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCB8fCBpbmRpY2F0ZWQucmV0cnlJbW1lZGlhdGVseSB8fCB0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nICYmIGluZGljYXRlZC5lcnJvciAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycihpbmRpY2F0ZWQuZXJyb3IpICYmICEodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpXCIsXG4gICAgICBcIm5ldyBzdGF0ZTogXCIgKyBzdGF0ZSArIChyZXRyeUltbWVkaWF0ZWx5ID8gXCI7IHdpbGwgcmV0cnkgY29ubmVjdGlvbiBpbW1lZGlhdGVseVwiIDogXCJcIilcbiAgICApO1xuICAgIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRTbG93VGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCk7XG4gICAgdGhpcy5jaGVja1N1c3BlbmRUaW1lcihpbmRpY2F0ZWQuc3RhdGUpO1xuICAgIGlmIChzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiB8fCBzdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUudGVybWluYWwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tpbmRpY2F0ZWQuc3RhdGVdO1xuICAgIGxldCByZXRyeURlbGF5ID0gbmV3U3RhdGUucmV0cnlEZWxheTtcbiAgICBpZiAobmV3U3RhdGUuc3RhdGUgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCsrO1xuICAgICAgcmV0cnlEZWxheSA9IGdldFJldHJ5VGltZShuZXdTdGF0ZS5yZXRyeURlbGF5LCB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQpO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2UgPSBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoXG4gICAgICB0aGlzLnN0YXRlLnN0YXRlLFxuICAgICAgbmV3U3RhdGUuc3RhdGUsXG4gICAgICByZXRyeURlbGF5LFxuICAgICAgaW5kaWNhdGVkLmVycm9yIHx8ICgoX2IgPSAoX2EyID0gY29ubmVjdGlvbmVycm9yc19kZWZhdWx0KVtuZXdTdGF0ZS5zdGF0ZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMikpXG4gICAgKTtcbiAgICBpZiAocmV0cnlJbW1lZGlhdGVseSkge1xuICAgICAgY29uc3QgYXV0b1JlY29ubmVjdCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNpbmNlTGFzdCA9IHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICYmIERhdGUubm93KCkgLSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCArIDE7XG4gICAgICBpZiAoc2luY2VMYXN0ICYmIHNpbmNlTGFzdCA8IDFlMykge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgICAgIFwiTGFzdCByZWNvbm5lY3QgYXR0ZW1wdCB3YXMgb25seSBcIiArIHNpbmNlTGFzdCArIFwibXMgYWdvLCB3YWl0aW5nIGFub3RoZXIgXCIgKyAoMWUzIC0gc2luY2VMYXN0KSArIFwibXMgYmVmb3JlIHRyeWluZyBhZ2FpblwiXG4gICAgICAgICk7XG4gICAgICAgIHNldFRpbWVvdXQoYXV0b1JlY29ubmVjdCwgMWUzIC0gc2luY2VMYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljayhhdXRvUmVjb25uZWN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiIHx8IHN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcihyZXRyeURlbGF5KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiICYmICFyZXRyeUltbWVkaWF0ZWx5IHx8IHN0YXRlID09PSBcInN1c3BlbmRlZFwiIHx8IG5ld1N0YXRlLnRlcm1pbmFsKSB7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGVkXCIgJiYgIXRoaXMuYWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpXCIsXG4gICAgICAgIFwiQnJva2VuIGludmFyaWFudDogYXR0ZW1wdGVkIHRvIGdvIGludG8gY29ubmVjdGVkIHN0YXRlLCBidXQgdGhlcmUgaXMgbm8gYWN0aXZlIHByb3RvY29sXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW5hY3RTdGF0ZUNoYW5nZShjaGFuZ2UpO1xuICAgIGlmICh0aGlzLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIHRoaXMuc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cykge1xuICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKHN0YXRlLCBjaGFuZ2UucmVhc29uKTtcbiAgICAgIHRoaXMuZmFpbFF1ZXVlZE1lc3NhZ2VzKGNoYW5nZS5yZWFzb24pO1xuICAgIH1cbiAgfVxuICByZXF1ZXN0U3RhdGUocmVxdWVzdCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGNvbnN0IHN0YXRlID0gcmVxdWVzdC5zdGF0ZTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKClcIixcbiAgICAgIFwicmVxdWVzdGVkIHN0YXRlOiBcIiArIHN0YXRlICsgXCI7IGN1cnJlbnQgc3RhdGU6IFwiICsgdGhpcy5zdGF0ZS5zdGF0ZVxuICAgICk7XG4gICAgaWYgKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRTbG93VGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICB0aGlzLmNoZWNrU3VzcGVuZFRpbWVyKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT0gXCJjb25uZWN0aW5nXCIgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSBcImNvbm5lY3RlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzdGF0ZSA9PSBcImNsb3NpbmdcIiAmJiB0aGlzLnN0YXRlLnN0YXRlID09IFwiY2xvc2VkXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZV0sIGNoYW5nZSA9IG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfZGVmYXVsdChcbiAgICAgIHRoaXMuc3RhdGUuc3RhdGUsXG4gICAgICBuZXdTdGF0ZS5zdGF0ZSxcbiAgICAgIG51bGwsXG4gICAgICByZXF1ZXN0LmVycm9yIHx8ICgoX2IgPSAoX2EyID0gY29ubmVjdGlvbmVycm9yc19kZWZhdWx0KVtuZXdTdGF0ZS5zdGF0ZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMikpXG4gICAgKTtcbiAgICB0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcbiAgICBpZiAoc3RhdGUgPT0gXCJjb25uZWN0aW5nXCIpIHtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhcnRDb25uZWN0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09IFwiY2xvc2luZ1wiKSB7XG4gICAgICB0aGlzLmNsb3NlSW1wbCgpO1xuICAgIH1cbiAgfVxuICBzdGFydENvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKVwiLFxuICAgICAgICBcIk11c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0LCBidXQgd2FzIFwiICsgdGhpcy5zdGF0ZS5zdGF0ZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXV0aCA9IHRoaXMucmVhbHRpbWUuYXV0aDtcbiAgICBjb25zdCBjb25uZWN0Q291bnQgPSArK3RoaXMuY29ubmVjdENvdW50ZXI7XG4gICAgY29uc3QgY29ubmVjdCA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKTtcbiAgICAgIHRoaXMuZ2V0VHJhbnNwb3J0UGFyYW1zKCh0cmFuc3BvcnRQYXJhbXMpID0+IHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydFBhcmFtcy5tb2RlID09PSBcInJlY292ZXJcIiAmJiB0cmFuc3BvcnRQYXJhbXMub3B0aW9ucy5yZWNvdmVyKSB7XG4gICAgICAgICAgY29uc3QgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkodHJhbnNwb3J0UGFyYW1zLm9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgICAgaWYgKHJlY292ZXJ5Q29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5yZWNvdmVyQ2hhbm5lbHMocmVjb3ZlcnlDb250ZXh0LmNoYW5uZWxTZXJpYWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KClcIiwgXCJzdGFydGluZyBjb25uZWN0aW9uXCIpO1xuICAgIHRoaXMuc3RhcnRTdXNwZW5kVGltZXIoKTtcbiAgICB0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpO1xuICAgIGlmIChhdXRoLm1ldGhvZCA9PT0gXCJiYXNpY1wiKSB7XG4gICAgICBjb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGF1dGhDYiA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmVycm9yUmVhc29uICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhhdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwpLCBhdXRoQ2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKGF1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlKSwgYXV0aENiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLypcbiAgICogdGhlcmUgYXJlLCBhdCBtb3N0LCB0d28gdHJhbnNwb3J0cyBhdmFpbGFibGUgd2l0aCB3aGljaCBhIGNvbm5lY3Rpb24gbWF5XG4gICAqIGJlIGF0dGVtcHRlZDogd2ViX3NvY2tldCBhbmQvb3IgYSBiYXNlIHRyYW5zcG9ydCAoeGhyX3BvbGxpbmcgaW4gYnJvd3NlcnMsXG4gICAqIGNvbWV0IGluIG5vZGVqcykuIHdlYl9zb2NrZXQgaXMgYWx3YXlzIHByZWZlcnJlZCwgYW5kIHRoZSBiYXNlIHRyYW5zcG9ydCBpc1xuICAgKiBvbmx5IHVzZWQgaW4gY2FzZSB3ZWJfc29ja2V0IGNvbm5lY3Rpdml0eSBhcHBlYXJzIHRvIGJlIHVuYXZhaWxhYmxlLlxuICAgKlxuICAgKiBjb25uZWN0SW1wbCBiZWdpbnMgdGhlIHRyYW5zcG9ydCBzZWxlY3Rpb24gcHJvY2VzcyBieSBjaGVja2luZyB3aGljaCB0cmFuc3BvcnRzXG4gICAqIGFyZSBhdmFpbGFibGUsIGFuZCBpZiB0aGVyZSBpcyBhIGNhY2hlZCBwcmVmZXJlbmNlLiBJdCB0aGVuIGRlZmVycyB0byB0aGVcbiAgICogdHJhbnNwb3J0LXNwZWNpZmljIGNvbm5lY3QgbWV0aG9kczogY29ubmVjdFdzIGFuZCBjb25uZWN0QmFzZS5cbiAgICpcbiAgICogSXQgaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgaW52YWxpZGF0aW5nIHRoZSBjYWNoZSBpbiB0aGUgY2FzZSB0aGF0IGEgYmFzZVxuICAgKiB0cmFuc3BvcnQgcHJlZmVyZW5jZSBpcyBzdG9yZWQgYnV0IHdlYiBzb2NrZXQgY29ubmVjdGl2aXR5IGlzIG5vdyBhdmFpbGFibGUuXG4gICAqXG4gICAqIGhhbmRsaW5nIG9mIHRoZSBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gZmFpbG92ZXIgZnJvbSB3ZWJfc29ja2V0IHRvIHRoZSBiYXNlXG4gICAqIHRyYW5zcG9ydCBpcyBpbXBsZW1lbnRlZCBpbiB0aGUgY29ubmVjdFdzIG1ldGhvZC5cbiAgICovXG4gIGNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnN0YXRlO1xuICAgIGlmIChzdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5zdGF0ZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RJbXBsKClcIixcbiAgICAgICAgXCJNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCwgYnV0IHdhcyBcIiArIHN0YXRlXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc3BvcnRQcmVmZXJlbmNlID0gdGhpcy5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgaWYgKHRyYW5zcG9ydFByZWZlcmVuY2UgJiYgdHJhbnNwb3J0UHJlZmVyZW5jZSA9PT0gdGhpcy5iYXNlVHJhbnNwb3J0ICYmIHRoaXMud2ViU29ja2V0VHJhbnNwb3J0QXZhaWxhYmxlKSB7XG4gICAgICB0aGlzLmNoZWNrV3NDb25uZWN0aXZpdHkoKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RJbXBsKCk6XCIsXG4gICAgICAgICAgICBcIndlYiBzb2NrZXQgY29ubmVjdGl2aXR5IGF2YWlsYWJsZSwgY2FuY2VsbGluZyBjb25uZWN0aW9uIGF0dGVtcHQgd2l0aCBcIiArIHRoaXMuYmFzZVRyYW5zcG9ydFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgIHRoaXMuY29ubmVjdFdzKHRyYW5zcG9ydFBhcmFtcywgKyt0aGlzLmNvbm5lY3RDb3VudGVyKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2gobm9vcDIpO1xuICAgIH1cbiAgICBpZiAodHJhbnNwb3J0UHJlZmVyZW5jZSAmJiB0cmFuc3BvcnRQcmVmZXJlbmNlID09PSB0aGlzLmJhc2VUcmFuc3BvcnQgfHwgdGhpcy5iYXNlVHJhbnNwb3J0ICYmICF0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29ubmVjdFdzKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICB9XG4gIH1cbiAgLypcbiAgICogY29ubmVjdFdzIHN0YXJ0cyB0d28gdGltZXJzIHRvIG1vbml0b3IgdGhlIHN1Y2Nlc3Mgb2YgYSB3ZWJfc29ja2V0IGNvbm5lY3Rpb24gYXR0ZW1wdDpcbiAgICogLSB3ZWJTb2NrZXRTbG93VGltZXI6IGlmIHRoaXMgdGltZXIgZmlyZXMgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHN1Y2NlZWRzLFxuICAgKiAgIGNtIHdpbGwgc2ltdWx0YW5lb3VzbHkgY2hlY2sgd2Vic29ja2V0IGFuZCBodHRwL3hociBjb25uZWN0aXZpdHkuIGlmIHRoZSBodHRwXG4gICAqICAgY29ubmVjdGl2aXR5IGNoZWNrIGZhaWxzLCB3ZSBnaXZlIHVwIHRoZSBjb25uZWN0aW9uIHNlcXVlbmNlIGVudGlyZWx5IGFuZFxuICAgKiAgIHRyYW5zaXRpb24gdG8gZGlzY29ubmVjdGVkLiBpZiB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpdml0eSBjaGVjayBmYWlscyB0aGVuXG4gICAqICAgd2UgYXNzdW1lIG5vIHdzIGNvbm5lY3Rpdml0eSBhbmQgZmFpbG92ZXIgdG8gYmFzZSB0cmFuc3BvcnQuIGluIHRoZSBjYXNlIHRoYXRcbiAgICogICB0aGUgY2hlY2tzIHN1Y2NlZWQsIHdlIGNvbnRpbnVlIHdpdGggd2Vic29ja2V0IGFuZCB3YWl0IGZvciBpdCB0byB0cnkgZmFsbGJhY2sgaG9zdHNcbiAgICogICBhbmQsIGlmIHVuc3VjY2Vzc2Z1bCwgdWx0aW1hdGVseSB0cmFuc2l0aW9uIHRvIGRpc2Nvbm5lY3RlZC5cbiAgICogLSB3ZWJTb2NrZXRHaXZlVXBUaW1lcjogaWYgdGhpcyB0aW1lciBmaXJlcywgYW5kIHRoZSBwcmVjZWRpbmcgd2Vic29ja2V0XG4gICAqICAgY29ubmVjdGl2aXR5IGNoZWNrIGlzIHN0aWxsIHBlbmRpbmcgdGhlbiB3ZSBhc3N1bWUgdGhhdCB0aGVyZSBpcyBhbiBpc3N1ZVxuICAgKiAgIHdpdGggdGhlIHRyYW5zcG9ydCBhbmQgZmFsbGJhY2sgdG8gYmFzZSB0cmFuc3BvcnQuXG4gICAqL1xuICBjb25uZWN0V3ModHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0V3MoKVwiKTtcbiAgICB0aGlzLndzQ2hlY2tSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMuYWJhbmRvbmVkV2ViU29ja2V0ID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFdlYlNvY2tldFNsb3dUaW1lcigpO1xuICAgIHRoaXMuc3RhcnRXZWJTb2NrZXRHaXZlVXBUaW1lcih0cmFuc3BvcnRQYXJhbXMpO1xuICAgIHRoaXMudHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcyhcIndlYl9zb2NrZXRcIiwgdHJhbnNwb3J0UGFyYW1zLCB0cnVlLCBjb25uZWN0Q291bnQsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLndzQ2hlY2tSZXN1bHQgIT09IGZhbHNlICYmICF0aGlzLmFiYW5kb25lZFdlYlNvY2tldDtcbiAgICB9KTtcbiAgfVxuICBjb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RCYXNlKClcIik7XG4gICAgaWYgKHRoaXMuYmFzZVRyYW5zcG9ydCkge1xuICAgICAgdGhpcy50cnlUcmFuc3BvcnRXaXRoRmFsbGJhY2tzKHRoaXMuYmFzZVRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zLCBmYWxzZSwgY29ubmVjdENvdW50LCAoKSA9PiB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7XG4gICAgICAgIHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcIk5vIHRyYW5zcG9ydHMgbGVmdCB0byB0cnlcIiwgOGU0LCA0MDQpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcyh0cmFuc3BvcnROYW1lLCB0cmFuc3BvcnRQYXJhbXMsIHdzLCBjb25uZWN0Q291bnQsIHNob3VsZENvbnRpbnVlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3MoKVwiLFxuICAgICAgdHJhbnNwb3J0TmFtZVxuICAgICk7XG4gICAgY29uc3QgZ2l2ZVVwID0gKGVycikgPT4ge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IGVyciB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbmRpZGF0ZUhvc3RzID0gdGhpcy5kb21haW5zLnNsaWNlKCk7XG4gICAgY29uc3QgaG9zdEF0dGVtcHRDYiA9IChmYXRhbCwgdHJhbnNwb3J0KSA9PiB7XG4gICAgICBpZiAoY29ubmVjdENvdW50ICE9PSB0aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghc2hvdWxkQ29udGludWUoKSkge1xuICAgICAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcbiAgICAgICAgdHJ5RmFsbGJhY2tIb3N0cygpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICBnaXZlVXAobmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChubyBhdmFpbGFibGUgaG9zdClcIiwgODAwMDMsIDQwNCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IGhvc3Q7XG4gICAgY29uc3QgdHJ5RmFsbGJhY2tIb3N0cyA9ICgpID0+IHtcbiAgICAgIGlmICghY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICAgIGdpdmVVcChuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGNvbm5lY3QgKGFuZCBubyBtb3JlIGZhbGxiYWNrIGhvc3RzIHRvIHRyeSlcIiwgODAwMDMsIDQwNCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSkge1xuICAgICAgICBnaXZlVXAobmV3IFBhcnRpYWxFcnJvckluZm8oXCJJbnRlcm5hbCBlcnJvcjogSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSBub3Qgc2V0XCIsIG51bGwsIDUwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgIHRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpLFxuICAgICAgICAoZXJyLCBjb25uZWN0aXZpdHkpID0+IHtcbiAgICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSB0aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2hvdWxkQ29udGludWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBnaXZlVXAoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGdpdmVVcChuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGNvbm5lY3QgKG5ldHdvcmsgdW5yZWFjaGFibGUpXCIsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBhcnJQb3BSYW5kb21FbGVtZW50KGNhbmRpZGF0ZUhvc3RzKTtcbiAgICAgICAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnROYW1lLCBob3N0QXR0ZW1wdENiKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgICAgdHJ5RmFsbGJhY2tIb3N0cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnROYW1lLCBob3N0QXR0ZW1wdENiKTtcbiAgfVxuICBjbG9zZUltcGwoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKClcIiwgXCJjbG9zaW5nIGNvbm5lY3Rpb25cIik7XG4gICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgICB0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNsb3NpbmcpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdUcmFuc3BvcnQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKVwiLFxuICAgICAgICBcIkNsb3NpbmcgcGVuZGluZyB0cmFuc3BvcnQ6IFwiICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0XG4gICAgICApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKClcIixcbiAgICAgICAgXCJDbG9zaW5nIGFjdGl2ZSB0cmFuc3BvcnQ6IFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKVxuICAgICAgKTtcbiAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImNsb3NlZFwiIH0pO1xuICB9XG4gIG9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzLCBjYWxsYmFjaykge1xuICAgIHZhciBfYTI7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdGVkXCI6IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKVwiLFxuICAgICAgICAgIFwiU2VuZGluZyBBVVRIIG1lc3NhZ2Ugb24gYWN0aXZlIHRyYW5zcG9ydFwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRyYW5zcG9ydCA9IChfYTIgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYW5zcG9ydCgpO1xuICAgICAgICBpZiAoYWN0aXZlVHJhbnNwb3J0ICYmIGFjdGl2ZVRyYW5zcG9ydC5vbkF1dGhVcGRhdGVkKSB7XG4gICAgICAgICAgYWN0aXZlVHJhbnNwb3J0Lm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoTXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25zLkFVVEgsXG4gICAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRva2VuRGV0YWlscy50b2tlblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZChhdXRoTXNnKTtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc0xpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMub2ZmKGZhaWx1cmVMaXN0ZW5lcik7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmFpbHVyZUxpc3RlbmVyID0gKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHN1Y2Nlc3NMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLm9mZihmYWlsdXJlTGlzdGVuZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IHRoaXMuZ2V0U3RhdGVFcnJvcigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25jZShcImNvbm5lY3Rpb25kZXRhaWxzXCIsIHN1Y2Nlc3NMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMub24oXCJjb25uZWN0aW9uc3RhdGVcIiwgZmFpbHVyZUxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpXCIsXG4gICAgICAgICAgXCJBYm9ydGluZyBjdXJyZW50IGNvbm5lY3Rpb24gYXR0ZW1wdHMgaW4gb3JkZXIgdG8gc3RhcnQgYWdhaW4gd2l0aCB0aGUgbmV3IGF1dGggZGV0YWlsc1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKVwiLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbiBzdGF0ZSBpcyBcIiArIHRoaXMuc3RhdGUuc3RhdGUgKyBcIjsgd2FpdGluZyB1bnRpbCBlaXRoZXIgY29ubmVjdGVkIG9yIGZhaWxlZFwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChzdGF0ZUNoYW5nZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwiY29ubmVjdGVkXCI6XG4gICAgICAgICAgICAgIHRoaXMub2ZmKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgICAgICAgIHRoaXMub2ZmKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IHRoaXMuZ2V0U3RhdGVFcnJvcigpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub24oXCJjb25uZWN0aW9uc3RhdGVcIiwgbGlzdGVuZXIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0ZSA9PT0gXCJjb25uZWN0aW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGluZ1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpXCIsXG4gICAgICBcIkRpc2Nvbm5lY3RpbmcgYWxsIHRyYW5zcG9ydHNcIlxuICAgICk7XG4gICAgdGhpcy5jb25uZWN0Q291bnRlcisrO1xuICAgIGlmICh0aGlzLnBlbmRpbmdUcmFuc3BvcnQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpXCIsXG4gICAgICAgIFwiRGlzY29ubmVjdGluZyBwZW5kaW5nIHRyYW5zcG9ydDogXCIgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRcbiAgICAgICk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhbnNwb3J0O1xuICAgIGlmICh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgcHJvcG9zZWQgdHJhbnNwb3J0OiBcIiArIHRoaXMucGVuZGluZ1RyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIHRoaXMucHJvcG9zZWRUcmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhbnNwb3J0O1xuICAgIGlmICh0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgYWN0aXZlIHRyYW5zcG9ydDogXCIgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpXG4gICAgICApO1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG4gIC8qKioqKioqKioqKioqKioqKipcbiAgICogZXZlbnQgcXVldWVpbmdcbiAgICoqKioqKioqKioqKioqKioqKi9cbiAgc2VuZChtc2csIHF1ZXVlRXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wMjtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKVwiLCBcInNlbmRpbmcgZXZlbnRcIik7XG4gICAgICB0aGlzLnNlbmRJbXBsKG5ldyBQZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFF1ZXVlID0gcXVldWVFdmVudCAmJiBzdGF0ZS5xdWV1ZUV2ZW50cztcbiAgICBpZiAoIXNob3VsZFF1ZXVlKSB7XG4gICAgICBjb25zdCBlcnIgPSBcInJlamVjdGluZyBldmVudCwgcXVldWVFdmVudCB3YXMgXCIgKyBxdWV1ZUV2ZW50ICsgXCIsIHN0YXRlIHdhcyBcIiArIHN0YXRlLnN0YXRlO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpXCIsIGVycik7XG4gICAgICBjYWxsYmFjayh0aGlzLmVycm9yUmVhc29uIHx8IG5ldyBFcnJvckluZm8oZXJyLCA5ZTQsIDQwMCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kKClcIixcbiAgICAgICAgXCJxdWV1ZWluZyBtc2c7IFwiICsgc3RyaW5naWZ5KFxuICAgICAgICAgIG1zZyxcbiAgICAgICAgICB0aGlzLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlLFxuICAgICAgICAgIHRoaXMucmVhbHRpbWUuX0Fubm90YXRpb25zLFxuICAgICAgICAgIHRoaXMucmVhbHRpbWUuX2xpdmVPYmplY3RzUGx1Z2luXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucXVldWUobXNnLCBjYWxsYmFjayk7XG4gIH1cbiAgc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpIHtcbiAgICBjb25zdCBtc2cgPSBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlO1xuICAgIGlmIChwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCAmJiAhcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCkge1xuICAgICAgbXNnLm1zZ1NlcmlhbCA9IHRoaXMubXNnU2VyaWFsKys7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLnNlbmQocGVuZGluZ01lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kSW1wbCgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb24gaW4gdHJhbnNwb3J0LnNlbmQoKTogXCIgKyBlLnN0YWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBxdWV1ZShtc2csIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIucXVldWUoKVwiLCBcInF1ZXVlaW5nIGV2ZW50XCIpO1xuICAgIHRoaXMucXVldWVkTWVzc2FnZXMucHVzaChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICB9XG4gIHNlbmRRdWV1ZWRNZXNzYWdlcygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZFF1ZXVlZE1lc3NhZ2VzKClcIixcbiAgICAgIFwic2VuZGluZyBcIiArIHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKSArIFwiIHF1ZXVlZCBtZXNzYWdlc1wiXG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ01lc3NhZ2U7XG4gICAgd2hpbGUgKHBlbmRpbmdNZXNzYWdlID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5zaGlmdCgpKVxuICAgICAgdGhpcy5zZW5kSW1wbChwZW5kaW5nTWVzc2FnZSk7XG4gIH1cbiAgcXVldWVQZW5kaW5nTWVzc2FnZXMocGVuZGluZ01lc3NhZ2VzKSB7XG4gICAgaWYgKHBlbmRpbmdNZXNzYWdlcyAmJiBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIucXVldWVQZW5kaW5nTWVzc2FnZXMoKVwiLFxuICAgICAgICBcInF1ZXVlaW5nIFwiICsgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCArIFwiIHBlbmRpbmcgbWVzc2FnZXNcIlxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucHJlcGVuZChwZW5kaW5nTWVzc2FnZXMpO1xuICAgIH1cbiAgfVxuICBmYWlsUXVldWVkTWVzc2FnZXMoZXJyKSB7XG4gICAgY29uc3QgbnVtUXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpO1xuICAgIGlmIChudW1RdWV1ZWQgPiAwKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZmFpbFF1ZXVlZE1lc3NhZ2VzKClcIixcbiAgICAgICAgXCJmYWlsaW5nIFwiICsgbnVtUXVldWVkICsgXCIgcXVldWVkIG1lc3NhZ2VzLCBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICApO1xuICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb21wbGV0ZUFsbE1lc3NhZ2VzKGVycik7XG4gICAgfVxuICB9XG4gIG9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUucXVldWUucHVzaCh7IG1lc3NhZ2UsIHRyYW5zcG9ydCB9KTtcbiAgICBpZiAoIXRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLmlzUHJvY2Vzc2luZykge1xuICAgICAgdGhpcy5wcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpO1xuICAgIH1cbiAgfVxuICBwcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBlbmRpbmdDaGFubmVsTWVzc2FnZSA9IHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICB0aGlzLnByb2Nlc3NDaGFubmVsTWVzc2FnZShwZW5kaW5nQ2hhbm5lbE1lc3NhZ2UubWVzc2FnZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIucHJvY2Vzc05leHRQZW5kaW5nQ2hhbm5lbE1lc3NhZ2UoKSByZWNlaXZlZCBlcnJvciBcIixcbiAgICAgICAgICBlcnJcbiAgICAgICAgKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHByb2Nlc3NDaGFubmVsTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgYXdhaXQgdGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgYXN5bmMgcGluZygpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXRlICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHBpbmcgc2VydmljZTsgbm90IGNvbm5lY3RlZFwiLCA0ZTQsIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IChfYTIgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYW5zcG9ydCgpO1xuICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICB0aHJvdyB0aGlzLmdldFN0YXRlRXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIucGluZygpXCIsIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnQpO1xuICAgIGNvbnN0IHBpbmdTdGFydCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaWQgPSBjaGVhcFJhbmRTdHIoKTtcbiAgICByZXR1cm4gd2l0aFRpbWVvdXRBc3luYyhcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9uSGVhcnRiZWF0ID0gKHJlc3BvbnNlSWQpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2VJZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoXCJoZWFydGJlYXRcIiwgb25IZWFydGJlYXQpO1xuICAgICAgICAgICAgcmVzb2x2ZShEYXRlLm5vdygpIC0gcGluZ1N0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5vbihcImhlYXJ0YmVhdFwiLCBvbkhlYXJ0YmVhdCk7XG4gICAgICAgIHRyYW5zcG9ydC5waW5nKGlkKTtcbiAgICAgIH0pLFxuICAgICAgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG4gICAgICBcIlRpbWVvdXQgd2FpdGluZyBmb3IgaGVhcnRiZWF0IHJlc3BvbnNlXCJcbiAgICApO1xuICB9XG4gIGFib3J0KGVycm9yKSB7XG4gICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5mYWlsKGVycm9yKTtcbiAgfVxuICBnZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgfHwgaGF2ZVdlYlN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKSk7XG4gIH1cbiAgcGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0KSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gdHJhbnNwb3J0LnNob3J0TmFtZTtcbiAgICBpZiAoaGF2ZVdlYlN0b3JhZ2UoKSkge1xuICAgICAgKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lLCB0cmFuc3BvcnQuc2hvcnROYW1lKTtcbiAgICB9XG4gIH1cbiAgdW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuICAgIGlmIChoYXZlV2ViU3RvcmFnZSgpKSB7XG4gICAgICAoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpO1xuICAgIH1cbiAgfVxuICAvKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZHVyaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdHMsIHNvIGltcGxlbWVudHMgUlNBNGMxLCBSU0E0YzIsXG4gICAqIGFuZCBSU0E0ZC4gSXQgaXMgZ2VuZXJhbGx5IG5vdCBpbnZva2VkIGZvciBzZXJ2ZXJzaWRlLXRyaWdnZXJlZCByZWF1dGhzIG9yIG1hbnVhbFxuICAgKiByZWF1dGhzLCBzbyBSU0E0YzMgZG9lcyBub3QgYXBwbHksIGV4Y2VwdCAocGVyIHBlciBSU0E0ZDEpIGluIHRoZSBjYXNlIHRoYXQgdGhlIGF1dGhcbiAgICogc2VydmVyIHJldHVybnMgNDAzLiAqL1xuICBhY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09IDQwMTcxKSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiZmFpbGVkXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gNDAxMDIpIHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IGVyciB9KTtcbiAgICB9IGVsc2UgaWYgKGVyci5zdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdC5Gb3JiaWRkZW4pIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmV0dXJuZWQgNDAzOyBmYWlsaW5nIHRoZSBjb25uZWN0aW9uXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSgpXCIsIG1zZyk7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiZmFpbGVkXCIsIGVycm9yOiBuZXcgRXJyb3JJbmZvKG1zZywgODAwMTksIDQwMywgZXJyKSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gXCJDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXF1ZXN0IGZhaWxlZFwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemVcIiwgbXNnKTtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogdGhpcy5zdGF0ZS5mYWlsU3RhdGUsIGVycm9yOiBuZXcgRXJyb3JJbmZvKG1zZywgODAwMTksIDQwMSwgZXJyKSB9KTtcbiAgICB9XG4gIH1cbiAgb25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KSB7XG4gICAgaWYgKCFjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gY29ubmVjdGlvbkRldGFpbHM7XG4gICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemUgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50SWQgPSBjb25uZWN0aW9uRGV0YWlscy5jbGllbnRJZDtcbiAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMucmVhbHRpbWUuYXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKClcIiwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB0cmFuc3BvcnQuZmFpbChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICBpZiAoY29ubmVjdGlvblN0YXRlVHRsKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICB9XG4gICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG4gICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbmRldGFpbHNcIiwgY29ubmVjdGlvbkRldGFpbHMpO1xuICB9XG4gIGNoZWNrV3NDb25uZWN0aXZpdHkoKSB7XG4gICAgY29uc3Qgd3NDb25uZWN0aXZpdHlDaGVja1VybCA9IHRoaXMub3B0aW9ucy53c0Nvbm5lY3Rpdml0eUNoZWNrVXJsIHx8IGRlZmF1bHRzX2RlZmF1bHQud3NDb25uZWN0aXZpdHlDaGVja1VybDtcbiAgICBjb25zdCB3cyA9IG5ldyBQbGF0Zm9ybS5Db25maWcuV2ViU29ja2V0KHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdzLm9uY2xvc2UgPSB3cy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHNlc3Npb25SZWNvdmVyeU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZWNvdmVyeUtleVN0b3JhZ2VOYW1lIHx8IFwiYWJseS1jb25uZWN0aW9uLXJlY292ZXJ5XCI7XG4gIH1cbiAgZ2V0U2Vzc2lvblJlY292ZXJEYXRhKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0U2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0aGlzLnNlc3Npb25SZWNvdmVyeU5hbWUoKSkpO1xuICB9XG4gIHNldFNlc3Npb25SZWNvdmVyRGF0YSh2YWx1ZSkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2V0U2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0aGlzLnNlc3Npb25SZWNvdmVyeU5hbWUoKSwgdmFsdWUpKTtcbiAgfVxuICBjbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlbW92ZVNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCkpKTtcbiAgfVxufTtcbnZhciBjb25uZWN0aW9ubWFuYWdlcl9kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jb25uZWN0aW9uLnRzXG52YXIgQ29ubmVjdGlvbiA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihhYmx5LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoYWJseS5sb2dnZXIpO1xuICAgIHRoaXMud2hlblN0YXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRlbWl0dGVyX2RlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIHRoaXMuYWJseSA9IGFibHk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBjb25uZWN0aW9ubWFuYWdlcl9kZWZhdWx0KGFibHksIG9wdGlvbnMpO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbihcImNvbm5lY3Rpb25zdGF0ZVwiLCAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQ7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoc3RhdGUsIHN0YXRlQ2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oXCJ1cGRhdGVcIiwgKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgc3RhdGVDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uLmNvbm5lY3QoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgfVxuICBhc3luYyBwaW5nKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb24ucGluZygpXCIsIFwiXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnBpbmcoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uLmNsb3NlKClcIiwgXCJjb25uZWN0aW9uS2V5ID0gXCIgKyB0aGlzLmtleSk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjbG9zaW5nXCIgfSk7XG4gIH1cbiAgZ2V0IHJlY292ZXJ5S2V5KCkge1xuICAgIHRoaXMubG9nZ2VyLmRlcHJlY2F0aW9uV2FybmluZyhcbiAgICAgIFwiVGhlIGBDb25uZWN0aW9uLnJlY292ZXJ5S2V5YCBhdHRyaWJ1dGUgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIGBDb25uZWN0aW9uLmNyZWF0ZVJlY292ZXJ5S2V5KClgIG1ldGhvZC4gUmVwbGFjZSB5b3VyIHVzYWdlIG9mIGByZWNvdmVyeUtleWAgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIGBjcmVhdGVSZWNvdmVyeUtleSgpYC4gYHJlY292ZXJ5S2V5YCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgfVxuICBjcmVhdGVSZWNvdmVyeUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICB9XG59O1xudmFyIGNvbm5lY3Rpb25fZGVmYXVsdCA9IENvbm5lY3Rpb247XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9iYXNlcmVhbHRpbWUudHNcbnZhciBfQmFzZVJlYWx0aW1lID0gY2xhc3MgX0Jhc2VSZWFsdGltZSBleHRlbmRzIGJhc2VjbGllbnRfZGVmYXVsdCB7XG4gIC8qXG4gICAqIFRoZSBwdWJsaWMgdHlwaW5ncyBkZWNsYXJlIHRoYXQgdGhpcyBvbmx5IGFjY2VwdHMgYW4gb2JqZWN0LCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG9uZSBvZiB0aGVzZSB0aGluZ3M6XG4gICAqXG4gICAqIDEuIHBhc3NlcyBhIHN0cmluZyAod2hpY2ggaXMgcXVpdGUgbGlrZWx5IGlmIHRoZXnigJlyZSBlLmcuIG1pZ3JhdGluZyBmcm9tIHRoZSBkZWZhdWx0IHZhcmlhbnQgdG8gdGhlIG1vZHVsYXIgdmFyaWFudClcbiAgICogMi4gcGFzc2VzIG5vIGFyZ3VtZW50IGF0IGFsbFxuICAgKlxuICAgKiB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoZXNlIGNhc2VzIGFyZSBwb3NzaWJsZSBzbyB0aGF0IGl0IGZvcmNlcyB1cyB0byBoYW5kbGUgdGhlbS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICAgIHN1cGVyKGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCBmYWxzZSwgXCJCYXNlUmVhbHRpbWVcIiwgbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcikpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lKClcIiwgXCJcIik7XG4gICAgaWYgKHR5cGVvZiBFZGdlUnVudGltZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgYEFibHkuUmVhbHRpbWUgaW5zdGFuY2UgY2Fubm90IGJlIHVzZWQgaW4gVmVyY2VsIEVkZ2UgcnVudGltZS4gSWYgeW91IGFyZSBydW5uaW5nIFZlcmNlbCBFZGdlIGZ1bmN0aW9ucywgcGxlYXNlIHJlcGxhY2UgeW91ciBcIm5ldyBBYmx5LlJlYWx0aW1lKClcIiB3aXRoIFwibmV3IEFibHkuUmVzdCgpXCIgYW5kIHVzZSBBYmx5IFJlc3QgQVBJIGluc3RlYWQgb2YgdGhlIFJlYWx0aW1lIEFQSS4gSWYgeW91IGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHlvdXIgYXBwbGljYXRpb24gaW4gdGhlIFZlcmNlbCBFZGdlIHJ1bnRpbWUsIHBsZWFzZSB1c2UgdGhlIGNvbmRpdGlvbiBcImlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgPT09ICdzdHJpbmcnKVwiIHRvIHByZXZlbnQgaW5zdGFudGlhdGluZyBBYmx5LlJlYWx0aW1lIGluc3RhbmNlIGR1cmluZyBTU1IgaW4gdGhlIFZlcmNlbCBFZGdlIHJ1bnRpbWUuYCxcbiAgICAgICAgNGU0LFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuX2FkZGl0aW9uYWxUcmFuc3BvcnRJbXBsZW1lbnRhdGlvbnMgPSBfQmFzZVJlYWx0aW1lLnRyYW5zcG9ydEltcGxlbWVudGF0aW9uc0Zyb21QbHVnaW5zKHRoaXMub3B0aW9ucy5wbHVnaW5zKTtcbiAgICB0aGlzLl9SZWFsdGltZVByZXNlbmNlID0gKF9iID0gKF9hMiA9IHRoaXMub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlJlYWx0aW1lUHJlc2VuY2UpICE9IG51bGwgPyBfYiA6IG51bGw7XG4gICAgdGhpcy5fbGl2ZU9iamVjdHNQbHVnaW4gPSAoX2QgPSAoX2MgPSB0aGlzLm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLkxpdmVPYmplY3RzKSAhPSBudWxsID8gX2QgOiBudWxsO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBjb25uZWN0aW9uX2RlZmF1bHQodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLl9jaGFubmVscyA9IG5ldyBDaGFubmVsczIodGhpcyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvQ29ubmVjdCAhPT0gZmFsc2UpXG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBzdGF0aWMgdHJhbnNwb3J0SW1wbGVtZW50YXRpb25zRnJvbVBsdWdpbnMocGx1Z2lucykge1xuICAgIGNvbnN0IHRyYW5zcG9ydHMgPSB7fTtcbiAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5XZWJTb2NrZXRUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydHNbVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0XSA9IHBsdWdpbnMuV2ViU29ja2V0VHJhbnNwb3J0O1xuICAgIH1cbiAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5YSFJQb2xsaW5nKSB7XG4gICAgICB0cmFuc3BvcnRzW1RyYW5zcG9ydE5hbWVzLlhoclBvbGxpbmddID0gcGx1Z2lucy5YSFJQb2xsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuICBnZXQgY2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWxzO1xuICB9XG4gIGdldCBjbGllbnRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoLmNsaWVudElkO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuY29ubmVjdCgpXCIsIFwiXCIpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuY2xvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgfVxufTtcbi8vIGludGVybmFsIEFQSSB0byBtYWtlIEV2ZW50RW1pdHRlciB1c2FibGUgaW4gb3RoZXIgU0RLc1xuX0Jhc2VSZWFsdGltZS5FdmVudEVtaXR0ZXIgPSBldmVudGVtaXR0ZXJfZGVmYXVsdDtcbnZhciBCYXNlUmVhbHRpbWUgPSBfQmFzZVJlYWx0aW1lO1xudmFyIENoYW5uZWxzMiA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihyZWFsdGltZSkge1xuICAgIHN1cGVyKHJlYWx0aW1lLmxvZ2dlcik7XG4gICAgdGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuICAgIHRoaXMuYWxsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVhbHRpbWUuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbihcInRyYW5zcG9ydC5hY3RpdmVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vblRyYW5zcG9ydEFjdGl2ZSgpO1xuICAgIH0pO1xuICB9XG4gIGNoYW5uZWxTZXJpYWxzKCkge1xuICAgIGxldCBzZXJpYWxzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGtleXNBcnJheSh0aGlzLmFsbCwgdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICAgIGlmIChjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCkge1xuICAgICAgICBzZXJpYWxzW25hbWVdID0gY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxzO1xuICB9XG4gIC8vIHJlY292ZXJDaGFubmVscyBnZXRzIHRoZSBnaXZlbiBjaGFubmVscyBhbmQgc2V0cyB0aGVpciBjaGFubmVsIHNlcmlhbHMuXG4gIHJlY292ZXJDaGFubmVscyhjaGFubmVsU2VyaWFscykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBrZXlzQXJyYXkoY2hhbm5lbFNlcmlhbHMsIHRydWUpKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICBjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWxzW25hbWVdO1xuICAgIH1cbiAgfVxuICAvLyBBY2Nlc3MgdG8gdGhpcyBtZXRob2QgaXMgc3luY2hyb25pc2VkIGJ5IENvbm5lY3Rpb25NYW5hZ2VyI3Byb2Nlc3NDaGFubmVsTWVzc2FnZS5cbiAgYXN5bmMgcHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1zZykge1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gbXNnLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWxOYW1lID09PSB2b2lkIDApIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UoKVwiLFxuICAgICAgICBcInJlY2VpdmVkIGV2ZW50IHVuc3BlY2lmaWVkIGNoYW5uZWwsIGFjdGlvbiA9IFwiICsgbXNnLmFjdGlvblxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UoKVwiLFxuICAgICAgICBcInJlY2VpdmVkIGV2ZW50IGZvciBub24tZXhpc3RlbnQgY2hhbm5lbDogXCIgKyBjaGFubmVsTmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgY2hhbm5lbC5wcm9jZXNzTWVzc2FnZShtc2cpO1xuICB9XG4gIC8qIGNhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGJlY29tZXMgY29ubmVjdGVkOyByZWF0dGVtcHQgYXR0YWNoL2RldGFjaFxuICAgKiBmb3IgY2hhbm5lbHMgdGhhdCBhcmUgYXR0YWNoaW5nIG9yIGRldGFjaGluZy4gKi9cbiAgb25UcmFuc3BvcnRBY3RpdmUoKSB7XG4gICAgZm9yIChjb25zdCBjaGFubmVsTmFtZSBpbiB0aGlzLmFsbCkge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICAgIGlmIChjaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGluZ1wiIHx8IGNoYW5uZWwuc3RhdGUgPT09IFwiZGV0YWNoaW5nXCIpIHtcbiAgICAgICAgY2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICAgIGNoYW5uZWwuX2F0dGFjaChmYWxzZSwgbnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICBjaGFubmVsLnJlcXVlc3RTdGF0ZShcImF0dGFjaGluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogQ29ubmVjdGlvbiBpbnRlcnJ1cHRpb25zIChpZSB3aGVuIHRoZSBjb25uZWN0aW9uIHdpbGwgbm8gbG9uZ2VyIHF1ZXVlXG4gICAqIGV2ZW50cykgaW1wbHkgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzIGZvciBhbnkgY2hhbm5lbCB3aGljaCBpcyBlaXRoZXJcbiAgICogYXR0YWNoZWQsIHBlbmRpbmcsIG9yIHdpbGwgYXR0ZW1wdCB0byBiZWNvbWUgYXR0YWNoZWQgaW4gdGhlIGZ1dHVyZSAqL1xuICBwcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKGNvbm5lY3Rpb25TdGF0ZSwgcmVhc29uKSB7XG4gICAgY29uc3QgY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGUgPSB7XG4gICAgICBjbG9zaW5nOiBcImRldGFjaGVkXCIsXG4gICAgICBjbG9zZWQ6IFwiZGV0YWNoZWRcIixcbiAgICAgIGZhaWxlZDogXCJmYWlsZWRcIixcbiAgICAgIHN1c3BlbmRlZDogXCJzdXNwZW5kZWRcIlxuICAgIH07XG4gICAgY29uc3QgZnJvbUNoYW5uZWxTdGF0ZXMgPSBbXCJhdHRhY2hpbmdcIiwgXCJhdHRhY2hlZFwiLCBcImRldGFjaGluZ1wiLCBcInN1c3BlbmRlZFwiXTtcbiAgICBjb25zdCB0b0NoYW5uZWxTdGF0ZSA9IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlW2Nvbm5lY3Rpb25TdGF0ZV07XG4gICAgZm9yIChjb25zdCBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuICAgICAgaWYgKGZyb21DaGFubmVsU3RhdGVzLmluY2x1ZGVzKGNoYW5uZWwuc3RhdGUpKSB7XG4gICAgICAgIGNoYW5uZWwubm90aWZ5U3RhdGUodG9DaGFubmVsU3RhdGUsIHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXSA9IG5ldyByZWFsdGltZWNoYW5uZWxfZGVmYXVsdCh0aGlzLnJlYWx0aW1lLCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgaWYgKGNoYW5uZWwuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zLCBjaGFubmVsLmNoYW5uZWxPcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwiQ2hhbm5lbHMuZ2V0KCkgY2Fubm90IGJlIHVzZWQgdG8gc2V0IGNoYW5uZWwgb3B0aW9ucyB0aGF0IHdvdWxkIGNhdXNlIHRoZSBjaGFubmVsIHRvIHJlYXR0YWNoLiBQbGVhc2UsIHVzZSBSZWFsdGltZUNoYW5uZWwuc2V0T3B0aW9ucygpIGluc3RlYWQuXCIsXG4gICAgICAgICAgNGU0LFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cbiAgZ2V0RGVyaXZlZChuYW1lLCBkZXJpdmVPcHRpb25zLCBjaGFubmVsT3B0aW9ucykge1xuICAgIGlmIChkZXJpdmVPcHRpb25zLmZpbHRlcikge1xuICAgICAgY29uc3QgZmlsdGVyID0gdG9CYXNlNjQoZGVyaXZlT3B0aW9ucy5maWx0ZXIpO1xuICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaERlcml2ZWRDaGFubmVsKG5hbWUpO1xuICAgICAgbmFtZSA9IGBbZmlsdGVyPSR7ZmlsdGVyfSR7bWF0Y2gucXVhbGlmaWVyUGFyYW19XSR7bWF0Y2guY2hhbm5lbE5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgfVxuICAvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cbiAgICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cbiAgcmVsZWFzZShuYW1lKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGVhc2VFcnIgPSBjaGFubmVsLmdldFJlbGVhc2VFcnIoKTtcbiAgICBpZiAocmVsZWFzZUVycikge1xuICAgICAgdGhyb3cgcmVsZWFzZUVycjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuYWxsW25hbWVdO1xuICB9XG59O1xudmFyIGJhc2VyZWFsdGltZV9kZWZhdWx0ID0gQmFzZVJlYWx0aW1lO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcHJlc2VuY2VtYXAudHNcbmZ1bmN0aW9uIG5ld2VyVGhhbihpdGVtLCBleGlzdGluZykge1xuICBpZiAoaXRlbS5pc1N5bnRoZXNpemVkKCkgfHwgZXhpc3RpbmcuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgcmV0dXJuIGl0ZW0udGltZXN0YW1wID49IGV4aXN0aW5nLnRpbWVzdGFtcDtcbiAgfVxuICBjb25zdCBpdGVtT3JkZXJpbmdzID0gaXRlbS5wYXJzZUlkKCksIGV4aXN0aW5nT3JkZXJpbmdzID0gZXhpc3RpbmcucGFyc2VJZCgpO1xuICBpZiAoaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPT09IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbCkge1xuICAgIHJldHVybiBpdGVtT3JkZXJpbmdzLmluZGV4ID4gZXhpc3RpbmdPcmRlcmluZ3MuaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID4gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsO1xuICB9XG59XG52YXIgUHJlc2VuY2VNYXAgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocHJlc2VuY2UsIG1lbWJlcktleSwgbmV3ZXIgPSBuZXdlclRoYW4pIHtcbiAgICBzdXBlcihwcmVzZW5jZS5sb2dnZXIpO1xuICAgIHRoaXMucHJlc2VuY2UgPSBwcmVzZW5jZTtcbiAgICB0aGlzLm1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgdGhpcy5tZW1iZXJLZXkgPSBtZW1iZXJLZXk7XG4gICAgdGhpcy5uZXdlclRoYW4gPSBuZXdlcjtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW2tleV07XG4gIH1cbiAgZ2V0Q2xpZW50KGNsaWVudElkKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgY29uc3QgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgaWYgKGl0ZW0uY2xpZW50SWQgPT0gY2xpZW50SWQgJiYgaXRlbS5hY3Rpb24gIT0gXCJhYnNlbnRcIilcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGlzdChwYXJhbXMpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgY2xpZW50SWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNsaWVudElkLCBjb25uZWN0aW9uSWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbm5lY3Rpb25JZCwgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFwKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWFwW2tleV07XG4gICAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiYWJzZW50XCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNsaWVudElkICYmIGNsaWVudElkICE9IGl0ZW0uY2xpZW50SWQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNvbm5lY3Rpb25JZCAmJiBjb25uZWN0aW9uSWQgIT0gaXRlbS5jb25uZWN0aW9uSWQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHV0KGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiZW50ZXJcIiB8fCBpdGVtLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgaXRlbSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoaXRlbSk7XG4gICAgICBpdGVtLmFjdGlvbiA9IFwicHJlc2VudFwiO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwga2V5ID0gdGhpcy5tZW1iZXJLZXkoaXRlbSk7XG4gICAgaWYgKHRoaXMucmVzaWR1YWxNZW1iZXJzKVxuICAgICAgZGVsZXRlIHRoaXMucmVzaWR1YWxNZW1iZXJzW2tleV07XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAmJiAhdGhpcy5uZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXBba2V5XSA9IGl0ZW07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFsdWVzKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgIGlmIChpdGVtLmFjdGlvbiAhPSBcImFic2VudFwiKVxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZW1vdmUoaXRlbSkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCBrZXkgPSB0aGlzLm1lbWJlcktleShpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICYmICF0aGlzLm5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICBpdGVtID0gcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyhpdGVtKTtcbiAgICAgIGl0ZW0uYWN0aW9uID0gXCJhYnNlbnRcIjtcbiAgICAgIG1hcFtrZXldID0gaXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG1hcFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gISFleGlzdGluZ0l0ZW07XG4gIH1cbiAgc3RhcnRTeW5jKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlByZXNlbmNlTWFwLnN0YXJ0U3luYygpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgXCI7IHN5bmNJblByb2dyZXNzID0gXCIgKyBzeW5jSW5Qcm9ncmVzc1xuICAgICk7XG4gICAgaWYgKCF0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IGNvcHkobWFwKTtcbiAgICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyh0cnVlKTtcbiAgICB9XG4gIH1cbiAgZW5kU3luYygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJQcmVzZW5jZU1hcC5lbmRTeW5jKClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyBcIjsgc3luY0luUHJvZ3Jlc3MgPSBcIiArIHN5bmNJblByb2dyZXNzXG4gICAgKTtcbiAgICBpZiAoc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyS2V5IGluIG1hcCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG1hcFttZW1iZXJLZXldO1xuICAgICAgICBpZiAoZW50cnkuYWN0aW9uID09PSBcImFic2VudFwiKSB7XG4gICAgICAgICAgZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnByZXNlbmNlLl9zeW50aGVzaXplTGVhdmVzKHZhbHVlc0FycmF5KHRoaXMucmVzaWR1YWxNZW1iZXJzKSk7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlcktleSBpbiB0aGlzLnJlc2lkdWFsTWVtYmVycykge1xuICAgICAgICBkZWxldGUgbWFwW21lbWJlcktleV07XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJzeW5jXCIpO1xuICB9XG4gIGFzeW5jIHdhaXRTeW5jKCkge1xuICAgIGNvbnN0IHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUHJlc2VuY2VNYXAud2FpdFN5bmMoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArIFwiOyBzeW5jSW5Qcm9ncmVzcyA9IFwiICsgc3luY0luUHJvZ3Jlc3NcbiAgICApO1xuICAgIGlmICghc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5vbmNlKFwic3luY1wiKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyhmYWxzZSk7XG4gICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICB9XG4gIHNldEluUHJvZ3Jlc3MoaW5Qcm9ncmVzcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlByZXNlbmNlTWFwLnNldEluUHJvZ3Jlc3MoKVwiLCBcImluUHJvZ3Jlc3MgPSBcIiArIGluUHJvZ3Jlc3MpO1xuICAgIHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBpblByb2dyZXNzO1xuICAgIHRoaXMucHJlc2VuY2Uuc3luY0NvbXBsZXRlID0gIWluUHJvZ3Jlc3M7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZXByZXNlbmNlLnRzXG5mdW5jdGlvbiBnZXRDbGllbnRJZChyZWFsdGltZVByZXNlbmNlKSB7XG4gIHJldHVybiByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwuY2xpZW50LmF1dGguY2xpZW50SWQ7XG59XG5mdW5jdGlvbiBpc0Fub255bW91c09yV2lsZGNhcmQocmVhbHRpbWVQcmVzZW5jZSkge1xuICBjb25zdCByZWFsdGltZSA9IHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5jbGllbnQ7XG4gIGNvbnN0IGNsaWVudElkID0gcmVhbHRpbWUuYXV0aC5jbGllbnRJZDtcbiAgcmV0dXJuICghY2xpZW50SWQgfHwgY2xpZW50SWQgPT09IFwiKlwiKSAmJiByZWFsdGltZS5jb25uZWN0aW9uLnN0YXRlID09PSBcImNvbm5lY3RlZFwiO1xufVxudmFyIFJlYWx0aW1lUHJlc2VuY2UgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgIHN1cGVyKGNoYW5uZWwubG9nZ2VyKTtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgIHRoaXMuc3luY0NvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5tZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMsIChpdGVtKSA9PiBpdGVtLmNsaWVudElkICsgXCI6XCIgKyBpdGVtLmNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5fbXlNZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMsIChpdGVtKSA9PiBpdGVtLmNsaWVudElkKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gIH1cbiAgYXN5bmMgZW50ZXIoZGF0YSkge1xuICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byBlbnRlciBhIHByZXNlbmNlIGNoYW5uZWxcIiwgNDAwMTIsIDQwMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHZvaWQgMCwgdm9pZCAwLCBkYXRhLCBcImVudGVyXCIpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZShkYXRhKSB7XG4gICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIHVwZGF0ZSBwcmVzZW5jZSBkYXRhXCIsIDQwMDEyLCA0MDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIHZvaWQgMCwgZGF0YSwgXCJ1cGRhdGVcIik7XG4gIH1cbiAgYXN5bmMgZW50ZXJDbGllbnQoY2xpZW50SWQsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIGNsaWVudElkLCBkYXRhLCBcImVudGVyXCIpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUNsaWVudChjbGllbnRJZCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHZvaWQgMCwgY2xpZW50SWQsIGRhdGEsIFwidXBkYXRlXCIpO1xuICB9XG4gIGFzeW5jIF9lbnRlck9yVXBkYXRlQ2xpZW50KGlkLCBjbGllbnRJZCwgZGF0YSwgYWN0aW9uKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICBpZiAoIWNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5cIiArIGFjdGlvbiArIFwiQ2xpZW50KClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgY2hhbm5lbC5uYW1lICsgXCIsIGlkID0gXCIgKyBpZCArIFwiLCBjbGllbnQgPSBcIiArIChjbGllbnRJZCB8fCBcIihpbXBsaWNpdCkgXCIgKyBnZXRDbGllbnRJZCh0aGlzKSlcbiAgICApO1xuICAgIGNvbnN0IHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQuZnJvbURhdGEoZGF0YSk7XG4gICAgcHJlc2VuY2UuYWN0aW9uID0gYWN0aW9uO1xuICAgIGlmIChpZCkge1xuICAgICAgcHJlc2VuY2UuaWQgPSBpZDtcbiAgICB9XG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgIH1cbiAgICBjb25zdCB3aXJlUHJlc01zZyA9IGF3YWl0IHByZXNlbmNlLmVuY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zKTtcbiAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICByZXR1cm4gY2hhbm5lbC5zZW5kUHJlc2VuY2UoW3dpcmVQcmVzTXNnXSk7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZWRcIjpcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICBjaGFubmVsLmF0dGFjaCgpO1xuICAgICAgY2FzZSBcImF0dGFjaGluZ1wiOlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuICAgICAgICAgICAgcHJlc2VuY2U6IHdpcmVQcmVzTXNnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgUGFydGlhbEVycm9ySW5mbyhcbiAgICAgICAgICBcIlVuYWJsZSB0byBcIiArIGFjdGlvbiArIFwiIHByZXNlbmNlIGNoYW5uZWwgd2hpbGUgaW4gXCIgKyBjaGFubmVsLnN0YXRlICsgXCIgc3RhdGVcIixcbiAgICAgICAgICA5MDAwMVxuICAgICAgICApO1xuICAgICAgICBlcnIuY29kZSA9IDkwMDAxO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGxlYXZlKGRhdGEpIHtcbiAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBoYXZlIGJlZW4gc3BlY2lmaWVkIHRvIGVudGVyIG9yIGxlYXZlIGEgcHJlc2VuY2UgY2hhbm5lbFwiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVhdmVDbGllbnQodm9pZCAwLCBkYXRhKTtcbiAgfVxuICBhc3luYyBsZWF2ZUNsaWVudChjbGllbnRJZCwgZGF0YSkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2UubGVhdmVDbGllbnQoKVwiLFxuICAgICAgXCJsZWF2aW5nOyBjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSArIFwiLCBjbGllbnQgPSBcIiArIGNsaWVudElkXG4gICAgKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21EYXRhKGRhdGEpO1xuICAgIHByZXNlbmNlLmFjdGlvbiA9IFwibGVhdmVcIjtcbiAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgIHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgfVxuICAgIGNvbnN0IHdpcmVQcmVzTXNnID0gYXdhaXQgcHJlc2VuY2UuZW5jb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMpO1xuICAgIHN3aXRjaCAoY2hhbm5lbC5zdGF0ZSkge1xuICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgIHJldHVybiBjaGFubmVsLnNlbmRQcmVzZW5jZShbd2lyZVByZXNNc2ddKTtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcbiAgICAgICAgICAgIHByZXNlbmNlOiB3aXJlUHJlc01zZyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgICAgY2FzZSBcImZhaWxlZFwiOiB7XG4gICAgICAgIHRocm93IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGxlYXZlIHByZXNlbmNlIGNoYW5uZWwgKGluY29tcGF0aWJsZSBzdGF0ZSlcIiwgOTAwMDEpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgY29uc3Qgd2FpdEZvclN5bmMgPSAhcGFyYW1zIHx8IChcIndhaXRGb3JTeW5jXCIgaW4gcGFyYW1zID8gcGFyYW1zLndhaXRGb3JTeW5jIDogdHJ1ZSk7XG4gICAgZnVuY3Rpb24gdG9NZXNzYWdlcyhtZW1iZXJzMikge1xuICAgICAgcmV0dXJuIHBhcmFtcyA/IG1lbWJlcnMyLmxpc3QocGFyYW1zKSA6IG1lbWJlcnMyLnZhbHVlcygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFubmVsLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICBpZiAod2FpdEZvclN5bmMpIHtcbiAgICAgICAgdGhyb3cgRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICBjb2RlOiA5MTAwNSxcbiAgICAgICAgICBtZXNzYWdlOiBcIlByZXNlbmNlIHN0YXRlIGlzIG91dCBvZiBzeW5jIGR1ZSB0byBjaGFubmVsIGJlaW5nIGluIHRoZSBTVVNQRU5ERUQgc3RhdGVcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b01lc3NhZ2VzKHRoaXMubWVtYmVycyk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuY2hhbm5lbC5lbnN1cmVBdHRhY2hlZCgpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLm1lbWJlcnM7XG4gICAgaWYgKHdhaXRGb3JTeW5jKSB7XG4gICAgICBhd2FpdCBtZW1iZXJzLndhaXRTeW5jKCk7XG4gICAgfVxuICAgIHJldHVybiB0b01lc3NhZ2VzKHRoaXMubWVtYmVycyk7XG4gIH1cbiAgYXN5bmMgaGlzdG9yeShwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZVByZXNlbmNlLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgY29uc3QgcmVzdE1peGluID0gdGhpcy5jaGFubmVsLmNsaWVudC5yZXN0LnByZXNlbmNlTWl4aW47XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcbiAgICAgIGlmICh0aGlzLmNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICBkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuICAgICAgICBwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLmNoYW5uZWwucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkLCB3YXM6IFwiICsgdGhpcy5jaGFubmVsLnN0YXRlLFxuICAgICAgICAgIDRlNCxcbiAgICAgICAgICA0MDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3RNaXhpbi5oaXN0b3J5KHRoaXMsIHBhcmFtcyk7XG4gIH1cbiAgc2V0UHJlc2VuY2UocHJlc2VuY2VTZXQsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5zZXRQcmVzZW5jZSgpXCIsXG4gICAgICBcInJlY2VpdmVkIHByZXNlbmNlIGZvciBcIiArIHByZXNlbmNlU2V0Lmxlbmd0aCArIFwiIHBhcnRpY2lwYW50czsgc3luY0NoYW5uZWxTZXJpYWwgPSBcIiArIHN5bmNDaGFubmVsU2VyaWFsXG4gICAgKTtcbiAgICBsZXQgc3luY0N1cnNvciwgbWF0Y2g7XG4gICAgY29uc3QgbWVtYmVycyA9IHRoaXMubWVtYmVycywgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzLCBicm9hZGNhc3RNZXNzYWdlcyA9IFtdLCBjb25uSWQgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkO1xuICAgIGlmIChpc1N5bmMpIHtcbiAgICAgIHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcbiAgICAgIGlmIChzeW5jQ2hhbm5lbFNlcmlhbCAmJiAobWF0Y2ggPSBzeW5jQ2hhbm5lbFNlcmlhbC5tYXRjaCgvXltcXHctXSs6KC4qKSQvKSkpIHtcbiAgICAgICAgc3luY0N1cnNvciA9IG1hdGNoWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcmVzZW5jZSBvZiBwcmVzZW5jZVNldCkge1xuICAgICAgc3dpdGNoIChwcmVzZW5jZS5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBcImxlYXZlXCI6XG4gICAgICAgICAgaWYgKG1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCAmJiAhcHJlc2VuY2UuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgICAgICAgICBteU1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbnRlclwiOlxuICAgICAgICBjYXNlIFwicHJlc2VudFwiOlxuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgaWYgKG1lbWJlcnMucHV0KHByZXNlbmNlKSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCkge1xuICAgICAgICAgICAgbXlNZW1iZXJzLnB1dChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTeW5jICYmICFzeW5jQ3Vyc29yKSB7XG4gICAgICBtZW1iZXJzLmVuZFN5bmMoKTtcbiAgICAgIHRoaXMuY2hhbm5lbC5zeW5jQ2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnJvYWRjYXN0TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByZXNlbmNlID0gYnJvYWRjYXN0TWVzc2FnZXNbaV07XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZW1pdChwcmVzZW5jZS5hY3Rpb24sIHByZXNlbmNlKTtcbiAgICB9XG4gIH1cbiAgb25BdHRhY2hlZChoYXNQcmVzZW5jZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSArIFwiLCBoYXNQcmVzZW5jZSA9IFwiICsgaGFzUHJlc2VuY2VcbiAgICApO1xuICAgIGlmIChoYXNQcmVzZW5jZSkge1xuICAgICAgdGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zeW50aGVzaXplTGVhdmVzKHRoaXMubWVtYmVycy52YWx1ZXMoKSk7XG4gICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpO1xuICAgIGNvbnN0IHBlbmRpbmdQcmVzZW5jZSA9IHRoaXMucGVuZGluZ1ByZXNlbmNlLCBwZW5kaW5nUHJlc0NvdW50ID0gcGVuZGluZ1ByZXNlbmNlLmxlbmd0aDtcbiAgICBpZiAocGVuZGluZ1ByZXNDb3VudCkge1xuICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICAgIGNvbnN0IHByZXNlbmNlQXJyYXkgPSBbXTtcbiAgICAgIGNvbnN0IG11bHRpY2FzdGVyID0gbXVsdGljYXN0ZXJfZGVmYXVsdC5jcmVhdGUodGhpcy5sb2dnZXIpO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlJlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZFwiLFxuICAgICAgICBcInNlbmRpbmcgXCIgKyBwZW5kaW5nUHJlc0NvdW50ICsgXCIgcXVldWVkIHByZXNlbmNlIG1lc3NhZ2VzXCJcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmdQcmVzQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBldmVudCA9IHBlbmRpbmdQcmVzZW5jZVtpXTtcbiAgICAgICAgcHJlc2VuY2VBcnJheS5wdXNoKGV2ZW50LnByZXNlbmNlKTtcbiAgICAgICAgbXVsdGljYXN0ZXIucHVzaChldmVudC5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlQXJyYXkpLnRoZW4oKCkgPT4gbXVsdGljYXN0ZXIoKSkuY2F0Y2goKGVycikgPT4gbXVsdGljYXN0ZXIoZXJyKSk7XG4gICAgfVxuICB9XG4gIGFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgZXJyKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgIHRoaXMub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgIHRoaXMuX2NsZWFyTXlNZW1iZXJzKCk7XG4gICAgICAgIHRoaXMubWVtYmVycy5jbGVhcigpO1xuICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICB0aGlzLmZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5mYWlsUGVuZGluZ1ByZXNlbmNlXCIsXG4gICAgICAgIFwiY2hhbm5lbDsgbmFtZSA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUgKyBcIiwgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoOyBpKyspXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2VbaV0uY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICAgIH1cbiAgfVxuICBfY2xlYXJNeU1lbWJlcnMoKSB7XG4gICAgdGhpcy5fbXlNZW1iZXJzLmNsZWFyKCk7XG4gIH1cbiAgX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKSB7XG4gICAgY29uc3QgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzO1xuICAgIGNvbnN0IGNvbm5JZCA9IHRoaXMuY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQ7XG4gICAgZm9yIChjb25zdCBtZW1iZXJLZXkgaW4gbXlNZW1iZXJzLm1hcCkge1xuICAgICAgY29uc3QgZW50cnkgPSBteU1lbWJlcnMubWFwW21lbWJlcktleV07XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpXCIsXG4gICAgICAgICdBdXRvLXJlZW50ZXJpbmcgY2xpZW50SWQgXCInICsgZW50cnkuY2xpZW50SWQgKyAnXCIgaW50byB0aGUgcHJlc2VuY2Ugc2V0J1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGlkID0gZW50cnkuY29ubmVjdGlvbklkID09PSBjb25uSWQgPyBlbnRyeS5pZCA6IHZvaWQgMDtcbiAgICAgIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoaWQsIGVudHJ5LmNsaWVudElkLCBlbnRyeS5kYXRhLCBcImVudGVyXCIpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEVyciA9IG5ldyBFcnJvckluZm8oXCJQcmVzZW5jZSBhdXRvIHJlLWVudGVyIGZhaWxlZFwiLCA5MTAwNCwgNDAwLCBlcnIpO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpXCIsXG4gICAgICAgICAgXCJQcmVzZW5jZSBhdXRvIHJlLWVudGVyIGZhaWxlZDsgcmVhc29uID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlX2RlZmF1bHQodGhpcy5jaGFubmVsLnN0YXRlLCB0aGlzLmNoYW5uZWwuc3RhdGUsIHRydWUsIGZhbHNlLCB3cmFwcGVkRXJyKTtcbiAgICAgICAgdGhpcy5jaGFubmVsLmVtaXQoXCJ1cGRhdGVcIiwgY2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc3ludGhlc2l6ZUxlYXZlcyhpdGVtcykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBjb25zdCBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICBhY3Rpb246IFwibGVhdmVcIixcbiAgICAgICAgY29ubmVjdGlvbklkOiBpdGVtLmNvbm5lY3Rpb25JZCxcbiAgICAgICAgY2xpZW50SWQ6IGl0ZW0uY2xpZW50SWQsXG4gICAgICAgIGRhdGE6IGl0ZW0uZGF0YSxcbiAgICAgICAgZW5jb2Rpbmc6IGl0ZW0uZW5jb2RpbmcsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfSk7XG4gICAgICBzdWJzY3JpcHRpb25zLmVtaXQoXCJsZWF2ZVwiLCBwcmVzZW5jZSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc3Vic2NyaWJlKC4uLl9hcmdzKSB7XG4gICAgY29uc3QgYXJncyA9IHJlYWx0aW1lY2hhbm5lbF9kZWZhdWx0LnByb2Nlc3NMaXN0ZW5lckFyZ3MoX2FyZ3MpO1xuICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgdGhyb3cgRXJyb3JJbmZvLmZyb21WYWx1ZXMoY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgaWYgKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMuYXR0YWNoT25TdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBjaGFubmVsLmF0dGFjaCgpO1xuICAgIH1cbiAgfVxuICB1bnN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxufTtcbnZhciByZWFsdGltZXByZXNlbmNlX2RlZmF1bHQgPSBSZWFsdGltZVByZXNlbmNlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvd2Vic29ja2V0dHJhbnNwb3J0LnRzXG52YXIgc2hvcnROYW1lID0gVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0O1xuZnVuY3Rpb24gaXNOb2RlV2ViU29ja2V0KHdzKSB7XG4gIHJldHVybiAhIXdzLm9uO1xufVxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgdHJhbnNwb3J0X2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSBQbGF0Zm9ybS5Db25maWcudXNlUHJvdG9jb2xIZWFydGJlYXRzO1xuICAgIHRoaXMud3NIb3N0ID0gcGFyYW1zLmhvc3Q7XG4gIH1cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgIHJldHVybiAhIVBsYXRmb3JtLkNvbmZpZy5XZWJTb2NrZXQ7XG4gIH1cbiAgY3JlYXRlV2ViU29ja2V0KHVyaSwgY29ubmVjdFBhcmFtcykge1xuICAgIHRoaXMudXJpID0gdXJpICsgdG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFBsYXRmb3JtLkNvbmZpZy5XZWJTb2NrZXQodGhpcy51cmkpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIldlYlNvY2tldFRyYW5zcG9ydDsgdXJpPVwiICsgdGhpcy51cmk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwic3RhcnRpbmdcIik7XG4gICAgdHJhbnNwb3J0X2RlZmF1bHQucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcbiAgICBjb25zdCBzZWxmMiA9IHRoaXMsIHBhcmFtcyA9IHRoaXMucGFyYW1zLCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG4gICAgY29uc3Qgd3NTY2hlbWUgPSBvcHRpb25zLnRscyA/IFwid3NzOi8vXCIgOiBcIndzOi8vXCI7XG4gICAgY29uc3Qgd3NVcmkgPSB3c1NjaGVtZSArIHRoaXMud3NIb3N0ICsgXCI6XCIgKyBkZWZhdWx0c19kZWZhdWx0LmdldFBvcnQob3B0aW9ucykgKyBcIi9cIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwidXJpOiBcIiArIHdzVXJpKTtcbiAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICB0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcygpLFxuICAgICAgZnVuY3Rpb24oZXJyLCBhdXRoUGFyYW1zKSB7XG4gICAgICAgIGlmIChzZWxmMi5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbVN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW0gaW4gYXV0aFBhcmFtcylcbiAgICAgICAgICBwYXJhbVN0ciArPSBcIiBcIiArIHBhcmFtICsgXCI6IFwiICsgYXV0aFBhcmFtc1twYXJhbV0gKyBcIjtcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHNlbGYyLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgICAgXCJhdXRoUGFyYW1zOlwiICsgcGFyYW1TdHIgKyBcIiBlcnI6IFwiICsgZXJyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBzZWxmMi5kaXNjb25uZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSBwYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSBzZWxmMi53c0Nvbm5lY3Rpb24gPSBzZWxmMi5jcmVhdGVXZWJTb2NrZXQod3NVcmksIGNvbm5lY3RQYXJhbXMpO1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5iaW5hcnlUeXBlID0gUGxhdGZvcm0uQ29uZmlnLmJpbmFyeVR5cGU7XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZjIub25Xc09wZW4oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbmNsb3NlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NDbG9zZShldik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NEYXRhKGV2LmRhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgc2VsZjIub25Xc0Vycm9yKGV2KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpc05vZGVXZWJTb2NrZXQod3NDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9uKFwicGluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZjIub25BY3Rpdml0eSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgc2VsZjIubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIGNyZWF0aW5nIHdlYnNvY2tldDogZXJyID0gXCIgKyAoZS5zdGFjayB8fCBlLm1lc3NhZ2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmMi5kaXNjb25uZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBzZW5kKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICBpZiAoIXdzQ29ubmVjdGlvbikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKVwiLCBcIk5vIHNvY2tldCBjb25uZWN0aW9uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgd3NDb25uZWN0aW9uLnNlbmQoXG4gICAgICAgIHNlcmlhbGl6ZTIobWVzc2FnZSwgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fTXNnUGFjaywgdGhpcy5wYXJhbXMuZm9ybWF0KVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBtc2cgPSBcIkV4Y2VwdGlvbiBmcm9tIHdzIGNvbm5lY3Rpb24gd2hlbiB0cnlpbmcgdG8gc2VuZDogXCIgKyBpbnNwZWN0RXJyb3IoZSk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpXCIsIG1zZyk7XG4gICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBuZXcgRXJyb3JJbmZvKG1zZywgNWU0LCA1MDApKTtcbiAgICB9XG4gIH1cbiAgb25Xc0RhdGEoZGF0YSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKVwiLFxuICAgICAgXCJkYXRhIHJlY2VpdmVkOyBsZW5ndGggPSBcIiArIGRhdGEubGVuZ3RoICsgXCI7IHR5cGUgPSBcIiArIHR5cGVvZiBkYXRhXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5vblByb3RvY29sTWVzc2FnZShcbiAgICAgICAgZGVzZXJpYWxpemUoXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Nc2dQYWNrLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fQW5ub3RhdGlvbnMsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fbGl2ZU9iamVjdHNQbHVnaW4sXG4gICAgICAgICAgdGhpcy5mb3JtYXRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgbWVzc2FnZTogXCIgKyBlLnN0YWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBvbldzT3BlbigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc09wZW4oKVwiLCBcIm9wZW5lZCBXZWJTb2NrZXRcIik7XG4gICAgdGhpcy5lbWl0KFwicHJlY29ubmVjdFwiKTtcbiAgfVxuICBvbldzQ2xvc2UoZXYpIHtcbiAgICBsZXQgd2FzQ2xlYW4sIGNvZGU7XG4gICAgaWYgKHR5cGVvZiBldiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb2RlID0gZXYuY29kZTtcbiAgICAgIHdhc0NsZWFuID0gZXYud2FzQ2xlYW4gfHwgY29kZSA9PT0gMWUzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gZXY7XG4gICAgICB3YXNDbGVhbiA9IGNvZGUgPT0gMWUzO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgaWYgKHdhc0NsZWFuKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKClcIiwgXCJDbGVhbmx5IGNsb3NlZCBXZWJTb2NrZXRcIik7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiV2Vic29ja2V0IGNsb3NlZFwiLCA4MDAwMywgNDAwKTtcbiAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiVW5jbGVhbiBkaXNjb25uZWN0aW9uIG9mIFdlYlNvY2tldCA7IGNvZGUgPSBcIiArIGNvZGUsIGVyciA9IG5ldyBFcnJvckluZm8obXNnLCA4MDAwMywgNDAwKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiZGlzcG9zZWRcIik7XG4gIH1cbiAgb25Xc0Vycm9yKGVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25FcnJvcigpXCIsXG4gICAgICBcIkVycm9yIGZyb20gV2ViU29ja2V0OiBcIiArIGVyci5tZXNzYWdlXG4gICAgKTtcbiAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KEVycm9yKGVyci5tZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiXCIpO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgY29uc3Qgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgaWYgKHdzQ29ubmVjdGlvbikge1xuICAgICAgd3NDb25uZWN0aW9uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIldlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJjbG9zaW5nIHdlYnNvY2tldFwiKTtcbiAgICAgICAgaWYgKCF3c0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpOiB3c0Nvbm5lY3Rpb24gaXMgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgd3NDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG52YXIgd2Vic29ja2V0dHJhbnNwb3J0X2RlZmF1bHQgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9maWx0ZXJlZHN1YnNjcmlwdGlvbnMudHNcbnZhciBGaWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSBjbGFzcyB7XG4gIHN0YXRpYyBzdWJzY3JpYmVGaWx0ZXIoY2hhbm5lbCwgZmlsdGVyLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGZpbHRlcmVkTGlzdGVuZXIgPSAobSkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgY29uc3QgbWFwcGluZyA9IHtcbiAgICAgICAgbmFtZTogbS5uYW1lLFxuICAgICAgICByZWZUaW1lc2VyaWFsOiAoX2IgPSAoX2EyID0gbS5leHRyYXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2IudGltZXNlcmlhbCxcbiAgICAgICAgcmVmVHlwZTogKF9kID0gKF9jID0gbS5leHRyYXMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfZC50eXBlLFxuICAgICAgICBpc1JlZjogISEoKF9mID0gKF9lID0gbS5leHRyYXMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfZi50aW1lc2VyaWFsKSxcbiAgICAgICAgY2xpZW50SWQ6IG0uY2xpZW50SWRcbiAgICAgIH07XG4gICAgICBpZiAoT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5maW5kKFxuICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gbWFwcGluZ1trZXldICE9PSB2YWx1ZSA6IGZhbHNlXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKG0pO1xuICAgIH07XG4gICAgdGhpcy5hZGRGaWx0ZXJlZFN1YnNjcmlwdGlvbihjaGFubmVsLCBmaWx0ZXIsIGxpc3RlbmVyLCBmaWx0ZXJlZExpc3RlbmVyKTtcbiAgICBjaGFubmVsLnN1YnNjcmlwdGlvbnMub24oZmlsdGVyZWRMaXN0ZW5lcik7XG4gIH1cbiAgLy8gQWRkcyBhIG5ldyBmaWx0ZXJlZCBzdWJzY3JpcHRpb25cbiAgc3RhdGljIGFkZEZpbHRlcmVkU3Vic2NyaXB0aW9uKGNoYW5uZWwsIGZpbHRlciwgcmVhbExpc3RlbmVyLCBmaWx0ZXJlZExpc3RlbmVyKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoIWNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGlmIChjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5oYXMocmVhbExpc3RlbmVyKSkge1xuICAgICAgY29uc3QgcmVhbExpc3RlbmVyTWFwID0gY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0KHJlYWxMaXN0ZW5lcik7XG4gICAgICByZWFsTGlzdGVuZXJNYXAuc2V0KGZpbHRlciwgKChfYTIgPSByZWFsTGlzdGVuZXJNYXAgPT0gbnVsbCA/IHZvaWQgMCA6IHJlYWxMaXN0ZW5lck1hcC5nZXQoZmlsdGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb25jYXQoZmlsdGVyZWRMaXN0ZW5lcikpIHx8IFtmaWx0ZXJlZExpc3RlbmVyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLnNldChcbiAgICAgICAgcmVhbExpc3RlbmVyLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW2ZpbHRlciwgW2ZpbHRlcmVkTGlzdGVuZXJdXV0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zKGNoYW5uZWwsIGZpbHRlciwgcmVhbExpc3RlbmVyKSB7XG4gICAgaWYgKCFjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIXJlYWxMaXN0ZW5lciAmJiBmaWx0ZXIpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmVudHJpZXMoKSkubWFwKChba2V5LCBmaWx0ZXJNYXBzXSkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBsZXQgbGlzdGVuZXJNYXBzID0gZmlsdGVyTWFwcy5nZXQoZmlsdGVyKTtcbiAgICAgICAgZmlsdGVyTWFwcy5kZWxldGUoZmlsdGVyKTtcbiAgICAgICAgaWYgKGZpbHRlck1hcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIChfYTIgPSBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJNYXBzO1xuICAgICAgfSkucmVkdWNlKFxuICAgICAgICAocHJldiwgY3VyKSA9PiBjdXIgPyBwcmV2LmNvbmNhdCguLi5jdXIpIDogcHJldixcbiAgICAgICAgW11cbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVhbExpc3RlbmVyIHx8ICFjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5oYXMocmVhbExpc3RlbmVyKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZWFsTGlzdGVuZXJNYXAgPSBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5nZXQocmVhbExpc3RlbmVyKTtcbiAgICBpZiAoIWZpbHRlcikge1xuICAgICAgY29uc3QgbGlzdGVuZXJzMiA9IEFycmF5LmZyb20ocmVhbExpc3RlbmVyTWFwLnZhbHVlcygpKS5yZWR1Y2UoKHByZXYsIGN1cikgPT4gcHJldi5jb25jYXQoLi4uY3VyKSwgW10pO1xuICAgICAgY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZGVsZXRlKHJlYWxMaXN0ZW5lcik7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzMjtcbiAgICB9XG4gICAgbGV0IGxpc3RlbmVycyA9IHJlYWxMaXN0ZW5lck1hcC5nZXQoZmlsdGVyKTtcbiAgICByZWFsTGlzdGVuZXJNYXAuZGVsZXRlKGZpbHRlcik7XG4gICAgcmV0dXJuIGxpc3RlbmVycyB8fCBbXTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2RlZmF1bHRyZWFsdGltZS50c1xudmFyIF9EZWZhdWx0UmVhbHRpbWUgPSBjbGFzcyBfRGVmYXVsdFJlYWx0aW1lIGV4dGVuZHMgYmFzZXJlYWx0aW1lX2RlZmF1bHQge1xuICAvLyBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgcmVxdWlyZXMgYW4gYXJndW1lbnQgdG8gYmUgcGFzc2VkLCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG5vdCBwYXNzIGFuIGFyZ3VtZW50LCB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoaXMgaXMgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIGl0LlxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBNc2dQYWNrID0gX0RlZmF1bHRSZWFsdGltZS5fTXNnUGFjaztcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIERlZmF1bHRSZWFsdGltZS5fTXNnUGFjayB0byBoYXZlIGJlZW4gc2V0XCIpO1xuICAgIH1cbiAgICBzdXBlcihcbiAgICAgIGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCB0cnVlLCBcIlJlYWx0aW1lXCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGFsbENvbW1vbk1vZHVsYXJQbHVnaW5zKSwge1xuICAgICAgICBDcnlwdG86IChfYTIgPSBfRGVmYXVsdFJlYWx0aW1lLkNyeXB0bykgIT0gbnVsbCA/IF9hMiA6IHZvaWQgMCxcbiAgICAgICAgTXNnUGFjayxcbiAgICAgICAgUmVhbHRpbWVQcmVzZW5jZToge1xuICAgICAgICAgIFJlYWx0aW1lUHJlc2VuY2U6IHJlYWx0aW1lcHJlc2VuY2VfZGVmYXVsdCxcbiAgICAgICAgICBQcmVzZW5jZU1lc3NhZ2U6IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LFxuICAgICAgICAgIFdpcmVQcmVzZW5jZU1lc3NhZ2VcbiAgICAgICAgfSxcbiAgICAgICAgQW5ub3RhdGlvbnM6IHtcbiAgICAgICAgICBBbm5vdGF0aW9uOiBhbm5vdGF0aW9uX2RlZmF1bHQsXG4gICAgICAgICAgV2lyZUFubm90YXRpb24sXG4gICAgICAgICAgUmVhbHRpbWVBbm5vdGF0aW9uczogcmVhbHRpbWVhbm5vdGF0aW9uc19kZWZhdWx0LFxuICAgICAgICAgIFJlc3RBbm5vdGF0aW9uczogcmVzdGFubm90YXRpb25zX2RlZmF1bHRcbiAgICAgICAgfSxcbiAgICAgICAgV2ViU29ja2V0VHJhbnNwb3J0OiB3ZWJzb2NrZXR0cmFuc3BvcnRfZGVmYXVsdCxcbiAgICAgICAgTWVzc2FnZUludGVyYWN0aW9uczogRmlsdGVyZWRTdWJzY3JpcHRpb25zXG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIHN0YXRpYyBnZXQgQ3J5cHRvKCkge1xuICAgIGlmICh0aGlzLl9DcnlwdG8gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX0NyeXB0bztcbiAgfVxuICBzdGF0aWMgc2V0IENyeXB0byhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX0NyeXB0byA9IG5ld1ZhbHVlO1xuICB9XG59O1xuX0RlZmF1bHRSZWFsdGltZS5VdGlscyA9IHV0aWxzX2V4cG9ydHM7XG5fRGVmYXVsdFJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbm1hbmFnZXJfZGVmYXVsdDtcbl9EZWZhdWx0UmVhbHRpbWUuUHJvdG9jb2xNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlX2RlZmF1bHQ7XG5fRGVmYXVsdFJlYWx0aW1lLl9DcnlwdG8gPSBudWxsO1xuX0RlZmF1bHRSZWFsdGltZS5NZXNzYWdlID0gRGVmYXVsdE1lc3NhZ2U7XG5fRGVmYXVsdFJlYWx0aW1lLlByZXNlbmNlTWVzc2FnZSA9IERlZmF1bHRQcmVzZW5jZU1lc3NhZ2U7XG5fRGVmYXVsdFJlYWx0aW1lLkFubm90YXRpb24gPSBEZWZhdWx0QW5ub3RhdGlvbjtcbl9EZWZhdWx0UmVhbHRpbWUuX01zZ1BhY2sgPSBudWxsO1xuLy8gVXNlZCBieSB0ZXN0c1xuX0RlZmF1bHRSZWFsdGltZS5fSHR0cCA9IEh0dHA7XG5fRGVmYXVsdFJlYWx0aW1lLl9QcmVzZW5jZU1hcCA9IFByZXNlbmNlTWFwO1xuX0RlZmF1bHRSZWFsdGltZS5fTWVzc2FnZUVuY29kaW5nID0gTWVzc2FnZUVuY29kaW5nO1xudmFyIERlZmF1bHRSZWFsdGltZSA9IF9EZWZhdWx0UmVhbHRpbWU7XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvbGliL3V0aWwvYnVmZmVydXRpbHMudHNcbnZhciBpbXBvcnRfY3J5cHRvID0gX190b0VTTShyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbnZhciBCdWZmZXJVdGlscyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5iYXNlNjRDaGFyU2V0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gICAgdGhpcy5oZXhDaGFyU2V0ID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIH1cbiAgYmFzZTY0RGVjb2RlKHN0cmluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmcsIFwiYmFzZTY0XCIpO1xuICB9XG4gIGJhc2U2NEVuY29kZShidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICB9XG4gIGJhc2U2NFVybEVuY29kZShidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIpLnRvU3RyaW5nKFwiYmFzZTY0dXJsXCIpO1xuICB9XG4gIGFyZUJ1ZmZlcnNFcXVhbChidWZmZXIxLCBidWZmZXIyKSB7XG4gICAgaWYgKCFidWZmZXIxIHx8ICFidWZmZXIyKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKGJ1ZmZlcjEpLmNvbXBhcmUodGhpcy50b0J1ZmZlcihidWZmZXIyKSkgPT0gMDtcbiAgfVxuICBieXRlTGVuZ3RoKGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgfVxuICBoZXhEZWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cmluZywgXCJoZXhcIik7XG4gIH1cbiAgaGV4RW5jb2RlKGJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKGJ1ZmZlcikudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cbiAgLyogSW4gbm9kZSwgQnVmZmVyVXRpbHMgbWV0aG9kcyB0aGF0IHJldHVybiBiaW5hcnkgb2JqZWN0cyByZXR1cm4gYSBCdWZmZXJcbiAgICogZm9yIGhpc3RvcmljYWwgcmVhc29uczsgdGhlIGJyb3dzZXIgZXF1aXZhbGVudHMgcmV0dXJuIEFycmF5QnVmZmVycyAqL1xuICBpc0J1ZmZlcihidWZmZXIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikgfHwgYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcik7XG4gIH1cbiAgdG9BcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgICBjb25zdCBub2RlQnVmZmVyID0gdGhpcy50b0J1ZmZlcihidWZmZXIpO1xuICAgIHJldHVybiBub2RlQnVmZmVyLmJ1ZmZlci5zbGljZShub2RlQnVmZmVyLmJ5dGVPZmZzZXQsIG5vZGVCdWZmZXIuYnl0ZU9mZnNldCArIG5vZGVCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgdG9CdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgfVxuICBhcnJheUJ1ZmZlclZpZXdUb0J1ZmZlcihhcnJheUJ1ZmZlclZpZXcpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihhcnJheUJ1ZmZlclZpZXcpO1xuICB9XG4gIHV0ZjhEZWNvZGUoYnVmZmVyKSB7XG4gICAgaWYgKCF0aGlzLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIHV0ZjhEZWNvZGUgdG8gYmUgYSBidWZmZXIsIGFycmF5YnVmZmVyLCBvciB2aWV3XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgfVxuICB1dGY4RW5jb2RlKHN0cmluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmcsIFwidXRmOFwiKTtcbiAgfVxuICBjb25jYXQoYnVmZmVycykge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMubWFwKCh4KSA9PiB0aGlzLnRvQnVmZmVyKHgpKSk7XG4gIH1cbiAgc2hhMjU2KG1lc3NhZ2UpIHtcbiAgICBjb25zdCBtZXNzYWdlQnVmZmVyID0gdGhpcy50b0J1ZmZlcihtZXNzYWdlKTtcbiAgICByZXR1cm4gaW1wb3J0X2NyeXB0by5kZWZhdWx0LmNyZWF0ZUhhc2goXCJTSEEyNTZcIikudXBkYXRlKG1lc3NhZ2VCdWZmZXIpLmRpZ2VzdCgpO1xuICB9XG4gIGhtYWNTaGEyNTYobWVzc2FnZSwga2V5KSB7XG4gICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IHRoaXMudG9CdWZmZXIobWVzc2FnZSk7XG4gICAgY29uc3Qga2V5QnVmZmVyID0gdGhpcy50b0J1ZmZlcihrZXkpO1xuICAgIHJldHVybiBpbXBvcnRfY3J5cHRvLmRlZmF1bHQuY3JlYXRlSG1hYyhcIlNIQTI1NlwiLCBrZXlCdWZmZXIpLnVwZGF0ZShtZXNzYWdlQnVmZmVyKS5kaWdlc3QoKTtcbiAgfVxufTtcbnZhciBidWZmZXJ1dGlsc19kZWZhdWx0ID0gbmV3IEJ1ZmZlclV0aWxzKCk7XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvbGliL3V0aWwvY3J5cHRvLnRzXG52YXIgaW1wb3J0X2NyeXB0bzIgPSBfX3RvRVNNKHJlcXVpcmUoXCJjcnlwdG9cIikpO1xudmFyIGltcG9ydF91dGlsID0gX190b0VTTShyZXF1aXJlKFwidXRpbFwiKSk7XG52YXIgY3JlYXRlQ3J5cHRvQ2xhc3MgPSBmdW5jdGlvbihidWZmZXJVdGlscykge1xuICB2YXIgREVGQVVMVF9BTEdPUklUSE0gPSBcImFlc1wiO1xuICB2YXIgREVGQVVMVF9LRVlMRU5HVEggPSAyNTY7XG4gIHZhciBERUZBVUxUX01PREUgPSBcImNiY1wiO1xuICB2YXIgREVGQVVMVF9CTE9DS0xFTkdUSCA9IDE2O1xuICBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbShieXRlcykge1xuICAgIHJldHVybiBpbXBvcnRfdXRpbC5kZWZhdWx0LnByb21pc2lmeShpbXBvcnRfY3J5cHRvMi5kZWZhdWx0LnJhbmRvbUJ5dGVzKShieXRlcyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCkge1xuICAgIHJldHVybiBwbGFpbnRleHRMZW5ndGggKyBERUZBVUxUX0JMT0NLTEVOR1RIICYgLURFRkFVTFRfQkxPQ0tMRU5HVEg7XG4gIH1cbiAgZnVuY3Rpb24gdmFsaWRhdGVDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5hbGdvcml0aG0gPT09IFwiYWVzXCIgJiYgcGFyYW1zLm1vZGUgPT09IFwiY2JjXCIpIHtcbiAgICAgIGlmIChwYXJhbXMua2V5TGVuZ3RoID09PSAxMjggfHwgcGFyYW1zLmtleUxlbmd0aCA9PT0gMjU2KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJVbnN1cHBvcnRlZCBrZXkgbGVuZ3RoIFwiICsgcGFyYW1zLmtleUxlbmd0aCArIFwiIGZvciBhZXMtY2JjIGVuY3J5cHRpb24uIEVuY3J5cHRpb24ga2V5IG11c3QgYmUgMTI4IG9yIDI1NiBiaXRzICgxNiBvciAzMiBBU0NJSSBjaGFyYWN0ZXJzKVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpc2VCYXNlNjQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKFwiX1wiLCBcIi9cIikucmVwbGFjZShcIi1cIiwgXCIrXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbGxlZEJ1ZmZlcihsZW5ndGgsIHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgIHJlc3VsdC5maWxsKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBwa2NzNVBhZGRpbmcgPSBbZmlsbGVkQnVmZmVyKDE2LCAxNildO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSAxNjsgaSsrKVxuICAgIHBrY3M1UGFkZGluZy5wdXNoKGZpbGxlZEJ1ZmZlcihpLCBpKSk7XG4gIGNsYXNzIENpcGhlclBhcmFtcyB7XG4gICAgY29uc3RydWN0b3IoYWxnb3JpdGhtLCBrZXlMZW5ndGgsIG1vZGUsIGtleSkge1xuICAgICAgdGhpcy5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICB0aGlzLmtleUxlbmd0aCA9IGtleUxlbmd0aDtcbiAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuaXYgPSBudWxsO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0luc3RDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG4gICAgcmV0dXJuICEhKHBhcmFtcy5hbGdvcml0aG0gJiYgcGFyYW1zLmtleSAmJiBwYXJhbXMua2V5TGVuZ3RoICYmIHBhcmFtcy5tb2RlKTtcbiAgfVxuICBjbGFzcyBDcnlwdG8yIHtcbiAgICAvKipcbiAgICAgKiBPYnRhaW4gYSBjb21wbGV0ZSBDaXBoZXJQYXJhbXMgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQgcGFyYW1zLCBmaWxsaW5nXG4gICAgICogaW4gYW55IG5vdCBwcm92aWRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzLCBjYWxjdWxhdGluZyBhIGtleUxlbmd0aCBmcm9tXG4gICAgICogdGhlIHN1cHBsaWVkIGtleSwgYW5kIHZhbGlkYXRpbmcgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIGFuIG9iamVjdCBjb250YWluaW5nIGF0IGEgbWluaW11bSBhIGBrZXlgIGtleSB3aXRoIHZhbHVlIHRoZVxuICAgICAqIGtleSwgYXMgZWl0aGVyIGEgYmluYXJ5IG9yIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqIE1heSBvcHRpb25hbGx5IGFsc28gY29udGFpbjogYWxnb3JpdGhtIChkZWZhdWx0cyB0byBBRVMpLFxuICAgICAqIG1vZGUgKGRlZmF1bHRzIHRvICdjYmMnKVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREZWZhdWx0UGFyYW1zKHBhcmFtcykge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGlmICghcGFyYW1zLmtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXkgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5rZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAga2V5ID0gYnVmZmVyVXRpbHMuYmFzZTY0RGVjb2RlKG5vcm1hbGlzZUJhc2U2NChwYXJhbXMua2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5rZXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBrZXkgPSBCdWZmZXIuZnJvbShwYXJhbXMua2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IHBhcmFtcy5rZXk7XG4gICAgICB9XG4gICAgICB2YXIgYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSB8fCBERUZBVUxUX0FMR09SSVRITTtcbiAgICAgIHZhciBrZXlMZW5ndGggPSBrZXkubGVuZ3RoICogODtcbiAgICAgIHZhciBtb2RlID0gcGFyYW1zLm1vZGUgfHwgREVGQVVMVF9NT0RFO1xuICAgICAgdmFyIGNpcGhlclBhcmFtcyA9IG5ldyBDaXBoZXJQYXJhbXMoYWxnb3JpdGhtLCBrZXlMZW5ndGgsIG1vZGUsIGtleSk7XG4gICAgICBpZiAocGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMua2V5TGVuZ3RoICE9PSBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleUxlbmd0aCBvZiBcIiArIHBhcmFtcy5rZXlMZW5ndGggKyBcIiB3YXMgc3BlY2lmaWVkLCBidXQgdGhlIGtleSBhY3R1YWxseSBoYXMgbGVuZ3RoIFwiICsgY2lwaGVyUGFyYW1zLmtleUxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVDaXBoZXJQYXJhbXMoY2lwaGVyUGFyYW1zKTtcbiAgICAgIHJldHVybiBjaXBoZXJQYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgcmFuZG9tIGVuY3J5cHRpb24ga2V5IGZyb20gdGhlIHN1cHBsaWVkIGtleWxlbmd0aCAob3IgdGhlXG4gICAgICogZGVmYXVsdCBrZXlMZW5ndGggaWYgbm9uZSBzdXBwbGllZCkgYXMgYSBCdWZmZXJcbiAgICAgKiBAcGFyYW0ga2V5TGVuZ3RoIChvcHRpb25hbCkgdGhlIHJlcXVpcmVkIGtleUxlbmd0aCBpbiBiaXRzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlUmFuZG9tS2V5KGtleUxlbmd0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlUmFuZG9tKChrZXlMZW5ndGggfHwgREVGQVVMVF9LRVlMRU5HVEgpIC8gOCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIkZhaWxlZCB0byBnZW5lcmF0ZSByYW5kb20ga2V5OiBcIiArIGVyci5tZXNzYWdlLCA1MDAsIDVlNCwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWw7IGdldCBhIENoYW5uZWxDaXBoZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGdpdmVuIGNpcGhlclBhcmFtc1xuICAgICAqIEBwYXJhbSBwYXJhbXMgZWl0aGVyIGEgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIG9yIHNvbWUgc3Vic2V0IG9mIGl0c1xuICAgICAqIGZpZWxkcyB0aGF0IGluY2x1ZGVzIGEga2V5XG4gICAgICovXG4gICAgc3RhdGljIGdldENpcGhlcihwYXJhbXMsIGxvZ2dlcikge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHZhciBjaXBoZXJQYXJhbXMgPSBpc0luc3RDaXBoZXJQYXJhbXMocGFyYW1zKSA/IHBhcmFtcyA6IHRoaXMuZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2lwaGVyUGFyYW1zLFxuICAgICAgICBjaXBoZXI6IG5ldyBDQkNDaXBoZXIoY2lwaGVyUGFyYW1zLCAoX2EyID0gcGFyYW1zLml2KSAhPSBudWxsID8gX2EyIDogbnVsbCwgbG9nZ2VyKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgQ3J5cHRvMi5DaXBoZXJQYXJhbXMgPSBDaXBoZXJQYXJhbXM7XG4gIENyeXB0bzI7XG4gIGNsYXNzIENCQ0NpcGhlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCBpdiwgbG9nZ2VyKSB7XG4gICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgIHRoaXMuZW5jcnlwdENpcGhlciA9IG51bGw7XG4gICAgICB0aGlzLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gKyBcIi1cIiArIFN0cmluZyhwYXJhbXMua2V5TGVuZ3RoKSArIFwiLVwiICsgcGFyYW1zLm1vZGU7XG4gICAgICB0aGlzLmtleSA9IHBhcmFtcy5rZXk7XG4gICAgICB0aGlzLml2ID0gaXY7XG4gICAgfVxuICAgIGFzeW5jIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDQkNDaXBoZXIuZW5jcnlwdCgpXCIsIFwiXCIpO1xuICAgICAgY29uc3QgaXYgPSBhd2FpdCB0aGlzLmdldEl2KCk7XG4gICAgICBpZiAoIXRoaXMuZW5jcnlwdENpcGhlcikge1xuICAgICAgICB0aGlzLmVuY3J5cHRDaXBoZXIgPSBpbXBvcnRfY3J5cHRvMi5kZWZhdWx0LmNyZWF0ZUNpcGhlcml2KHRoaXMuYWxnb3JpdGhtLCB0aGlzLmtleSwgaXYpO1xuICAgICAgfVxuICAgICAgdmFyIHBsYWludGV4dEJ1ZmZlciA9IGJ1ZmZlclV0aWxzLnRvQnVmZmVyKHBsYWludGV4dCk7XG4gICAgICB2YXIgcGxhaW50ZXh0TGVuZ3RoID0gcGxhaW50ZXh0QnVmZmVyLmxlbmd0aCwgcGFkZGVkTGVuZ3RoID0gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCk7XG4gICAgICB2YXIgY2lwaGVyT3V0ID0gdGhpcy5lbmNyeXB0Q2lwaGVyLnVwZGF0ZShcbiAgICAgICAgQnVmZmVyLmNvbmNhdChbcGxhaW50ZXh0QnVmZmVyLCBwa2NzNVBhZGRpbmdbcGFkZGVkTGVuZ3RoIC0gcGxhaW50ZXh0TGVuZ3RoXV0pXG4gICAgICApO1xuICAgICAgdmFyIGNpcGhlcnRleHQgPSBCdWZmZXIuY29uY2F0KFtpdiwgY2lwaGVyT3V0XSk7XG4gICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG4gICAgYXN5bmMgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICB2YXIgZGVjcnlwdENpcGhlciA9IGltcG9ydF9jcnlwdG8yLmRlZmF1bHQuY3JlYXRlRGVjaXBoZXJpdih0aGlzLmFsZ29yaXRobSwgdGhpcy5rZXksIGNpcGhlcnRleHQuc2xpY2UoMCwgREVGQVVMVF9CTE9DS0xFTkdUSCkpLCBwbGFpbnRleHQgPSBkZWNyeXB0Q2lwaGVyLnVwZGF0ZShjaXBoZXJ0ZXh0LnNsaWNlKERFRkFVTFRfQkxPQ0tMRU5HVEgpKSwgZmluYWwgPSBkZWNyeXB0Q2lwaGVyLmZpbmFsKCk7XG4gICAgICBpZiAoZmluYWwgJiYgZmluYWwubGVuZ3RoKVxuICAgICAgICBwbGFpbnRleHQgPSBCdWZmZXIuY29uY2F0KFtwbGFpbnRleHQsIGZpbmFsXSk7XG4gICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbiAgICBhc3luYyBnZXRJdigpIHtcbiAgICAgIGlmICh0aGlzLml2KSB7XG4gICAgICAgIHZhciBpdiA9IHRoaXMuaXY7XG4gICAgICAgIHRoaXMuaXYgPSBudWxsO1xuICAgICAgICByZXR1cm4gaXY7XG4gICAgICB9XG4gICAgICB2YXIgcmFuZG9tQmxvY2sgPSBhd2FpdCBnZW5lcmF0ZVJhbmRvbShERUZBVUxUX0JMT0NLTEVOR1RIKTtcbiAgICAgIGlmICghdGhpcy5lbmNyeXB0Q2lwaGVyKSB7XG4gICAgICAgIHJldHVybiByYW5kb21CbG9jaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRDaXBoZXIudXBkYXRlKHJhbmRvbUJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIENyeXB0bzI7XG59O1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi91dGlsL2h0dHAudHNcbnZhciBpbXBvcnRfZ290ID0gX190b0VTTShyZXF1aXJlKFwiZ290XCIpKTtcbnZhciBpbXBvcnRfaHR0cDUgPSBfX3RvRVNNKHJlcXVpcmUoXCJodHRwXCIpKTtcbnZhciBpbXBvcnRfaHR0cHMgPSBfX3RvRVNNKHJlcXVpcmUoXCJodHRwc1wiKSk7XG52YXIgZ2xvYmFsQWdlbnRQb29sID0gW107XG52YXIgX2E7XG52YXIgSHR0cDIgPSAoX2EgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuYWdlbnQgPSBudWxsO1xuICAgIHRoaXMuc3VwcG9ydHNBdXRoSGVhZGVycyA9IHRydWU7XG4gICAgdGhpcy5zdXBwb3J0c0xpbmtIZWFkZXJzID0gdHJ1ZTtcbiAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICBpZiAoKF9hMiA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm9wdGlvbnMuZGlzYWJsZUNvbm5lY3Rpdml0eUNoZWNrKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSAoKF9iID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsKSB8fCBkZWZhdWx0c19kZWZhdWx0LmNvbm5lY3Rpdml0eUNoZWNrVXJsO1xuICAgICAgY29uc3QgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSAoX2QgPSAoX2MgPSB0aGlzLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMpICE9IG51bGwgPyBfZCA6IG51bGw7XG4gICAgICBjb25zdCBjb25uZWN0aXZpdHlVcmxJc0RlZmF1bHQgPSAhKChfZSA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Uub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybCk7XG4gICAgICBjb25zdCB7IGVycm9yLCBzdGF0dXNDb2RlLCBib2R5IH0gPSBhd2FpdCB0aGlzLmRvVXJpKFxuICAgICAgICBIdHRwTWV0aG9kc19kZWZhdWx0LkdldCxcbiAgICAgICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zXG4gICAgICApO1xuICAgICAgaWYgKCFlcnJvciAmJiAhY29ubmVjdGl2aXR5VXJsSXNEZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBpc1N1Y2Nlc3NDb2RlKHN0YXR1c0NvZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFlcnJvciAmJiAoYm9keSA9PSBudWxsID8gdm9pZCAwIDogYm9keS50b1N0cmluZygpLnRyaW0oKSkgPT09IFwieWVzXCI7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudCAhPSBudWxsID8gY2xpZW50IDogbnVsbDtcbiAgfVxuICBhc3luYyBkb1VyaShtZXRob2QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB0aGlzLmNsaWVudCAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnJlc3RBZ2VudE9wdGlvbnMgfHwgZGVmYXVsdHNfZGVmYXVsdC5yZXN0QWdlbnRPcHRpb25zO1xuICAgIGNvbnN0IGRvT3B0aW9ucyA9IHsgaGVhZGVyczogaGVhZGVycyB8fCB2b2lkIDAsIHJlc3BvbnNlVHlwZTogXCJidWZmZXJcIiB9O1xuICAgIGlmICghdGhpcy5hZ2VudCkge1xuICAgICAgY29uc3QgcGVyc2lzdGVkQWdlbnQgPSAoX2EyID0gZ2xvYmFsQWdlbnRQb29sLmZpbmQoKHgpID0+IHNoYWxsb3dFcXVhbHMoYWdlbnRPcHRpb25zLCB4Lm9wdGlvbnMpKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5hZ2VudHM7XG4gICAgICBpZiAocGVyc2lzdGVkQWdlbnQpIHtcbiAgICAgICAgdGhpcy5hZ2VudCA9IHBlcnNpc3RlZEFnZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZ2VudCA9IHtcbiAgICAgICAgICBodHRwOiBuZXcgaW1wb3J0X2h0dHA1LmRlZmF1bHQuQWdlbnQoYWdlbnRPcHRpb25zKSxcbiAgICAgICAgICBodHRwczogbmV3IGltcG9ydF9odHRwcy5kZWZhdWx0LkFnZW50KGFnZW50T3B0aW9ucylcbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmFsQWdlbnRQb29sLnB1c2goe1xuICAgICAgICAgIG9wdGlvbnM6IGFnZW50T3B0aW9ucyxcbiAgICAgICAgICBhZ2VudHM6IHRoaXMuYWdlbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICBkb09wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMpXG4gICAgICBkb09wdGlvbnMuc2VhcmNoUGFyYW1zID0gcGFyYW1zO1xuICAgIGRvT3B0aW9ucy5hZ2VudCA9IHRoaXMuYWdlbnQ7XG4gICAgZG9PcHRpb25zLnVybCA9IHVyaTtcbiAgICBkb09wdGlvbnMudGltZW91dCA9IHtcbiAgICAgIHJlcXVlc3Q6ICh0aGlzLmNsaWVudCAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuVElNRU9VVFMpLmh0dHBSZXF1ZXN0VGltZW91dFxuICAgIH07XG4gICAgZG9PcHRpb25zLnJldHJ5ID0geyBsaW1pdDogMCB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBpbXBvcnRfZ290LmRlZmF1bHRbbWV0aG9kXShkb09wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXIobnVsbCwgcmVzLCByZXMuYm9keSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgaW1wb3J0X2dvdC5kZWZhdWx0LkhUVFBFcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlcihudWxsLCBlcnIucmVzcG9uc2UsIGVyci5yZXNwb25zZS5ib2R5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyKGVycik7XG4gICAgfVxuICB9XG4gIHNob3VsZEZhbGxiYWNrKGVycikge1xuICAgIGNvbnN0IHsgY29kZSwgc3RhdHVzQ29kZSB9ID0gZXJyO1xuICAgIHJldHVybiBjb2RlID09PSBcIkVORVRVTlJFQUNIXCIgfHwgY29kZSA9PT0gXCJFSE9TVFVOUkVBQ0hcIiB8fCBjb2RlID09PSBcIkVIT1NURE9XTlwiIHx8IGNvZGUgPT09IFwiRVRJTUVET1VUXCIgfHwgY29kZSA9PT0gXCJFU09DS0VUVElNRURPVVRcIiB8fCBjb2RlID09PSBcIkVOT1RGT1VORFwiIHx8IGNvZGUgPT09IFwiRUNPTk5SRVNFVFwiIHx8IGNvZGUgPT09IFwiRUNPTk5SRUZVU0VEXCIgfHwgc3RhdHVzQ29kZSA+PSA1MDAgJiYgc3RhdHVzQ29kZSA8PSA1MDQ7XG4gIH1cbiAgX2hhbmRsZXIoZXJyLCByZXNwb25zZSwgYm9keSkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IGVyciB9O1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZSwgaGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgaWYgKHN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICBzd2l0Y2ggKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pIHtcbiAgICAgICAgY2FzZSBcImFwcGxpY2F0aW9uL2pzb25cIjpcbiAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFwcGxpY2F0aW9uL3gtbXNncGFja1wiOlxuICAgICAgICAgIGlmICghKChfYTIgPSB0aGlzLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5fTXNnUGFjaykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkgPSB0aGlzLmNsaWVudC5fTXNnUGFjay5kZWNvZGUoYm9keSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IGJvZHkuZXJyb3IgPyBFcnJvckluZm8uZnJvbVZhbHVlcyhib2R5LmVycm9yKSA6IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGhlYWRlcnNbXCJ4LWFibHktZXJyb3JtZXNzYWdlXCJdIHx8IFwiRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6IFwiICsgc3RhdHVzQ29kZSArIFwiIGJvZHkgd2FzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGJvZHkpLFxuICAgICAgICBOdW1iZXIoaGVhZGVyc1tcIngtYWJseS1lcnJvcmNvZGVcIl0pLFxuICAgICAgICBzdGF0dXNDb2RlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgZXJyb3IsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkOiB0cnVlLCBzdGF0dXNDb2RlIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVycm9yOiBudWxsLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZDogZmFsc2UsIHN0YXR1c0NvZGUgfTtcbiAgfVxufSwgX2EubWV0aG9kcyA9IFtIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5EZWxldGUsIEh0dHBNZXRob2RzX2RlZmF1bHQuUG9zdCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5QdXQsIEh0dHBNZXRob2RzX2RlZmF1bHQuUGF0Y2hdLCBfYS5tZXRob2RzV2l0aG91dEJvZHkgPSBbSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsIEh0dHBNZXRob2RzX2RlZmF1bHQuRGVsZXRlXSwgX2EubWV0aG9kc1dpdGhCb2R5ID0gW0h0dHBNZXRob2RzX2RlZmF1bHQuUG9zdCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5QdXQsIEh0dHBNZXRob2RzX2RlZmF1bHQuUGF0Y2hdLCBfYSk7XG52YXIgaHR0cF9kZWZhdWx0ID0gSHR0cDI7XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvY29uZmlnLnRzXG52YXIgaW1wb3J0X2NyeXB0bzMgPSBfX3RvRVNNKHJlcXVpcmUoXCJjcnlwdG9cIikpO1xudmFyIGltcG9ydF93cyA9IF9fdG9FU00ocmVxdWlyZShcIndzXCIpKTtcbnZhciBpbXBvcnRfdXRpbDIgPSBfX3RvRVNNKHJlcXVpcmUoXCJ1dGlsXCIpKTtcbnZhciBDb25maWcgPSB7XG4gIGFnZW50OiBcIm5vZGVqcy9cIiArIHByb2Nlc3MudmVyc2lvbnMubm9kZSxcbiAgbG9nVGltZXN0YW1wczogdHJ1ZSxcbiAgdXNlckFnZW50OiBudWxsLFxuICBiaW5hcnlUeXBlOiBcIm5vZGVidWZmZXJcIixcbiAgV2ViU29ja2V0OiBpbXBvcnRfd3MuZGVmYXVsdCxcbiAgdXNlUHJvdG9jb2xIZWFydGJlYXRzOiBmYWxzZSxcbiAgc3VwcG9ydHNCaW5hcnk6IHRydWUsXG4gIHByZWZlckJpbmFyeTogdHJ1ZSxcbiAgbmV4dFRpY2s6IHByb2Nlc3MubmV4dFRpY2ssXG4gIGluc3BlY3Q6IGltcG9ydF91dGlsMi5kZWZhdWx0Lmluc3BlY3QsXG4gIHN0cmluZ0J5dGVTaXplOiBCdWZmZXIuYnl0ZUxlbmd0aCxcbiAgaW5oZXJpdHM6IGltcG9ydF91dGlsMi5kZWZhdWx0LmluaGVyaXRzLFxuICBhZGRFdmVudExpc3RlbmVyOiBudWxsLFxuICBnZXRSYW5kb21BcnJheUJ1ZmZlcjogYXN5bmMgZnVuY3Rpb24oYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBpbXBvcnRfdXRpbDIuZGVmYXVsdC5wcm9taXNpZnkoaW1wb3J0X2NyeXB0bzMuZGVmYXVsdC5yYW5kb21CeXRlcykoYnl0ZUxlbmd0aCk7XG4gIH1cbn07XG52YXIgY29uZmlnX2RlZmF1bHQgPSBDb25maWc7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL1hIUlN0YXRlcy50c1xudmFyIFhIUlN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFhIUlN0YXRlczIpID0+IHtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1NFTkRcIl0gPSAwXSA9IFwiUkVRX1NFTkRcIjtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1JFQ1ZcIl0gPSAxXSA9IFwiUkVRX1JFQ1ZcIjtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1JFQ1ZfUE9MTFwiXSA9IDJdID0gXCJSRVFfUkVDVl9QT0xMXCI7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9SRUNWX1NUUkVBTVwiXSA9IDNdID0gXCJSRVFfUkVDVl9TVFJFQU1cIjtcbiAgcmV0dXJuIFhIUlN0YXRlczI7XG59KShYSFJTdGF0ZXMgfHwge30pO1xudmFyIFhIUlN0YXRlc19kZWZhdWx0ID0gWEhSU3RhdGVzO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29tZXR0cmFuc3BvcnQudHNcbmZ1bmN0aW9uIHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSB7XG4gIGNvbnN0IFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUyA9IFs4MDAxNSwgODAwMTcsIDgwMDMwXTtcbiAgaWYgKGVyci5jb2RlKSB7XG4gICAgaWYgKGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKGVycikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUy5pbmNsdWRlcyhlcnIuY29kZSkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZXJyLmNvZGUgPj0gNGU0ICYmIGVyci5jb2RlIDwgNWU0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikge1xuICBpZiAoc2hvdWxkQmVFcnJvckFjdGlvbihlcnIpKSB7XG4gICAgcmV0dXJuIFtmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkVSUk9SLCBlcnJvcjogZXJyIH0pXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2Zyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuRElTQ09OTkVDVEVELCBlcnJvcjogZXJyIH0pXTtcbiAgfVxufVxudmFyIENvbWV0VHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyB0cmFuc3BvcnRfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICBzdXBlcihcbiAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLFxuICAgICAgYXV0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIC8qIGJpbmFyeSBub3Qgc3VwcG9ydGVkIGZvciBjb21ldCBzbyBmb3JjZSBKU09OIHByb3RvY29sICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICAvKiBIaXN0b3JpY2FsIGNvbW1lbnQsIGJhY2sgZnJvbSB3aGVuIHdlIHN1cHBvcnRlZCBKU09OUDpcbiAgICAgKlxuICAgICAqID4gRm9yIGNvbWV0LCB3ZSBjb3VsZCBkbyB0aGUgYXV0aCB1cGRhdGUgYnkgYWJvcnRpbmcgdGhlIGN1cnJlbnQgcmVjdiBhbmRcbiAgICAgKiA+IHN0YXJ0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRoYXQnZCBiZSBzdWZmaWNpZW50IGZvciByZWFsdGltZS5cbiAgICAgKiA+IFByb2JsZW0gaXMgSlNPTlAgLSB5b3UgY2FuJ3QgY2FuY2VsIHRydWx5IGFib3J0IGEgcmVjdiBvbmNlIHN0YXJ0ZWQuIFNvXG4gICAgICogPiB3ZSBuZWVkIHRvIHNlbmQgYW4gQVVUSCBmb3IganNvbnAuIEluIHdoaWNoIGNhc2UgaXQncyBzaW1wbGVyIHRvIGtlZXAgYWxsXG4gICAgICogPiBjb21ldCB0cmFuc3BvcnRzIHRoZSBzYW1lIGFuZCBkbyBpdCBmb3IgYWxsIG9mIHRoZW0uIFNvIHdlIHNlbmQgdGhlIEFVVEhcbiAgICAgKiA+IGluc3RlYWQsIGFuZCBkb24ndCBuZWVkIHRvIGFib3J0IHRoZSByZWN2XG4gICAgICpcbiAgICAgKiBOb3cgdGhhdCB3ZeKAmXZlIGRyb3BwZWQgSlNPTlAgc3VwcG9ydCwgd2UgbWF5IGJlIGFibGUgdG8gcmV2aXNpdCB0aGUgYWJvdmU7XG4gICAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzEyMTQuXG4gICAgICovXG4gICAgdGhpcy5vbkF1dGhVcGRhdGVkID0gKHRva2VuRGV0YWlscykgPT4ge1xuICAgICAgdGhpcy5hdXRoUGFyYW1zID0geyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9O1xuICAgIH07XG4gICAgdGhpcy5zdHJlYW0gPSBcInN0cmVhbVwiIGluIHBhcmFtcyA/IHBhcmFtcy5zdHJlYW0gOiB0cnVlO1xuICAgIHRoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJzdGFydGluZ1wiKTtcbiAgICB0cmFuc3BvcnRfZGVmYXVsdC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcbiAgICBjb25zdCBob3N0ID0gcGFyYW1zLmhvc3QgfHwgb3B0aW9ucy5wcmltYXJ5RG9tYWluO1xuICAgIGNvbnN0IHBvcnQgPSBkZWZhdWx0c19kZWZhdWx0LmdldFBvcnQob3B0aW9ucyk7XG4gICAgY29uc3QgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/IFwiaHR0cHM6Ly9cIiA6IFwiaHR0cDovL1wiO1xuICAgIHRoaXMuYmFzZVVyaSA9IGNvbWV0U2NoZW1lICsgaG9zdCArIFwiOlwiICsgcG9ydCArIFwiL2NvbWV0L1wiO1xuICAgIGNvbnN0IGNvbm5lY3RVcmkgPSB0aGlzLmJhc2VVcmkgKyBcImNvbm5lY3RcIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJ1cmk6IFwiICsgY29ubmVjdFVyaSk7XG4gICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKCksIChlcnIsIGF1dGhQYXJhbXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRoUGFyYW1zID0gYXV0aFBhcmFtcztcbiAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSB0aGlzLnBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuICAgICAgaWYgKFwic3RyZWFtXCIgaW4gY29ubmVjdFBhcmFtcylcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBjb25uZWN0UGFyYW1zLnN0cmVhbTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIixcbiAgICAgICAgXCJjb25uZWN0UGFyYW1zOlwiICsgdG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKVxuICAgICAgKTtcbiAgICAgIGxldCBwcmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbm5lY3RSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgICAgY29ubmVjdFVyaSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY29ubmVjdFBhcmFtcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVlxuICAgICAgKTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmVjb25uZWN0ZWQpIHtcbiAgICAgICAgICBwcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZW1pdChcInByZWNvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycjIpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgZXJyMiA9IGVycjIgfHwgbmV3IEVycm9ySW5mbyhcIlJlcXVlc3QgY2FuY2VsbGVkXCIsIDgwMDAzLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgICBpZiAoIXByZWNvbm5lY3RlZCAmJiAhZXJyMikge1xuICAgICAgICAgIHByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicHJlY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICBpZiAoZXJyMi5jb2RlKSB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyMikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVjdigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29ubmVjdFJlcXVlc3QuZXhlYygpO1xuICAgIH0pO1xuICB9XG4gIHJlcXVlc3RDbG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKVwiKTtcbiAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QodHJ1ZSk7XG4gIH1cbiAgcmVxdWVzdERpc2Nvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKVwiKTtcbiAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoZmFsc2UpO1xuICB9XG4gIF9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoY2xvc2luZykge1xuICAgIGNvbnN0IGNsb3NlT3JEaXNjb25uZWN0VXJpID0gY2xvc2luZyA/IHRoaXMuY2xvc2VVcmkgOiB0aGlzLmRpc2Nvbm5lY3RVcmk7XG4gICAgaWYgKGNsb3NlT3JEaXNjb25uZWN0VXJpKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KGNsb3NlT3JEaXNjb25uZWN0VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5EKTtcbiAgICAgIHJlcXVlc3Qub24oXCJjb21wbGV0ZVwiLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdFwiICsgKGNsb3NpbmcgPyBcIkNsb3NlKClcIiA6IFwiRGlzY29ubmVjdCgpXCIpLFxuICAgICAgICAgICAgXCJyZXF1ZXN0IHJldHVybmVkIGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVxdWVzdC5leGVjKCk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiXCIpO1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiYWJvcnRpbmcgcmVjdiByZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcImRpc3Bvc2VkXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uQ29ubmVjdChtZXNzYWdlKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25TdHIgPSAoX2EyID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb25uZWN0aW9uS2V5O1xuICAgIHRyYW5zcG9ydF9kZWZhdWx0LnByb3RvdHlwZS5vbkNvbm5lY3QuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBjb25zdCBiYXNlQ29ubmVjdGlvblVyaSA9IHRoaXMuYmFzZVVyaSArIGNvbm5lY3Rpb25TdHI7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29tZXRUcmFuc3BvcnQub25Db25uZWN0KClcIiwgXCJiYXNlVXJpID0gXCIgKyBiYXNlQ29ubmVjdGlvblVyaSk7XG4gICAgdGhpcy5zZW5kVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9zZW5kXCI7XG4gICAgdGhpcy5yZWN2VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9yZWN2XCI7XG4gICAgdGhpcy5jbG9zZVVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgXCIvY2xvc2VcIjtcbiAgICB0aGlzLmRpc2Nvbm5lY3RVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArIFwiL2Rpc2Nvbm5lY3RcIjtcbiAgfVxuICBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcbiAgICAgIHRoaXMucGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuICAgIHBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICB9XG4gIHNlbmRBbnlQZW5kaW5nKCkge1xuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zO1xuICAgIGlmICghcGVuZGluZ0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICB9XG4gIHNlbmRJdGVtcyhpdGVtcykge1xuICAgIGNvbnN0IHNlbmRSZXF1ZXN0ID0gdGhpcy5zZW5kUmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHRoaXMuc2VuZFVyaSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmF1dGhQYXJhbXMsXG4gICAgICB0aGlzLmVuY29kZVJlcXVlc3QoaXRlbXMpLFxuICAgICAgWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1NFTkRcbiAgICApO1xuICAgIHNlbmRSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycilcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkNvbWV0VHJhbnNwb3J0LnNlbmRJdGVtcygpXCIsXG4gICAgICAgICAgXCJvbiBjb21wbGV0ZTogZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICApO1xuICAgICAgdGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgIHRoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdJdGVtcykge1xuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kQW55UGVuZGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VuZFJlcXVlc3QuZXhlYygpO1xuICB9XG4gIHJlY3YoKSB7XG4gICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJlY3ZSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHRoaXMucmVjdlVyaSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmF1dGhQYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9QT0xMXG4gICAgKTtcbiAgICByZWN2UmVxdWVzdC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgIH0pO1xuICAgIHJlY3ZSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycikgPT4ge1xuICAgICAgdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMucmVjdigpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmVjdlJlcXVlc3QuZXhlYygpO1xuICB9XG4gIG9uRGF0YShyZXNwb25zZURhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmRlY29kZVJlc3BvbnNlKHJlc3BvbnNlRGF0YSk7XG4gICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoXG4gICAgICAgICAgICBmcm9tRGVzZXJpYWxpemVkKFxuICAgICAgICAgICAgICBpdGVtc1tpXSxcbiAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fQW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX2xpdmVPYmplY3RzUGx1Z2luXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29tZXRUcmFuc3BvcnQub25EYXRhKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgZXZlbnQ6IFwiICsgZS5zdGFja1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlUmVxdWVzdChyZXF1ZXN0SXRlbXMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVxdWVzdEl0ZW1zKTtcbiAgfVxuICBkZWNvZGVSZXNwb25zZShyZXNwb25zZURhdGEpIHtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlRGF0YSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2VEYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2VEYXRhO1xuICB9XG59O1xudmFyIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQgPSBDb21ldFRyYW5zcG9ydDtcblxuLy8gc3JjL3BsYXRmb3JtL25vZGVqcy9saWIvdHJhbnNwb3J0L25vZGVjb21ldHRyYW5zcG9ydC5qc1xudmFyIGltcG9ydF9odHRwNiA9IF9fdG9FU00ocmVxdWlyZShcImh0dHBcIikpO1xudmFyIGltcG9ydF9odHRwczIgPSBfX3RvRVNNKHJlcXVpcmUoXCJodHRwc1wiKSk7XG52YXIgaW1wb3J0X3VybCA9IF9fdG9FU00ocmVxdWlyZShcInVybFwiKSk7XG52YXIgaW1wb3J0X3V0aWwzID0gX190b0VTTShyZXF1aXJlKFwidXRpbFwiKSk7XG52YXIgbm9vcDMgPSBmdW5jdGlvbigpIHtcbn07XG52YXIgc2hvcnROYW1lMiA9IFRyYW5zcG9ydE5hbWVzLkNvbWV0O1xudmFyIE5vZGVDb21ldFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgY29tZXR0cmFuc3BvcnRfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICBzdXBlcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcbiAgICB0aGlzLmh0dHBBZ2VudCA9IG51bGw7XG4gICAgdGhpcy5odHRwc0FnZW50ID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IDA7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWUyO1xuICB9XG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJOb2RlQ29tZXRUcmFuc3BvcnQ7IHVyaT1cIiArIHRoaXMuYmFzZVVyaSArIFwiOyBpc0Nvbm5lY3RlZD1cIiArIHRoaXMuaXNDb25uZWN0ZWQgKyBcIjsgZm9ybWF0PVwiICsgdGhpcy5mb3JtYXQgKyBcIjsgc3RyZWFtPVwiICsgdGhpcy5zdHJlYW07XG4gIH1cbiAgZ2V0QWdlbnQodGxzKSB7XG4gICAgdmFyIHByb3AgPSB0bHMgPyBcImh0dHBzQWdlbnRcIiA6IFwiaHR0cEFnZW50XCIsIGFnZW50MiA9IHRoaXNbcHJvcF07XG4gICAgaWYgKCFhZ2VudDIpXG4gICAgICBhZ2VudDIgPSB0aGlzW3Byb3BdID0gbmV3ICh0bHMgPyBpbXBvcnRfaHR0cHMyLmRlZmF1bHQgOiBpbXBvcnRfaHR0cDYuZGVmYXVsdCkuQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUgfSk7XG4gICAgcmV0dXJuIGFnZW50MjtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHZhciBzZWxmMiA9IHRoaXM7XG4gICAgdGhpcy5vbmNlTm9QZW5kaW5nKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYyLmh0dHBBZ2VudClcbiAgICAgICAgc2VsZjIuaHR0cEFnZW50LmRlc3Ryb3koKTtcbiAgICAgIGlmIChzZWxmMi5odHRwc0FnZW50KVxuICAgICAgICBzZWxmMi5odHRwc0FnZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICBjb21ldHRyYW5zcG9ydF9kZWZhdWx0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH1cbiAgLyogdmFsaWQgaW4gbm9uLXN0cmVhbWluZyBtb2RlIG9ubHksIG9yIGRhdGEgb25seSBjb250YWlucyBsYXN0IHVwZGF0ZSAqL1xuICByZXF1ZXN0KHVyaSwgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVxID0gdGhpcy5jcmVhdGVSZXF1ZXN0KHVyaSwgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSk7XG4gICAgcmVxLm9uY2UoXCJjb21wbGV0ZVwiLCBjYWxsYmFjayk7XG4gICAgcmVxLmV4ZWMoKTtcbiAgICByZXR1cm4gcmVxO1xuICB9XG4gIGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGhpcy5mb3JtYXQsIHRoaXMudGltZW91dHMsIHRoaXMpO1xuICB9XG4gIGFkZFBlbmRpbmcoKSB7XG4gICAgKyt0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuICByZW1vdmVQZW5kaW5nKCkge1xuICAgIGlmICgtLXRoaXMucGVuZGluZ1JlcXVlc3RzIDw9IDApIHtcbiAgICAgIHRoaXMuZW1pdChcIm5vcGVuZGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgb25jZU5vUGVuZGluZyhsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9PSAwKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9uY2UoXCJub3BlbmRpbmdcIiwgbGlzdGVuZXIpO1xuICB9XG59O1xudmFyIFJlcXVlc3QgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCBmb3JtYXQsIHRpbWVvdXRzLCB0cmFuc3BvcnQpIHtcbiAgICBzdXBlcih0cmFuc3BvcnQubG9nZ2VyKTtcbiAgICBpZiAodHlwZW9mIHVyaSA9PSBcInN0cmluZ1wiKVxuICAgICAgdXJpID0gaW1wb3J0X3VybC5kZWZhdWx0LnBhcnNlKHVyaSk7XG4gICAgdmFyIHRscyA9IHVyaS5wcm90b2NvbCA9PSBcImh0dHBzOlwiO1xuICAgIHRoaXMuY2xpZW50ID0gdGxzID8gaW1wb3J0X2h0dHBzMi5kZWZhdWx0IDogaW1wb3J0X2h0dHA2LmRlZmF1bHQ7XG4gICAgdGhpcy5yZXF1ZXN0TW9kZSA9IHJlcXVlc3RNb2RlO1xuICAgIHRoaXMudGltZW91dHMgPSB0aW1lb3V0cztcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXMgPSBudWxsO1xuICAgIHZhciBtZXRob2QgPSBcIkdFVFwiLCBjb250ZW50VHlwZSA9IGZvcm1hdCA9PSBcIm1zZ3BhY2tcIiA/IFwiYXBwbGljYXRpb24veC1tc2dwYWNrXCIgOiBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICBoZWFkZXJzID0gaGVhZGVycyA/IG1peGluKHt9LCBoZWFkZXJzKSA6IHt9O1xuICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gPSBjb250ZW50VHlwZTtcbiAgICBpZiAoYm9keSkge1xuICAgICAgbWV0aG9kID0gXCJQT1NUXCI7XG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIGJvZHkgPSBCdWZmZXIuZnJvbShib2R5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSBib2R5Lmxlbmd0aDtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBjb250ZW50VHlwZTtcbiAgICB9XG4gICAgdmFyIHJlcXVlc3RPcHRpb25zID0gdGhpcy5yZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgIGhvc3RuYW1lOiB1cmkuaG9zdG5hbWUsXG4gICAgICBwb3J0OiB1cmkucG9ydCxcbiAgICAgIHBhdGg6IHVyaS5wYXRoICsgdG9RdWVyeVN0cmluZyhwYXJhbXMpLFxuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVyc1xuICAgIH07XG4gICAgaWYgKHRyYW5zcG9ydClcbiAgICAgIHJlcXVlc3RPcHRpb25zLmFnZW50ID0gdHJhbnNwb3J0LmdldEFnZW50KHRscyk7XG4gIH1cbiAgZXhlYygpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMucmVxdWVzdE1vZGUgPT0gWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1NFTkQgPyB0aGlzLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IHRoaXMudGltZW91dHMucmVjdlRpbWVvdXQsIHNlbGYyID0gdGhpcztcbiAgICB2YXIgdGltZXIgPSB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYyLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCksIHJlcSA9IHRoaXMucmVxID0gdGhpcy5jbGllbnQucmVxdWVzdCh0aGlzLnJlcXVlc3RPcHRpb25zKTtcbiAgICByZXEub24oXG4gICAgICBcImVycm9yXCIsXG4gICAgICB0aGlzLm9uUmVxRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXCJSZXF1ZXN0IGVycm9yOiBcIiArIGVyci5tZXNzYWdlLCBudWxsLCA0MDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBzZWxmMi50aW1lciA9IG51bGw7XG4gICAgICAgIHNlbGYyLmNvbXBsZXRlKGVycik7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXEub24oXCJyZXNwb25zZVwiLCBmdW5jdGlvbihyZXMpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICBzZWxmMi50aW1lciA9IG51bGw7XG4gICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuTm9Db250ZW50KSB7XG4gICAgICAgIHJlcy5yZXN1bWUoKTtcbiAgICAgICAgc2VsZjIuY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzLm9uKFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIHNlbGYyLm9uUmVzRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgUGFydGlhbEVycm9ySW5mbyhcIlJlc3BvbnNlIGVycm9yOiBcIiArIGVyci5tZXNzYWdlLCBudWxsLCA0MDApO1xuICAgICAgICAgIHNlbGYyLmNvbXBsZXRlKGVycik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBzZWxmMi5yZXMgPSByZXM7XG4gICAgICBpZiAoc2VsZjIucmVxdWVzdE1vZGUgPT0gWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNICYmIHN0YXR1c0NvZGUgPCA0MDApIHtcbiAgICAgICAgc2VsZjIucmVhZFN0cmVhbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZjIucmVhZEZ1bGx5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMudHJhbnNwb3J0KVxuICAgICAgdGhpcy50cmFuc3BvcnQuYWRkUGVuZGluZygpO1xuICAgIHJlcS5lbmQodGhpcy5ib2R5KTtcbiAgfVxuICByZWFkU3RyZWFtKCkge1xuICAgIHZhciByZXMgPSB0aGlzLnJlcywgc2VsZjIgPSB0aGlzO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5zdHJlYW1Db21wbGV0ZSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIG9uQ2h1bmsoY2h1bmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNodW5rID0gSlNPTi5wYXJzZShjaHVuayk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIk1hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHNlbGYyLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIk5vZGVDb21ldFRyYW5zcG9ydC5SZXF1ZXN0LnJlYWRTdHJlYW0oKVwiLCBtc2cpO1xuICAgICAgICBzZWxmMi5jb21wbGV0ZShuZXcgUGFydGlhbEVycm9ySW5mbyhtc2csIG51bGwsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxmMi5lbWl0KFwiZGF0YVwiLCBjaHVuayk7XG4gICAgfVxuICAgIHJlcy5vbihcbiAgICAgIFwiZGF0YVwiLFxuICAgICAgdGhpcy5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBuZXdDaHVua3MgPSBTdHJpbmcoZGF0YSkuc3BsaXQoXCJcXG5cIiksIGNodW5rcyA9IHNlbGYyLmNodW5rcztcbiAgICAgICAgaWYgKG5ld0NodW5rcy5sZW5ndGggPiAxICYmIGNodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2gobmV3Q2h1bmtzLnNoaWZ0KCkpO1xuICAgICAgICAgIHNlbGYyLmNodW5rcyA9IFtdO1xuICAgICAgICAgIG9uQ2h1bmsoY2h1bmtzLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFpbGluZ05ld0NodW5rID0gbmV3Q2h1bmtzLnBvcCgpO1xuICAgICAgICBpZiAodHJhaWxpbmdOZXdDaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmMi5jaHVua3MucHVzaCh0cmFpbGluZ05ld0NodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdDaHVua3MubWFwKG9uQ2h1bmspO1xuICAgICAgfVxuICAgICk7XG4gICAgcmVzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZjIuc3RyZWFtQ29tcGxldGUgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZjIuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlYWRGdWxseSgpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5yZXMsIGNodW5rcyA9IFtdLCBzZWxmMiA9IHRoaXM7XG4gICAgcmVzLm9uKFwiZGF0YVwiLCBmdW5jdGlvbihjaHVuaykge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH0pO1xuICAgIHJlcy5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib2R5ID0gQnVmZmVyLmNvbmNhdChjaHVua3MpLCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoU3RyaW5nKGJvZHkpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHZhciBtc2cgPSBcIk1hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oc2VsZjIubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiTm9kZUNvbWV0VHJhbnNwb3J0LlJlcXVlc3QucmVhZEZ1bGx5KClcIiwgbXNnKTtcbiAgICAgICAgICBzZWxmMi5jb21wbGV0ZShuZXcgUGFydGlhbEVycm9ySW5mbyhtc2csIG51bGwsIDQwMCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDQwMCB8fCBBcnJheS5pc0FycmF5KGJvZHkpKSB7XG4gICAgICAgICAgc2VsZjIuY29tcGxldGUobnVsbCwgYm9keSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnIgPSBib2R5LmVycm9yICYmIEVycm9ySW5mby5mcm9tVmFsdWVzKGJvZHkuZXJyb3IpO1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIGVyciA9IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFxuICAgICAgICAgICAgXCJFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogXCIgKyBzdGF0dXNDb2RlICsgXCIsIGJvZHkgd2FzOiBcIiArIGltcG9ydF91dGlsMy5kZWZhdWx0Lmluc3BlY3QoYm9keSksXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3RhdHVzQ29kZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZjIuY29tcGxldGUoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbXBsZXRlKGVyciwgYm9keSkge1xuICAgIGlmICghdGhpcy5yZXF1ZXN0Q29tcGxldGUpIHtcbiAgICAgIHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIGlmIChib2R5KVxuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGJvZHkpO1xuICAgICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgZXJyLCBib2R5KTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMub25kYXRhICYmICF0aGlzLnN0cmVhbUNvbXBsZXRlKSB7XG4gICAgICAgICAgaWYgKHRoaXMub25kYXRhICYmIHRoaXMucmVzKVxuICAgICAgICAgICAgdGhpcy5yZXMucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIHRoaXMub25kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZVBlbmRpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiTm9kZUNvbWV0VHJhbnNwb3J0LlJlcXVlc3QuYWJvcnQoKVwiLCBcIlwiKTtcbiAgICB2YXIgdGltZXIgPSB0aGlzLnRpbWVyO1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gICAgaWYgKHJlcSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiTm9kZUNvbWV0VHJhbnNwb3J0LlJlcXVlc3QuYWJvcnQoKVwiLCBcImFib3J0aW5nIHJlcXVlc3RcIik7XG4gICAgICByZXEucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLm9uUmVxRXJyb3IpO1xuICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgbm9vcDMpO1xuICAgICAgcmVxLmFib3J0KCk7XG4gICAgICB0aGlzLnJlcSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY29tcGxldGUoeyBzdGF0dXNDb2RlOiA0MDAsIGNvZGU6IDgwMDAzLCBtZXNzYWdlOiBcIkNhbmNlbGxlZFwiIH0pO1xuICB9XG59O1xudmFyIG5vZGVjb21ldHRyYW5zcG9ydF9kZWZhdWx0ID0gTm9kZUNvbWV0VHJhbnNwb3J0O1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi90cmFuc3BvcnQvaW5kZXgudHNcbnZhciB0cmFuc3BvcnRfZGVmYXVsdDIgPSB7XG4gIG9yZGVyOiBbVHJhbnNwb3J0TmFtZXMuQ29tZXRdLFxuICBidW5kbGVkSW1wbGVtZW50YXRpb25zOiB7XG4gICAgW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldF06IHdlYnNvY2tldHRyYW5zcG9ydF9kZWZhdWx0LFxuICAgIFtUcmFuc3BvcnROYW1lcy5Db21ldF06IG5vZGVjb21ldHRyYW5zcG9ydF9kZWZhdWx0XG4gIH1cbn07XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvbGliL3V0aWwvZGVmYXVsdHMudHNcbnZhciBEZWZhdWx0czIgPSB7XG4gIGNvbm5lY3Rpdml0eUNoZWNrVXJsOiBcImh0dHBzOi8vaW50ZXJuZXQtdXAuYWJseS1yZWFsdGltZS5jb20vaXMtdGhlLWludGVybmV0LXVwLnR4dFwiLFxuICB3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsOiBcIndzczovL3dzLXVwLmFibHktcmVhbHRpbWUuY29tXCIsXG4gIC8qIE5vdGU6IG9yZGVyIG1hdHRlcnMgaGVyZTogdGhlIGJhc2UgdHJhbnNwb3J0IGlzIHRoZSBsZWZ0bW9zdCBvbmUgaW4gdGhlXG4gICAqIGludGVyc2VjdGlvbiBvZiBiYXNlVHJhbnNwb3J0T3JkZXIgYW5kIHRoZSB0cmFuc3BvcnRzIGNsaWVudE9wdGlvbiB0aGF0J3Mgc3VwcG9ydGVkLiAqL1xuICBkZWZhdWx0VHJhbnNwb3J0czogW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldF0sXG4gIHJlc3RBZ2VudE9wdGlvbnM6IHsgbWF4U29ja2V0czogNDAsIGtlZXBBbGl2ZTogdHJ1ZSB9XG59O1xudmFyIGRlZmF1bHRzX2RlZmF1bHQyID0gRGVmYXVsdHMyO1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2luZGV4LnRzXG52YXIgbXNncGFjayA9IHJlcXVpcmVfbXNncGFjaygpO1xudmFyIENyeXB0byA9IGNyZWF0ZUNyeXB0b0NsYXNzKGJ1ZmZlcnV0aWxzX2RlZmF1bHQpO1xuUGxhdGZvcm0uQ3J5cHRvID0gQ3J5cHRvO1xuUGxhdGZvcm0uQnVmZmVyVXRpbHMgPSBidWZmZXJ1dGlsc19kZWZhdWx0O1xuUGxhdGZvcm0uSHR0cCA9IGh0dHBfZGVmYXVsdDtcblBsYXRmb3JtLkNvbmZpZyA9IGNvbmZpZ19kZWZhdWx0O1xuUGxhdGZvcm0uVHJhbnNwb3J0cyA9IHRyYW5zcG9ydF9kZWZhdWx0MjtcblBsYXRmb3JtLldlYlN0b3JhZ2UgPSBudWxsO1xuZm9yIChjb25zdCBjbGllbnRDbGFzcyBvZiBbRGVmYXVsdFJlc3QsIERlZmF1bHRSZWFsdGltZV0pIHtcbiAgY2xpZW50Q2xhc3MuQ3J5cHRvID0gQ3J5cHRvO1xuICBjbGllbnRDbGFzcy5fTXNnUGFjayA9IG1zZ3BhY2s7XG59XG5sb2dnZXJfZGVmYXVsdC5pbml0TG9nSGFuZGxlcnMoKTtcblBsYXRmb3JtLkRlZmF1bHRzID0gZ2V0RGVmYXVsdHMoZGVmYXVsdHNfZGVmYXVsdDIpO1xuaWYgKFBsYXRmb3JtLkNvbmZpZy5hZ2VudCkge1xuICBQbGF0Zm9ybS5EZWZhdWx0cy5hZ2VudCArPSBcIiBcIiArIFBsYXRmb3JtLkNvbmZpZy5hZ2VudDtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFcnJvckluZm8sXG4gIFJlc3Q6IERlZmF1bHRSZXN0LFxuICBSZWFsdGltZTogRGVmYXVsdFJlYWx0aW1lLFxuICBtc2dwYWNrOiBudWxsLFxuICBtYWtlUHJvdG9jb2xNZXNzYWdlRnJvbURlc2VyaWFsaXplZDogbWFrZUZyb21EZXNlcmlhbGl6ZWRXaXRoRGVwZW5kZW5jaWVzXG59O1xuaWYgKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIpIHtcbiAgdmFyIF9fY3AgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICAgIGlmICgoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIikgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGZyb20pKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIGtleSwge1xuICAgICAgICAgIGdldDogKCkgPT4gZnJvbVtrZXldLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEoZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fY3AobW9kdWxlLmV4cG9ydHMsIGV4cG9ydHMpO1xufVxucmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufSkpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmx5LW5vZGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably-node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably-node.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably-node.js ***!
  \*************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)\n\nAbly JavaScript Library v2.17.1\nhttps://github.com/ably/ably-js\n\nReleased under the Apache Licence v2.0*/(function (g, f) {\n    if (true) {\n      module.exports = f(__webpack_require__(/*! ws */ \"(rsc)/./node_modules/.pnpm/ws@8.19.0/node_modules/ws/index.js\"), __webpack_require__(/*! got */ \"(rsc)/./node_modules/.pnpm/got@11.8.6/node_modules/got/dist/source/index.js\"));\n    } else {}\n  }(this, (__da, __db) => {\nvar exports = {};\nvar module = { exports };\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __await = function(promise, isYieldStar) {\n  this[0] = promise;\n  this[1] = isYieldStar;\n};\nvar __asyncGenerator = (__this, __arguments, generator) => {\n  var resume = (k, v, yes, no) => {\n    try {\n      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;\n      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === \"return\" ? k : \"next\", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume(\"throw\", e, yes, no));\n    } catch (e) {\n      no(e);\n    }\n  };\n  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));\n  var it = {};\n  return generator = generator.apply(__this, __arguments), it[Symbol.asyncIterator] = () => it, method(\"next\"), method(\"throw\"), method(\"return\"), it;\n};\n\n// node_modules/bops/from.js\nvar require_from = __commonJS({\n  \"node_modules/bops/from.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var version2 = ((process || {}).version || \"v0.0.0\").slice(1).split(\".\")[0];\n    module2.exports = Number(version2) < 6 ? function from(source, encoding) {\n      return new Buffer2(source, encoding);\n    } : function from(source, encoding) {\n      return Buffer2.from(source, encoding);\n    };\n  }\n});\n\n// node_modules/bops/to.js\nvar require_to = __commonJS({\n  \"node_modules/bops/to.js\"(exports2, module2) {\n    module2.exports = function(source, encoding) {\n      return source.toString(encoding);\n    };\n  }\n});\n\n// node_modules/bops/is.js\nvar require_is = __commonJS({\n  \"node_modules/bops/is.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    module2.exports = function(buffer) {\n      return Buffer2.isBuffer(buffer);\n    };\n  }\n});\n\n// node_modules/bops/subarray.js\nvar require_subarray = __commonJS({\n  \"node_modules/bops/subarray.js\"(exports2, module2) {\n    module2.exports = function(source, from, to) {\n      return arguments.length === 2 ? source.slice(from) : source.slice(from, to);\n    };\n  }\n});\n\n// node_modules/bops/join.js\nvar require_join = __commonJS({\n  \"node_modules/bops/join.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    module2.exports = function(targets, hint) {\n      return hint !== void 0 ? Buffer2.concat(targets, hint) : Buffer2.concat(targets);\n    };\n  }\n});\n\n// node_modules/bops/copy.js\nvar require_copy = __commonJS({\n  \"node_modules/bops/copy.js\"(exports2, module2) {\n    module2.exports = copy2;\n    function copy2(source, target, target_start, source_start, source_end) {\n      return source.copy(target, target_start, source_start, source_end);\n    }\n  }\n});\n\n// node_modules/bops/create.js\nvar require_create = __commonJS({\n  \"node_modules/bops/create.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var version2 = ((process || {}).version || \"v0.0.0\").slice(1).split(\".\")[0];\n    module2.exports = Number(version2) < 6 ? function create(size) {\n      return new Buffer2(size);\n    } : function create(size) {\n      return Buffer2.alloc(size);\n    };\n  }\n});\n\n// node_modules/bops/read.js\nvar require_read = __commonJS({\n  \"node_modules/bops/read.js\"(exports2, module2) {\n    var proto = {};\n    var rex = /read.+/;\n    var buildFn;\n    buildFn = function(key2) {\n      var code = \"return buf.\" + key2 + \"(\" + [\"a\", \"b\", \"c\"].join(\",\") + \")\";\n      return new Function([\"buf\", \"a\", \"b\", \"c\"], code);\n    };\n    module2.exports = proto;\n    for (key in Buffer.prototype) {\n      if (rex.test(key)) {\n        proto[key] = buildFn(key);\n      }\n    }\n    var key;\n  }\n});\n\n// node_modules/bops/write.js\nvar require_write = __commonJS({\n  \"node_modules/bops/write.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var proto = {};\n    var rex = /write.+/;\n    var buildFn;\n    buildFn = function(key2) {\n      var code = \"return buf.\" + key2 + \"(\" + [\"a\", \"b\", \"c\"].join(\",\") + \")\";\n      return new Function([\"buf\", \"a\", \"b\", \"c\"], code);\n    };\n    module2.exports = proto;\n    for (key in Buffer2.prototype) {\n      if (rex.test(key)) {\n        proto[key] = buildFn(key);\n      }\n    }\n    var key;\n  }\n});\n\n// node_modules/bops/index.js\nvar require_bops = __commonJS({\n  \"node_modules/bops/index.js\"(exports2, module2) {\n    var proto = {};\n    module2.exports = proto;\n    proto.from = require_from();\n    proto.to = require_to();\n    proto.is = require_is();\n    proto.subarray = require_subarray();\n    proto.join = require_join();\n    proto.copy = require_copy();\n    proto.create = require_create();\n    mix(require_read(), proto);\n    mix(require_write(), proto);\n    function mix(from, into) {\n      for (var key in from) {\n        into[key] = from[key];\n      }\n    }\n  }\n});\n\n// node_modules/@ably/msgpack-js/msgpack.js\nvar require_msgpack = __commonJS({\n  \"node_modules/@ably/msgpack-js/msgpack.js\"(exports2) {\n    \"use strict\";\n    var bops = require_bops();\n    exports2.encode = function(value, sparse) {\n      var size = sizeof(value, sparse);\n      if (size == 0)\n        return void 0;\n      var buffer = bops.create(size);\n      encode2(value, buffer, 0, sparse);\n      return buffer;\n    };\n    exports2.decode = decode2;\n    var SH_L_32 = (1 << 16) * (1 << 16);\n    var SH_R_32 = 1 / SH_L_32;\n    function readInt64BE(buf, offset) {\n      offset = offset || 0;\n      return buf.readInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n    }\n    function readUInt64BE(buf, offset) {\n      offset = offset || 0;\n      return buf.readUInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n    }\n    function writeInt64BE(buf, val, offset) {\n      if (val < 9223372036854776e3) {\n        buf.writeInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n      } else {\n        buf.writeUInt32BE(2147483647, offset);\n        buf.writeUInt32BE(4294967295, offset + 4);\n      }\n    }\n    function writeUInt64BE(buf, val, offset) {\n      if (val < 18446744073709552e3) {\n        buf.writeUInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n      } else {\n        buf.writeUInt32BE(4294967295, offset);\n        buf.writeUInt32BE(4294967295, offset + 4);\n      }\n    }\n    function Decoder(buffer, offset) {\n      this.offset = offset || 0;\n      this.buffer = buffer;\n      this.bufferLength = buffer.length;\n    }\n    Decoder.prototype.map = function(length) {\n      if (length * 2 > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a map of length ${length})`);\n      }\n      var value = {};\n      for (var i = 0; i < length; i++) {\n        var key = this.parse();\n        value[key] = this.parse();\n      }\n      return value;\n    };\n    Decoder.prototype.bin = Decoder.prototype.buf = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a binary of length ${length})`);\n      }\n      var value = bops.subarray(this.buffer, this.offset, this.offset + length);\n      this.offset += length;\n      return value;\n    };\n    Decoder.prototype.str = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a string of length ${length})`);\n      }\n      var value = bops.to(bops.subarray(this.buffer, this.offset, this.offset + length));\n      this.offset += length;\n      return value;\n    };\n    Decoder.prototype.array = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced an array of length ${length})`);\n      }\n      var value = new Array(length);\n      for (var i = 0; i < length; i++) {\n        value[i] = this.parse();\n      }\n      return value;\n    };\n    Decoder.prototype.parse = function() {\n      var type = this.buffer[this.offset];\n      var value, length, extType;\n      if (type === void 0) {\n        throw new Error(\"malformed messagepack (referenced offset is outside buffer)\");\n      }\n      if ((type & 128) === 0) {\n        this.offset++;\n        return type;\n      }\n      if ((type & 240) === 128) {\n        length = type & 15;\n        this.offset++;\n        return this.map(length);\n      }\n      if ((type & 240) === 144) {\n        length = type & 15;\n        this.offset++;\n        return this.array(length);\n      }\n      if ((type & 224) === 160) {\n        length = type & 31;\n        this.offset++;\n        return this.str(length);\n      }\n      if ((type & 224) === 224) {\n        value = bops.readInt8(this.buffer, this.offset);\n        this.offset++;\n        return value;\n      }\n      switch (type) {\n        case 192:\n          this.offset++;\n          return null;\n        case 194:\n          this.offset++;\n          return false;\n        case 195:\n          this.offset++;\n          return true;\n        case 196:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return this.bin(length);\n        case 197:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.bin(length);\n        case 198:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.bin(length);\n        case 199:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 2);\n          this.offset += 3;\n          return [extType, this.bin(length)];\n        case 200:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 3);\n          this.offset += 4;\n          return [extType, this.bin(length)];\n        case 201:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 5);\n          this.offset += 6;\n          return [extType, this.bin(length)];\n        case 202:\n          value = bops.readFloatBE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 203:\n          value = bops.readDoubleBE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 204:\n          value = this.buffer[this.offset + 1];\n          this.offset += 2;\n          return value;\n        case 205:\n          value = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 206:\n          value = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 207:\n          value = readUInt64BE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 208:\n          value = bops.readInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 209:\n          value = bops.readInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 210:\n          value = bops.readInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 211:\n          value = readInt64BE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 212:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          value = bops.readUInt8(this.buffer, this.offset + 2);\n          this.offset += 3;\n          return extType === 0 && value === 0 ? void 0 : [extType, value];\n        case 213:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(2)];\n        case 214:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(4)];\n        case 215:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(8)];\n        case 216:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(16)];\n        case 217:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return this.str(length);\n        case 218:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.str(length);\n        case 219:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.str(length);\n        case 220:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.array(length);\n        case 221:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.array(length);\n        case 222:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.map(length);\n        case 223:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.map(length);\n      }\n      throw new Error(\"Unknown type 0x\" + type.toString(16));\n    };\n    function decode2(buffer) {\n      var decoder = new Decoder(buffer);\n      var value = decoder.parse();\n      if (decoder.offset !== buffer.length)\n        throw new Error(buffer.length - decoder.offset + \" trailing bytes\");\n      return value;\n    }\n    function encodeableKeys(value, sparse) {\n      return Object.keys(value).filter(function(e) {\n        var val = value[e], type = typeof val;\n        return (!sparse || val !== void 0 && val !== null) && (\"function\" !== type || !!val.toJSON);\n      });\n    }\n    function encode2(value, buffer, offset, sparse, isMapElement) {\n      var type = typeof value;\n      var length, size;\n      if (type === \"string\") {\n        value = bops.from(value);\n        length = value.length;\n        if (length < 32) {\n          buffer[offset] = length | 160;\n          bops.copy(value, buffer, offset + 1);\n          return 1 + length;\n        }\n        if (length < 256) {\n          buffer[offset] = 217;\n          bops.writeUInt8(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 2);\n          return 2 + length;\n        }\n        if (length < 65536) {\n          buffer[offset] = 218;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 3);\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          buffer[offset] = 219;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 5);\n          return 5 + length;\n        }\n      }\n      if (bops.is(value)) {\n        length = value.length;\n        if (length < 256) {\n          buffer[offset] = 196;\n          bops.writeUInt8(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 2);\n          return 2 + length;\n        }\n        if (length < 65536) {\n          buffer[offset] = 197;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 3);\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          buffer[offset] = 198;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 5);\n          return 5 + length;\n        }\n      }\n      if (type === \"number\") {\n        if (Math.floor(value) !== value) {\n          buffer[offset] = 203;\n          bops.writeDoubleBE(buffer, value, offset + 1);\n          return 9;\n        }\n        if (value >= 0) {\n          if (value < 128) {\n            buffer[offset] = value;\n            return 1;\n          }\n          if (value < 256) {\n            buffer[offset] = 204;\n            buffer[offset + 1] = value;\n            return 2;\n          }\n          if (value < 65536) {\n            buffer[offset] = 205;\n            bops.writeUInt16BE(buffer, value, offset + 1);\n            return 3;\n          }\n          if (value < 4294967296) {\n            buffer[offset] = 206;\n            bops.writeUInt32BE(buffer, value, offset + 1);\n            return 5;\n          }\n          if (value < 18446744073709552e3) {\n            buffer[offset] = 207;\n            writeUInt64BE(buffer, value, offset + 1);\n            return 9;\n          }\n          throw new Error(\"Number too big 0x\" + value.toString(16));\n        }\n        if (value >= -32) {\n          bops.writeInt8(buffer, value, offset);\n          return 1;\n        }\n        if (value >= -128) {\n          buffer[offset] = 208;\n          bops.writeInt8(buffer, value, offset + 1);\n          return 2;\n        }\n        if (value >= -32768) {\n          buffer[offset] = 209;\n          bops.writeInt16BE(buffer, value, offset + 1);\n          return 3;\n        }\n        if (value >= -2147483648) {\n          buffer[offset] = 210;\n          bops.writeInt32BE(buffer, value, offset + 1);\n          return 5;\n        }\n        if (value >= -9223372036854776e3) {\n          buffer[offset] = 211;\n          writeInt64BE(buffer, value, offset + 1);\n          return 9;\n        }\n        throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n      }\n      if (type === \"undefined\") {\n        if (sparse && isMapElement)\n          return 0;\n        buffer[offset] = 212;\n        buffer[offset + 1] = 0;\n        buffer[offset + 2] = 0;\n        return 3;\n      }\n      if (value === null) {\n        if (sparse && isMapElement)\n          return 0;\n        buffer[offset] = 192;\n        return 1;\n      }\n      if (type === \"boolean\") {\n        buffer[offset] = value ? 195 : 194;\n        return 1;\n      }\n      if (\"function\" === typeof value.toJSON)\n        return encode2(value.toJSON(), buffer, offset, sparse);\n      if (type === \"object\") {\n        size = 0;\n        var isArray = Array.isArray(value);\n        if (isArray) {\n          length = value.length;\n        } else {\n          var keys = encodeableKeys(value, sparse);\n          length = keys.length;\n        }\n        if (length < 16) {\n          buffer[offset] = length | (isArray ? 144 : 128);\n          size = 1;\n        } else if (length < 65536) {\n          buffer[offset] = isArray ? 220 : 222;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          size = 3;\n        } else if (length < 4294967296) {\n          buffer[offset] = isArray ? 221 : 223;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          size = 5;\n        }\n        if (isArray) {\n          for (var i = 0; i < length; i++) {\n            size += encode2(value[i], buffer, offset + size, sparse);\n          }\n        } else {\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            size += encode2(key, buffer, offset + size);\n            size += encode2(value[key], buffer, offset + size, sparse, true);\n          }\n        }\n        return size;\n      }\n      if (type === \"function\")\n        return void 0;\n      throw new Error(\"Unknown type \" + type);\n    }\n    function sizeof(value, sparse, isMapElement) {\n      var type = typeof value;\n      var length, size;\n      if (type === \"string\") {\n        length = bops.from(value).length;\n        if (length < 32) {\n          return 1 + length;\n        }\n        if (length < 256) {\n          return 2 + length;\n        }\n        if (length < 65536) {\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          return 5 + length;\n        }\n      }\n      if (bops.is(value)) {\n        length = value.length;\n        if (length < 256) {\n          return 2 + length;\n        }\n        if (length < 65536) {\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          return 5 + length;\n        }\n      }\n      if (type === \"number\") {\n        if (Math.floor(value) !== value)\n          return 9;\n        if (value >= 0) {\n          if (value < 128)\n            return 1;\n          if (value < 256)\n            return 2;\n          if (value < 65536)\n            return 3;\n          if (value < 4294967296)\n            return 5;\n          if (value < 18446744073709552e3)\n            return 9;\n          throw new Error(\"Number too big 0x\" + value.toString(16));\n        }\n        if (value >= -32)\n          return 1;\n        if (value >= -128)\n          return 2;\n        if (value >= -32768)\n          return 3;\n        if (value >= -2147483648)\n          return 5;\n        if (value >= -9223372036854776e3)\n          return 9;\n        throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n      }\n      if (type === \"boolean\")\n        return 1;\n      if (value === null)\n        return sparse && isMapElement ? 0 : 1;\n      if (value === void 0)\n        return sparse && isMapElement ? 0 : 3;\n      if (\"function\" === typeof value.toJSON)\n        return sizeof(value.toJSON(), sparse);\n      if (type === \"object\") {\n        size = 0;\n        if (Array.isArray(value)) {\n          length = value.length;\n          for (var i = 0; i < length; i++) {\n            size += sizeof(value[i], sparse);\n          }\n        } else {\n          var keys = encodeableKeys(value, sparse);\n          length = keys.length;\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            size += sizeof(key) + sizeof(value[key], sparse, true);\n          }\n        }\n        if (length < 16) {\n          return 1 + size;\n        }\n        if (length < 65536) {\n          return 3 + size;\n        }\n        if (length < 4294967296) {\n          return 5 + size;\n        }\n        throw new Error(\"Array or object too long 0x\" + length.toString(16));\n      }\n      if (type === \"function\")\n        return 0;\n      throw new Error(\"Unknown type \" + type);\n    }\n  }\n});\n\n// src/common/platform.ts\nvar Platform = class {\n};\n\n// src/common/lib/util/logger.ts\nvar globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\nfunction pad(timeSegment, three) {\n  return `${timeSegment}`.padStart(three ? 3 : 2, \"0\");\n}\nfunction getHandler(logger) {\n  return Platform.Config.logTimestamps ? function(msg) {\n    const time = /* @__PURE__ */ new Date();\n    logger(\n      pad(time.getHours()) + \":\" + pad(time.getMinutes()) + \":\" + pad(time.getSeconds()) + \".\" + pad(time.getMilliseconds(), 1) + \" \" + msg\n    );\n  } : function(msg) {\n    logger(msg);\n  };\n}\nvar getDefaultLoggers = () => {\n  var _a2;\n  let consoleLogger;\n  let errorLogger;\n  if (typeof ((_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) === \"function\") {\n    consoleLogger = function(...args) {\n      console.log.apply(console, args);\n    };\n    errorLogger = console.warn ? function(...args) {\n      console.warn.apply(console, args);\n    } : consoleLogger;\n  } else {\n    consoleLogger = errorLogger = function() {\n    };\n  }\n  return [consoleLogger, errorLogger].map(getHandler);\n};\nvar _Logger = class _Logger {\n  constructor() {\n    this.deprecated = (description, msg) => {\n      this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\n    };\n    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n      the object being serialised if the log level will not output the message */\n    this.shouldLog = (level) => {\n      return level <= this.logLevel;\n    };\n    this.setLog = (level, handler) => {\n      if (level !== void 0)\n        this.logLevel = level;\n      if (handler !== void 0)\n        this.logHandler = this.logErrorHandler = handler;\n    };\n    this.logLevel = _Logger.defaultLogLevel;\n    this.logHandler = _Logger.defaultLogHandler;\n    this.logErrorHandler = _Logger.defaultLogErrorHandler;\n  }\n  static initLogHandlers() {\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\n    this.defaultLogHandler = logHandler;\n    this.defaultLogErrorHandler = logErrorHandler;\n    this.defaultLogger = new _Logger();\n  }\n  /**\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\n   */\n  static logActionNoStrip(logger, level, action, message) {\n    logger.logAction(level, action, message);\n  }\n  logAction(level, action, message) {\n    if (this.shouldLog(level)) {\n      (level === 1 /* Error */ ? this.logErrorHandler : this.logHandler)(\"Ably: \" + action + \": \" + message, level);\n    }\n  }\n  renamedClientOption(oldName, newName) {\n    this.deprecationWarning(\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  renamedMethod(className, oldName, newName) {\n    this.deprecationWarning(\n      `\\`${className}\\`\\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  deprecationWarning(message) {\n    if (this.shouldLog(1 /* Error */)) {\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, 1 /* Error */);\n    }\n  }\n};\n_Logger.defaultLogLevel = 1 /* Error */;\n// public constants\n_Logger.LOG_NONE = 0 /* None */;\n_Logger.LOG_ERROR = 1 /* Error */;\n_Logger.LOG_MAJOR = 2 /* Major */;\n_Logger.LOG_MINOR = 3 /* Minor */;\n_Logger.LOG_MICRO = 4 /* Micro */;\n/* public static functions */\n/**\n * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\n *\n * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you canâ€™t dynamically specify the log level.\n */\n_Logger.logAction = (logger, level, action, message) => {\n  _Logger.logActionNoStrip(logger, level, action, message);\n};\nvar Logger = _Logger;\nvar logger_default = Logger;\n\n// src/common/lib/util/utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Format: () => Format,\n  allSame: () => allSame,\n  allToLowerCase: () => allToLowerCase,\n  allToUpperCase: () => allToUpperCase,\n  arrChooseN: () => arrChooseN,\n  arrDeleteValue: () => arrDeleteValue,\n  arrEquals: () => arrEquals,\n  arrIntersect: () => arrIntersect,\n  arrIntersectOb: () => arrIntersectOb,\n  arrPopRandomElement: () => arrPopRandomElement,\n  arrWithoutValue: () => arrWithoutValue,\n  cheapRandStr: () => cheapRandStr,\n  containsValue: () => containsValue,\n  copy: () => copy,\n  createMissingPluginError: () => createMissingPluginError,\n  dataSizeBytes: () => dataSizeBytes,\n  decodeBody: () => decodeBody,\n  encodeBody: () => encodeBody,\n  ensureArray: () => ensureArray,\n  forInOwnNonNullProperties: () => forInOwnNonNullProperties,\n  getBackoffCoefficient: () => getBackoffCoefficient,\n  getGlobalObject: () => getGlobalObject,\n  getJitterCoefficient: () => getJitterCoefficient,\n  getRetryTime: () => getRetryTime,\n  inherits: () => inherits,\n  inspectBody: () => inspectBody,\n  inspectError: () => inspectError,\n  intersect: () => intersect,\n  isEmpty: () => isEmpty,\n  isErrorInfoOrPartialErrorInfo: () => isErrorInfoOrPartialErrorInfo,\n  isNil: () => isNil,\n  isObject: () => isObject,\n  keysArray: () => keysArray,\n  listenerToAsyncIterator: () => listenerToAsyncIterator,\n  matchDerivedChannel: () => matchDerivedChannel,\n  mixin: () => mixin,\n  parseQueryString: () => parseQueryString,\n  prototypicalClone: () => prototypicalClone,\n  randomString: () => randomString,\n  shallowClone: () => shallowClone,\n  shallowEquals: () => shallowEquals,\n  stringifyValues: () => stringifyValues,\n  throwMissingPluginError: () => throwMissingPluginError,\n  toBase64: () => toBase64,\n  toQueryString: () => toQueryString,\n  valuesArray: () => valuesArray,\n  whenPromiseSettles: () => whenPromiseSettles,\n  withTimeoutAsync: () => withTimeoutAsync\n});\n\n// src/common/lib/types/errorinfo.ts\nfunction toString(err) {\n  let result = \"[\" + err.constructor.name;\n  if (err.message)\n    result += \": \" + err.message;\n  if (err.statusCode)\n    result += \"; statusCode=\" + err.statusCode;\n  if (err.code)\n    result += \"; code=\" + err.code;\n  if (err.cause)\n    result += \"; cause=\" + inspectError(err.cause);\n  if (err.href && !(err.message && err.message.indexOf(\"help.ably.io\") > -1))\n    result += \"; see \" + err.href + \" \";\n  result += \"]\";\n  return result;\n}\nvar ErrorInfo = class _ErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _ErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || typeof code !== \"number\" || typeof statusCode !== \"number\") {\n      throw new Error(\"ErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\nvar PartialErrorInfo = class _PartialErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _PartialErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || !isNil(code) && typeof code !== \"number\" || !isNil(statusCode) && typeof statusCode !== \"number\") {\n      throw new Error(\"PartialErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _PartialErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\n\n// src/common/lib/util/utils.ts\nfunction randomPosn(arrOrStr) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\nfunction mixin(target, ...args) {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\nfunction copy(src) {\n  return mixin({}, src);\n}\nfunction ensureArray(obj) {\n  if (isNil(obj)) {\n    return [];\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\nfunction isObject(ob) {\n  return Object.prototype.toString.call(ob) == \"[object Object]\";\n}\nfunction isEmpty(ob) {\n  for (const prop in ob)\n    return false;\n  return true;\n}\nfunction isNil(arg) {\n  return arg == null;\n}\nfunction shallowClone(ob) {\n  const result = new Object();\n  for (const prop in ob)\n    result[prop] = ob[prop];\n  return result;\n}\nfunction prototypicalClone(ob, ownProperties) {\n  class F {\n  }\n  F.prototype = ob;\n  const result = new F();\n  if (ownProperties)\n    mixin(result, ownProperties);\n  return result;\n}\nvar inherits = function(ctor, superCtor) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\nfunction containsValue(ob, val) {\n  for (const i in ob) {\n    if (ob[i] == val)\n      return true;\n  }\n  return false;\n}\nfunction intersect(arr, ob) {\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\nfunction arrIntersect(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arr2.indexOf(member) != -1)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrIntersectOb(arr, ob) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrDeleteValue(arr, val) {\n  const idx = arr.indexOf(val);\n  const res = idx != -1;\n  if (res)\n    arr.splice(idx, 1);\n  return res;\n}\nfunction arrWithoutValue(arr, val) {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\nfunction keysArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(prop);\n  }\n  return result;\n}\nfunction valuesArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\nfunction forInOwnNonNullProperties(ob, fn) {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\nfunction allSame(arr, prop) {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arr.every(function(item) {\n    return item[prop] === first;\n  });\n}\nvar Format = /* @__PURE__ */ ((Format2) => {\n  Format2[\"msgpack\"] = \"msgpack\";\n  Format2[\"json\"] = \"json\";\n  return Format2;\n})(Format || {});\nfunction arrPopRandomElement(arr) {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\nfunction toQueryString(params) {\n  const parts = [];\n  if (params) {\n    for (const key in params)\n      parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n  return parts.length ? \"?\" + parts.join(\"&\") : \"\";\n}\nfunction stringifyValues(params) {\n  return Object.fromEntries(Object.entries(params).map(([k, v]) => [k, String(v)]));\n}\nfunction parseQueryString(query) {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result = {};\n  while (match = search.exec(query))\n    result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n  return result;\n}\nfunction isErrorInfoOrPartialErrorInfo(err) {\n  return typeof err == \"object\" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\nfunction inspectError(err) {\n  var _a2, _b;\n  if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === \"ErrorInfo\" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === \"PartialErrorInfo\")\n    return err.toString();\n  return Platform.Config.inspect(err);\n}\nfunction inspectBody(body) {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return body.toString();\n  } else if (typeof body === \"string\") {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\nfunction dataSizeBytes(data) {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === \"string\") {\n    return Platform.Config.stringByteSize(data);\n  }\n  if (typeof data === \"number\") {\n    return 8;\n  }\n  if (typeof data === \"boolean\") {\n    return 1;\n  }\n  throw new Error(\n    `Expected input of Utils.dataSizeBytes to be a string, a number, a boolean or a buffer, but was: ${typeof data}`\n  );\n}\nfunction cheapRandStr() {\n  return String(Math.random()).substr(2);\n}\nvar randomString = async (numBytes) => {\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n  return Platform.BufferUtils.base64Encode(buffer);\n};\nfunction arrChooseN(arr, n) {\n  const numItems = Math.min(n, arr.length), mutableArr = arr.slice(), result = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\nfunction whenPromiseSettles(promise, callback) {\n  promise.then((result) => {\n    callback == null ? void 0 : callback(null, result);\n  }).catch((err) => {\n    callback == null ? void 0 : callback(err);\n  });\n}\nfunction decodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.decode(body);\n  }\n  return JSON.parse(String(body));\n}\nfunction encodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.encode(body, true);\n  }\n  return JSON.stringify(body);\n}\nfunction allToLowerCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toLowerCase();\n  });\n}\nfunction allToUpperCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toUpperCase();\n  });\n}\nfunction getBackoffCoefficient(count) {\n  return Math.min((count + 2) / 3, 2);\n}\nfunction getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\nfunction getRetryTime(initialTimeout, retryAttempt) {\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\nfunction getGlobalObject() {\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return self;\n}\nfunction shallowEquals(source, target) {\n  return Object.keys(source).every((key) => source[key] === target[key]) && Object.keys(target).every((key) => target[key] === source[key]);\n}\nfunction matchDerivedChannel(name) {\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/;\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo(\"regex match failed\", 400, 40010);\n  }\n  if (match[2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  return {\n    qualifierParam: match[3] || \"\",\n    channelName: match[4]\n  };\n}\nfunction toBase64(str) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\nfunction arrEquals(a, b) {\n  return a.length === b.length && a.every(function(val, i) {\n    return val === b[i];\n  });\n}\nfunction createMissingPluginError(pluginName) {\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n}\nfunction throwMissingPluginError(pluginName) {\n  throw createMissingPluginError(pluginName);\n}\nasync function withTimeoutAsync(promise, timeout = 5e3, err = \"Timeout expired\") {\n  const e = new ErrorInfo(err, 5e4, 500);\n  return Promise.race([promise, new Promise((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\n}\nfunction listenerToAsyncIterator(registerListener) {\n  return __asyncGenerator(this, null, function* () {\n    const eventQueue = [];\n    let resolveNext = null;\n    const removeListener2 = registerListener((event) => {\n      if (resolveNext) {\n        const resolve = resolveNext;\n        resolveNext = null;\n        resolve(event);\n      } else {\n        eventQueue.push(event);\n      }\n    });\n    try {\n      while (true) {\n        if (eventQueue.length > 0) {\n          yield eventQueue.shift();\n        } else {\n          if (resolveNext) {\n            throw new ErrorInfo(\"Concurrent next() calls are not supported\", 4e4, 400);\n          }\n          const event = yield new __await(new Promise((resolve) => {\n            resolveNext = resolve;\n          }));\n          yield event;\n        }\n      }\n    } finally {\n      removeListener2();\n    }\n  });\n}\n\n// package.json\nvar version = \"2.17.1\";\n\n// src/common/lib/util/defaults.ts\nvar agent = \"ably-js/\" + version;\nvar Defaults = {\n  ENDPOINT: \"main\",\n  ENVIRONMENT: \"\",\n  REST_HOST: \"rest.ably.io\",\n  REALTIME_HOST: \"realtime.ably.io\",\n  FALLBACK_HOSTS: [\n    \"main.a.fallback.ably-realtime.com\",\n    \"main.b.fallback.ably-realtime.com\",\n    \"main.c.fallback.ably-realtime.com\",\n    \"main.d.fallback.ably-realtime.com\",\n    \"main.e.fallback.ably-realtime.com\"\n  ],\n  PORT: 80,\n  TLS_PORT: 443,\n  TIMEOUTS: {\n    /* Documented as options params: */\n    disconnectedRetryTimeout: 15e3,\n    suspendedRetryTimeout: 3e4,\n    /* Undocumented, but part of the api and can be used by customers: */\n    httpRequestTimeout: 1e4,\n    httpMaxRetryDuration: 15e3,\n    channelRetryTimeout: 15e3,\n    fallbackRetryTimeout: 6e5,\n    /* For internal / test use only: */\n    connectionStateTtl: 12e4,\n    realtimeRequestTimeout: 1e4,\n    recvTimeout: 9e4,\n    webSocketConnectTimeout: 1e4,\n    webSocketSlowTimeout: 4e3\n  },\n  httpMaxRetryCount: 3,\n  maxMessageSize: 65536,\n  version,\n  protocolVersion: 5,\n  agent,\n  getPort,\n  getHttpScheme,\n  getPrimaryDomainFromEndpoint,\n  getEndpointFallbackHosts,\n  getFallbackHosts,\n  getHosts,\n  checkHost,\n  objectifyOptions,\n  normaliseOptions,\n  defaultGetHeaders,\n  defaultPostHeaders\n};\nfunction getPort(options, tls) {\n  return tls || options.tls ? options.tlsPort : options.port;\n}\nfunction getHttpScheme(options) {\n  return options.tls ? \"https://\" : \"http://\";\n}\nfunction isFqdnIpOrLocalhost(endpoint) {\n  return endpoint.includes(\".\") || endpoint.includes(\"::\") || endpoint === \"localhost\";\n}\nfunction getPrimaryDomainFromEndpoint(endpoint) {\n  if (isFqdnIpOrLocalhost(endpoint))\n    return endpoint;\n  if (endpoint.startsWith(\"nonprod:\")) {\n    const routingPolicyId = endpoint.replace(\"nonprod:\", \"\");\n    return `${routingPolicyId}.realtime.ably-nonprod.net`;\n  }\n  return `${endpoint}.realtime.ably.net`;\n}\nfunction getEndpointFallbackHosts(endpoint) {\n  if (isFqdnIpOrLocalhost(endpoint))\n    return [];\n  if (endpoint.startsWith(\"nonprod:\")) {\n    const routingPolicyId = endpoint.replace(\"nonprod:\", \"\");\n    return endpointFallbacks(routingPolicyId, \"ably-realtime-nonprod.com\");\n  }\n  return endpointFallbacks(endpoint, \"ably-realtime.com\");\n}\nfunction endpointFallbacks(routingPolicyId, domain) {\n  return [\"a\", \"b\", \"c\", \"d\", \"e\"].map((id) => `${routingPolicyId}.${id}.fallback.${domain}`);\n}\nfunction getFallbackHosts(options) {\n  const fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== \"undefined\" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n  return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\nfunction getHosts(options) {\n  return [options.primaryDomain].concat(getFallbackHosts(options));\n}\nfunction checkHost(host) {\n  if (typeof host !== \"string\") {\n    throw new ErrorInfo(\"host must be a string; was a \" + typeof host, 4e4, 400);\n  }\n  if (!host.length) {\n    throw new ErrorInfo(\"host must not be zero-length\", 4e4, 400);\n  }\n}\nfunction getTimeouts(options) {\n  const timeouts = {};\n  for (const prop in Defaults.TIMEOUTS) {\n    timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];\n  }\n  return timeouts;\n}\nfunction getAgentString(options) {\n  let agentStr = Defaults.agent;\n  if (options.agents) {\n    for (var agent2 in options.agents) {\n      agentStr += \" \" + agent2 + \"/\" + options.agents[agent2];\n    }\n  }\n  return agentStr;\n}\nfunction objectifyOptions(options, allowKeyOrToken, sourceForErrorMessage, logger, modularPluginsToInclude) {\n  if (options === void 0) {\n    const msg = allowKeyOrToken ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token` : `${sourceForErrorMessage} must be initialized with a client options object`;\n    logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n    throw new Error(msg);\n  }\n  let optionsObj;\n  if (typeof options === \"string\") {\n    if (options.indexOf(\":\") == -1) {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\\u2019s \\`token\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { token: options };\n    } else {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\\u2019s \\`key\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { key: options };\n    }\n  } else {\n    optionsObj = options;\n  }\n  if (modularPluginsToInclude) {\n    optionsObj = __spreadProps(__spreadValues({}, optionsObj), { plugins: __spreadValues(__spreadValues({}, modularPluginsToInclude), optionsObj.plugins) });\n  }\n  return optionsObj;\n}\nfunction checkIfClientOptionsAreValid(options) {\n  if (options.endpoint && (options.environment || options.restHost || options.realtimeHost)) {\n    throw new ErrorInfo(\n      \"The `endpoint` option cannot be used in conjunction with the `environment`, `restHost`, or `realtimeHost` options.\",\n      40106,\n      400\n    );\n  }\n  if (options.environment && (options.restHost || options.realtimeHost)) {\n    throw new ErrorInfo(\n      \"The `environment` option cannot be used in conjunction with the `restHost`, or `realtimeHost` options.\",\n      40106,\n      400\n    );\n  }\n}\nfunction normaliseOptions(options, MsgPack, logger) {\n  const loggerToUse = logger != null ? logger : logger_default.defaultLogger;\n  if (options.environment) {\n    loggerToUse.deprecated(\"The `environment` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  if (options.restHost) {\n    loggerToUse.deprecated(\"The `restHost` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  if (options.realtimeHost) {\n    loggerToUse.deprecated(\"The `realtimeHost` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  checkIfClientOptionsAreValid(options);\n  if (typeof options.recover === \"function\" && options.closeOnUnload === true) {\n    logger_default.logAction(\n      loggerToUse,\n      logger_default.LOG_ERROR,\n      \"Defaults.normaliseOptions\",\n      \"closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter\"\n    );\n    options.recover = void 0;\n  }\n  if (!(\"closeOnUnload\" in options)) {\n    options.closeOnUnload = !options.recover;\n  }\n  if (!(\"queueMessages\" in options))\n    options.queueMessages = true;\n  const endpoint = options.endpoint || Defaults.ENDPOINT;\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n    options.fallbackHosts = getEndpointFallbackHosts(options.environment || endpoint);\n  }\n  const primaryDomainFromEnvironment = options.environment && `${options.environment}.realtime.ably.net`;\n  const primaryDomainFromLegacyOptions = options.restHost || options.realtimeHost || primaryDomainFromEnvironment;\n  const primaryDomain = primaryDomainFromLegacyOptions || getPrimaryDomainFromEndpoint(endpoint);\n  (options.fallbackHosts || []).concat(primaryDomain).forEach(checkHost);\n  options.port = options.port || Defaults.PORT;\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n  if (!(\"tls\" in options))\n    options.tls = true;\n  const timeouts = getTimeouts(options);\n  if (MsgPack) {\n    if (\"useBinaryProtocol\" in options) {\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n    } else {\n      options.useBinaryProtocol = Platform.Config.preferBinary;\n    }\n  } else {\n    options.useBinaryProtocol = false;\n  }\n  const headers = {};\n  if (options.clientId) {\n    headers[\"X-Ably-ClientId\"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n  }\n  if (!(\"idempotentRestPublishing\" in options)) {\n    options.idempotentRestPublishing = true;\n  }\n  let connectivityCheckParams = null;\n  let connectivityCheckUrl = options.connectivityCheckUrl;\n  if (options.connectivityCheckUrl) {\n    let [uri, qs] = options.connectivityCheckUrl.split(\"?\");\n    connectivityCheckParams = qs ? parseQueryString(qs) : {};\n    if (uri.indexOf(\"://\") === -1) {\n      uri = \"https://\" + uri;\n    }\n    connectivityCheckUrl = uri;\n  }\n  let wsConnectivityCheckUrl = options.wsConnectivityCheckUrl;\n  if (wsConnectivityCheckUrl && wsConnectivityCheckUrl.indexOf(\"://\") === -1) {\n    wsConnectivityCheckUrl = \"wss://\" + wsConnectivityCheckUrl;\n  }\n  return __spreadProps(__spreadValues({}, options), {\n    primaryDomain,\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\n    timeouts,\n    connectivityCheckParams,\n    connectivityCheckUrl,\n    wsConnectivityCheckUrl,\n    headers\n  });\n}\nfunction normaliseChannelOptions(Crypto2, logger, options) {\n  const channelOptions = options || {};\n  if (channelOptions.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(channelOptions.cipher, logger);\n    channelOptions.cipher = cipher.cipherParams;\n    channelOptions.channelCipher = cipher.cipher;\n  } else if (\"cipher\" in channelOptions) {\n    channelOptions.cipher = void 0;\n    channelOptions.channelCipher = null;\n  }\n  return channelOptions;\n}\nvar contentTypes = {\n  json: \"application/json\",\n  xml: \"application/xml\",\n  html: \"text/html\",\n  msgpack: \"application/x-msgpack\",\n  text: \"text/plain\"\n};\nvar defaultHeadersOptions = {\n  format: \"json\" /* json */,\n  protocolVersion: Defaults.protocolVersion\n};\nfunction defaultGetHeaders(options, { format, protocolVersion = defaultHeadersOptions.protocolVersion } = {}) {\n  const accept = contentTypes[format != null ? format : options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */];\n  return {\n    accept,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nfunction defaultPostHeaders(options, { format, protocolVersion = defaultHeadersOptions.protocolVersion } = {}) {\n  const accept = contentTypes[format != null ? format : options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */];\n  const contentType = accept;\n  return {\n    accept,\n    \"content-type\": contentType,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nvar defaults_default = Defaults;\nfunction getDefaults(platformDefaults) {\n  return Object.assign(Defaults, platformDefaults);\n}\n\n// src/common/lib/util/multicaster.ts\nvar Multicaster = class _Multicaster {\n  // Private constructor; use static Multicaster.create instead\n  constructor(logger, members) {\n    this.logger = logger;\n    this.members = members || [];\n  }\n  call(err, result) {\n    for (const member of this.members) {\n      if (member) {\n        try {\n          member(err, result);\n        } catch (e) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Multicaster multiple callback handler\",\n            \"Unexpected exception: \" + e + \"; stack = \" + e.stack\n          );\n        }\n      }\n    }\n  }\n  push(...args) {\n    this.members.push(...args);\n  }\n  createPromise() {\n    return new Promise((resolve, reject) => {\n      this.push((err, result) => {\n        err ? reject(err) : resolve(result);\n      });\n    });\n  }\n  resolveAll(result) {\n    this.call(null, result);\n  }\n  rejectAll(err) {\n    this.call(err);\n  }\n  static create(logger, members) {\n    const instance = new _Multicaster(logger, members);\n    return Object.assign((err, result) => instance.call(err, result), {\n      push: (fn) => instance.push(fn),\n      createPromise: () => instance.createPromise(),\n      resolveAll: (result) => instance.resolveAll(result),\n      rejectAll: (err) => instance.rejectAll(err)\n    });\n  }\n};\nvar multicaster_default = Multicaster;\n\n// src/common/constants/HttpMethods.ts\nvar HttpMethods = /* @__PURE__ */ ((HttpMethods2) => {\n  HttpMethods2[\"Get\"] = \"get\";\n  HttpMethods2[\"Delete\"] = \"delete\";\n  HttpMethods2[\"Post\"] = \"post\";\n  HttpMethods2[\"Put\"] = \"put\";\n  HttpMethods2[\"Patch\"] = \"patch\";\n  return HttpMethods2;\n})(HttpMethods || {});\nvar HttpMethods_default = HttpMethods;\n\n// src/common/constants/HttpStatusCodes.ts\nvar HttpStatusCodes = /* @__PURE__ */ ((HttpStatusCodes2) => {\n  HttpStatusCodes2[HttpStatusCodes2[\"Success\"] = 200] = \"Success\";\n  HttpStatusCodes2[HttpStatusCodes2[\"NoContent\"] = 204] = \"NoContent\";\n  HttpStatusCodes2[HttpStatusCodes2[\"BadRequest\"] = 400] = \"BadRequest\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Unauthorized\"] = 401] = \"Unauthorized\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Forbidden\"] = 403] = \"Forbidden\";\n  HttpStatusCodes2[HttpStatusCodes2[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n  HttpStatusCodes2[HttpStatusCodes2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  return HttpStatusCodes2;\n})(HttpStatusCodes || {});\nfunction isSuccessCode(statusCode) {\n  return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;\n}\nvar HttpStatusCodes_default = HttpStatusCodes;\n\n// src/common/lib/client/auth.ts\nvar MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction random() {\n  return (\"000000\" + Math.floor(Math.random() * 1e16)).slice(-16);\n}\nfunction isRealtime(client) {\n  return !!client.connection;\n}\nfunction normaliseAuthcallbackError(err) {\n  if (!isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\nvar hmac = (text, key) => {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n  return bufferUtils.base64Encode(digest);\n};\nfunction c14n(capability) {\n  if (!capability)\n    return \"\";\n  if (typeof capability == \"string\")\n    capability = JSON.parse(capability);\n  const c14nCapability = /* @__PURE__ */ Object.create(null);\n  const keys = keysArray(capability, true);\n  if (!keys)\n    return \"\";\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = capability[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\nfunction logAndValidateTokenAuthMethod(authOptions, logger) {\n  if (authOptions.authCallback) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authCallback\");\n  } else if (authOptions.authUrl) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authUrl\");\n  } else if (authOptions.key) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with client-side signing\");\n  } else if (authOptions.tokenDetails) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with supplied token only\");\n  } else {\n    const msg = \"authOptions must include valid authentication parameters\";\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n    throw new Error(msg);\n  }\n}\nfunction basicAuthForced(options) {\n  return \"useTokenAuth\" in options && !options.useTokenAuth;\n}\nfunction useTokenAuth(options) {\n  return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);\n}\nfunction noWayToRenew(options) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\nvar trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\nvar Auth = class {\n  constructor(client, options) {\n    // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n    this.authOptions = {};\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n    if (useTokenAuth(options)) {\n      if (noWayToRenew(options)) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"Auth()\",\n          \"Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams, options);\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    } else {\n      if (!options.key) {\n        const msg = \"No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth()\", \"anonymous, using basic auth\");\n      this._saveBasicOptions(options);\n    }\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async authorize(tokenParams, authOptions) {\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n      throw new ErrorInfo(\"Unable to update auth options with incompatible key\", 40102, 401);\n    }\n    try {\n      let tokenDetails = await this._forceNewToken(tokenParams != null ? tokenParams : null, authOptions != null ? authOptions : null);\n      if (isRealtime(this.client)) {\n        return new Promise((resolve, reject) => {\n          this.client.connection.connectionManager.onAuthUpdated(\n            tokenDetails,\n            (err, tokenDetails2) => err ? reject(err) : resolve(tokenDetails2)\n          );\n        });\n      } else {\n        return tokenDetails;\n      }\n    } catch (err) {\n      if (this.client.connection && err.statusCode === HttpStatusCodes_default.Forbidden) {\n        this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n      }\n      throw err;\n    }\n  }\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  async _forceNewToken(tokenParams, authOptions) {\n    this.tokenDetails = null;\n    this._saveTokenOptions(tokenParams, authOptions);\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    try {\n      return this._ensureValidAuthCredentials(true);\n    } finally {\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n    }\n  }\n  async requestToken(tokenParams, authOptions) {\n    const resolvedAuthOptions = authOptions || this.authOptions;\n    const resolvedTokenParams = tokenParams || copy(this.tokenParams);\n    let tokenRequestCallback, client = this.client;\n    if (resolvedAuthOptions.authCallback) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authCallback\");\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\n    } else if (resolvedAuthOptions.authUrl) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authUrl\");\n      tokenRequestCallback = (params, cb) => {\n        const authHeaders = mixin(\n          { accept: \"application/json, text/plain\" },\n          resolvedAuthOptions.authHeaders\n        );\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === \"post\";\n        let providedQsParams;\n        const queryIdx = resolvedAuthOptions.authUrl.indexOf(\"?\");\n        if (queryIdx > -1) {\n          providedQsParams = parseQueryString(resolvedAuthOptions.authUrl.slice(queryIdx));\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl.slice(0, queryIdx);\n          if (!usePost) {\n            resolvedAuthOptions.authParams = mixin(\n              providedQsParams,\n              resolvedAuthOptions.authParams\n            );\n          }\n        }\n        const authParams = mixin({}, resolvedAuthOptions.authParams || {}, params);\n        const authUrlRequestCallback = (result) => {\n          var _a2, _b;\n          let body = (_a2 = result.body) != null ? _a2 : null;\n          let contentType = null;\n          if (result.error) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received Error: \" + inspectError(result.error)\n            );\n          } else {\n            const contentTypeHeaderOrHeaders = (_b = result.headers[\"content-type\"]) != null ? _b : null;\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\n              contentType = contentTypeHeaderOrHeaders.join(\", \");\n            } else {\n              contentType = contentTypeHeaderOrHeaders;\n            }\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received; content-type: \" + contentType + \"; body: \" + inspectBody(body)\n            );\n          }\n          if (result.error) {\n            cb(result.error, null);\n            return;\n          }\n          if (result.unpacked) {\n            cb(null, body);\n            return;\n          }\n          if (Platform.BufferUtils.isBuffer(body))\n            body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo(\"authUrl response is missing a content-type header\", 40170, 401), null);\n            return;\n          }\n          const json = contentType.indexOf(\"application/json\") > -1, text = contentType.indexOf(\"text/plain\") > -1 || contentType.indexOf(\"application/jwt\") > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                \"authUrl responded with unacceptable content-type \" + contentType + \", should be either text/plain, application/jwt or application/json\",\n                40170,\n                401\n              ),\n              null\n            );\n            return;\n          }\n          if (json) {\n            if (body.length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo(\"authUrl response exceeded max permitted length\", 40170, 401), null);\n              return;\n            }\n            try {\n              body = JSON.parse(body);\n            } catch (e) {\n              cb(\n                new ErrorInfo(\n                  \"Unexpected error processing authURL response; err = \" + e.message,\n                  40170,\n                  401\n                ),\n                null\n              );\n              return;\n            }\n          }\n          cb(null, body, contentType);\n        };\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Auth.requestToken().tokenRequestCallback\",\n          \"Requesting token from \" + resolvedAuthOptions.authUrl + \"; Params: \" + JSON.stringify(authParams) + \"; method: \" + (usePost ? \"POST\" : \"GET\")\n        );\n        if (usePost) {\n          const headers = authHeaders || {};\n          headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n          const body = toQueryString(authParams).slice(1);\n          whenPromiseSettles(\n            this.client.http.doUri(\n              HttpMethods_default.Post,\n              resolvedAuthOptions.authUrl,\n              headers,\n              body,\n              providedQsParams\n            ),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        } else {\n          whenPromiseSettles(\n            this.client.http.doUri(HttpMethods_default.Get, resolvedAuthOptions.authUrl, authHeaders || {}, null, authParams),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        }\n      };\n    } else if (resolvedAuthOptions.key) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth.requestToken()\",\n        \"using token auth with client-side signing\"\n      );\n      tokenRequestCallback = (params, cb) => {\n        whenPromiseSettles(\n          this.createTokenRequest(params, resolvedAuthOptions),\n          (err, result) => cb(err, result != null ? result : null)\n        );\n      };\n    } else {\n      const msg = \"Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)\";\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Auth()\",\n        \"library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n      );\n      throw new ErrorInfo(msg, 40171, 403);\n    }\n    if (\"capability\" in resolvedTokenParams)\n      resolvedTokenParams.capability = c14n(\n        resolvedTokenParams.capability\n      );\n    const tokenRequest = (signedTokenParams, tokenCb) => {\n      const keyName = signedTokenParams.keyName, path = \"/keys/\" + keyName + \"/requestToken\", tokenUri = function(host) {\n        return client.baseUri(host) + path;\n      };\n      const requestHeaders = defaults_default.defaultPostHeaders(this.client.options, { format: \"json\" /* json */ });\n      if (resolvedAuthOptions.requestHeaders)\n        mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Auth.requestToken().requestToken\",\n        \"Sending POST to \" + path + \"; Token params: \" + JSON.stringify(signedTokenParams)\n      );\n      whenPromiseSettles(\n        this.client.http.do(HttpMethods_default.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\n        (err, result) => err ? tokenCb(err) : tokenCb(result.error, result.body, result.unpacked)\n      );\n    };\n    return new Promise((resolve, reject) => {\n      let tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(() => {\n        tokenRequestCallbackTimeoutExpired = true;\n        const msg = \"Token request callback timed out after \" + timeoutLength / 1e3 + \" seconds\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n        reject(new ErrorInfo(msg, 40170, 401));\n      }, timeoutLength);\n      tokenRequestCallback(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\n        if (tokenRequestCallbackTimeoutExpired)\n          return;\n        clearTimeout(tokenRequestCallbackTimeout);\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Auth.requestToken()\",\n            \"token request signing call returned error; err = \" + inspectError(err)\n          );\n          reject(normaliseAuthcallbackError(err));\n          return;\n        }\n        if (typeof tokenRequestOrDetails === \"string\") {\n          if (tokenRequestOrDetails.length === 0) {\n            reject(new ErrorInfo(\"Token string is empty\", 40170, 401));\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n            reject(\n              new ErrorInfo(\n                \"Token string exceeded max permitted length (was \" + tokenRequestOrDetails.length + \" bytes)\",\n                40170,\n                401\n              )\n            );\n          } else if (tokenRequestOrDetails === \"undefined\" || tokenRequestOrDetails === \"null\") {\n            reject(new ErrorInfo(\"Token string was literal null/undefined\", 40170, 401));\n          } else if (tokenRequestOrDetails[0] === \"{\" && !(contentType && contentType.indexOf(\"application/jwt\") > -1)) {\n            reject(\n              new ErrorInfo(\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n                40170,\n                401\n              )\n            );\n          } else {\n            resolve({ token: tokenRequestOrDetails });\n          }\n          return;\n        }\n        if (typeof tokenRequestOrDetails !== \"object\" || tokenRequestOrDetails === null) {\n          const msg = \"Expected token request callback to call back with a token string or token request/details object, but got a \" + typeof tokenRequestOrDetails;\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n          reject(\n            new ErrorInfo(\n              \"Token request/details object exceeded max permitted stringified size (was \" + objectSize + \" bytes)\",\n              40170,\n              401\n            )\n          );\n          return;\n        }\n        if (\"issued\" in tokenRequestOrDetails) {\n          resolve(tokenRequestOrDetails);\n          return;\n        }\n        if (!(\"keyName\" in tokenRequestOrDetails)) {\n          const msg = \"Expected token request callback to call back with a token string, token request object, or token details object\";\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        tokenRequest(tokenRequestOrDetails, (err2, tokenResponse, unpacked) => {\n          if (err2) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Auth.requestToken()\",\n              \"token request API call returned error; err = \" + inspectError(err2)\n            );\n            reject(normaliseAuthcallbackError(err2));\n            return;\n          }\n          if (!unpacked)\n            tokenResponse = JSON.parse(tokenResponse);\n          logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"token received\");\n          resolve(tokenResponse);\n        });\n      });\n    });\n  }\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async createTokenRequest(tokenParams, authOptions) {\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || copy(this.tokenParams);\n    const key = authOptions.key;\n    if (!key) {\n      throw new ErrorInfo(\"No key specified\", 40101, 403);\n    }\n    const keyParts = key.split(\":\"), keyName = keyParts[0], keySecret = keyParts[1];\n    if (!keySecret) {\n      throw new ErrorInfo(\"Invalid key specified\", 40101, 403);\n    }\n    if (tokenParams.clientId === \"\") {\n      throw new ErrorInfo(\"clientId can\\u2019t be an empty string\", 40012, 400);\n    }\n    if (\"capability\" in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n    const request = mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || \"\", ttl = tokenParams.ttl || \"\", capability = tokenParams.capability || \"\";\n    if (!request.timestamp) {\n      request.timestamp = await this._getTimestamp(authOptions && authOptions.queryTime);\n    }\n    const nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;\n    const signText = request.keyName + \"\\n\" + ttl + \"\\n\" + capability + \"\\n\" + clientId + \"\\n\" + timestamp + \"\\n\" + nonce + \"\\n\";\n    request.mac = request.mac || hmac(signText, keySecret);\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getTokenRequest()\", \"generated signed request\");\n    return request;\n  }\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  async getAuthParams() {\n    if (this.method == \"basic\")\n      return { key: this.key };\n    else {\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { access_token: tokenDetails.token };\n    }\n  }\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  async getAuthHeaders() {\n    if (this.method == \"basic\") {\n      return { authorization: \"Basic \" + this.basicKey };\n    } else {\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { authorization: \"Bearer \" + toBase64(tokenDetails.token) };\n    }\n  }\n  _saveBasicOptions(authOptions) {\n    this.method = \"basic\";\n    this.key = authOptions.key;\n    this.basicKey = toBase64(authOptions.key);\n    this.authOptions = authOptions || {};\n    if (\"clientId\" in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n  _saveTokenOptions(tokenParams, authOptions) {\n    this.method = \"token\";\n    if (tokenParams) {\n      this.tokenParams = tokenParams;\n    }\n    if (authOptions) {\n      if (authOptions.token) {\n        authOptions.tokenDetails = typeof authOptions.token === \"string\" ? { token: authOptions.token } : authOptions.token;\n      }\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n      if (\"clientId\" in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n      this.authOptions = authOptions;\n    }\n  }\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  async _ensureValidAuthCredentials(forceSupersede) {\n    const token = this.tokenDetails;\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        throw new ErrorInfo(\n          \"Mismatch between clientId in token (\" + token.clientId + \") and current clientId (\" + this.clientId + \")\",\n          40102,\n          403\n        );\n      }\n      if (!this.client.isTimeOffsetSet() || !token.expires || token.expires >= this.client.getTimestampUsingOffset()) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Auth.getToken()\",\n          \"using cached token; expires = \" + token.expires\n        );\n        return token;\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"deleting expired token\");\n      this.tokenDetails = null;\n    }\n    const promise = (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create(this.logger))).createPromise();\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return promise;\n    }\n    const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();\n    let tokenResponse, caughtError = null;\n    try {\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n    } catch (err) {\n      caughtError = err;\n    }\n    if (this.currentTokenRequestId > tokenRequestId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth._ensureValidAuthCredentials()\",\n        \"Discarding token request response; overtaken by newer one\"\n      );\n      return promise;\n    }\n    this.currentTokenRequestId = null;\n    const multicaster = this.waitingForTokenRequest;\n    this.waitingForTokenRequest = null;\n    if (caughtError) {\n      multicaster == null ? void 0 : multicaster.rejectAll(caughtError);\n      return promise;\n    }\n    multicaster == null ? void 0 : multicaster.resolveAll(this.tokenDetails = tokenResponse);\n    return promise;\n  }\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId) {\n    if (!(typeof clientId === \"string\" || clientId === null)) {\n      throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n    } else if (clientId === \"*\") {\n      throw new ErrorInfo(\n        'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err)\n        throw err;\n    }\n  }\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      const msg = \"Unexpected clientId mismatch: client has \" + this.clientId + \", requested \" + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth._uncheckedSetClientId()\", msg);\n      return err;\n    } else {\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n  _tokenClientIdMismatch(tokenClientId) {\n    return !!(this.clientId && this.clientId !== \"*\" && tokenClientId && tokenClientId !== \"*\" && this.clientId !== tokenClientId);\n  }\n  static isTokenErr(error) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n  revokeTokens(specifiers, options) {\n    return this.client.rest.revokeTokens(specifiers, options);\n  }\n  /**\n   * Same as {@link BaseClient.getTimestamp} but also takes into account {@link Auth.authOptions}\n   */\n  async _getTimestamp(queryTime) {\n    return this.client.getTimestamp(queryTime || !!this.authOptions.queryTime);\n  }\n};\nvar auth_default = Auth;\n\n// src/common/types/http.ts\nfunction paramString(params) {\n  const paramPairs = [];\n  if (params) {\n    for (const needle in params) {\n      paramPairs.push(needle + \"=\" + params[needle]);\n    }\n  }\n  return paramPairs.join(\"&\");\n}\nfunction appendingParams(uri, params) {\n  return uri + (params ? \"?\" : \"\") + paramString(params);\n}\nfunction logResult(result, method, uri, params, logger) {\n  if (result.error) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(uri, params) + \"; Error: \" + inspectError(result.error)\n    );\n  } else {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received; \" + appendingParams(uri, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body\" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + result.body)\n    );\n  }\n}\nfunction logRequest(method, uri, body, params, logger) {\n  if (logger.shouldLog(logger_default.LOG_MICRO)) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Sending; \" + appendingParams(uri, params) + \"; Body\" + (Platform.BufferUtils.isBuffer(body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(body) : \": \" + body)\n    );\n  }\n}\nvar Http = class {\n  constructor(client) {\n    this.client = client;\n    this.platformHttp = new Platform.Http(client);\n    this.checkConnectivity = this.platformHttp.checkConnectivity ? () => this.platformHttp.checkConnectivity() : void 0;\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  get supportsAuthHeaders() {\n    return this.platformHttp.supportsAuthHeaders;\n  }\n  get supportsLinkHeaders() {\n    return this.platformHttp.supportsLinkHeaders;\n  }\n  _getHosts(client) {\n    const connection = client.connection, connectionHost = connection && connection.connectionManager.host;\n    if (connectionHost) {\n      return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));\n    }\n    return defaults_default.getHosts(client.options);\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async do(method, path, headers, body, params) {\n    try {\n      const client = this.client;\n      if (!client) {\n        return { error: new ErrorInfo(\"http.do called without client\", 5e4, 500) };\n      }\n      const uriFromHost = typeof path === \"function\" ? path : function(host) {\n        return client.baseUri(host) + path;\n      };\n      const currentFallback = client._currentFallback;\n      if (currentFallback) {\n        if (currentFallback.validUntil > Date.now()) {\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\n          if (result.error && this.platformHttp.shouldFallback(result.error)) {\n            client._currentFallback = null;\n            return this.do(method, path, headers, body, params);\n          }\n          return result;\n        } else {\n          client._currentFallback = null;\n        }\n      }\n      const hosts = this._getHosts(client);\n      if (hosts.length === 1) {\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\n      }\n      let tryAHostStartedAt = null;\n      const tryAHost = async (candidateHosts, persistOnSuccess) => {\n        const host = candidateHosts.shift();\n        tryAHostStartedAt = tryAHostStartedAt != null ? tryAHostStartedAt : /* @__PURE__ */ new Date();\n        const result = await this.doUri(method, uriFromHost(host), headers, body, params);\n        if (result.error && this.platformHttp.shouldFallback(result.error) && candidateHosts.length) {\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\n            return {\n              error: new ErrorInfo(\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\n                50003,\n                500\n              )\n            };\n          }\n          return tryAHost(candidateHosts, true);\n        }\n        if (persistOnSuccess) {\n          client._currentFallback = {\n            host,\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout\n          };\n        }\n        return result;\n      };\n      return tryAHost(hosts);\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async doUri(method, uri, headers, body, params) {\n    try {\n      logRequest(method, uri, body, params, this.logger);\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\n      if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n        logResult(result, method, uri, params, this.logger);\n      }\n      return result;\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n};\n\n// src/common/lib/util/eventemitter.ts\nfunction callListener(logger, eventThis, listener, args) {\n  try {\n    listener.apply(eventThis, args);\n  } catch (e) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_ERROR,\n      \"EventEmitter.emit()\",\n      \"Unexpected listener exception: \" + e + \"; stack = \" + (e && e.stack)\n    );\n  }\n}\nfunction removeListener(targetListeners, listener, eventFilter) {\n  let listeners;\n  let index;\n  let eventName;\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n    listeners = targetListeners[targetListenersIndex];\n    if (eventFilter) {\n      listeners = listeners[eventFilter];\n    }\n    if (Array.isArray(listeners)) {\n      while ((index = listeners.indexOf(listener)) !== -1) {\n        listeners.splice(index, 1);\n      }\n      if (eventFilter && listeners.length === 0) {\n        delete targetListeners[targetListenersIndex][eventFilter];\n      }\n    } else if (isObject(listeners)) {\n      for (eventName in listeners) {\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\n          removeListener([listeners], listener, eventName);\n        }\n      }\n    }\n  }\n}\nvar EventEmitter = class {\n  constructor(logger) {\n    this.logger = logger;\n    this.any = [];\n    this.events = /* @__PURE__ */ Object.create(null);\n    this.anyOnce = [];\n    this.eventsOnce = /* @__PURE__ */ Object.create(null);\n  }\n  on(...args) {\n    if (args.length === 1) {\n      const listener = args[0];\n      if (typeof listener === \"function\") {\n        this.any.push(listener);\n      } else {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n    }\n    if (args.length === 2) {\n      const [event, listener] = args;\n      if (typeof listener !== \"function\") {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n      if (isNil(event)) {\n        this.any.push(listener);\n      } else if (Array.isArray(event)) {\n        event.forEach((eventName) => {\n          this.on(eventName, listener);\n        });\n      } else {\n        if (typeof event !== \"string\") {\n          throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n        }\n        const listeners = this.events[event] || (this.events[event] = []);\n        listeners.push(listener);\n      }\n    }\n  }\n  off(...args) {\n    if (args.length == 0 || isNil(args[0]) && isNil(args[1])) {\n      this.any = [];\n      this.events = /* @__PURE__ */ Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = /* @__PURE__ */ Object.create(null);\n      return;\n    }\n    const [firstArg, secondArg] = args;\n    let listener = null;\n    let event = null;\n    if (args.length === 1 || !secondArg) {\n      if (typeof firstArg === \"function\") {\n        listener = firstArg;\n      } else {\n        event = firstArg;\n      }\n    } else {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      [event, listener] = [firstArg, secondArg];\n    }\n    if (listener && isNil(event)) {\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n      return;\n    }\n    if (Array.isArray(event)) {\n      event.forEach((eventName) => {\n        this.off(eventName, listener);\n      });\n      return;\n    }\n    if (typeof event !== \"string\") {\n      throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n    }\n    if (listener) {\n      removeListener([this.events, this.eventsOnce], listener, event);\n    } else {\n      delete this.events[event];\n      delete this.eventsOnce[event];\n    }\n  }\n  /**\n   * Get the array of listeners for a given event; excludes once events\n   * @param event (optional) the name of the event, or none for 'any'\n   * @return array of events, or null if none\n   */\n  listeners(event) {\n    if (event) {\n      const listeners = this.events[event] || [];\n      if (this.eventsOnce[event])\n        Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n      return listeners.length ? listeners : null;\n    }\n    return this.any.length ? this.any : null;\n  }\n  /**\n   * Emit an event\n   * @param event the event name\n   * @param args the arguments to pass to the listener\n   */\n  emit(event, ...args) {\n    const eventThis = { event };\n    const listeners = [];\n    if (this.anyOnce.length) {\n      Array.prototype.push.apply(listeners, this.anyOnce);\n      this.anyOnce = [];\n    }\n    if (this.any.length) {\n      Array.prototype.push.apply(listeners, this.any);\n    }\n    const eventsOnceListeners = this.eventsOnce[event];\n    if (eventsOnceListeners) {\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\n      delete this.eventsOnce[event];\n    }\n    const eventsListeners = this.events[event];\n    if (eventsListeners) {\n      Array.prototype.push.apply(listeners, eventsListeners);\n    }\n    listeners.forEach((listener) => {\n      callListener(this.logger, eventThis, listener, args);\n    });\n  }\n  once(...args) {\n    const argCount = args.length;\n    if (argCount === 0 || argCount === 1 && typeof args[0] !== \"function\") {\n      const event = args[0];\n      return new Promise((resolve) => {\n        this.once(event, resolve);\n      });\n    }\n    const [firstArg, secondArg] = args;\n    if (args.length === 1 && typeof firstArg === \"function\") {\n      this.anyOnce.push(firstArg);\n    } else if (isNil(firstArg)) {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      this.anyOnce.push(secondArg);\n    } else if (Array.isArray(firstArg)) {\n      const self2 = this;\n      const listenerWrapper = function() {\n        const innerArgs = Array.prototype.slice.call(arguments);\n        firstArg.forEach(function(eventName) {\n          self2.off(eventName, listenerWrapper);\n        });\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        secondArg.apply(this, innerArgs);\n      };\n      firstArg.forEach(function(eventName) {\n        self2.on(eventName, listenerWrapper);\n      });\n    } else {\n      if (typeof firstArg !== \"string\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n      if (secondArg) {\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        listeners.push(secondArg);\n      }\n    }\n  }\n  /**\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n   * @param targetState the name of the state event to listen to\n   * @param currentState the name of the current state of this object\n   */\n  async whenState(targetState, currentState) {\n    if (typeof targetState !== \"string\" || typeof currentState !== \"string\") {\n      throw new Error(\"whenState requires a valid state String argument\");\n    }\n    if (targetState === currentState) {\n      return null;\n    } else {\n      return this.once(targetState);\n    }\n  }\n};\nvar eventemitter_default = EventEmitter;\n\n// src/common/lib/types/protocolmessagecommon.ts\nvar actions = {\n  HEARTBEAT: 0,\n  ACK: 1,\n  NACK: 2,\n  CONNECT: 3,\n  CONNECTED: 4,\n  DISCONNECT: 5,\n  DISCONNECTED: 6,\n  CLOSE: 7,\n  CLOSED: 8,\n  ERROR: 9,\n  ATTACH: 10,\n  ATTACHED: 11,\n  DETACH: 12,\n  DETACHED: 13,\n  PRESENCE: 14,\n  MESSAGE: 15,\n  SYNC: 16,\n  AUTH: 17,\n  ACTIVATE: 18,\n  OBJECT: 19,\n  OBJECT_SYNC: 20,\n  ANNOTATION: 21\n};\nvar ActionName = [];\nObject.keys(actions).forEach(function(name) {\n  ActionName[actions[name]] = name;\n});\nvar flags = {\n  /* Channel attach state flags */\n  HAS_PRESENCE: 1 << 0,\n  HAS_BACKLOG: 1 << 1,\n  RESUMED: 1 << 2,\n  TRANSIENT: 1 << 4,\n  ATTACH_RESUME: 1 << 5,\n  HAS_OBJECTS: 1 << 7,\n  /* Channel mode flags */\n  PRESENCE: 1 << 16,\n  PUBLISH: 1 << 17,\n  SUBSCRIBE: 1 << 18,\n  PRESENCE_SUBSCRIBE: 1 << 19,\n  ANNOTATION_PUBLISH: 1 << 21,\n  ANNOTATION_SUBSCRIBE: 1 << 22,\n  OBJECT_SUBSCRIBE: 1 << 24,\n  OBJECT_PUBLISH: 1 << 25\n};\nvar flagNames = Object.keys(flags);\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE | flags.ANNOTATION_PUBLISH | flags.ANNOTATION_SUBSCRIBE | flags.OBJECT_SUBSCRIBE | flags.OBJECT_PUBLISH;\nvar channelModes = [\n  \"PRESENCE\",\n  \"PUBLISH\",\n  \"SUBSCRIBE\",\n  \"PRESENCE_SUBSCRIBE\",\n  \"ANNOTATION_PUBLISH\",\n  \"ANNOTATION_SUBSCRIBE\",\n  \"OBJECT_SUBSCRIBE\",\n  \"OBJECT_PUBLISH\"\n];\n\n// src/common/lib/types/basemessage.ts\nfunction normaliseContext(context) {\n  if (!context || !context.channelOptions) {\n    return {\n      channelOptions: context,\n      plugins: {},\n      baseEncodedPreviousPayload: void 0\n    };\n  }\n  return context;\n}\nfunction normalizeCipherOptions(Crypto2, logger, options) {\n  if (options && options.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(options.cipher, logger);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher\n    };\n  }\n  return options != null ? options : {};\n}\nasync function encrypt(msg, cipherOptions) {\n  const { data, encoding } = await encryptData(msg.data, msg.encoding, cipherOptions);\n  msg.data = data;\n  msg.encoding = encoding;\n  return msg;\n}\nasync function encryptData(data, encoding, cipherOptions) {\n  let cipher = cipherOptions.channelCipher;\n  let dataToEncrypt = data;\n  let finalEncoding = encoding ? encoding + \"/\" : \"\";\n  if (!Platform.BufferUtils.isBuffer(dataToEncrypt)) {\n    dataToEncrypt = Platform.BufferUtils.utf8Encode(String(dataToEncrypt));\n    finalEncoding = finalEncoding + \"utf-8/\";\n  }\n  const ciphertext = await cipher.encrypt(dataToEncrypt);\n  finalEncoding = finalEncoding + \"cipher+\" + cipher.algorithm;\n  return {\n    data: ciphertext,\n    encoding: finalEncoding\n  };\n}\nasync function encode(msg, options) {\n  const { data, encoding } = encodeData(msg.data, msg.encoding);\n  msg.data = data;\n  msg.encoding = encoding;\n  if (options != null && options.cipher) {\n    return encrypt(msg, options);\n  } else {\n    return msg;\n  }\n}\nfunction encodeData(data, encoding) {\n  const nativeDataType = typeof data == \"string\" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;\n  if (nativeDataType) {\n    return {\n      data,\n      encoding\n    };\n  }\n  if (isObject(data) || Array.isArray(data)) {\n    return {\n      data: JSON.stringify(data),\n      encoding: encoding ? encoding + \"/json\" : \"json\"\n    };\n  }\n  throw new ErrorInfo(\"Data type is unsupported\", 40013, 400);\n}\nasync function decode(message, inputContext) {\n  const { data, encoding, error } = await decodeData(message.data, message.encoding, inputContext);\n  message.data = data;\n  message.encoding = encoding;\n  if (error) {\n    throw error;\n  }\n}\nasync function decodeData(data, encoding, inputContext) {\n  const context = normaliseContext(inputContext);\n  let lastPayload = data;\n  let decodedData = data;\n  let finalEncoding = encoding;\n  let decodingError;\n  if (encoding) {\n    const xforms = encoding.split(\"/\");\n    let lastProcessedEncodingIndex;\n    let encodingsToProcess = xforms.length;\n    let xform = \"\";\n    try {\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n        if (!match)\n          break;\n        xform = match[1];\n        switch (xform) {\n          case \"base64\":\n            decodedData = Platform.BufferUtils.base64Decode(String(decodedData));\n            if (lastProcessedEncodingIndex == xforms.length) {\n              lastPayload = decodedData;\n            }\n            continue;\n          case \"utf-8\":\n            decodedData = Platform.BufferUtils.utf8Decode(decodedData);\n            continue;\n          case \"json\":\n            decodedData = JSON.parse(decodedData);\n            continue;\n          case \"cipher\":\n            if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {\n              const xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;\n              if (xformAlgorithm != cipher.algorithm) {\n                throw new Error(\"Unable to decrypt message with given cipher; incompatible cipher params\");\n              }\n              decodedData = await cipher.decrypt(decodedData);\n              continue;\n            } else {\n              throw new Error(\"Unable to decrypt message; not an encrypted channel\");\n            }\n          case \"vcdiff\":\n            if (!context.plugins || !context.plugins.vcdiff) {\n              throw new ErrorInfo(\"Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)\", 40019, 400);\n            }\n            if (typeof Uint8Array === \"undefined\") {\n              throw new ErrorInfo(\n                \"Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)\",\n                40020,\n                400\n              );\n            }\n            try {\n              let deltaBase = context.baseEncodedPreviousPayload;\n              if (typeof deltaBase === \"string\") {\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n              }\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase);\n              decodedData = Platform.BufferUtils.toBuffer(decodedData);\n              decodedData = Platform.BufferUtils.arrayBufferViewToBuffer(\n                context.plugins.vcdiff.decode(decodedData, deltaBaseBuffer)\n              );\n              lastPayload = decodedData;\n            } catch (e) {\n              throw new ErrorInfo(\"Vcdiff delta decode failed with \" + e, 40018, 400);\n            }\n            continue;\n          default:\n            throw new Error(\"Unknown encoding\");\n        }\n      }\n    } catch (e) {\n      const err = e;\n      decodingError = new ErrorInfo(\n        `Error processing the ${xform} encoding, decoder returned \\u2018${err.message}\\u2019`,\n        err.code || 40013,\n        400\n      );\n    } finally {\n      finalEncoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join(\"/\");\n    }\n  }\n  if (decodingError) {\n    return {\n      error: decodingError,\n      data: decodedData,\n      encoding: finalEncoding\n    };\n  }\n  context.baseEncodedPreviousPayload = lastPayload;\n  return {\n    data: decodedData,\n    encoding: finalEncoding\n  };\n}\nfunction wireToJSON(...args) {\n  const format = args.length > 0 ? \"json\" /* json */ : \"msgpack\" /* msgpack */;\n  const { data, encoding } = encodeDataForWire(this.data, this.encoding, format);\n  return Object.assign({}, this, { encoding, data });\n}\nfunction encodeDataForWire(data, encoding, format) {\n  if (!data || !Platform.BufferUtils.isBuffer(data)) {\n    return {\n      data,\n      encoding\n    };\n  }\n  if (format === \"msgpack\" /* msgpack */) {\n    return {\n      data: Platform.BufferUtils.toBuffer(data),\n      encoding\n    };\n  }\n  return {\n    data: Platform.BufferUtils.base64Encode(data),\n    encoding: encoding ? encoding + \"/base64\" : \"base64\"\n  };\n}\nvar MessageEncoding = {\n  encryptData,\n  encodeData,\n  encodeDataForWire,\n  decodeData\n};\nfunction populateFieldsFromParent(parent) {\n  const { id, connectionId, timestamp } = parent;\n  let msgs;\n  switch (parent.action) {\n    case actions.MESSAGE: {\n      msgs = parent.messages;\n      break;\n    }\n    case actions.PRESENCE:\n    case actions.SYNC:\n      msgs = parent.presence;\n      break;\n    case actions.ANNOTATION:\n      msgs = parent.annotations;\n      break;\n    case actions.OBJECT:\n    case actions.OBJECT_SYNC:\n      msgs = parent.state;\n      break;\n    default:\n      throw new ErrorInfo(\"Unexpected action \" + parent.action, 4e4, 400);\n  }\n  for (let i = 0; i < msgs.length; i++) {\n    const msg = msgs[i];\n    if (!msg.connectionId) {\n      msg.connectionId = connectionId;\n    }\n    if (!msg.timestamp) {\n      msg.timestamp = timestamp;\n    }\n    if (id && !msg.id) {\n      msg.id = id + \":\" + i;\n    }\n  }\n}\nfunction strMsg(m, cls) {\n  let result = \"[\" + cls;\n  for (const attr in m) {\n    if (attr === \"data\") {\n      if (typeof m.data == \"string\") {\n        result += \"; data=\" + m.data;\n      } else if (Platform.BufferUtils.isBuffer(m.data)) {\n        result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(m.data);\n      } else if (typeof m.data !== \"undefined\") {\n        result += \"; data (json)=\" + JSON.stringify(m.data);\n      }\n    } else if (attr && (attr === \"extras\" || attr === \"operation\")) {\n      result += \"; \" + attr + \"=\" + JSON.stringify(m[attr]);\n    } else if (attr === \"version\") {\n      result += \"; version=\" + JSON.stringify(m[attr]);\n    } else if (attr === \"annotations\") {\n      result += \"; annotations=\" + JSON.stringify(m[attr]);\n    } else if (m[attr] !== void 0) {\n      result += \"; \" + attr + \"=\" + m[attr];\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar BaseMessage = class {\n};\n\n// src/common/lib/client/baseclient.ts\nvar BaseClient = class {\n  constructor(options) {\n    /**\n     * These exports are for use by UMD plugins; reason being so that constructors and static methods can be accessed by these plugins without needing to import the classes directly and result in the class existing in both the plugin and the core library.\n     */\n    this.Platform = Platform;\n    this.ErrorInfo = ErrorInfo;\n    this.Logger = logger_default;\n    this.Defaults = defaults_default;\n    this.Utils = utils_exports;\n    this.EventEmitter = eventemitter_default;\n    this.MessageEncoding = MessageEncoding;\n    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    this._additionalHTTPRequestImplementations = (_a2 = options.plugins) != null ? _a2 : null;\n    this.logger = new logger_default();\n    this.logger.setLog(options.logLevel, options.logHandler);\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"BaseClient()\",\n      \"initialized with clientOptions \" + Platform.Config.inspect(options)\n    );\n    this._MsgPack = (_c = (_b = options.plugins) == null ? void 0 : _b.MsgPack) != null ? _c : null;\n    const normalOptions = this.options = defaults_default.normaliseOptions(options, this._MsgPack, this.logger);\n    if (normalOptions.key) {\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n      if (!keyMatch) {\n        const msg = \"invalid key parameter\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"BaseClient()\", msg);\n        throw new ErrorInfo(msg, 40400, 404);\n      }\n      normalOptions.keyName = keyMatch[1];\n      normalOptions.keySecret = keyMatch[2];\n    }\n    if (\"clientId\" in normalOptions) {\n      if (!(typeof normalOptions.clientId === \"string\" || normalOptions.clientId === null))\n        throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n      else if (normalOptions.clientId === \"*\")\n        throw new ErrorInfo(\n          'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\n          40012,\n          400\n        );\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"BaseClient()\", \"started; version = \" + defaults_default.version);\n    this._currentFallback = null;\n    this.serverTimeOffset = null;\n    this.http = new Http(this);\n    this.auth = new auth_default(this, normalOptions);\n    this._rest = ((_d = options.plugins) == null ? void 0 : _d.Rest) ? new options.plugins.Rest(this) : null;\n    this._Crypto = (_f = (_e = options.plugins) == null ? void 0 : _e.Crypto) != null ? _f : null;\n    this.__FilteredSubscriptions = (_h = (_g = options.plugins) == null ? void 0 : _g.MessageInteractions) != null ? _h : null;\n    this._Annotations = (_j = (_i = options.plugins) == null ? void 0 : _i.Annotations) != null ? _j : null;\n  }\n  get rest() {\n    if (!this._rest) {\n      throwMissingPluginError(\"Rest\");\n    }\n    return this._rest;\n  }\n  get _FilteredSubscriptions() {\n    if (!this.__FilteredSubscriptions) {\n      throwMissingPluginError(\"MessageInteractions\");\n    }\n    return this.__FilteredSubscriptions;\n  }\n  get channels() {\n    return this.rest.channels;\n  }\n  get push() {\n    return this.rest.push;\n  }\n  /** RSH8 */\n  device() {\n    var _a2;\n    if (!((_a2 = this.options.plugins) == null ? void 0 : _a2.Push) || !this.push.LocalDevice) {\n      throwMissingPluginError(\"Push\");\n    }\n    if (!this._device) {\n      this._device = this.push.LocalDevice.load(this);\n    }\n    return this._device;\n  }\n  baseUri(host) {\n    return defaults_default.getHttpScheme(this.options) + host + \":\" + defaults_default.getPort(this.options, false);\n  }\n  async stats(params) {\n    return this.rest.stats(params);\n  }\n  async time(params) {\n    return this.rest.time(params);\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    return this.rest.request(method, path, version2, params, body, customHeaders);\n  }\n  batchPublish(specOrSpecs) {\n    return this.rest.batchPublish(specOrSpecs);\n  }\n  batchPresence(channels) {\n    return this.rest.batchPresence(channels);\n  }\n  setLog(logOptions) {\n    this.logger.setLog(logOptions.level, logOptions.handler);\n  }\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  async getTimestamp(queryTime) {\n    if (!this.isTimeOffsetSet() && queryTime) {\n      return this.time();\n    }\n    return this.getTimestampUsingOffset();\n  }\n  getTimestampUsingOffset() {\n    return Date.now() + (this.serverTimeOffset || 0);\n  }\n  isTimeOffsetSet() {\n    return this.serverTimeOffset !== null;\n  }\n};\nBaseClient.Platform = Platform;\nvar baseclient_default = BaseClient;\n\n// src/common/lib/types/devicedetails.ts\nvar DeviceDetails = class _DeviceDetails {\n  toJSON() {\n    var _a2, _b, _c;\n    return {\n      id: this.id,\n      deviceSecret: this.deviceSecret,\n      platform: this.platform,\n      formFactor: this.formFactor,\n      clientId: this.clientId,\n      metadata: this.metadata,\n      deviceIdentityToken: this.deviceIdentityToken,\n      push: {\n        recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,\n        state: (_b = this.push) == null ? void 0 : _b.state,\n        error: (_c = this.push) == null ? void 0 : _c.error\n      }\n    };\n  }\n  toString() {\n    var _a2, _b, _c, _d;\n    let result = \"[DeviceDetails\";\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.platform)\n      result += \"; platform=\" + this.platform;\n    if (this.formFactor)\n      result += \"; formFactor=\" + this.formFactor;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.metadata)\n      result += \"; metadata=\" + this.metadata;\n    if (this.deviceIdentityToken)\n      result += \"; deviceIdentityToken=\" + JSON.stringify(this.deviceIdentityToken);\n    if ((_a2 = this.push) == null ? void 0 : _a2.recipient)\n      result += \"; push.recipient=\" + JSON.stringify(this.push.recipient);\n    if ((_b = this.push) == null ? void 0 : _b.state)\n      result += \"; push.state=\" + this.push.state;\n    if ((_c = this.push) == null ? void 0 : _c.error)\n      result += \"; push.error=\" + JSON.stringify(this.push.error);\n    if ((_d = this.push) == null ? void 0 : _d.metadata)\n      result += \"; push.metadata=\" + this.push.metadata;\n    result += \"]\";\n    return result;\n  }\n  static toRequestBody(body, MsgPack, format) {\n    return encodeBody(body, MsgPack, format);\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _DeviceDetails.fromValuesArray(body);\n    } else {\n      return _DeviceDetails.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    values.error = values.error && ErrorInfo.fromValues(values.error);\n    return Object.assign(new _DeviceDetails(), values);\n  }\n  static fromLocalDevice(device) {\n    return Object.assign(new _DeviceDetails(), device);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _DeviceDetails.fromValues(values[i]);\n    return result;\n  }\n};\nvar devicedetails_default = DeviceDetails;\n\n// src/common/lib/client/resource.ts\nasync function withAuthDetails(client, headers, params, opCallback) {\n  if (client.http.supportsAuthHeaders) {\n    const authHeaders = await client.auth.getAuthHeaders();\n    return opCallback(mixin(authHeaders, headers), params);\n  } else {\n    const authParams = await client.auth.getAuthParams();\n    return opCallback(headers, mixin(authParams, params));\n  }\n}\nfunction unenvelope(result, MsgPack, format) {\n  if (result.err && !result.body) {\n    return { err: result.err };\n  }\n  if (result.statusCode === HttpStatusCodes_default.NoContent) {\n    return __spreadProps(__spreadValues({}, result), { body: [], unpacked: true });\n  }\n  let body = result.body;\n  if (!result.unpacked) {\n    try {\n      body = decodeBody(body, MsgPack, format);\n    } catch (e) {\n      if (isErrorInfoOrPartialErrorInfo(e)) {\n        return { err: e };\n      } else {\n        return { err: new PartialErrorInfo(inspectError(e), null) };\n      }\n    }\n  }\n  if (!body) {\n    return { err: new PartialErrorInfo(\"unenvelope(): Response body is missing\", null) };\n  }\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body;\n  if (wrappedStatusCode === void 0) {\n    return __spreadProps(__spreadValues({}, result), { body, unpacked: true });\n  }\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n    let wrappedErr = response && response.error || result.err;\n    if (!wrappedErr) {\n      wrappedErr = new Error(\"Error in unenveloping \" + body);\n      wrappedErr.statusCode = wrappedStatusCode;\n    }\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n  }\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n}\nfunction logResult2(result, method, path, params, logger) {\n  if (result.err) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(path, params) + \"; Error: \" + inspectError(result.err)\n    );\n  } else {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received; \" + appendingParams(path, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body: \" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + Platform.Config.inspect(result.body))\n    );\n  }\n}\nvar Resource = class _Resource {\n  static async get(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, throwError != null ? throwError : false);\n  }\n  static async delete(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, throwError);\n  }\n  static async post(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, throwError);\n  }\n  static async patch(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, throwError);\n  }\n  static async put(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, throwError);\n  }\n  static async do(method, client, path, body, headers, params, envelope, throwError) {\n    if (envelope) {\n      (params = params || {})[\"envelope\"] = envelope;\n    }\n    const logger = client.logger;\n    async function doRequest(headers2, params2) {\n      var _a2;\n      if (logger.shouldLog(logger_default.LOG_MICRO)) {\n        let decodedBody = body;\n        if (((_a2 = headers2[\"content-type\"]) == null ? void 0 : _a2.indexOf(\"msgpack\")) > 0) {\n          try {\n            if (!client._MsgPack) {\n              throwMissingPluginError(\"MsgPack\");\n            }\n            decodedBody = client._MsgPack.decode(body);\n          } catch (decodeErr) {\n            logger_default.logAction(\n              logger,\n              logger_default.LOG_MICRO,\n              \"Resource.\" + method + \"()\",\n              \"Sending MsgPack Decoding Error: \" + inspectError(decodeErr)\n            );\n          }\n        }\n        logger_default.logAction(\n          logger,\n          logger_default.LOG_MICRO,\n          \"Resource.\" + method + \"()\",\n          \"Sending; \" + appendingParams(path, params2) + \"; Body: \" + decodedBody\n        );\n      }\n      const httpResult = await client.http.do(method, path, headers2, body, params2);\n      if (httpResult.error && auth_default.isTokenErr(httpResult.error)) {\n        await client.auth.authorize(null, null);\n        return withAuthDetails(client, headers2, params2, doRequest);\n      }\n      return {\n        err: httpResult.error,\n        body: httpResult.body,\n        headers: httpResult.headers,\n        unpacked: httpResult.unpacked,\n        statusCode: httpResult.statusCode\n      };\n    }\n    let result = await withAuthDetails(client, headers, params, doRequest);\n    if (envelope) {\n      result = unenvelope(result, client._MsgPack, envelope);\n    }\n    if (logger.shouldLog(logger_default.LOG_MICRO)) {\n      logResult2(result, method, path, params, logger);\n    }\n    if (throwError) {\n      if (result.err) {\n        throw result.err;\n      } else {\n        const response = __spreadValues({}, result);\n        delete response.err;\n        return response;\n      }\n    }\n    return result;\n  }\n};\nvar resource_default = Resource;\n\n// src/common/lib/client/paginatedresource.ts\nfunction getRelParams(linkUrl) {\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n  return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);\n}\nfunction parseRelLinks(linkHeader) {\n  if (typeof linkHeader == \"string\")\n    linkHeader = linkHeader.split(\",\");\n  const relParams = {};\n  for (let i = 0; i < linkHeader.length; i++) {\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n    if (linkMatch) {\n      const params = getRelParams(linkMatch[1]);\n      if (params)\n        relParams[linkMatch[2]] = params;\n    }\n  }\n  return relParams;\n}\nfunction returnErrOnly(err, body, useHPR) {\n  return !(useHPR && (body || typeof err.code === \"number\"));\n}\nvar PaginatedResource = class {\n  constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {\n    this.client = client;\n    this.path = path;\n    this.headers = headers;\n    this.envelope = envelope != null ? envelope : null;\n    this.bodyHandler = bodyHandler;\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async get(params) {\n    const result = await resource_default.get(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async delete(params) {\n    const result = await resource_default.delete(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async post(params, body) {\n    const result = await resource_default.post(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async put(params, body) {\n    const result = await resource_default.put(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async patch(params, body) {\n    const result = await resource_default.patch(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async handlePage(result) {\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"PaginatedResource.handlePage()\",\n        \"Unexpected error getting resource: err = \" + inspectError(result.err)\n      );\n      throw result.err;\n    }\n    let items, linkHeader, relParams;\n    try {\n      items = result.statusCode == HttpStatusCodes_default.NoContent ? [] : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\n    } catch (e) {\n      throw result.err || e;\n    }\n    if (result.headers && (linkHeader = result.headers[\"Link\"] || result.headers[\"link\"])) {\n      relParams = parseRelLinks(linkHeader);\n    }\n    if (this.useHttpPaginatedResponse) {\n      return new HttpPaginatedResponse(\n        this,\n        items,\n        result.headers || {},\n        result.statusCode,\n        relParams,\n        result.err\n      );\n    } else {\n      return new PaginatedResult(this, items, relParams);\n    }\n  }\n};\nvar PaginatedResult = class {\n  constructor(resource, items, relParams) {\n    this.resource = resource;\n    this.items = items;\n    this._relParams = relParams;\n  }\n  async first() {\n    if (this.hasFirst()) {\n      return this.get(this._relParams.first);\n    }\n    throw new ErrorInfo(\"No link to the first page of results\", 40400, 404);\n  }\n  async current() {\n    if (this.hasCurrent()) {\n      return this.get(this._relParams.current);\n    }\n    throw new ErrorInfo(\"No link to the current page of results\", 40400, 404);\n  }\n  async next() {\n    if (this.hasNext()) {\n      return this.get(this._relParams.next);\n    }\n    return null;\n  }\n  hasFirst() {\n    return this._relParams != null && \"first\" in this._relParams;\n  }\n  hasCurrent() {\n    return this._relParams != null && \"current\" in this._relParams;\n  }\n  hasNext() {\n    return this._relParams != null && \"next\" in this._relParams;\n  }\n  isLast() {\n    return !this.hasNext();\n  }\n  /* We assume that only the initial request can be a POST, and that accessing\n   * the rest of a multipage set of results can always be done with GET */\n  async get(params) {\n    const res = this.resource;\n    const result = await resource_default.get(res.client, res.path, res.headers, params, res.envelope, false);\n    return res.handlePage(result);\n  }\n};\nvar HttpPaginatedResponse = class extends PaginatedResult {\n  constructor(resource, items, headers, statusCode, relParams, err) {\n    super(resource, items, relParams);\n    this.statusCode = statusCode;\n    this.success = statusCode < 300 && statusCode >= 200;\n    this.headers = headers;\n    this.errorCode = err && err.code;\n    this.errorMessage = err && err.message;\n  }\n  toJSON() {\n    return {\n      items: this.items,\n      statusCode: this.statusCode,\n      success: this.success,\n      headers: this.headers,\n      errorCode: this.errorCode,\n      errorMessage: this.errorMessage\n    };\n  }\n};\nvar paginatedresource_default = PaginatedResource;\n\n// src/common/lib/types/pushchannelsubscription.ts\nvar _PushChannelSubscription = class _PushChannelSubscription {\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    return {\n      channel: this.channel,\n      deviceId: this.deviceId,\n      clientId: this.clientId\n    };\n  }\n  toString() {\n    let result = \"[PushChannelSubscription\";\n    if (this.channel)\n      result += \"; channel=\" + this.channel;\n    if (this.deviceId)\n      result += \"; deviceId=\" + this.deviceId;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    result += \"]\";\n    return result;\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _PushChannelSubscription.fromValuesArray(body);\n    } else {\n      return _PushChannelSubscription.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    return Object.assign(new _PushChannelSubscription(), values);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _PushChannelSubscription.fromValues(values[i]);\n    return result;\n  }\n};\n_PushChannelSubscription.toRequestBody = encodeBody;\nvar PushChannelSubscription = _PushChannelSubscription;\nvar pushchannelsubscription_default = PushChannelSubscription;\n\n// src/common/lib/client/push.ts\nvar Push = class {\n  constructor(client) {\n    var _a2;\n    this.client = client;\n    this.admin = new Admin(client);\n    if (Platform.Config.push && ((_a2 = client.options.plugins) == null ? void 0 : _a2.Push)) {\n      this.stateMachine = new client.options.plugins.Push.ActivationStateMachine(client);\n      this.LocalDevice = client.options.plugins.Push.localDeviceFactory(devicedetails_default);\n    }\n  }\n  async activate(registerCallback, updateFailedCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.activatedCallback) {\n        reject(new ErrorInfo(\"Activation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.activatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.updateFailedCallback = updateFailedCallback;\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledActivate(this.stateMachine, registerCallback)\n      );\n    });\n  }\n  async deactivate(deregisterCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.deactivatedCallback) {\n        reject(new ErrorInfo(\"Deactivation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.deactivatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledDeactivate(this.stateMachine, deregisterCallback)\n      );\n    });\n  }\n};\nvar Admin = class {\n  constructor(client) {\n    this.client = client;\n    this.deviceRegistrations = new DeviceRegistrations(client);\n    this.channelSubscriptions = new ChannelSubscriptions(client);\n  }\n  async publish(recipient, payload) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    const body = mixin({ recipient }, payload);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    await resource_default.post(client, \"/push/publish\", requestBody, headers, params, null, true);\n  }\n};\nvar DeviceRegistrations = class {\n  constructor(client) {\n    this.client = client;\n  }\n  async save(device) {\n    const client = this.client;\n    const body = devicedetails_default.fromValues(device);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.put(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(device.id),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async get(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    const response = await resource_default.get(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      {},\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/deviceRegistrations\", headers, envelope, async function(body, headers2, unpacked) {\n      return devicedetails_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async remove(deviceIdOrDetails) {\n    const client = this.client, headers = defaults_default.defaultGetHeaders(client.options), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/deviceRegistrations\", headers, params, null, true);\n  }\n};\nvar ChannelSubscriptions = class _ChannelSubscriptions {\n  constructor(client) {\n    /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n    this.remove = _ChannelSubscriptions.prototype.removeWhere;\n    this.client = client;\n  }\n  async save(subscription) {\n    const client = this.client;\n    const body = pushchannelsubscription_default.fromValues(subscription);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.post(\n      client,\n      \"/push/channelSubscriptions\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return pushchannelsubscription_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/channelSubscriptions\", headers, envelope, async function(body, headers2, unpacked) {\n      return pushchannelsubscription_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/channelSubscriptions\", headers, params, null, true);\n  }\n  async listChannels(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    return new paginatedresource_default(client, \"/push/channels\", headers, envelope, async function(body, headers2, unpacked) {\n      const parsedBody = !unpacked && format ? decodeBody(body, client._MsgPack, format) : body;\n      for (let i = 0; i < parsedBody.length; i++) {\n        parsedBody[i] = String(parsedBody[i]);\n      }\n      return parsedBody;\n    }).get(params);\n  }\n};\nvar push_default = Push;\n\n// src/common/lib/types/presencemessage.ts\nvar actions2 = [\"absent\", \"present\", \"enter\", \"leave\", \"update\"];\nasync function fromEncoded(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wpm = WirePresenceMessage.fromValues(encoded);\n  return wpm.decode(options, logger);\n}\nasync function fromEncodedArray(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded(encoded, channel) {\n  return WirePresenceMessage.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded(encoded, channel);\n    })\n  );\n}\nvar PresenceMessage = class _PresenceMessage extends BaseMessage {\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n   * sent by the connection (usually means a leave event sent 15s after a\n   * disconnection). This is useful because synthesized messages cannot be\n   * compared for newness by id lexicographically - RTP2b1\n   */\n  isSynthesized() {\n    if (!this.id || !this.connectionId) {\n      return true;\n    }\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n  }\n  /* RTP2b2 */\n  parseId() {\n    if (!this.id)\n      throw new Error(\"parseId(): Presence message does not contain an id\");\n    const parts = this.id.split(\":\");\n    return {\n      connectionId: parts[0],\n      msgSerial: parseInt(parts[1], 10),\n      index: parseInt(parts[2], 10)\n    };\n  }\n  async encode(options) {\n    const res = Object.assign(new WirePresenceMessage(), this, {\n      action: actions2.indexOf(this.action || \"present\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _PresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _PresenceMessage.fromValues(v));\n  }\n  static fromData(data) {\n    if (data instanceof _PresenceMessage) {\n      return data;\n    }\n    return _PresenceMessage.fromValues({\n      data\n    });\n  }\n  toString() {\n    return strMsg(this, \"PresenceMessage\");\n  }\n};\nvar WirePresenceMessage = class _WirePresenceMessage extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WirePresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WirePresenceMessage.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new PresenceMessage(), __spreadProps(__spreadValues({}, this), {\n      action: actions2[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WirePresenceMessage.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WirePresenceMessage\");\n  }\n};\nvar presencemessage_default = PresenceMessage;\n\n// src/common/lib/client/restpresence.ts\nvar RestPresence = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  get logger() {\n    return this.channel.logger;\n  }\n  async get(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.get()\", \"channel = \" + this.channel.name);\n    const client = this.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.channel.client.rest.presenceMixin.basePath(this),\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, this.channel);\n      }\n    ).get(params);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.history()\", \"channel = \" + this.channel.name);\n    return this.channel.client.rest.presenceMixin.history(this, params);\n  }\n};\nvar restpresence_default = RestPresence;\n\n// src/common/lib/types/message.ts\nvar actions3 = [\n  \"message.create\",\n  \"message.update\",\n  \"message.delete\",\n  \"meta\",\n  \"message.summary\",\n  \"message.append\"\n];\nfunction stringifyAction(action) {\n  return actions3[action || 0] || \"unknown\";\n}\nfunction getMessageSize(msg) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += dataSizeBytes(msg.data);\n  }\n  return size;\n}\nasync function fromEncoded2(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(options, logger);\n}\nasync function fromEncodedArray2(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded2(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded2(encoded, channel) {\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray2(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded2(encoded, channel);\n    })\n  );\n}\nasync function encodeArray(messages, options) {\n  return Promise.all(messages.map((message) => message.encode(options)));\n}\nvar serialize = encodeBody;\nfunction getMessagesSize(messages) {\n  let msg, total = 0;\n  for (let i = 0; i < messages.length; i++) {\n    msg = messages[i];\n    total += msg.size || (msg.size = getMessageSize(msg));\n  }\n  return total;\n}\nvar Message = class _Message extends BaseMessage {\n  expandFields() {\n    if (!this.version) {\n      this.version = {};\n    }\n    if (!this.version.serial && this.serial) {\n      this.version.serial = this.serial;\n    }\n    if (!this.version.timestamp && this.timestamp) {\n      this.version.timestamp = this.timestamp;\n    }\n    if (!this.annotations) {\n      this.annotations = {\n        summary: {}\n      };\n    } else if (!this.annotations.summary) {\n      this.annotations.summary = {};\n    }\n    if (this.annotations && this.annotations.summary) {\n      for (const [type, summaryEntry] of Object.entries(this.annotations.summary)) {\n        if (type.endsWith(\":distinct.v1\") || type.endsWith(\":unique.v1\") || type.endsWith(\":multiple.v1\")) {\n          for (const [, entry] of Object.entries(summaryEntry)) {\n            if (!entry.clipped) {\n              entry.clipped = false;\n            }\n          }\n        } else if (type.endsWith(\":flag.v1\")) {\n          if (!summaryEntry.clipped) {\n            summaryEntry.clipped = false;\n          }\n        }\n      }\n    }\n  }\n  async encode(options) {\n    const res = Object.assign(new WireMessage(), this, {\n      action: actions3.indexOf(this.action || \"message.create\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _Message(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Message.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Message\");\n  }\n};\nvar WireMessage = class _WireMessage extends BaseMessage {\n  // Overload toJSON() to intercept JSON.stringify()\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireMessage.fromValues(v));\n  }\n  // for contexts where some decoding errors need to be handled specially by the caller\n  async decodeWithErr(inputContext, logger) {\n    const res = Object.assign(new Message(), __spreadProps(__spreadValues({}, this), {\n      action: stringifyAction(this.action)\n    }));\n    let err;\n    try {\n      await decode(res, inputContext);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireMessage.decode()\", inspectError(e));\n      err = e;\n    }\n    res.expandFields();\n    return { decoded: res, err };\n  }\n  async decode(inputContext, logger) {\n    const { decoded } = await this.decodeWithErr(inputContext, logger);\n    return decoded;\n  }\n  toString() {\n    return strMsg(this, \"WireMessage\");\n  }\n};\nvar message_default = Message;\n\n// src/common/lib/client/restchannel.ts\nvar MSG_ID_ENTROPY_BYTES = 9;\nfunction allEmptyIds(messages) {\n  return messages.every(function(message) {\n    return !message.id;\n  });\n}\nvar RestChannel = class {\n  constructor(client, name, channelOptions) {\n    this._annotations = null;\n    var _a2, _b;\n    logger_default.logAction(client.logger, logger_default.LOG_MINOR, \"RestChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.client = client;\n    this.presence = new restpresence_default(this);\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, channelOptions);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RestAnnotations(this);\n    }\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  setOptions(options) {\n    var _a2;\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.history()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.history(this, params);\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null) {\n      messages = [message_default.fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [message_default.fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = message_default.fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    if (!params) {\n      params = {};\n    }\n    const client = this.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, idempotentRestPublishing = client.options.idempotentRestPublishing, headers = defaults_default.defaultPostHeaders(client.options);\n    mixin(headers, options.headers);\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\n      const msgIdBase = await randomString(MSG_ID_ENTROPY_BYTES);\n      messages.forEach(function(message, index) {\n        message.id = msgIdBase + \":\" + index.toString();\n      });\n    }\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages), maxMessageSize = options.maxMessageSize;\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        `Maximum size of messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400\n      );\n    }\n    return this._publish(serialize(wireMessages, client._MsgPack, format), headers, params);\n  }\n  async _publish(requestBody, headers, params) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const { body, unpacked } = await resource_default.post(\n      client,\n      client.rest.channelMixin.basePath(this) + \"/messages\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    const decoded = (unpacked ? body : decodeBody(body, client._MsgPack, format)) || {};\n    delete decoded[\"channel\"];\n    delete decoded[\"messageId\"];\n    return decoded;\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n  async getMessage(serialOrMessage) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.getMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.getMessage(this, serialOrMessage);\n  }\n  async updateMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.updateMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.updateDeleteMessage(this, \"message.update\", message, operation, params);\n  }\n  async deleteMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.deleteMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.updateDeleteMessage(this, \"message.delete\", message, operation, params);\n  }\n  async appendMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.appendMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.updateDeleteMessage(this, \"message.append\", message, operation, params);\n  }\n  async getMessageVersions(serialOrMessage, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.getMessageVersions()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.getMessageVersions(this, serialOrMessage, params);\n  }\n};\nvar restchannel_default = RestChannel;\n\n// src/common/lib/types/stats.ts\nvar Stats = class _Stats {\n  constructor(values) {\n    this.entries = values && values.entries || void 0;\n    this.schema = values && values.schema || void 0;\n    this.appId = values && values.appId || void 0;\n    this.inProgress = values && values.inProgress || void 0;\n    this.unit = values && values.unit || void 0;\n    this.intervalId = values && values.intervalId || void 0;\n  }\n  static fromValues(values) {\n    return new _Stats(values);\n  }\n};\nvar stats_default = Stats;\n\n// src/common/lib/client/restchannelmixin.ts\nvar RestChannelMixin = class {\n  static basePath(channel) {\n    return \"/channels/\" + encodeURIComponent(channel.name);\n  }\n  static history(channel, params) {\n    const client = channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, this.basePath(channel) + \"/messages\", headers, envelope, async function(body, headers2, unpacked) {\n      const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n      return _fromEncodedArray2(decoded, channel);\n    }).get(params);\n  }\n  static async status(channel) {\n    const format = channel.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(channel.client.options);\n    const response = await resource_default.get(\n      channel.client,\n      this.basePath(channel),\n      headers,\n      {},\n      format,\n      true\n    );\n    return response.body;\n  }\n  static async getMessage(channel, serialOrMessage) {\n    const serial = typeof serialOrMessage === \"string\" ? serialOrMessage : serialOrMessage.serial;\n    if (!serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    const client = channel.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    const { body, unpacked } = await resource_default.get(\n      client,\n      this.basePath(channel) + \"/messages/\" + encodeURIComponent(serial),\n      headers,\n      {},\n      null,\n      true\n    );\n    const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n    return _fromEncoded2(decoded, channel);\n  }\n  static async updateDeleteMessage(channel, action, message, operation, params) {\n    if (!message.serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial and cannot be updated. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    const client = channel.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(client.options);\n    mixin(headers, client.options.headers);\n    const requestMessage = message_default.fromValues(message);\n    requestMessage.action = action;\n    requestMessage.version = operation;\n    const encoded = await requestMessage.encode(channel.channelOptions);\n    const requestBody = serialize(encoded, client._MsgPack, format);\n    let method = resource_default.patch;\n    const { body, unpacked } = await method(\n      client,\n      this.basePath(channel) + \"/messages/\" + encodeURIComponent(message.serial),\n      requestBody,\n      headers,\n      params || {},\n      null,\n      true\n    );\n    const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n    return decoded || { versionSerial: null };\n  }\n  static getMessageVersions(channel, serialOrMessage, params) {\n    const serial = typeof serialOrMessage === \"string\" ? serialOrMessage : serialOrMessage.serial;\n    if (!serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    const client = channel.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const envelope = channel.client.http.supportsLinkHeaders ? void 0 : format;\n    const headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.basePath(channel) + \"/messages/\" + encodeURIComponent(serial) + \"/versions\",\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray2(decoded, channel);\n      }\n    ).get(params || {});\n  }\n};\n\n// src/common/lib/client/restpresencemixin.ts\nvar RestPresenceMixin = class {\n  static basePath(presence) {\n    return RestChannelMixin.basePath(presence.channel) + \"/presence\";\n  }\n  static async history(presence, params) {\n    const client = presence.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = presence.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.basePath(presence) + \"/history\",\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, presence.channel);\n      }\n    ).get(params);\n  }\n};\n\n// src/common/lib/client/rest.ts\nvar Rest = class {\n  constructor(client) {\n    this.channelMixin = RestChannelMixin;\n    this.presenceMixin = RestPresenceMixin;\n    // exposed for plugins but shouldn't be bundled with minimal realtime\n    this.Resource = resource_default;\n    this.PaginatedResource = paginatedresource_default;\n    this.DeviceDetails = devicedetails_default;\n    this.PushChannelSubscription = pushchannelsubscription_default;\n    this.client = client;\n    this.channels = new Channels(this.client);\n    this.push = new push_default(this.client);\n  }\n  async stats(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options), format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    mixin(headers, this.client.options.headers);\n    return new paginatedresource_default(this.client, \"/stats\", headers, envelope, async (body, _, unpacked) => {\n      const statsValues = unpacked ? body : decodeBody(body, this.client._MsgPack, format);\n      for (let i = 0; i < statsValues.length; i++)\n        statsValues[i] = stats_default.fromValues(statsValues[i]);\n      return statsValues;\n    }).get(params);\n  }\n  async time(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options, { format: \"json\" /* json */ });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const timeUri = (host) => {\n      return this.client.baseUri(host) + \"/time\";\n    };\n    let { error, body, unpacked } = await this.client.http.do(\n      HttpMethods_default.Get,\n      timeUri,\n      headers,\n      null,\n      params\n    );\n    if (error) {\n      throw error;\n    }\n    if (!unpacked)\n      body = JSON.parse(body);\n    const time = body[0];\n    if (!time) {\n      throw new ErrorInfo(\"Internal error (unexpected result type from GET /time)\", 5e4, 500);\n    }\n    this.client.serverTimeOffset = time - Date.now();\n    return time;\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    var _a2;\n    const [encoder, decoder, format] = (() => {\n      if (this.client.options.useBinaryProtocol) {\n        if (!this.client._MsgPack) {\n          throwMissingPluginError(\"MsgPack\");\n        }\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, \"msgpack\" /* msgpack */];\n      } else {\n        return [JSON.stringify, JSON.parse, \"json\" /* json */];\n      }\n    })();\n    const envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    params = params || {};\n    const _method = method.toLowerCase();\n    const headers = _method == \"get\" ? defaults_default.defaultGetHeaders(this.client.options, { format, protocolVersion: version2 }) : defaults_default.defaultPostHeaders(this.client.options, { format, protocolVersion: version2 });\n    if (typeof body !== \"string\") {\n      body = (_a2 = encoder(body)) != null ? _a2 : null;\n    }\n    mixin(headers, this.client.options.headers);\n    if (customHeaders) {\n      mixin(headers, customHeaders);\n    }\n    const paginatedResource = new paginatedresource_default(\n      this.client,\n      path,\n      headers,\n      envelope,\n      async function(resbody, headers2, unpacked) {\n        return ensureArray(unpacked ? resbody : decoder(resbody));\n      },\n      /* useHttpPaginatedResponse: */\n      true\n    );\n    if (!Platform.Http.methods.includes(_method)) {\n      throw new ErrorInfo(\"Unsupported method \" + _method, 40500, 405);\n    }\n    if (Platform.Http.methodsWithBody.includes(_method)) {\n      return paginatedResource[_method](params, body);\n    } else {\n      return paginatedResource[_method](params);\n    }\n  }\n  async batchPublish(specOrSpecs) {\n    let requestBodyDTO;\n    let singleSpecMode;\n    if (Array.isArray(specOrSpecs)) {\n      requestBodyDTO = specOrSpecs;\n      singleSpecMode = false;\n    } else {\n      requestBodyDTO = [specOrSpecs];\n      singleSpecMode = true;\n    }\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(this.client, \"/messages\", requestBody, headers, {}, null, true);\n    const batchResults = response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n    if (singleSpecMode) {\n      return batchResults[0];\n    } else {\n      return batchResults;\n    }\n  }\n  async batchPresence(channels) {\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const channelsParam = channels.join(\",\");\n    const response = await resource_default.get(this.client, \"/presence\", headers, { channels: channelsParam }, null, true);\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n  async revokeTokens(specifiers, options) {\n    if (useTokenAuth(this.client.options)) {\n      throw new ErrorInfo(\"Cannot revoke tokens when using token auth\", 40162, 401);\n    }\n    const keyName = this.client.options.keyName;\n    let resolvedOptions = options != null ? options : {};\n    const requestBodyDTO = __spreadValues({\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`)\n    }, resolvedOptions);\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(\n      this.client,\n      `/keys/${keyName}/revokeTokens`,\n      requestBody,\n      headers,\n      {},\n      null,\n      true\n    );\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n};\nvar Channels = class {\n  constructor(client) {\n    this.client = client;\n    this.all = /* @__PURE__ */ Object.create(null);\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      this.all[name] = channel = new restchannel_default(this.client, name, channelOptions);\n    } else if (channelOptions) {\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    delete this.all[String(name)];\n  }\n};\n\n// src/common/lib/client/baserest.ts\nvar BaseRest = class extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    super(defaults_default.objectifyOptions(options, false, \"BaseRest\", logger_default.defaultLogger, { Rest }));\n  }\n};\n\n// src/common/lib/client/modularplugins.ts\nvar allCommonModularPlugins = { Rest };\n\n// src/common/lib/types/defaultmessage.ts\nvar DefaultMessage = class extends message_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded2(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray2(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return message_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/defaultpresencemessage.ts\nvar DefaultPresenceMessage = class extends presencemessage_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return presencemessage_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/annotation.ts\nvar actions4 = [\"annotation.create\", \"annotation.delete\"];\nasync function fromEncoded3(logger, encoded, options) {\n  const wa = WireAnnotation.fromValues(encoded);\n  return wa.decode(options || {}, logger);\n}\nasync function fromEncodedArray3(logger, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded3(logger, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded3(encoded, channel) {\n  return WireAnnotation.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray3(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded3(encoded, channel);\n    })\n  );\n}\nvar Annotation = class _Annotation extends BaseMessage {\n  async encode() {\n    const res = Object.assign(new WireAnnotation(), this, {\n      action: actions4.indexOf(this.action || \"annotation.create\")\n    });\n    return encode(res, {});\n  }\n  static fromValues(values) {\n    return Object.assign(new _Annotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Annotation.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Annotation\");\n  }\n};\nvar WireAnnotation = class _WireAnnotation extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireAnnotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireAnnotation.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new Annotation(), __spreadProps(__spreadValues({}, this), {\n      action: actions4[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireAnnotation.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WireAnnotation\");\n  }\n};\nvar annotation_default = Annotation;\n\n// src/common/lib/types/defaultannotation.ts\nvar DefaultAnnotation = class extends annotation_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded3(logger_default.defaultLogger, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray3(logger_default.defaultLogger, encodedArray, options);\n  }\n  static fromValues(values) {\n    return annotation_default.fromValues(values);\n  }\n};\n\n// src/common/lib/client/restannotations.ts\nfunction serialFromMsgOrSerial(msgOrSerial) {\n  let messageSerial;\n  switch (typeof msgOrSerial) {\n    case \"string\":\n      messageSerial = msgOrSerial;\n      break;\n    case \"object\":\n      messageSerial = msgOrSerial.serial;\n      break;\n  }\n  if (!messageSerial || typeof messageSerial !== \"string\") {\n    throw new ErrorInfo(\n      \"First argument of annotations.publish() must be either a Message (or at least an object with a string `serial` property) or a message serial (string)\",\n      40003,\n      400\n    );\n  }\n  return messageSerial;\n}\nfunction constructValidateAnnotation(msgOrSerial, annotationValues) {\n  const messageSerial = serialFromMsgOrSerial(msgOrSerial);\n  if (!annotationValues || typeof annotationValues !== \"object\") {\n    throw new ErrorInfo(\n      \"Second argument of annotations.publish() must be an object (the intended annotation to publish)\",\n      40003,\n      400\n    );\n  }\n  const annotation = annotation_default.fromValues(annotationValues);\n  annotation.messageSerial = messageSerial;\n  if (!annotation.action) {\n    annotation.action = \"annotation.create\";\n  }\n  return annotation;\n}\nfunction basePathForSerial(channel, serial) {\n  return channel.client.rest.channelMixin.basePath(channel) + \"/messages/\" + encodeURIComponent(serial) + \"/annotations\";\n}\nvar RestAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    const client = this.channel.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    mixin(headers, client.options.headers);\n    const requestBody = encodeBody([wireAnnotation], client._MsgPack, format);\n    await resource_default.post(\n      client,\n      basePathForSerial(this.channel, annotation.messageSerial),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    return this.publish(msgOrSerial, annotationValues);\n  }\n  async get(msgOrSerial, params) {\n    const client = this.channel.client, messageSerial = serialFromMsgOrSerial(msgOrSerial), format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      basePathForSerial(this.channel, messageSerial),\n      headers,\n      envelope,\n      async (body, _, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray3(decoded, this.channel);\n      }\n    ).get(params);\n  }\n};\nvar restannotations_default = RestAnnotations;\n\n// src/common/lib/types/protocolmessage.ts\nvar serialize2 = encodeBody;\nfunction toStringArray(array) {\n  const result = [];\n  if (array) {\n    for (let i = 0; i < array.length; i++) {\n      result.push(array[i].toString());\n    }\n  }\n  return \"[ \" + result.join(\", \") + \" ]\";\n}\nfunction deserialize(serialized, MsgPack, presenceMessagePlugin, annotationsPlugin, objectsPlugin, format) {\n  const deserialized = decodeBody(serialized, MsgPack, format);\n  return fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin, objectsPlugin);\n}\nfunction fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin, objectsPlugin) {\n  let error;\n  if (deserialized.error) {\n    error = ErrorInfo.fromValues(deserialized.error);\n  }\n  let messages;\n  if (deserialized.messages) {\n    messages = WireMessage.fromValuesArray(deserialized.messages);\n  }\n  let presence;\n  if (presenceMessagePlugin && deserialized.presence) {\n    presence = presenceMessagePlugin.WirePresenceMessage.fromValuesArray(\n      deserialized.presence\n    );\n  }\n  let annotations;\n  if (annotationsPlugin && deserialized.annotations) {\n    annotations = annotationsPlugin.WireAnnotation.fromValuesArray(\n      deserialized.annotations\n    );\n  }\n  let state;\n  if (objectsPlugin && deserialized.state) {\n    state = objectsPlugin.WireObjectMessage.fromValuesArray(\n      deserialized.state,\n      utils_exports,\n      MessageEncoding\n    );\n  }\n  return Object.assign(new ProtocolMessage(), __spreadProps(__spreadValues({}, deserialized), { presence, messages, annotations, state, error }));\n}\nfunction makeFromDeserializedWithDependencies(dependencies) {\n  return (deserialized) => {\n    var _a2;\n    return fromDeserialized(\n      deserialized,\n      {\n        PresenceMessage: presencemessage_default,\n        WirePresenceMessage\n      },\n      { Annotation: annotation_default, WireAnnotation, RealtimeAnnotations: realtimeannotations_default, RestAnnotations: restannotations_default },\n      (_a2 = dependencies == null ? void 0 : dependencies.LiveObjectsPlugin) != null ? _a2 : null\n    );\n  };\n}\nfunction fromValues(values) {\n  return Object.assign(new ProtocolMessage(), values);\n}\nfunction stringify(msg, presenceMessagePlugin, annotationsPlugin, objectsPlugin) {\n  let result = \"[ProtocolMessage\";\n  if (msg.action !== void 0)\n    result += \"; action=\" + ActionName[msg.action] || 0;\n  const simpleAttributes = [\"id\", \"channel\", \"channelSerial\", \"connectionId\", \"count\", \"msgSerial\", \"timestamp\"];\n  let attribute;\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n    attribute = simpleAttributes[attribIndex];\n    if (msg[attribute] !== void 0)\n      result += \"; \" + attribute + \"=\" + msg[attribute];\n  }\n  if (msg.messages)\n    result += \"; messages=\" + toStringArray(WireMessage.fromValuesArray(msg.messages));\n  if (msg.presence && presenceMessagePlugin)\n    result += \"; presence=\" + toStringArray(presenceMessagePlugin.WirePresenceMessage.fromValuesArray(msg.presence));\n  if (msg.annotations && annotationsPlugin) {\n    result += \"; annotations=\" + toStringArray(annotationsPlugin.WireAnnotation.fromValuesArray(msg.annotations));\n  }\n  if (msg.state && objectsPlugin) {\n    result += \"; state=\" + toStringArray(objectsPlugin.WireObjectMessage.fromValuesArray(msg.state, utils_exports, MessageEncoding));\n  }\n  if (msg.error)\n    result += \"; error=\" + ErrorInfo.fromValues(msg.error).toString();\n  if (msg.auth && msg.auth.accessToken)\n    result += \"; token=\" + msg.auth.accessToken;\n  if (msg.flags)\n    result += \"; flags=\" + flagNames.filter(msg.hasFlag).join(\",\");\n  if (msg.params) {\n    let stringifiedParams = \"\";\n    forInOwnNonNullProperties(msg.params, function(prop) {\n      if (stringifiedParams.length > 0) {\n        stringifiedParams += \"; \";\n      }\n      stringifiedParams += prop + \"=\" + msg.params[prop];\n    });\n    if (stringifiedParams.length > 0) {\n      result += \"; params=[\" + stringifiedParams + \"]\";\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar ProtocolMessage = class {\n  constructor() {\n    this.hasFlag = (flag) => {\n      return (this.flags & flags[flag]) > 0;\n    };\n  }\n  setFlag(flag) {\n    return this.flags = this.flags | flags[flag];\n  }\n  getMode() {\n    return (this.flags || 0) & flags.MODE_ALL;\n  }\n  encodeModesToFlags(modes) {\n    modes.forEach((mode) => this.setFlag(mode));\n  }\n  decodeModesFromFlags() {\n    const modes = [];\n    channelModes.forEach((mode) => {\n      if (this.hasFlag(mode)) {\n        modes.push(mode);\n      }\n    });\n    return modes.length > 0 ? modes : void 0;\n  }\n};\nvar protocolmessage_default = ProtocolMessage;\n\n// src/common/lib/client/channelstatechange.ts\nvar ChannelStateChange = class {\n  constructor(previous, current, resumed, hasBacklog, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (current === \"attached\") {\n      this.resumed = resumed;\n      this.hasBacklog = hasBacklog;\n    }\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar channelstatechange_default = ChannelStateChange;\n\n// src/common/lib/client/realtimechannel.ts\nvar noop = function() {\n};\nfunction validateChannelOptions(options) {\n  if (options && \"params\" in options && !isObject(options.params)) {\n    return new ErrorInfo(\"options.params must be an object\", 4e4, 400);\n  }\n  if (options && \"modes\" in options) {\n    if (!Array.isArray(options.modes)) {\n      return new ErrorInfo(\"options.modes must be an array\", 4e4, 400);\n    }\n    for (let i = 0; i < options.modes.length; i++) {\n      const currentMode = options.modes[i];\n      if (!currentMode || typeof currentMode !== \"string\" || !channelModes.includes(String.prototype.toUpperCase.call(currentMode))) {\n        return new ErrorInfo(\"Invalid channel mode: \" + currentMode, 4e4, 400);\n      }\n    }\n  }\n}\nvar RealtimeChannel = class _RealtimeChannel extends eventemitter_default {\n  constructor(client, name, options) {\n    var _a2, _b, _c;\n    super(client.logger);\n    this._annotations = null;\n    this._mode = 0;\n    this.retryCount = 0;\n    this.history = async function(params) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.history()\", \"channel = \" + this.name);\n      const restMixin = this.client.rest.channelMixin;\n      if (params && params.untilAttach) {\n        if (this.state !== \"attached\") {\n          throw new ErrorInfo(\"option untilAttach requires the channel to be attached\", 4e4, 400);\n        }\n        if (!this.properties.attachSerial) {\n          throw new ErrorInfo(\n            \"untilAttach was specified and channel is attached, but attachSerial is not defined\",\n            4e4,\n            400\n          );\n        }\n        delete params.untilAttach;\n        params.from_serial = this.properties.attachSerial;\n      }\n      return restMixin.history(this, params);\n    };\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, options);\n    this.client = client;\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RealtimeAnnotations(this);\n    }\n    this.connectionManager = client.connection.connectionManager;\n    this.state = \"initialized\";\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.syncChannelSerial = void 0;\n    this.properties = {\n      attachSerial: void 0,\n      channelSerial: void 0\n    };\n    this.setOptions(options);\n    this.errorReason = null;\n    this._attachResume = false;\n    this._decodingContext = {\n      channelOptions: this.channelOptions,\n      plugins: client.options.plugins || {},\n      baseEncodedPreviousPayload: void 0\n    };\n    this._lastPayload = {\n      messageId: null,\n      protocolMessageChannelSerial: null,\n      decodeFailureRecoveryInProgress: null\n    };\n    this._allChannelChanges = new eventemitter_default(this.logger);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n    if ((_c = client.options.plugins) == null ? void 0 : _c.LiveObjects) {\n      this._object = new client.options.plugins.LiveObjects.RealtimeObject(this);\n    }\n  }\n  get presence() {\n    if (!this._presence) {\n      throwMissingPluginError(\"RealtimePresence\");\n    }\n    return this._presence;\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  /** @spec RTL27 */\n  get object() {\n    if (!this._object) {\n      throwMissingPluginError(\"LiveObjects\");\n    }\n    return this._object;\n  }\n  invalidStateError() {\n    return new ErrorInfo(\n      \"Channel operation failed as channel state is \" + this.state,\n      90001,\n      400,\n      this.errorReason || void 0\n    );\n  }\n  static processListenerArgs(args) {\n    args = Array.prototype.slice.call(args);\n    if (typeof args[0] === \"function\") {\n      args.unshift(null);\n    }\n    return args;\n  }\n  async setOptions(options) {\n    var _a2;\n    const previousChannelOptions = this.channelOptions;\n    const err = validateChannelOptions(options);\n    if (err) {\n      throw err;\n    }\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n    if (this._decodingContext)\n      this._decodingContext.channelOptions = this.channelOptions;\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n      this.attachImpl();\n      return new Promise((resolve, reject) => {\n        this._allChannelChanges.once(\n          [\"attached\", \"update\", \"detached\", \"failed\"],\n          function(stateChange) {\n            switch (this.event) {\n              case \"update\":\n              case \"attached\":\n                resolve();\n                break;\n              default:\n                reject(stateChange.reason);\n            }\n          }\n        );\n      });\n    }\n  }\n  _shouldReattachToSetOptions(options, prevOptions) {\n    if (!(this.state === \"attached\" || this.state === \"attaching\")) {\n      return false;\n    }\n    if (options == null ? void 0 : options.params) {\n      const requestedParams = omitAgent(options.params);\n      const existingParams = omitAgent(prevOptions.params);\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n        return true;\n      }\n      if (!shallowEquals(existingParams, requestedParams)) {\n        return true;\n      }\n    }\n    if (options == null ? void 0 : options.modes) {\n      if (!prevOptions.modes || !arrEquals(options.modes, prevOptions.modes)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null || first === void 0) {\n      messages = [message_default.fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [message_default.fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = message_default.fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    const maxMessageSize = this.client.options.maxMessageSize;\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages);\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        `Maximum size of messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400\n      );\n    }\n    this.throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.publish()\",\n      \"sending message; channel state is \" + this.state + \", message count = \" + wireMessages.length\n    );\n    const pm = fromValues({\n      action: actions.MESSAGE,\n      channel: this.name,\n      messages: wireMessages,\n      params: params ? stringifyValues(params) : void 0\n    });\n    const res = await this.sendMessage(pm);\n    return res || { serials: [] };\n  }\n  throwIfUnpublishableState() {\n    if (!this.connectionManager.activeState()) {\n      throw this.connectionManager.getError();\n    }\n    if (this.state === \"failed\" || this.state === \"suspended\") {\n      throw this.invalidStateError();\n    }\n  }\n  onEvent(messages) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.onEvent()\", \"received message\");\n    const subscriptions = this.subscriptions;\n    for (let i = 0; i < messages.length; i++) {\n      const message = messages[i];\n      subscriptions.emit(message.name, message);\n    }\n  }\n  async attach() {\n    if (this.state === \"attached\") {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      this._attach(false, null, (err, result) => err ? reject(err) : resolve(result));\n    });\n  }\n  _attach(forceReattach, attachReason, callback) {\n    if (!callback) {\n      callback = (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"RealtimeChannel._attach()\",\n            \"Channel attach failed: \" + err.toString()\n          );\n        }\n      };\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      callback(connectionManager.getError());\n      return;\n    }\n    if (this.state !== \"attaching\" || forceReattach) {\n      this.requestState(\"attaching\", attachReason);\n    }\n    this.once(function(stateChange) {\n      switch (this.event) {\n        case \"attached\":\n          callback == null ? void 0 : callback(null, stateChange);\n          break;\n        case \"detached\":\n        case \"suspended\":\n        case \"failed\":\n          callback == null ? void 0 : callback(\n            stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to attach; reason unknown; state = \" + this.event, 9e4, 500)\n          );\n          break;\n        case \"detaching\":\n          callback == null ? void 0 : callback(new ErrorInfo(\"Attach request superseded by a subsequent detach request\", 9e4, 409));\n          break;\n      }\n    });\n  }\n  attachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.attachImpl()\", \"sending ATTACH message\");\n    const attachMsg = fromValues({\n      action: actions.ATTACH,\n      channel: this.name,\n      params: this.channelOptions.params,\n      // RTL4c1: Includes the channel serial to resume from a previous message\n      // or attachment.\n      channelSerial: this.properties.channelSerial\n    });\n    if (this.channelOptions.modes) {\n      attachMsg.encodeModesToFlags(allToUpperCase(this.channelOptions.modes));\n    }\n    if (this._attachResume) {\n      attachMsg.setFlag(\"ATTACH_RESUME\");\n    }\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n    }\n    this.sendMessage(attachMsg).catch(noop);\n  }\n  async detach() {\n    const connectionManager = this.connectionManager;\n    switch (this.state) {\n      case \"suspended\":\n        this.notifyState(\"detached\");\n        return;\n      case \"detached\":\n        return;\n      case \"failed\":\n        throw new ErrorInfo(\"Unable to detach; channel state = failed\", 90001, 400);\n      default:\n        if (connectionManager.state.state !== \"connected\") {\n          this.notifyState(\"detached\");\n          return;\n        }\n        this.requestState(\"detaching\");\n      case \"detaching\":\n        return new Promise((resolve, reject) => {\n          this.once(function(stateChange) {\n            switch (this.event) {\n              case \"detached\":\n                resolve();\n                break;\n              case \"attached\":\n              case \"suspended\":\n              case \"failed\":\n                reject(\n                  stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to detach; reason unknown; state = \" + this.event, 9e4, 500)\n                );\n                break;\n              case \"attaching\":\n                reject(new ErrorInfo(\"Detach request superseded by a subsequent attach request\", 9e4, 409));\n                break;\n            }\n          });\n        });\n    }\n  }\n  detachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.detach()\", \"sending DETACH message\");\n    const msg = fromValues({ action: actions.DETACH, channel: this.name });\n    this.sendMessage(msg).catch(noop);\n  }\n  async subscribe(...args) {\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (this.state === \"failed\") {\n      throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n    if (event && typeof event === \"object\" && !Array.isArray(event)) {\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\n    } else {\n      this.subscriptions.on(event, listener);\n    }\n    if (this.channelOptions.attachOnSubscribe !== false) {\n      return this.attach();\n    } else {\n      return null;\n    }\n  }\n  unsubscribe(...args) {\n    var _a2;\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (typeof event === \"object\" && !listener || ((_a2 = this.filteredSubscriptions) == null ? void 0 : _a2.has(listener))) {\n      this.client._FilteredSubscriptions.getAndDeleteFilteredSubscriptions(this, event, listener).forEach((l) => this.subscriptions.off(l));\n      return;\n    }\n    this.subscriptions.off(event, listener);\n  }\n  sync() {\n    switch (this.state) {\n      case \"initialized\":\n      case \"detaching\":\n      case \"detached\":\n        throw new PartialErrorInfo(\"Unable to sync to channel; not attached\", 4e4);\n      default:\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    const syncMessage = fromValues({ action: actions.SYNC, channel: this.name });\n    if (this.syncChannelSerial) {\n      syncMessage.channelSerial = this.syncChannelSerial;\n    }\n    connectionManager.send(syncMessage);\n  }\n  async sendMessage(msg) {\n    return new Promise((resolve, reject) => {\n      this.connectionManager.send(msg, this.client.options.queueMessages, (err, publishResponse) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(publishResponse);\n        }\n      });\n    });\n  }\n  async sendPresence(presence) {\n    const msg = fromValues({\n      action: actions.PRESENCE,\n      channel: this.name,\n      presence\n    });\n    await this.sendMessage(msg);\n  }\n  async sendState(objectMessages) {\n    const msg = fromValues({\n      action: actions.OBJECT,\n      channel: this.name,\n      state: objectMessages\n    });\n    await this.sendMessage(msg);\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\n  async processMessage(message) {\n    if (message.action === actions.ATTACHED || message.action === actions.MESSAGE || message.action === actions.PRESENCE || message.action === actions.OBJECT || message.action === actions.ANNOTATION) {\n      this.setChannelSerial(message.channelSerial);\n    }\n    let syncChannelSerial, isSync = false;\n    switch (message.action) {\n      case actions.ATTACHED: {\n        this.properties.attachSerial = message.channelSerial;\n        this._mode = message.getMode();\n        this.params = message.params || {};\n        const modesFromFlags = message.decodeModesFromFlags();\n        this.modes = modesFromFlags && allToLowerCase(modesFromFlags) || void 0;\n        const resumed = message.hasFlag(\"RESUMED\");\n        const hasPresence = message.hasFlag(\"HAS_PRESENCE\");\n        const hasBacklog = message.hasFlag(\"HAS_BACKLOG\");\n        const hasObjects = message.hasFlag(\"HAS_OBJECTS\");\n        if (this.state === \"attached\") {\n          if (!resumed) {\n            if (this._presence) {\n              this._presence.onAttached(hasPresence);\n            }\n            if (this._object) {\n              this._object.onAttached(hasObjects);\n            }\n          }\n          const change = new channelstatechange_default(this.state, this.state, resumed, hasBacklog, message.error);\n          this._allChannelChanges.emit(\"update\", change);\n          if (!resumed || this.channelOptions.updateOnAttached) {\n            this.emit(\"update\", change);\n          }\n        } else if (this.state === \"detaching\") {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"attached\", message.error, resumed, hasPresence, hasBacklog, hasObjects);\n        }\n        break;\n      }\n      case actions.DETACHED: {\n        const detachErr = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo(\"Channel detached\", 90001, 404);\n        if (this.state === \"detaching\") {\n          this.notifyState(\"detached\", detachErr);\n        } else if (this.state === \"attaching\") {\n          this.notifyState(\"suspended\", detachErr);\n        } else if (this.state === \"attached\" || this.state === \"suspended\") {\n          this.requestState(\"attaching\", detachErr);\n        }\n        break;\n      }\n      case actions.SYNC:\n        isSync = true;\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n        if (!message.presence)\n          break;\n      case actions.PRESENCE: {\n        if (!message.presence) {\n          break;\n        }\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._presence) {\n          const presenceMessages = await Promise.all(\n            message.presence.map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._presence.setPresence(presenceMessages, isSync, syncChannelSerial);\n        }\n        break;\n      }\n      case actions.OBJECT:\n      case actions.OBJECT_SYNC: {\n        if (!this._object || !message.state) {\n          return;\n        }\n        populateFieldsFromParent(message);\n        const format = this.client.connection.connectionManager.getActiveTransportFormat();\n        const objectMessages = message.state.map((om) => om.decode(this.client, format));\n        if (message.action === actions.OBJECT) {\n          this._object.handleObjectMessages(objectMessages);\n        } else {\n          this._object.handleObjectSyncMessages(objectMessages, message.channelSerial);\n        }\n        break;\n      }\n      case actions.MESSAGE: {\n        if (this.state !== \"attached\") {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"RealtimeChannel.processMessage()\",\n            'Message \"' + message.id + '\" skipped as this channel \"' + this.name + '\" state is not \"attached\" (state is \"' + this.state + '\").'\n          );\n          return;\n        }\n        populateFieldsFromParent(message);\n        const encoded = message.messages, firstMessage = encoded[0], lastMessage = encoded[encoded.length - 1];\n        if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {\n          const msg = 'Delta message decode failure - previous message not available for message \"' + message.id + '\" on this channel \"' + this.name + '\".';\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", msg);\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\n          break;\n        }\n        let messages = [];\n        for (let i = 0; i < encoded.length; i++) {\n          const { decoded, err } = await encoded[i].decodeWithErr(this._decodingContext, this.logger);\n          messages[i] = decoded;\n          if (err) {\n            switch (err.code) {\n              case 40018:\n                this._startDecodeFailureRecovery(err);\n                return;\n              case 40019:\n              case 40021:\n                this.notifyState(\"failed\", err);\n                return;\n              default:\n            }\n          }\n        }\n        this._lastPayload.messageId = lastMessage.id;\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n        this.onEvent(messages);\n        break;\n      }\n      case actions.ANNOTATION: {\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._annotations) {\n          const annotations = await Promise.all(\n            (message.annotations || []).map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._annotations._processIncoming(annotations);\n        }\n        break;\n      }\n      case actions.ERROR: {\n        const err = message.error;\n        if (err && err.code == 80016) {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"failed\", ErrorInfo.fromValues(err));\n        }\n        break;\n      }\n      default:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"RealtimeChannel.processMessage()\",\n          \"Protocol error: unrecognised message action (\" + message.action + \")\"\n        );\n    }\n  }\n  _startDecodeFailureRecovery(reason) {\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MAJOR,\n        \"RealtimeChannel.processMessage()\",\n        \"Starting decode failure recovery process.\"\n      );\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\n      this._attach(true, reason, () => {\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\n      });\n    }\n  }\n  onAttached() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.onAttached\",\n      \"activating channel; name = \" + this.name\n    );\n  }\n  notifyState(state, reason, resumed, hasPresence, hasBacklog, hasObjects) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.notifyState\",\n      \"name = \" + this.name + \", current state = \" + this.state + \", notifying state \" + state\n    );\n    this.clearStateTimer();\n    if ([\"detached\", \"suspended\", \"failed\"].includes(state)) {\n      this.properties.channelSerial = null;\n    }\n    if (state === this.state) {\n      return;\n    }\n    if (this._presence) {\n      this._presence.actOnChannelState(state, hasPresence, reason);\n    }\n    if (this._object) {\n      this._object.actOnChannelState(state, hasObjects);\n    }\n    if (state === \"suspended\" && this.connectionManager.state.sendEvents) {\n      this.startRetryTimer();\n    } else {\n      this.cancelRetryTimer();\n    }\n    if (reason) {\n      this.errorReason = reason;\n    }\n    const change = new channelstatechange_default(this.state, state, resumed, hasBacklog, reason);\n    const action = 'Channel state for channel \"' + this.name + '\"';\n    const message = state + (reason ? \"; reason: \" + reason : \"\");\n    if (state === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    if (state !== \"attaching\" && state !== \"suspended\") {\n      this.retryCount = 0;\n    }\n    if (state === \"attached\") {\n      this.onAttached();\n    }\n    if (state === \"attached\") {\n      this._attachResume = true;\n    } else if (state === \"detaching\" || state === \"failed\") {\n      this._attachResume = false;\n    }\n    this.state = state;\n    this._allChannelChanges.emit(state, change);\n    this.emit(state, change);\n  }\n  requestState(state, reason) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.requestState\",\n      \"name = \" + this.name + \", state = \" + state\n    );\n    this.notifyState(state, reason);\n    this.checkPendingState();\n  }\n  checkPendingState() {\n    const cmState = this.connectionManager.state;\n    if (!cmState.sendEvents) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.checkPendingState\",\n        \"sendEvents is false; state is \" + this.connectionManager.state.state\n      );\n      return;\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.checkPendingState\",\n      \"name = \" + this.name + \", state = \" + this.state\n    );\n    switch (this.state) {\n      case \"attaching\":\n        this.startStateTimerIfNotRunning();\n        this.attachImpl();\n        break;\n      case \"detaching\":\n        this.startStateTimerIfNotRunning();\n        this.detachImpl();\n        break;\n      case \"attached\":\n        this.sync();\n        break;\n      default:\n        break;\n    }\n  }\n  timeoutPendingState() {\n    switch (this.state) {\n      case \"attaching\": {\n        const err = new ErrorInfo(\"Channel attach timed out\", 90007, 408);\n        this.notifyState(\"suspended\", err);\n        break;\n      }\n      case \"detaching\": {\n        const err = new ErrorInfo(\"Channel detach timed out\", 90007, 408);\n        this.notifyState(\"attached\", err);\n        break;\n      }\n      default:\n        this.checkPendingState();\n        break;\n    }\n  }\n  startStateTimerIfNotRunning() {\n    if (!this.stateTimer) {\n      this.stateTimer = setTimeout(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel.startStateTimerIfNotRunning\", \"timer expired\");\n        this.stateTimer = null;\n        this.timeoutPendingState();\n      }, this.client.options.timeouts.realtimeRequestTimeout);\n    }\n  }\n  clearStateTimer() {\n    const stateTimer = this.stateTimer;\n    if (stateTimer) {\n      clearTimeout(stateTimer);\n      this.stateTimer = null;\n    }\n  }\n  startRetryTimer() {\n    if (this.retryTimer)\n      return;\n    this.retryCount++;\n    const retryDelay = getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\n    this.retryTimer = setTimeout(() => {\n      if (this.state === \"suspended\" && this.connectionManager.state.sendEvents) {\n        this.retryTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"RealtimeChannel retry timer expired\",\n          \"attempting a new attach\"\n        );\n        this.requestState(\"attaching\");\n      }\n    }, retryDelay);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n  getReleaseErr() {\n    const s = this.state;\n    if (s === \"initialized\" || s === \"detached\" || s === \"failed\") {\n      return null;\n    }\n    return new ErrorInfo(\n      \"Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was \" + s,\n      90001,\n      400\n    );\n  }\n  setChannelSerial(channelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.setChannelSerial()\",\n      \"Updating channel serial; serial = \" + channelSerial + \"; previous = \" + this.properties.channelSerial\n    );\n    if (channelSerial) {\n      this.properties.channelSerial = channelSerial;\n    }\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n  async getMessage(serialOrMessage) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.getMessage()\", \"channel = \" + this.name);\n    const restMixin = this.client.rest.channelMixin;\n    return restMixin.getMessage(this, serialOrMessage);\n  }\n  async updateMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.updateMessage()\", \"channel = \" + this.name);\n    return this.sendUpdate(message, \"message.update\", operation, params);\n  }\n  async deleteMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.deleteMessage()\", \"channel = \" + this.name);\n    return this.sendUpdate(message, \"message.delete\", operation, params);\n  }\n  async appendMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.appendMessage()\", \"channel = \" + this.name);\n    return this.sendUpdate(message, \"message.append\", operation, params);\n  }\n  async sendUpdate(message, action, operation, params) {\n    var _a2, _b;\n    if (!message.serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial and cannot be updated. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    this.throwIfUnpublishableState();\n    const updateDeleteMsg = message_default.fromValues(__spreadProps(__spreadValues({}, message), {\n      action,\n      version: operation\n    }));\n    const wireMessage = await updateDeleteMsg.encode(this.channelOptions);\n    const pm = fromValues({\n      action: actions.MESSAGE,\n      channel: this.name,\n      messages: [wireMessage],\n      params: params ? stringifyValues(params) : void 0\n    });\n    const publishResponse = await this.sendMessage(pm);\n    return { versionSerial: (_b = (_a2 = publishResponse == null ? void 0 : publishResponse.serials) == null ? void 0 : _a2[0]) != null ? _b : null };\n  }\n  async getMessageVersions(serialOrMessage, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.getMessageVersions()\", \"channel = \" + this.name);\n    const restMixin = this.client.rest.channelMixin;\n    return restMixin.getMessageVersions(this, serialOrMessage, params);\n  }\n  /**\n   * Ensures the channel is attached, attaching if necessary.\n   *\n   * This method is intended for use by features like Presence or Objects that need to\n   * implicitly attach the channel when an operation is called (e.g., `presence.get()` per RTP11b,\n   * or `objects.get()`). This guarantees that the corresponding sync sequence will start and\n   * that the operation will resolve for callers even if they did not explicitly attach beforehand.\n   */\n  async ensureAttached() {\n    switch (this.state) {\n      case \"attached\":\n      case \"suspended\":\n        break;\n      case \"initialized\":\n      case \"detached\":\n      case \"detaching\":\n      case \"attaching\":\n        await this.attach();\n        break;\n      case \"failed\":\n      default:\n        throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n  }\n};\nfunction omitAgent(channelParams) {\n  const _a2 = channelParams || {}, { agent: _ } = _a2, paramsWithoutAgent = __objRest(_a2, [\"agent\"]);\n  return paramsWithoutAgent;\n}\nvar realtimechannel_default = RealtimeChannel;\n\n// src/common/lib/client/realtimeannotations.ts\nvar RealtimeAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n    this.logger = channel.logger;\n    this.subscriptions = new eventemitter_default(this.logger);\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const channelName = this.channel.name;\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    this.channel.throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeAnnotations.publish()\",\n      \"channelName = \" + channelName + \", sending annotation with messageSerial = \" + annotation.messageSerial + \", type = \" + annotation.type\n    );\n    const pm = fromValues({\n      action: actions.ANNOTATION,\n      channel: channelName,\n      annotations: [wireAnnotation]\n    });\n    await this.channel.sendMessage(pm);\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    await this.publish(msgOrSerial, annotationValues);\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (this.channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n    if ((this.channel.state === \"attached\" && this.channel._mode & flags.ANNOTATION_SUBSCRIBE) === 0) {\n      throw new ErrorInfo(\n        \"You are trying to add an annotation listener, but you haven't requested the annotation_subscribe channel mode in ChannelOptions, so this won't do anything (we only deliver annotations to clients who have explicitly requested them)\",\n        93001,\n        400\n      );\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n  _processIncoming(annotations) {\n    for (const annotation of annotations) {\n      this.subscriptions.emit(annotation.type || \"\", annotation);\n    }\n  }\n  async get(msgOrSerial, params) {\n    return restannotations_default.prototype.get.call(this, msgOrSerial, params);\n  }\n};\nvar realtimeannotations_default = RealtimeAnnotations;\n\n// src/common/lib/client/defaultrest.ts\nvar _DefaultRest = class _DefaultRest extends BaseRest {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2, _b;\n    const MsgPack = _DefaultRest._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRest._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Rest\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRest.Crypto) != null ? _a2 : void 0,\n        MsgPack: (_b = _DefaultRest._MsgPack) != null ? _b : void 0,\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        }\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRest._Crypto = null;\n_DefaultRest.Message = DefaultMessage;\n_DefaultRest.PresenceMessage = DefaultPresenceMessage;\n_DefaultRest.Annotation = DefaultAnnotation;\n_DefaultRest._MsgPack = null;\n// Used by tests\n_DefaultRest._Http = Http;\nvar DefaultRest = _DefaultRest;\n\n// src/common/lib/transport/messagequeue.ts\nvar MessageQueue = class extends eventemitter_default {\n  constructor(logger) {\n    super(logger);\n    this.messages = [];\n  }\n  count() {\n    return this.messages.length;\n  }\n  push(message) {\n    this.messages.push(message);\n  }\n  shift() {\n    return this.messages.shift();\n  }\n  last() {\n    return this.messages[this.messages.length - 1];\n  }\n  copyAll() {\n    return this.messages.slice();\n  }\n  append(messages) {\n    this.messages.push.apply(this.messages, messages);\n  }\n  prepend(messages) {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n  /**\n   * For all messages targeted by the selector, calls their callback and removes them from the queue.\n   *\n   * @param selector - Describes which messages to target. 'all' means all messages in the queue (regardless of whether they have had a `msgSerial` assigned); `serial` / `count` targets a range of messages described by an `ACK` or `NACK` received from Ably (this assumes that all the messages in the queue have had a `msgSerial` assigned).\n   */\n  completeMessages(selector, err, res) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.completeMessages()\",\n      selector == \"all\" ? \"(all)\" : \"serial = \" + selector.serial + \"; count = \" + selector.count\n    );\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error(\"MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue\");\n    }\n    let completeMessages = [];\n    if (selector === \"all\") {\n      completeMessages = messages.splice(0);\n    } else {\n      const first = messages[0];\n      if (first) {\n        const startSerial = first.message.msgSerial;\n        const endSerial = selector.serial + selector.count;\n        if (endSerial > startSerial) {\n          completeMessages = messages.splice(0, endSerial - startSerial);\n        }\n      }\n    }\n    for (let i = 0; i < completeMessages.length; i++) {\n      const message = completeMessages[i];\n      const publishResponse = res == null ? void 0 : res[i];\n      message.callback(err, publishResponse);\n    }\n    if (messages.length == 0)\n      this.emit(\"idle\");\n  }\n  completeAllMessages(err) {\n    this.completeMessages(\"all\", err);\n  }\n  resetSendAttempted() {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n  clear() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.clear()\",\n      \"clearing \" + this.messages.length + \" messages\"\n    );\n    this.messages = [];\n    this.emit(\"idle\");\n  }\n};\nvar messagequeue_default = MessageQueue;\n\n// src/common/lib/transport/protocol.ts\nvar PendingMessage = class {\n  constructor(message, callback) {\n    this.message = message;\n    this.callback = callback;\n    this.merged = false;\n    const action = message.action;\n    this.sendAttempted = false;\n    this.ackRequired = typeof action === \"number\" && [actions.MESSAGE, actions.PRESENCE, actions.ANNOTATION, actions.OBJECT].includes(action);\n  }\n};\nvar Protocol = class extends eventemitter_default {\n  constructor(transport) {\n    super(transport.logger);\n    this.transport = transport;\n    this.messageQueue = new messagequeue_default(this.logger);\n    transport.on(\"ack\", (serial, count, res) => {\n      this.onAck(serial, count, res);\n    });\n    transport.on(\"nack\", (serial, count, err) => {\n      this.onNack(serial, count, err);\n    });\n  }\n  onAck(serial, count, res) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"Protocol.onAck()\", \"serial = \" + serial + \"; count = \" + count);\n    this.messageQueue.completeMessages({ serial, count }, null, res);\n  }\n  onNack(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_ERROR,\n      \"Protocol.onNack()\",\n      \"serial = \" + serial + \"; count = \" + count + \"; err = \" + inspectError(err)\n    );\n    if (!err) {\n      err = new ErrorInfo(\"Unable to send message; channel not responding\", 50001, 500);\n    }\n    this.messageQueue.completeMessages({ serial, count }, err);\n  }\n  onceIdle(listener) {\n    const messageQueue = this.messageQueue;\n    if (messageQueue.count() === 0) {\n      listener();\n      return;\n    }\n    messageQueue.once(\"idle\", listener);\n  }\n  send(pendingMessage) {\n    if (pendingMessage.ackRequired) {\n      this.messageQueue.push(pendingMessage);\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Protocol.send()\",\n        \"sending msg; \" + stringify(\n          pendingMessage.message,\n          this.transport.connectionManager.realtime._RealtimePresence,\n          this.transport.connectionManager.realtime._Annotations,\n          this.transport.connectionManager.realtime._liveObjectsPlugin\n        )\n      );\n    }\n    pendingMessage.sendAttempted = true;\n    this.transport.send(pendingMessage.message);\n  }\n  getTransport() {\n    return this.transport;\n  }\n  getPendingMessages() {\n    return this.messageQueue.copyAll();\n  }\n  clearPendingMessages() {\n    return this.messageQueue.clear();\n  }\n  finish() {\n    const transport = this.transport;\n    this.onceIdle(function() {\n      transport.disconnect();\n    });\n  }\n};\nvar protocol_default = Protocol;\n\n// src/common/lib/client/connectionstatechange.ts\nvar ConnectionStateChange = class {\n  constructor(previous, current, retryIn, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn)\n      this.retryIn = retryIn;\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar connectionstatechange_default = ConnectionStateChange;\n\n// src/common/lib/transport/connectionerrors.ts\nvar ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 8e4,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001\n};\nvar ConnectionErrors = {\n  disconnected: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.DISCONNECTED,\n    message: \"Connection to server temporarily unavailable\"\n  }),\n  suspended: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.SUSPENDED,\n    message: \"Connection to server unavailable\"\n  }),\n  failed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.FAILED,\n    message: \"Connection failed or disconnected by server\"\n  }),\n  closing: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSING,\n    message: \"Connection closing\"\n  }),\n  closed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSED,\n    message: \"Connection closed\"\n  }),\n  unknownConnectionErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal connection error\"\n  }),\n  unknownChannelErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal channel error\"\n  })\n};\nfunction isRetriable(err) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\nvar connectionerrors_default = ConnectionErrors;\n\n// src/common/lib/transport/transport.ts\nvar closeMessage = fromValues({ action: actions.CLOSE });\nvar disconnectMessage = fromValues({ action: actions.DISCONNECT });\nvar Transport = class extends eventemitter_default {\n  constructor(connectionManager, auth, params, forceJsonProtocol) {\n    super(connectionManager.logger);\n    if (forceJsonProtocol) {\n      params.format = void 0;\n      params.heartbeats = true;\n    }\n    this.connectionManager = connectionManager;\n    this.auth = auth;\n    this.params = params;\n    this.timeouts = params.options.timeouts;\n    this.format = params.format;\n    this.isConnected = false;\n    this.isFinished = false;\n    this.isDisposed = false;\n    this.maxIdleInterval = null;\n    this.idleTimer = null;\n    this.lastActivity = null;\n  }\n  connect() {\n  }\n  close() {\n    if (this.isConnected) {\n      this.requestClose();\n    }\n    this.finish(\"closed\", connectionerrors_default.closed());\n  }\n  disconnect(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"disconnected\", err || connectionerrors_default.disconnected());\n  }\n  fail(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"failed\", err || connectionerrors_default.failed());\n  }\n  finish(event, err) {\n    var _a2;\n    if (this.isFinished) {\n      return;\n    }\n    this.isFinished = true;\n    this.isConnected = false;\n    this.maxIdleInterval = null;\n    clearTimeout((_a2 = this.idleTimer) != null ? _a2 : void 0);\n    this.idleTimer = null;\n    this.emit(event, err);\n    this.dispose();\n  }\n  onProtocolMessage(message) {\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Transport.onProtocolMessage()\",\n        \"received on \" + this.shortName + \": \" + stringify(\n          message,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations,\n          this.connectionManager.realtime._liveObjectsPlugin\n        ) + \"; connectionId = \" + this.connectionManager.connectionId\n      );\n    }\n    this.onActivity();\n    switch (message.action) {\n      case actions.HEARTBEAT:\n        logger_default.logActionNoStrip(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Transport.onProtocolMessage()\",\n          this.shortName + \" heartbeat; connectionId = \" + this.connectionManager.connectionId\n        );\n        this.emit(\"heartbeat\", message.id);\n        break;\n      case actions.CONNECTED:\n        this.onConnect(message);\n        this.emit(\"connected\", message.error, message.connectionId, message.connectionDetails, message);\n        break;\n      case actions.CLOSED:\n        this.onClose(message);\n        break;\n      case actions.DISCONNECTED:\n        this.onDisconnect(message);\n        break;\n      case actions.ACK:\n        this.emit(\"ack\", message.msgSerial, message.count, message.res);\n        break;\n      case actions.NACK:\n        this.emit(\"nack\", message.msgSerial, message.count, message.error);\n        break;\n      case actions.SYNC:\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      case actions.ACTIVATE:\n        break;\n      case actions.AUTH:\n        whenPromiseSettles(this.auth.authorize(), (err) => {\n          if (err) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Transport.onProtocolMessage()\",\n              \"Ably requested re-authentication, but unable to obtain a new token: \" + inspectError(err)\n            );\n          }\n        });\n        break;\n      case actions.ERROR:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Transport.onProtocolMessage()\",\n          \"received error action; connectionId = \" + this.connectionManager.connectionId + \"; err = \" + Platform.Config.inspect(message.error) + (message.channel ? \", channel: \" + message.channel : \"\")\n        );\n        if (message.channel === void 0) {\n          this.onFatalError(message);\n          break;\n        }\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      default:\n        this.connectionManager.onChannelMessage(message, this);\n    }\n  }\n  onConnect(message) {\n    this.isConnected = true;\n    if (!message.connectionDetails) {\n      throw new Error(\"Transport.onConnect(): Connect message recieved without connectionDetails\");\n    }\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval;\n    if (maxPromisedIdle) {\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n      this.onActivity();\n    }\n  }\n  onDisconnect(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onDisconnect()\", \"err = \" + inspectError(err));\n    this.finish(\"disconnected\", err);\n  }\n  onFatalError(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onFatalError()\", \"err = \" + inspectError(err));\n    this.finish(\"failed\", err);\n  }\n  onClose(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onClose()\", \"err = \" + inspectError(err));\n    this.finish(\"closed\", err);\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestClose()\", \"\");\n    this.send(closeMessage);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestDisconnect()\", \"\");\n    this.send(disconnectMessage);\n  }\n  ping(id) {\n    const msg = { action: actions.HEARTBEAT };\n    if (id)\n      msg.id = id;\n    this.send(fromValues(msg));\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.dispose()\", \"\");\n    this.isDisposed = true;\n    this.off();\n  }\n  onActivity() {\n    if (!this.maxIdleInterval) {\n      return;\n    }\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\n    this.setIdleTimer(this.maxIdleInterval + 100);\n  }\n  setIdleTimer(timeout) {\n    if (!this.idleTimer) {\n      this.idleTimer = setTimeout(() => {\n        this.onIdleTimerExpire();\n      }, timeout);\n    }\n  }\n  onIdleTimerExpire() {\n    if (!this.lastActivity || !this.maxIdleInterval) {\n      throw new Error(\"Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set\");\n    }\n    this.idleTimer = null;\n    const sinceLast = Date.now() - this.lastActivity;\n    const timeRemaining = this.maxIdleInterval - sinceLast;\n    if (timeRemaining <= 0) {\n      const msg = \"No activity seen from realtime in \" + sinceLast + \"ms; assuming connection has dropped\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Transport.onIdleTimerExpire()\", msg);\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\n    } else {\n      this.setIdleTimer(timeRemaining + 100);\n    }\n  }\n  static tryConnect(transportCtor, connectionManager, auth, transportParams, callback) {\n    const transport = new transportCtor(connectionManager, auth, transportParams);\n    let transportAttemptTimer;\n    const errorCb = function(err) {\n      clearTimeout(transportAttemptTimer);\n      callback({ event: this.event, error: err });\n    };\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n    transportAttemptTimer = setTimeout(() => {\n      transport.off([\"preconnect\", \"disconnected\", \"failed\"]);\n      transport.dispose();\n      errorCb.call(\n        { event: \"disconnected\" },\n        new ErrorInfo(\"Timeout waiting for transport to indicate itself viable\", 5e4, 500)\n      );\n    }, realtimeRequestTimeout);\n    transport.on([\"failed\", \"disconnected\"], errorCb);\n    transport.on(\"preconnect\", function() {\n      logger_default.logAction(\n        connectionManager.logger,\n        logger_default.LOG_MINOR,\n        \"Transport.tryConnect()\",\n        \"viable transport \" + transport\n      );\n      clearTimeout(transportAttemptTimer);\n      transport.off([\"failed\", \"disconnected\"], errorCb);\n      callback(null, transport);\n    });\n    transport.connect();\n    return transport;\n  }\n  static isAvailable() {\n    throw new ErrorInfo(\"isAvailable not implemented for transport\", 5e4, 500);\n  }\n};\nvar transport_default = Transport;\n\n// src/common/constants/TransportName.ts\nvar TransportNames;\n((TransportNames2) => {\n  TransportNames2.WebSocket = \"web_socket\";\n  TransportNames2.Comet = \"comet\";\n  TransportNames2.XhrPolling = \"xhr_polling\";\n})(TransportNames || (TransportNames = {}));\n\n// src/common/lib/transport/connectionmanager.ts\nvar globalObject2 = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\nvar haveWebStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.localSupported);\n};\nvar haveSessionStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.sessionSupported);\n};\nvar noop2 = function() {\n};\nvar transportPreferenceName = \"ably-transport-preference\";\nfunction decodeRecoveryKey(recoveryKey) {\n  try {\n    return JSON.parse(recoveryKey);\n  } catch (e) {\n    return null;\n  }\n}\nvar TransportParams = class {\n  constructor(options, host, mode, connectionKey) {\n    this.options = options;\n    this.host = host;\n    this.mode = mode;\n    this.connectionKey = connectionKey;\n    this.format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n  }\n  getConnectParams(authParams) {\n    const params = authParams ? copy(authParams) : {};\n    const options = this.options;\n    switch (this.mode) {\n      case \"resume\":\n        params.resume = this.connectionKey;\n        break;\n      case \"recover\": {\n        const recoveryContext = decodeRecoveryKey(options.recover);\n        if (recoveryContext) {\n          params.recover = recoveryContext.connectionKey;\n        }\n        break;\n      }\n      default:\n    }\n    if (options.clientId !== void 0) {\n      params.clientId = options.clientId;\n    }\n    if (options.echoMessages === false) {\n      params.echo = \"false\";\n    }\n    if (this.format !== void 0) {\n      params.format = this.format;\n    }\n    if (this.stream !== void 0) {\n      params.stream = this.stream;\n    }\n    if (this.heartbeats !== void 0) {\n      params.heartbeats = this.heartbeats;\n    }\n    params.v = defaults_default.protocolVersion;\n    params.agent = getAgentString(this.options);\n    if (options.transportParams !== void 0) {\n      mixin(params, options.transportParams);\n    }\n    return params;\n  }\n  toString() {\n    let result = \"[mode=\" + this.mode;\n    if (this.host) {\n      result += \",host=\" + this.host;\n    }\n    if (this.connectionKey) {\n      result += \",connectionKey=\" + this.connectionKey;\n    }\n    if (this.format) {\n      result += \",format=\" + this.format;\n    }\n    result += \"]\";\n    return result;\n  }\n};\nvar ConnectionManager = class _ConnectionManager extends eventemitter_default {\n  constructor(realtime, options) {\n    super(realtime.logger);\n    this.supportedTransports = {};\n    this.disconnectedRetryCount = 0;\n    this.pendingChannelMessagesState = { isProcessing: false, queue: [] };\n    this.realtime = realtime;\n    this.initTransports();\n    this.options = options;\n    const timeouts = options.timeouts;\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\n    this.states = {\n      initialized: {\n        state: \"initialized\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        failState: \"disconnected\"\n      },\n      connecting: {\n        state: \"connecting\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: connectingTimeout,\n        failState: \"disconnected\"\n      },\n      connected: {\n        state: \"connected\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: true,\n        failState: \"disconnected\"\n      },\n      disconnected: {\n        state: \"disconnected\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: timeouts.disconnectedRetryTimeout,\n        failState: \"disconnected\"\n      },\n      suspended: {\n        state: \"suspended\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.suspendedRetryTimeout,\n        failState: \"suspended\"\n      },\n      closing: {\n        state: \"closing\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.realtimeRequestTimeout,\n        failState: \"closed\"\n      },\n      closed: { state: \"closed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"closed\" },\n      failed: { state: \"failed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"failed\" }\n    };\n    this.state = this.states.initialized;\n    this.errorReason = null;\n    this.queuedMessages = new messagequeue_default(this.logger);\n    this.msgSerial = 0;\n    this.connectionDetails = void 0;\n    this.connectionId = void 0;\n    this.connectionKey = void 0;\n    this.connectionStateTtl = timeouts.connectionStateTtl;\n    this.maxIdleInterval = null;\n    this.transports = intersect(options.transports || defaults_default.defaultTransports, this.supportedTransports);\n    this.transportPreference = null;\n    if (this.transports.includes(TransportNames.WebSocket)) {\n      this.webSocketTransportAvailable = true;\n    }\n    if (this.transports.includes(TransportNames.XhrPolling)) {\n      this.baseTransport = TransportNames.XhrPolling;\n    } else if (this.transports.includes(TransportNames.Comet)) {\n      this.baseTransport = TransportNames.Comet;\n    }\n    this.domains = defaults_default.getHosts(options);\n    this.activeProtocol = null;\n    this.host = null;\n    this.lastAutoReconnectAttempt = null;\n    this.lastActivity = null;\n    this.forceFallbackHost = false;\n    this.connectCounter = 0;\n    this.wsCheckResult = null;\n    this.webSocketSlowTimer = null;\n    this.webSocketGiveUpTimer = null;\n    this.abandonedWebSocket = false;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.ConnectionManager()\", \"started\");\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"requested transports = [\" + (options.transports || defaults_default.defaultTransports) + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"available transports = [\" + this.transports + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"http domains = [\" + this.domains + \"]\"\n    );\n    if (!this.transports.length) {\n      const msg = \"no requested transports available\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"realtime.ConnectionManager()\", msg);\n      throw new Error(msg);\n    }\n    const addEventListener = Platform.Config.addEventListener;\n    if (addEventListener) {\n      if (haveSessionStorage() && typeof options.recover === \"function\") {\n        addEventListener(\"beforeunload\", this.persistConnection.bind(this));\n      }\n      if (options.closeOnUnload === true) {\n        addEventListener(\"beforeunload\", () => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"Realtime.ConnectionManager()\",\n            \"beforeunload event has triggered the connection to close as closeOnUnload is true\"\n          );\n          this.requestState({ state: \"closing\" });\n        });\n      }\n      addEventListener(\"online\", () => {\n        var _a2;\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018online\\u2019 event\",\n            \"reattempting connection\"\n          );\n          this.requestState({ state: \"connecting\" });\n        } else if (this.state == this.states.connecting) {\n          (_a2 = this.pendingTransport) == null ? void 0 : _a2.off();\n          this.disconnectAllTransports();\n          this.startConnect();\n        }\n      });\n      addEventListener(\"offline\", () => {\n        if (this.state == this.states.connected) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018offline\\u2019 event\",\n            \"disconnecting active transport\"\n          );\n          this.disconnectAllTransports();\n        }\n      });\n    }\n  }\n  /*********************\n   * transport management\n   *********************/\n  // Used by tests\n  static supportedTransports(additionalImplementations) {\n    const storage = { supportedTransports: {} };\n    this.initTransports(additionalImplementations, storage);\n    return storage.supportedTransports;\n  }\n  static initTransports(additionalImplementations, storage) {\n    const implementations = __spreadValues(__spreadValues({}, Platform.Transports.bundledImplementations), additionalImplementations);\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\n      const transport = implementations[transportName];\n      if (transport && transport.isAvailable()) {\n        storage.supportedTransports[transportName] = transport;\n      }\n    });\n  }\n  initTransports() {\n    _ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\n  }\n  createTransportParams(host, mode) {\n    return new TransportParams(this.options, host, mode, this.connectionKey);\n  }\n  getTransportParams(callback) {\n    const decideMode = (modeCb) => {\n      if (this.connectionKey) {\n        modeCb(\"resume\");\n        return;\n      }\n      if (typeof this.options.recover === \"string\") {\n        modeCb(\"recover\");\n        return;\n      }\n      const recoverFn = this.options.recover, lastSessionData = this.getSessionRecoverData(), sessionRecoveryName = this.sessionRecoveryName();\n      if (lastSessionData && typeof recoverFn === \"function\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Calling clientOptions-provided recover function with last session data (recovery scope: \" + sessionRecoveryName + \")\"\n        );\n        recoverFn(lastSessionData, (shouldRecover) => {\n          if (shouldRecover) {\n            this.options.recover = lastSessionData.recoveryKey;\n            modeCb(\"recover\");\n          } else {\n            modeCb(\"clean\");\n          }\n        });\n        return;\n      }\n      modeCb(\"clean\");\n    };\n    decideMode((mode) => {\n      const transportParams = this.createTransportParams(null, mode);\n      if (mode === \"recover\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport recovery mode = recover; recoveryKey = \" + this.options.recover\n        );\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\n        if (recoveryContext) {\n          this.msgSerial = recoveryContext.msgSerial;\n        }\n      } else {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport params = \" + transportParams.toString()\n        );\n      }\n      callback(transportParams);\n    });\n  }\n  /**\n   * Attempt to connect using a given transport\n   * @param transportParams\n   * @param candidate, the transport to try\n   * @param callback\n   */\n  tryATransport(transportParams, candidate, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.tryATransport()\", \"trying \" + candidate);\n    this.proposedTransport = transport_default.tryConnect(\n      this.supportedTransports[candidate],\n      this,\n      this.realtime.auth,\n      transportParams,\n      (wrappedErr, transport) => {\n        const state = this.state;\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\n          if (transport) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager.tryATransport()\",\n              \"connection \" + state.state + \" while we were attempting the transport; closing \" + transport\n            );\n            transport.close();\n          }\n          callback(true);\n          return;\n        }\n        if (wrappedErr) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.tryATransport()\",\n            \"transport \" + candidate + \" \" + wrappedErr.event + \", err: \" + wrappedErr.error.toString()\n          );\n          if (auth_default.isTokenErr(wrappedErr.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason))) {\n            this.errorReason = wrappedErr.error;\n            whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err) => {\n              if (err) {\n                this.actOnErrorFromAuthorize(err);\n                return;\n              }\n              this.tryATransport(transportParams, candidate, callback);\n            });\n          } else if (wrappedErr.event === \"failed\") {\n            this.notifyState({ state: \"failed\", error: wrappedErr.error });\n            callback(true);\n          } else if (wrappedErr.event === \"disconnected\") {\n            if (!isRetriable(wrappedErr.error)) {\n              this.notifyState({ state: this.states.connecting.failState, error: wrappedErr.error });\n              callback(true);\n            } else {\n              callback(false);\n            }\n          }\n          return;\n        }\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.tryATransport()\",\n          \"viable transport \" + candidate + \"; setting pending\"\n        );\n        this.setTransportPending(transport, transportParams);\n        callback(null, transport);\n      }\n    );\n  }\n  /**\n   * Called when a transport is indicated to be viable, and the ConnectionManager\n   * expects to activate this transport as soon as it is connected.\n   * @param transport\n   * @param transportParams\n   */\n  setTransportPending(transport, transportParams) {\n    const mode = transportParams.mode;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.setTransportPending()\",\n      \"transport = \" + transport + \"; mode = \" + mode\n    );\n    this.pendingTransport = transport;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    transport.once(\"connected\", (error, connectionId, connectionDetails) => {\n      this.activateTransport(error, transport, connectionId, connectionDetails);\n      if (mode === \"recover\" && this.options.recover) {\n        delete this.options.recover;\n        this.unpersistConnection();\n      }\n    });\n    const self2 = this;\n    transport.on([\"disconnected\", \"closed\", \"failed\"], function(error) {\n      self2.deactivateTransport(transport, this.event, error);\n    });\n    this.emit(\"transport.pending\", transport);\n  }\n  /**\n   * Called when a transport is connected, and the connectionmanager decides that\n   * it will now be the active transport. Returns whether or not it activated\n   * the transport (if the connection is closing/closed it will choose not to).\n   * @param transport the transport instance\n   * @param connectionId the id of the new active connection\n   * @param connectionDetails the details of the new active connection\n   */\n  activateTransport(error, transport, connectionId, connectionDetails) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"transport = \" + transport\n    );\n    if (error) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", \"error = \" + error);\n    }\n    if (connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionId =  \" + connectionId\n      );\n    }\n    if (connectionDetails) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionDetails =  \" + JSON.stringify(connectionDetails)\n      );\n    }\n    this.persistTransportPreference(transport);\n    const existingState = this.state, connectedState = this.states.connected.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"current state = \" + existingState.state\n    );\n    if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Disconnecting transport and abandoning\"\n      );\n      transport.disconnect();\n      return false;\n    }\n    delete this.pendingTransport;\n    if (!transport.isConnected) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Declining to activate transport \" + transport + \" since it appears to no longer be connected\"\n      );\n      return false;\n    }\n    const existingActiveProtocol = this.activeProtocol;\n    this.activeProtocol = new protocol_default(transport);\n    this.host = transport.params.host;\n    const connectionKey = connectionDetails.connectionKey;\n    if (connectionKey && this.connectionKey != connectionKey) {\n      this.setConnection(connectionId, connectionDetails, !!error);\n    }\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\n    Platform.Config.nextTick(() => {\n      transport.on(\n        \"connected\",\n        (connectedErr, _connectionId, connectionDetails2) => {\n          this.onConnectionDetailsUpdate(connectionDetails2, transport);\n          this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, connectedErr));\n        }\n      );\n    });\n    if (existingState.state === this.states.connected.state) {\n      if (error) {\n        this.errorReason = this.realtime.connection.errorReason = error;\n        this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, error));\n      }\n    } else {\n      this.notifyState({ state: \"connected\", error });\n      this.errorReason = this.realtime.connection.errorReason = error || null;\n    }\n    this.emit(\"transport.active\", transport);\n    if (existingActiveProtocol) {\n      if (existingActiveProtocol.messageQueue.count() > 0) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.activateTransport()\",\n          \"Previous active protocol (for transport \" + existingActiveProtocol.transport.shortName + \", new one is \" + transport.shortName + \") finishing with \" + existingActiveProtocol.messageQueue.count() + \" messages still pending\"\n        );\n      }\n      if (existingActiveProtocol.transport === transport) {\n        const msg = \"Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = \" + transport.shortName + \"; stack = \" + new Error().stack;\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", msg);\n      } else {\n        existingActiveProtocol.finish();\n      }\n    }\n    return true;\n  }\n  /**\n   * Called when a transport is no longer the active transport. This can occur\n   * in any transport connection state.\n   * @param transport\n   */\n  deactivateTransport(transport, state, error) {\n    const currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = transport === this.pendingTransport, noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"transport = \" + transport\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"state = \" + state + (wasActive ? \"; was active\" : wasPending ? \"; was pending\" : \"\") + (noTransportsScheduledForActivation ? \"\" : \"; another transport is scheduled for activation\")\n    );\n    if (error && error.message)\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"reason =  \" + error.message\n      );\n    if (wasActive) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"Getting, clearing, and requeuing \" + this.activeProtocol.messageQueue.count() + \" pending messages\"\n      );\n      this.queuePendingMessages(currentProtocol.getPendingMessages());\n      currentProtocol.clearPendingMessages();\n      this.activeProtocol = this.host = null;\n    }\n    this.emit(\"transport.inactive\", transport);\n    if (wasActive && noTransportsScheduledForActivation || wasActive && state === \"failed\" || state === \"closed\" || currentProtocol === null && wasPending) {\n      if (state === \"disconnected\" && error && error.statusCode > 500 && this.domains.length > 1) {\n        this.unpersistTransportPreference();\n        this.forceFallbackHost = true;\n        this.notifyState({ state, error, retryImmediately: true });\n        return;\n      }\n      const newConnectionState = state === \"failed\" && auth_default.isTokenErr(error) ? \"disconnected\" : state;\n      this.notifyState({ state: newConnectionState, error });\n      return;\n    }\n  }\n  /* Helper that returns true if there are no transports which are pending,\n   * have been connected, and are just waiting for onceNoPending to fire before\n   * being activated */\n  noTransportsScheduledForActivation() {\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\n  }\n  setConnection(connectionId, connectionDetails, hasConnectionError) {\n    const prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;\n    if (connIdChanged || recoverFailure) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.setConnection()\", \"Resetting msgSerial\");\n      this.msgSerial = 0;\n      this.queuedMessages.resetSendAttempted();\n    }\n    if (this.connectionId !== connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.setConnection()\",\n        \"New connectionId; reattaching any attached channels\"\n      );\n    }\n    this.realtime.connection.id = this.connectionId = connectionId;\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n  }\n  clearConnection() {\n    this.realtime.connection.id = this.connectionId = void 0;\n    this.realtime.connection.key = this.connectionKey = void 0;\n    this.msgSerial = 0;\n    this.queuedMessages.resetSendAttempted();\n    this.unpersistConnection();\n  }\n  createRecoveryKey() {\n    if (!this.connectionKey) {\n      return null;\n    }\n    return JSON.stringify({\n      connectionKey: this.connectionKey,\n      msgSerial: this.msgSerial,\n      channelSerials: this.realtime.channels.channelSerials()\n    });\n  }\n  checkConnectionStateFreshness() {\n    if (!this.lastActivity || !this.connectionId) {\n      return;\n    }\n    const sinceLast = Date.now() - this.lastActivity;\n    if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.checkConnectionStateFreshness()\",\n        \"Last known activity from realtime was \" + sinceLast + \"ms ago; discarding connection state\"\n      );\n      this.clearConnection();\n      this.states.connecting.failState = \"suspended\";\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  persistConnection() {\n    if (haveSessionStorage()) {\n      const recoveryKey = this.createRecoveryKey();\n      if (recoveryKey) {\n        this.setSessionRecoverData({\n          recoveryKey,\n          disconnectedAt: Date.now(),\n          location: globalObject2.location,\n          clientId: this.realtime.auth.clientId\n        });\n      }\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  unpersistConnection() {\n    this.clearSessionRecoverData();\n  }\n  getActiveTransportFormat() {\n    var _a2;\n    return (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport().format;\n  }\n  /*********************\n   * state management\n   *********************/\n  getError() {\n    if (this.errorReason) {\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\n      newError.cause = this.errorReason;\n      return newError;\n    }\n    return this.getStateError();\n  }\n  getStateError() {\n    var _a2, _b;\n    return (_b = (_a2 = connectionerrors_default)[this.state.state]) == null ? void 0 : _b.call(_a2);\n  }\n  activeState() {\n    return this.state.queueEvents || this.state.sendEvents;\n  }\n  enactStateChange(stateChange) {\n    const action = \"Connection state\";\n    const message = stateChange.current + (stateChange.reason ? \"; reason: \" + stateChange.reason : \"\");\n    if (stateChange.current === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.enactStateChange\",\n      \"setting new state: \" + stateChange.current + \"; reason = \" + (stateChange.reason && stateChange.reason.message)\n    );\n    const newState = this.state = this.states[stateChange.current];\n    if (stateChange.reason) {\n      this.errorReason = stateChange.reason;\n      this.realtime.connection.errorReason = stateChange.reason;\n    }\n    if (newState.terminal || newState.state === \"suspended\") {\n      this.clearConnection();\n    }\n    this.emit(\"connectionstate\", stateChange);\n  }\n  /****************************************\n   * ConnectionManager connection lifecycle\n   ****************************************/\n  startTransitionTimer(transitionState) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.startTransitionTimer()\",\n      \"transitionState: \" + transitionState.state\n    );\n    if (this.transitionTimer) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startTransitionTimer()\",\n        \"clearing already-running timer\"\n      );\n      clearTimeout(this.transitionTimer);\n    }\n    this.transitionTimer = setTimeout(() => {\n      if (this.transitionTimer) {\n        this.transitionTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager \" + transitionState.state + \" timer expired\",\n          \"requesting new state: \" + transitionState.failState\n        );\n        this.notifyState({ state: transitionState.failState });\n      }\n    }, transitionState.retryDelay);\n  }\n  cancelTransitionTimer() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.cancelTransitionTimer()\", \"\");\n    if (this.transitionTimer) {\n      clearTimeout(this.transitionTimer);\n      this.transitionTimer = null;\n    }\n  }\n  startSuspendTimer() {\n    if (this.suspendTimer)\n      return;\n    this.suspendTimer = setTimeout(() => {\n      if (this.suspendTimer) {\n        this.suspendTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager suspend timer expired\",\n          \"requesting new state: suspended\"\n        );\n        this.states.connecting.failState = \"suspended\";\n        this.notifyState({ state: \"suspended\" });\n      }\n    }, this.connectionStateTtl);\n  }\n  checkSuspendTimer(state) {\n    if (state !== \"disconnected\" && state !== \"suspended\" && state !== \"connecting\")\n      this.cancelSuspendTimer();\n  }\n  cancelSuspendTimer() {\n    this.states.connecting.failState = \"disconnected\";\n    if (this.suspendTimer) {\n      clearTimeout(this.suspendTimer);\n      this.suspendTimer = null;\n    }\n  }\n  startRetryTimer(interval) {\n    this.retryTimer = setTimeout(() => {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager retry timer expired\", \"retrying\");\n      this.retryTimer = null;\n      this.requestState({ state: \"connecting\" });\n    }, interval);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  startWebSocketSlowTimer() {\n    this.webSocketSlowTimer = setTimeout(() => {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager WebSocket slow timer\",\n        \"checking connectivity\"\n      );\n      this.checkWsConnectivity().then(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check succeeded\"\n        );\n        this.wsCheckResult = true;\n      }).catch(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check failed\"\n        );\n        this.wsCheckResult = false;\n      });\n      if (this.realtime.http.checkConnectivity) {\n        whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n          if (err || !connectivity) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MAJOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check failed\"\n            );\n            this.cancelWebSocketGiveUpTimer();\n            this.notifyState({\n              state: \"disconnected\",\n              error: new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404)\n            });\n          } else {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check succeeded\"\n            );\n          }\n        });\n      }\n    }, this.options.timeouts.webSocketSlowTimeout);\n  }\n  cancelWebSocketSlowTimer() {\n    if (this.webSocketSlowTimer) {\n      clearTimeout(this.webSocketSlowTimer);\n      this.webSocketSlowTimer = null;\n    }\n  }\n  startWebSocketGiveUpTimer(transportParams) {\n    this.webSocketGiveUpTimer = setTimeout(() => {\n      var _a2, _b;\n      if (!this.wsCheckResult) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket give up timer\",\n          \"websocket connection took more than 10s; \" + (this.baseTransport ? \"trying base transport\" : \"\")\n        );\n        if (this.baseTransport) {\n          this.abandonedWebSocket = true;\n          (_a2 = this.proposedTransport) == null ? void 0 : _a2.dispose();\n          (_b = this.pendingTransport) == null ? void 0 : _b.dispose();\n          this.connectBase(transportParams, ++this.connectCounter);\n        } else {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"ConnectionManager WebSocket give up timer\",\n            \"websocket connectivity appears to be unavailable but no other transports to try\"\n          );\n        }\n      }\n    }, this.options.timeouts.webSocketConnectTimeout);\n  }\n  cancelWebSocketGiveUpTimer() {\n    if (this.webSocketGiveUpTimer) {\n      clearTimeout(this.webSocketGiveUpTimer);\n      this.webSocketGiveUpTimer = null;\n    }\n  }\n  notifyState(indicated) {\n    var _a2, _b;\n    const state = indicated.state;\n    const retryImmediately = state === \"disconnected\" && (this.state === this.states.connected || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && auth_default.isTokenErr(indicated.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason)));\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.notifyState()\",\n      \"new state: \" + state + (retryImmediately ? \"; will retry connection immediately\" : \"\")\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.checkSuspendTimer(indicated.state);\n    if (state === \"suspended\" || state === \"connected\") {\n      this.disconnectedRetryCount = 0;\n    }\n    if (this.state.terminal)\n      return;\n    const newState = this.states[indicated.state];\n    let retryDelay = newState.retryDelay;\n    if (newState.state === \"disconnected\") {\n      this.disconnectedRetryCount++;\n      retryDelay = getRetryTime(newState.retryDelay, this.disconnectedRetryCount);\n    }\n    const change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      retryDelay,\n      indicated.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    if (retryImmediately) {\n      const autoReconnect = () => {\n        if (this.state === this.states.disconnected) {\n          this.lastAutoReconnectAttempt = Date.now();\n          this.requestState({ state: \"connecting\" });\n        }\n      };\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\n      if (sinceLast && sinceLast < 1e3) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.notifyState()\",\n          \"Last reconnect attempt was only \" + sinceLast + \"ms ago, waiting another \" + (1e3 - sinceLast) + \"ms before trying again\"\n        );\n        setTimeout(autoReconnect, 1e3 - sinceLast);\n      } else {\n        Platform.Config.nextTick(autoReconnect);\n      }\n    } else if (state === \"disconnected\" || state === \"suspended\") {\n      this.startRetryTimer(retryDelay);\n    }\n    if (state === \"disconnected\" && !retryImmediately || state === \"suspended\" || newState.terminal) {\n      Platform.Config.nextTick(() => {\n        this.disconnectAllTransports();\n      });\n    }\n    if (state == \"connected\" && !this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.notifyState()\",\n        \"Broken invariant: attempted to go into connected state, but there is no active protocol\"\n      );\n    }\n    this.enactStateChange(change);\n    if (this.state.sendEvents) {\n      this.sendQueuedMessages();\n    } else if (!this.state.queueEvents) {\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n      this.failQueuedMessages(change.reason);\n    }\n  }\n  requestState(request) {\n    var _a2, _b;\n    const state = request.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.requestState()\",\n      \"requested state: \" + state + \"; current state: \" + this.state.state\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.checkSuspendTimer(state);\n    if (state == \"connecting\" && this.state.state == \"connected\")\n      return;\n    if (state == \"closing\" && this.state.state == \"closed\")\n      return;\n    const newState = this.states[state], change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      null,\n      request.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    this.enactStateChange(change);\n    if (state == \"connecting\") {\n      Platform.Config.nextTick(() => {\n        this.startConnect();\n      });\n    }\n    if (state == \"closing\") {\n      this.closeImpl();\n    }\n  }\n  startConnect() {\n    if (this.state !== this.states.connecting) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startConnect()\",\n        \"Must be in connecting state to connect, but was \" + this.state.state\n      );\n      return;\n    }\n    const auth = this.realtime.auth;\n    const connectCount = ++this.connectCounter;\n    const connect = () => {\n      this.checkConnectionStateFreshness();\n      this.getTransportParams((transportParams) => {\n        if (transportParams.mode === \"recover\" && transportParams.options.recover) {\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n          if (recoveryContext) {\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n          }\n        }\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        this.connectImpl(transportParams, connectCount);\n      });\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.startConnect()\", \"starting connection\");\n    this.startSuspendTimer();\n    this.startTransitionTimer(this.states.connecting);\n    if (auth.method === \"basic\") {\n      connect();\n    } else {\n      const authCb = (err) => {\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        if (err) {\n          this.actOnErrorFromAuthorize(err);\n        } else {\n          connect();\n        }\n      };\n      if (this.errorReason && auth_default.isTokenErr(this.errorReason)) {\n        whenPromiseSettles(auth._forceNewToken(null, null), authCb);\n      } else {\n        whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\n      }\n    }\n  }\n  /*\n   * there are, at most, two transports available with which a connection may\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\n   * comet in nodejs). web_socket is always preferred, and the base transport is\n   * only used in case web_socket connectivity appears to be unavailable.\n   *\n   * connectImpl begins the transport selection process by checking which transports\n   * are available, and if there is a cached preference. It then defers to the\n   * transport-specific connect methods: connectWs and connectBase.\n   *\n   * It is also responsible for invalidating the cache in the case that a base\n   * transport preference is stored but web socket connectivity is now available.\n   *\n   * handling of the case where we need to failover from web_socket to the base\n   * transport is implemented in the connectWs method.\n   */\n  connectImpl(transportParams, connectCount) {\n    const state = this.state.state;\n    if (state !== this.states.connecting.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.connectImpl()\",\n        \"Must be in connecting state to connect, but was \" + state\n      );\n      return;\n    }\n    const transportPreference = this.getTransportPreference();\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\n      this.checkWsConnectivity().then(() => {\n        this.unpersistTransportPreference();\n        if (this.state === this.states.connecting) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.connectImpl():\",\n            \"web socket connectivity available, cancelling connection attempt with \" + this.baseTransport\n          );\n          this.disconnectAllTransports();\n          this.connectWs(transportParams, ++this.connectCounter);\n        }\n      }).catch(noop2);\n    }\n    if (transportPreference && transportPreference === this.baseTransport || this.baseTransport && !this.webSocketTransportAvailable) {\n      this.connectBase(transportParams, connectCount);\n    } else {\n      this.connectWs(transportParams, connectCount);\n    }\n  }\n  /*\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\n   *   connectivity check fails, we give up the connection sequence entirely and\n   *   transition to disconnected. if the websocket connectivity check fails then\n   *   we assume no ws connectivity and failover to base transport. in the case that\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\n   *   and, if unsuccessful, ultimately transition to disconnected.\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\n   *   connectivity check is still pending then we assume that there is an issue\n   *   with the transport and fallback to base transport.\n   */\n  connectWs(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectWs()\");\n    this.wsCheckResult = null;\n    this.abandonedWebSocket = false;\n    this.startWebSocketSlowTimer();\n    this.startWebSocketGiveUpTimer(transportParams);\n    this.tryTransportWithFallbacks(\"web_socket\", transportParams, true, connectCount, () => {\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\n    });\n  }\n  connectBase(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectBase()\");\n    if (this.baseTransport) {\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\n    } else {\n      this.notifyState({\n        state: \"disconnected\",\n        error: new ErrorInfo(\"No transports left to try\", 8e4, 404)\n      });\n    }\n  }\n  tryTransportWithFallbacks(transportName, transportParams, ws, connectCount, shouldContinue) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.tryTransportWithFallbacks()\",\n      transportName\n    );\n    const giveUp = (err) => {\n      this.notifyState({ state: this.states.connecting.failState, error: err });\n    };\n    const candidateHosts = this.domains.slice();\n    const hostAttemptCb = (fatal, transport) => {\n      if (connectCount !== this.connectCounter) {\n        return;\n      }\n      if (!shouldContinue()) {\n        if (transport) {\n          transport.dispose();\n        }\n        return;\n      }\n      if (!transport && !fatal) {\n        tryFallbackHosts();\n      }\n    };\n    const host = candidateHosts.shift();\n    if (!host) {\n      giveUp(new ErrorInfo(\"Unable to connect (no available host)\", 80003, 404));\n      return;\n    }\n    transportParams.host = host;\n    const tryFallbackHosts = () => {\n      if (!candidateHosts.length) {\n        giveUp(new ErrorInfo(\"Unable to connect (and no more fallback hosts to try)\", 80003, 404));\n        return;\n      }\n      if (!this.realtime.http.checkConnectivity) {\n        giveUp(new PartialErrorInfo(\"Internal error: Http.checkConnectivity not set\", null, 500));\n        return;\n      }\n      whenPromiseSettles(\n        this.realtime.http.checkConnectivity(),\n        (err, connectivity) => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (!shouldContinue()) {\n            return;\n          }\n          if (err) {\n            giveUp(err);\n            return;\n          }\n          if (!connectivity) {\n            giveUp(new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404));\n            return;\n          }\n          transportParams.host = arrPopRandomElement(candidateHosts);\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\n        }\n      );\n    };\n    if (this.forceFallbackHost && candidateHosts.length) {\n      this.forceFallbackHost = false;\n      tryFallbackHosts();\n      return;\n    }\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\n  }\n  closeImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.closeImpl()\", \"closing connection\");\n    this.cancelSuspendTimer();\n    this.startTransitionTimer(this.states.closing);\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.close();\n    }\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().close();\n    }\n    this.notifyState({ state: \"closed\" });\n  }\n  onAuthUpdated(tokenDetails, callback) {\n    var _a2;\n    switch (this.state.state) {\n      case \"connected\": {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Sending AUTH message on active transport\"\n        );\n        const activeTransport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n        if (activeTransport && activeTransport.onAuthUpdated) {\n          activeTransport.onAuthUpdated(tokenDetails);\n        }\n        const authMsg = fromValues({\n          action: actions.AUTH,\n          auth: {\n            accessToken: tokenDetails.token\n          }\n        });\n        this.send(authMsg);\n        const successListener = () => {\n          this.off(failureListener);\n          callback(null, tokenDetails);\n        };\n        const failureListener = (stateChange) => {\n          if (stateChange.current === \"failed\") {\n            this.off(successListener);\n            this.off(failureListener);\n            callback(stateChange.reason || this.getStateError());\n          }\n        };\n        this.once(\"connectiondetails\", successListener);\n        this.on(\"connectionstate\", failureListener);\n        break;\n      }\n      case \"connecting\":\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Aborting current connection attempts in order to start again with the new auth details\"\n        );\n        this.disconnectAllTransports();\n      default: {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Connection state is \" + this.state.state + \"; waiting until either connected or failed\"\n        );\n        const listener = (stateChange) => {\n          switch (stateChange.current) {\n            case \"connected\":\n              this.off(listener);\n              callback(null, tokenDetails);\n              break;\n            case \"failed\":\n            case \"closed\":\n            case \"suspended\":\n              this.off(listener);\n              callback(stateChange.reason || this.getStateError());\n              break;\n            default:\n              break;\n          }\n        };\n        this.on(\"connectionstate\", listener);\n        if (this.state.state === \"connecting\") {\n          this.startConnect();\n        } else {\n          this.requestState({ state: \"connecting\" });\n        }\n      }\n    }\n  }\n  disconnectAllTransports() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.disconnectAllTransports()\",\n      \"Disconnecting all transports\"\n    );\n    this.connectCounter++;\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.proposedTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting proposed transport: \" + this.pendingTransport\n      );\n      this.proposedTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().disconnect();\n    }\n  }\n  /******************\n   * event queueing\n   ******************/\n  send(msg, queueEvent, callback) {\n    callback = callback || noop2;\n    const state = this.state;\n    if (state.sendEvents) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", \"sending event\");\n      this.sendImpl(new PendingMessage(msg, callback));\n      return;\n    }\n    const shouldQueue = queueEvent && state.queueEvents;\n    if (!shouldQueue) {\n      const err = \"rejecting event, queueEvent was \" + queueEvent + \", state was \" + state.state;\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", err);\n      callback(this.errorReason || new ErrorInfo(err, 9e4, 400));\n      return;\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.send()\",\n        \"queueing msg; \" + stringify(\n          msg,\n          this.realtime._RealtimePresence,\n          this.realtime._Annotations,\n          this.realtime._liveObjectsPlugin\n        )\n      );\n    }\n    this.queue(msg, callback);\n  }\n  sendImpl(pendingMessage) {\n    const msg = pendingMessage.message;\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n      msg.msgSerial = this.msgSerial++;\n    }\n    try {\n      this.activeProtocol.send(pendingMessage);\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.sendImpl()\",\n        \"Unexpected exception in transport.send(): \" + e.stack\n      );\n    }\n  }\n  queue(msg, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.queue()\", \"queueing event\");\n    this.queuedMessages.push(new PendingMessage(msg, callback));\n  }\n  sendQueuedMessages() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.sendQueuedMessages()\",\n      \"sending \" + this.queuedMessages.count() + \" queued messages\"\n    );\n    let pendingMessage;\n    while (pendingMessage = this.queuedMessages.shift())\n      this.sendImpl(pendingMessage);\n  }\n  queuePendingMessages(pendingMessages) {\n    if (pendingMessages && pendingMessages.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.queuePendingMessages()\",\n        \"queueing \" + pendingMessages.length + \" pending messages\"\n      );\n      this.queuedMessages.prepend(pendingMessages);\n    }\n  }\n  failQueuedMessages(err) {\n    const numQueued = this.queuedMessages.count();\n    if (numQueued > 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.failQueuedMessages()\",\n        \"failing \" + numQueued + \" queued messages, err = \" + inspectError(err)\n      );\n      this.queuedMessages.completeAllMessages(err);\n    }\n  }\n  onChannelMessage(message, transport) {\n    this.pendingChannelMessagesState.queue.push({ message, transport });\n    if (!this.pendingChannelMessagesState.isProcessing) {\n      this.processNextPendingChannelMessage();\n    }\n  }\n  processNextPendingChannelMessage() {\n    if (this.pendingChannelMessagesState.queue.length > 0) {\n      this.pendingChannelMessagesState.isProcessing = true;\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift();\n      this.processChannelMessage(pendingChannelMessage.message).catch((err) => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.processNextPendingChannelMessage() received error \",\n          err\n        );\n      }).finally(() => {\n        this.pendingChannelMessagesState.isProcessing = false;\n        this.processNextPendingChannelMessage();\n      });\n    }\n  }\n  async processChannelMessage(message) {\n    await this.realtime.channels.processChannelMessage(message);\n  }\n  async ping() {\n    var _a2;\n    if (this.state.state !== \"connected\") {\n      throw new ErrorInfo(\"Unable to ping service; not connected\", 4e4, 400);\n    }\n    const transport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n    if (!transport) {\n      throw this.getStateError();\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.ping()\", \"transport = \" + transport);\n    const pingStart = Date.now();\n    const id = cheapRandStr();\n    return withTimeoutAsync(\n      new Promise((resolve) => {\n        const onHeartbeat = (responseId) => {\n          if (responseId === id) {\n            transport.off(\"heartbeat\", onHeartbeat);\n            resolve(Date.now() - pingStart);\n          }\n        };\n        transport.on(\"heartbeat\", onHeartbeat);\n        transport.ping(id);\n      }),\n      this.options.timeouts.realtimeRequestTimeout,\n      \"Timeout waiting for heartbeat response\"\n    );\n  }\n  abort(error) {\n    this.activeProtocol.getTransport().fail(error);\n  }\n  getTransportPreference() {\n    var _a2, _b;\n    return this.transportPreference || haveWebStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.get) == null ? void 0 : _b.call(_a2, transportPreferenceName));\n  }\n  persistTransportPreference(transport) {\n    var _a2, _b;\n    this.transportPreference = transport.shortName;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(_a2, transportPreferenceName, transport.shortName);\n    }\n  }\n  unpersistTransportPreference() {\n    var _a2, _b;\n    this.transportPreference = null;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, transportPreferenceName);\n    }\n  }\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n   * server returns 403. */\n  actOnErrorFromAuthorize(err) {\n    if (err.code === 40171) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.code === 40102) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.statusCode === HttpStatusCodes_default.Forbidden) {\n      const msg = \"Client configured authentication provider returned 403; failing the connection\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.actOnErrorFromAuthorize()\", msg);\n      this.notifyState({ state: \"failed\", error: new ErrorInfo(msg, 80019, 403, err) });\n    } else {\n      const msg = \"Client configured authentication provider request failed\";\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.actOnErrorFromAuthorize\", msg);\n      this.notifyState({ state: this.state.failState, error: new ErrorInfo(msg, 80019, 401, err) });\n    }\n  }\n  onConnectionDetailsUpdate(connectionDetails, transport) {\n    if (!connectionDetails) {\n      return;\n    }\n    this.connectionDetails = connectionDetails;\n    if (connectionDetails.maxMessageSize) {\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\n    }\n    const clientId = connectionDetails.clientId;\n    if (clientId) {\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\n      if (err) {\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.onConnectionDetailsUpdate()\", err.message);\n        transport.fail(err);\n        return;\n      }\n    }\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\n    if (connectionStateTtl) {\n      this.connectionStateTtl = connectionStateTtl;\n    }\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\n    this.emit(\"connectiondetails\", connectionDetails);\n  }\n  checkWsConnectivity() {\n    const wsConnectivityCheckUrl = this.options.wsConnectivityCheckUrl || defaults_default.wsConnectivityCheckUrl;\n    const ws = new Platform.Config.WebSocket(wsConnectivityCheckUrl);\n    return new Promise((resolve, reject) => {\n      let finished = false;\n      ws.onopen = () => {\n        if (!finished) {\n          finished = true;\n          resolve();\n          ws.close();\n        }\n      };\n      ws.onclose = ws.onerror = () => {\n        if (!finished) {\n          finished = true;\n          reject();\n        }\n      };\n    });\n  }\n  sessionRecoveryName() {\n    return this.options.recoveryKeyStorageName || \"ably-connection-recovery\";\n  }\n  getSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.getSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n  setSessionRecoverData(value) {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.setSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName(), value));\n  }\n  clearSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.removeSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n};\nvar connectionmanager_default = ConnectionManager;\n\n// src/common/lib/client/connection.ts\nvar Connection = class extends eventemitter_default {\n  constructor(ably, options) {\n    super(ably.logger);\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    this.ably = ably;\n    this.connectionManager = new connectionmanager_default(ably, options);\n    this.state = this.connectionManager.state.state;\n    this.key = void 0;\n    this.id = void 0;\n    this.errorReason = null;\n    this.connectionManager.on(\"connectionstate\", (stateChange) => {\n      const state = this.state = stateChange.current;\n      Platform.Config.nextTick(() => {\n        this.emit(state, stateChange);\n      });\n    });\n    this.connectionManager.on(\"update\", (stateChange) => {\n      Platform.Config.nextTick(() => {\n        this.emit(\"update\", stateChange);\n      });\n    });\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.connect()\", \"\");\n    this.connectionManager.requestState({ state: \"connecting\" });\n  }\n  async ping() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.ping()\", \"\");\n    return this.connectionManager.ping();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.close()\", \"connectionKey = \" + this.key);\n    this.connectionManager.requestState({ state: \"closing\" });\n  }\n  get recoveryKey() {\n    this.logger.deprecationWarning(\n      \"The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.\"\n    );\n    return this.createRecoveryKey();\n  }\n  createRecoveryKey() {\n    return this.connectionManager.createRecoveryKey();\n  }\n};\nvar connection_default = Connection;\n\n// src/common/lib/client/baserealtime.ts\nvar _BaseRealtime = class _BaseRealtime extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    var _a2, _b, _c, _d;\n    super(defaults_default.objectifyOptions(options, false, \"BaseRealtime\", logger_default.defaultLogger));\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime()\", \"\");\n    if (typeof EdgeRuntime === \"string\") {\n      throw new ErrorInfo(\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime. If you are running Vercel Edge functions, please replace your \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API instead of the Realtime API. If you are server-rendering your application in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\" to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\n        4e4,\n        400\n      );\n    }\n    this._additionalTransportImplementations = _BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\n    this._RealtimePresence = (_b = (_a2 = this.options.plugins) == null ? void 0 : _a2.RealtimePresence) != null ? _b : null;\n    this._liveObjectsPlugin = (_d = (_c = this.options.plugins) == null ? void 0 : _c.LiveObjects) != null ? _d : null;\n    this.connection = new connection_default(this, this.options);\n    this._channels = new Channels2(this);\n    if (this.options.autoConnect !== false)\n      this.connect();\n  }\n  static transportImplementationsFromPlugins(plugins) {\n    const transports = {};\n    if (plugins == null ? void 0 : plugins.WebSocketTransport) {\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\n    }\n    if (plugins == null ? void 0 : plugins.XHRPolling) {\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\n    }\n    return transports;\n  }\n  get channels() {\n    return this._channels;\n  }\n  get clientId() {\n    return this.auth.clientId;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.connect()\", \"\");\n    this.connection.connect();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.close()\", \"\");\n    this.connection.close();\n  }\n};\n// internal API to make EventEmitter usable in other SDKs\n_BaseRealtime.EventEmitter = eventemitter_default;\nvar BaseRealtime = _BaseRealtime;\nvar Channels2 = class extends eventemitter_default {\n  constructor(realtime) {\n    super(realtime.logger);\n    this.realtime = realtime;\n    this.all = /* @__PURE__ */ Object.create(null);\n    realtime.connection.connectionManager.on(\"transport.active\", () => {\n      this.onTransportActive();\n    });\n  }\n  channelSerials() {\n    let serials = {};\n    for (const name of keysArray(this.all, true)) {\n      const channel = this.all[name];\n      if (channel.properties.channelSerial) {\n        serials[name] = channel.properties.channelSerial;\n      }\n    }\n    return serials;\n  }\n  // recoverChannels gets the given channels and sets their channel serials.\n  recoverChannels(channelSerials) {\n    for (const name of keysArray(channelSerials, true)) {\n      const channel = this.get(name);\n      channel.properties.channelSerial = channelSerials[name];\n    }\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\n  async processChannelMessage(msg) {\n    const channelName = msg.channel;\n    if (channelName === void 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event unspecified channel, action = \" + msg.action\n      );\n      return;\n    }\n    const channel = this.all[channelName];\n    if (!channel) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event for non-existent channel: \" + channelName\n      );\n      return;\n    }\n    await channel.processMessage(msg);\n  }\n  /* called when a transport becomes connected; reattempt attach/detach\n   * for channels that are attaching or detaching. */\n  onTransportActive() {\n    for (const channelName in this.all) {\n      const channel = this.all[channelName];\n      if (channel.state === \"attaching\" || channel.state === \"detaching\") {\n        channel.checkPendingState();\n      } else if (channel.state === \"suspended\") {\n        channel._attach(false, null);\n      } else if (channel.state === \"attached\") {\n        channel.requestState(\"attaching\");\n      }\n    }\n  }\n  /* Connection interruptions (ie when the connection will no longer queue\n   * events) imply connection state changes for any channel which is either\n   * attached, pending, or will attempt to become attached in the future */\n  propogateConnectionInterruption(connectionState, reason) {\n    const connectionStateToChannelState = {\n      closing: \"detached\",\n      closed: \"detached\",\n      failed: \"failed\",\n      suspended: \"suspended\"\n    };\n    const fromChannelStates = [\"attaching\", \"attached\", \"detaching\", \"suspended\"];\n    const toChannelState = connectionStateToChannelState[connectionState];\n    for (const channelId in this.all) {\n      const channel = this.all[channelId];\n      if (fromChannelStates.includes(channel.state)) {\n        channel.notifyState(toChannelState, reason);\n      }\n    }\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      channel = this.all[name] = new realtimechannel_default(this.realtime, name, channelOptions);\n    } else if (channelOptions) {\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n        throw new ErrorInfo(\n          \"Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.\",\n          4e4,\n          400\n        );\n      }\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  getDerived(name, deriveOptions, channelOptions) {\n    if (deriveOptions.filter) {\n      const filter = toBase64(deriveOptions.filter);\n      const match = matchDerivedChannel(name);\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\n    }\n    return this.get(name, channelOptions);\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    name = String(name);\n    const channel = this.all[name];\n    if (!channel) {\n      return;\n    }\n    const releaseErr = channel.getReleaseErr();\n    if (releaseErr) {\n      throw releaseErr;\n    }\n    delete this.all[name];\n  }\n};\nvar baserealtime_default = BaseRealtime;\n\n// src/common/lib/client/presencemap.ts\nfunction newerThan(item, existing) {\n  if (item.isSynthesized() || existing.isSynthesized()) {\n    return item.timestamp >= existing.timestamp;\n  }\n  const itemOrderings = item.parseId(), existingOrderings = existing.parseId();\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n    return itemOrderings.index > existingOrderings.index;\n  } else {\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\n  }\n}\nvar PresenceMap = class extends eventemitter_default {\n  constructor(presence, memberKey, newer = newerThan) {\n    super(presence.logger);\n    this.presence = presence;\n    this.map = /* @__PURE__ */ Object.create(null);\n    this.syncInProgress = false;\n    this.residualMembers = null;\n    this.memberKey = memberKey;\n    this.newerThan = newer;\n  }\n  get(key) {\n    return this.map[key];\n  }\n  getClient(clientId) {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.clientId == clientId && item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  list(params) {\n    const map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action === \"absent\")\n        continue;\n      if (clientId && clientId != item.clientId)\n        continue;\n      if (connectionId && connectionId != item.connectionId)\n        continue;\n      result.push(item);\n    }\n    return result;\n  }\n  put(item) {\n    if (item.action === \"enter\" || item.action === \"update\") {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"present\";\n    }\n    const map = this.map, key = this.memberKey(item);\n    if (this.residualMembers)\n      delete this.residualMembers[key];\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    map[key] = item;\n    return true;\n  }\n  values() {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  remove(item) {\n    const map = this.map, key = this.memberKey(item);\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    if (this.syncInProgress) {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"absent\";\n      map[key] = item;\n    } else {\n      delete map[key];\n    }\n    return !!existingItem;\n  }\n  startSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.startSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!this.syncInProgress) {\n      this.residualMembers = copy(map);\n      this.setInProgress(true);\n    }\n  }\n  endSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.endSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (syncInProgress) {\n      for (const memberKey in map) {\n        const entry = map[memberKey];\n        if (entry.action === \"absent\") {\n          delete map[memberKey];\n        }\n      }\n      this.presence._synthesizeLeaves(valuesArray(this.residualMembers));\n      for (const memberKey in this.residualMembers) {\n        delete map[memberKey];\n      }\n      this.residualMembers = null;\n      this.setInProgress(false);\n    }\n    this.emit(\"sync\");\n  }\n  async waitSync() {\n    const syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.waitSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!syncInProgress) {\n      return;\n    }\n    await this.once(\"sync\");\n  }\n  clear() {\n    this.map = {};\n    this.setInProgress(false);\n    this.residualMembers = null;\n  }\n  setInProgress(inProgress) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"PresenceMap.setInProgress()\", \"inProgress = \" + inProgress);\n    this.syncInProgress = inProgress;\n    this.presence.syncComplete = !inProgress;\n  }\n};\n\n// src/common/lib/client/realtimepresence.ts\nfunction getClientId(realtimePresence) {\n  return realtimePresence.channel.client.auth.clientId;\n}\nfunction isAnonymousOrWildcard(realtimePresence) {\n  const realtime = realtimePresence.channel.client;\n  const clientId = realtime.auth.clientId;\n  return (!clientId || clientId === \"*\") && realtime.connection.state === \"connected\";\n}\nvar RealtimePresence = class extends eventemitter_default {\n  constructor(channel) {\n    super(channel.logger);\n    this.channel = channel;\n    this.syncComplete = false;\n    this.members = new PresenceMap(this, (item) => item.clientId + \":\" + item.connectionId);\n    this._myMembers = new PresenceMap(this, (item) => item.clientId);\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.pendingPresence = [];\n  }\n  async enter(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to enter a presence channel\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"enter\");\n  }\n  async update(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to update presence data\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"update\");\n  }\n  async enterClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"enter\");\n  }\n  async updateClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"update\");\n  }\n  async _enterOrUpdateClient(id, clientId, data, action) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.\" + action + \"Client()\",\n      \"channel = \" + channel.name + \", id = \" + id + \", client = \" + (clientId || \"(implicit) \" + getClientId(this))\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = action;\n    if (id) {\n      presence.id = id;\n    }\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"initialized\":\n      case \"detached\":\n        channel.attach();\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      default: {\n        const err = new PartialErrorInfo(\n          \"Unable to \" + action + \" presence channel while in \" + channel.state + \" state\",\n          90001\n        );\n        err.code = 90001;\n        throw err;\n      }\n    }\n  }\n  async leave(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must have been specified to enter or leave a presence channel\", 40012, 400);\n    }\n    return this.leaveClient(void 0, data);\n  }\n  async leaveClient(clientId, data) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.leaveClient()\",\n      \"leaving; channel = \" + this.channel.name + \", client = \" + clientId\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = \"leave\";\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      case \"initialized\":\n      case \"failed\": {\n        throw new PartialErrorInfo(\"Unable to leave presence channel (incompatible state)\", 90001);\n      }\n      default:\n        throw channel.invalidStateError();\n    }\n  }\n  async get(params) {\n    const waitForSync = !params || (\"waitForSync\" in params ? params.waitForSync : true);\n    function toMessages(members2) {\n      return params ? members2.list(params) : members2.values();\n    }\n    if (this.channel.state === \"suspended\") {\n      if (waitForSync) {\n        throw ErrorInfo.fromValues({\n          statusCode: 400,\n          code: 91005,\n          message: \"Presence state is out of sync due to channel being in the SUSPENDED state\"\n        });\n      }\n      return toMessages(this.members);\n    }\n    await this.channel.ensureAttached();\n    const members = this.members;\n    if (waitForSync) {\n      await members.waitSync();\n    }\n    return toMessages(this.members);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimePresence.history()\", \"channel = \" + this.name);\n    const restMixin = this.channel.client.rest.presenceMixin;\n    if (params && params.untilAttach) {\n      if (this.channel.state === \"attached\") {\n        delete params.untilAttach;\n        params.from_serial = this.channel.properties.attachSerial;\n      } else {\n        throw new ErrorInfo(\n          \"option untilAttach requires the channel to be attached, was: \" + this.channel.state,\n          4e4,\n          400\n        );\n      }\n    }\n    return restMixin.history(this, params);\n  }\n  setPresence(presenceSet, isSync, syncChannelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.setPresence()\",\n      \"received presence for \" + presenceSet.length + \" participants; syncChannelSerial = \" + syncChannelSerial\n    );\n    let syncCursor, match;\n    const members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;\n    if (isSync) {\n      this.members.startSync();\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n        syncCursor = match[1];\n      }\n    }\n    for (let presence of presenceSet) {\n      switch (presence.action) {\n        case \"leave\":\n          if (members.remove(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\n            myMembers.remove(presence);\n          }\n          break;\n        case \"enter\":\n        case \"present\":\n        case \"update\":\n          if (members.put(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId) {\n            myMembers.put(presence);\n          }\n          break;\n      }\n    }\n    if (isSync && !syncCursor) {\n      members.endSync();\n      this.channel.syncChannelSerial = null;\n    }\n    for (let i = 0; i < broadcastMessages.length; i++) {\n      const presence = broadcastMessages[i];\n      this.subscriptions.emit(presence.action, presence);\n    }\n  }\n  onAttached(hasPresence) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimePresence.onAttached()\",\n      \"channel = \" + this.channel.name + \", hasPresence = \" + hasPresence\n    );\n    if (hasPresence) {\n      this.members.startSync();\n    } else {\n      this._synthesizeLeaves(this.members.values());\n      this.members.clear();\n    }\n    this._ensureMyMembersPresent();\n    const pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;\n    if (pendingPresCount) {\n      this.pendingPresence = [];\n      const presenceArray = [];\n      const multicaster = multicaster_default.create(this.logger);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence.onAttached\",\n        \"sending \" + pendingPresCount + \" queued presence messages\"\n      );\n      for (let i = 0; i < pendingPresCount; i++) {\n        const event = pendingPresence[i];\n        presenceArray.push(event.presence);\n        multicaster.push(event.callback);\n      }\n      this.channel.sendPresence(presenceArray).then(() => multicaster()).catch((err) => multicaster(err));\n    }\n  }\n  actOnChannelState(state, hasPresence, err) {\n    switch (state) {\n      case \"attached\":\n        this.onAttached(hasPresence);\n        break;\n      case \"detached\":\n      case \"failed\":\n        this._clearMyMembers();\n        this.members.clear();\n      case \"suspended\":\n        this.failPendingPresence(err);\n        break;\n    }\n  }\n  failPendingPresence(err) {\n    if (this.pendingPresence.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.failPendingPresence\",\n        \"channel; name = \" + this.channel.name + \", err = \" + inspectError(err)\n      );\n      for (let i = 0; i < this.pendingPresence.length; i++)\n        try {\n          this.pendingPresence[i].callback(err);\n        } catch (e) {\n        }\n      this.pendingPresence = [];\n    }\n  }\n  _clearMyMembers() {\n    this._myMembers.clear();\n  }\n  _ensureMyMembersPresent() {\n    const myMembers = this._myMembers;\n    const connId = this.channel.connectionManager.connectionId;\n    for (const memberKey in myMembers.map) {\n      const entry = myMembers.map[memberKey];\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence._ensureMyMembersPresent()\",\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set'\n      );\n      const id = entry.connectionId === connId ? entry.id : void 0;\n      this._enterOrUpdateClient(id, entry.clientId, entry.data, \"enter\").catch((err) => {\n        const wrappedErr = new ErrorInfo(\"Presence auto re-enter failed\", 91004, 400, err);\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"RealtimePresence._ensureMyMembersPresent()\",\n          \"Presence auto re-enter failed; reason = \" + inspectError(err)\n        );\n        const change = new channelstatechange_default(this.channel.state, this.channel.state, true, false, wrappedErr);\n        this.channel.emit(\"update\", change);\n      });\n    }\n  }\n  _synthesizeLeaves(items) {\n    const subscriptions = this.subscriptions;\n    items.forEach(function(item) {\n      const presence = presencemessage_default.fromValues({\n        action: \"leave\",\n        connectionId: item.connectionId,\n        clientId: item.clientId,\n        data: item.data,\n        encoding: item.encoding,\n        timestamp: Date.now()\n      });\n      subscriptions.emit(\"leave\", presence);\n    });\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n};\nvar realtimepresence_default = RealtimePresence;\n\n// src/common/lib/transport/websockettransport.ts\nvar shortName = TransportNames.WebSocket;\nfunction isNodeWebSocket(ws) {\n  return !!ws.on;\n}\nvar WebSocketTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName;\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\n    this.wsHost = params.host;\n  }\n  static isAvailable() {\n    return !!Platform.Config.WebSocket;\n  }\n  createWebSocket(uri, connectParams) {\n    this.uri = uri + toQueryString(connectParams);\n    return new Platform.Config.WebSocket(this.uri);\n  }\n  toString() {\n    return \"WebSocketTransport; uri=\" + this.uri;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const self2 = this, params = this.params, options = params.options;\n    const wsScheme = options.tls ? \"wss://\" : \"ws://\";\n    const wsUri = wsScheme + this.wsHost + \":\" + defaults_default.getPort(options) + \"/\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"uri: \" + wsUri);\n    whenPromiseSettles(\n      this.auth.getAuthParams(),\n      function(err, authParams) {\n        if (self2.isDisposed) {\n          return;\n        }\n        let paramStr = \"\";\n        for (const param in authParams)\n          paramStr += \" \" + param + \": \" + authParams[param] + \";\";\n        logger_default.logAction(\n          self2.logger,\n          logger_default.LOG_MINOR,\n          \"WebSocketTransport.connect()\",\n          \"authParams:\" + paramStr + \" err: \" + err\n        );\n        if (err) {\n          self2.disconnect(err);\n          return;\n        }\n        const connectParams = params.getConnectParams(authParams);\n        try {\n          const wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);\n          wsConnection.binaryType = Platform.Config.binaryType;\n          wsConnection.onopen = function() {\n            self2.onWsOpen();\n          };\n          wsConnection.onclose = function(ev) {\n            self2.onWsClose(ev);\n          };\n          wsConnection.onmessage = function(ev) {\n            self2.onWsData(ev.data);\n          };\n          wsConnection.onerror = function(ev) {\n            self2.onWsError(ev);\n          };\n          if (isNodeWebSocket(wsConnection)) {\n            wsConnection.on(\"ping\", function() {\n              self2.onActivity();\n            });\n          }\n        } catch (e) {\n          logger_default.logAction(\n            self2.logger,\n            logger_default.LOG_ERROR,\n            \"WebSocketTransport.connect()\",\n            \"Unexpected exception creating websocket: err = \" + (e.stack || e.message)\n          );\n          self2.disconnect(e);\n        }\n      }\n    );\n  }\n  send(message) {\n    const wsConnection = this.wsConnection;\n    if (!wsConnection) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", \"No socket connection\");\n      return;\n    }\n    try {\n      wsConnection.send(\n        serialize2(message, this.connectionManager.realtime._MsgPack, this.params.format)\n      );\n    } catch (e) {\n      const msg = \"Exception from ws connection when trying to send: \" + inspectError(e);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", msg);\n      this.finish(\"disconnected\", new ErrorInfo(msg, 5e4, 500));\n    }\n  }\n  onWsData(data) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"WebSocketTransport.onWsData()\",\n      \"data received; length = \" + data.length + \"; type = \" + typeof data\n    );\n    try {\n      this.onProtocolMessage(\n        deserialize(\n          data,\n          this.connectionManager.realtime._MsgPack,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations,\n          this.connectionManager.realtime._liveObjectsPlugin,\n          this.format\n        )\n      );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"WebSocketTransport.onWsData()\",\n        \"Unexpected exception handing channel message: \" + e.stack\n      );\n    }\n  }\n  onWsOpen() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsOpen()\", \"opened WebSocket\");\n    this.emit(\"preconnect\");\n  }\n  onWsClose(ev) {\n    let wasClean, code;\n    if (typeof ev == \"object\") {\n      code = ev.code;\n      wasClean = ev.wasClean || code === 1e3;\n    } else {\n      code = ev;\n      wasClean = code == 1e3;\n    }\n    delete this.wsConnection;\n    if (wasClean) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", \"Cleanly closed WebSocket\");\n      const err = new ErrorInfo(\"Websocket closed\", 80003, 400);\n      this.finish(\"disconnected\", err);\n    } else {\n      const msg = \"Unclean disconnection of WebSocket ; code = \" + code, err = new ErrorInfo(msg, 80003, 400);\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", msg);\n      this.finish(\"disconnected\", err);\n    }\n    this.emit(\"disposed\");\n  }\n  onWsError(err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"WebSocketTransport.onError()\",\n      \"Error from WebSocket: \" + err.message\n    );\n    Platform.Config.nextTick(() => {\n      this.disconnect(Error(err.message));\n    });\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.dispose()\", \"\");\n    this.isDisposed = true;\n    const wsConnection = this.wsConnection;\n    if (wsConnection) {\n      wsConnection.onmessage = function() {\n      };\n      delete this.wsConnection;\n      Platform.Config.nextTick(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"WebSocketTransport.dispose()\", \"closing websocket\");\n        if (!wsConnection) {\n          throw new Error(\"WebSocketTransport.dispose(): wsConnection is not defined\");\n        }\n        wsConnection.close();\n      });\n    }\n  }\n};\nvar websockettransport_default = WebSocketTransport;\n\n// src/common/lib/client/filteredsubscriptions.ts\nvar FilteredSubscriptions = class {\n  static subscribeFilter(channel, filter, listener) {\n    const filteredListener = (m) => {\n      var _a2, _b, _c, _d, _e, _f;\n      const mapping = {\n        name: m.name,\n        refTimeserial: (_b = (_a2 = m.extras) == null ? void 0 : _a2.ref) == null ? void 0 : _b.timeserial,\n        refType: (_d = (_c = m.extras) == null ? void 0 : _c.ref) == null ? void 0 : _d.type,\n        isRef: !!((_f = (_e = m.extras) == null ? void 0 : _e.ref) == null ? void 0 : _f.timeserial),\n        clientId: m.clientId\n      };\n      if (Object.entries(filter).find(\n        ([key, value]) => value !== void 0 ? mapping[key] !== value : false\n      )) {\n        return;\n      }\n      listener(m);\n    };\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\n    channel.subscriptions.on(filteredListener);\n  }\n  // Adds a new filtered subscription\n  static addFilteredSubscription(channel, filter, realListener, filteredListener) {\n    var _a2;\n    if (!channel.filteredSubscriptions) {\n      channel.filteredSubscriptions = /* @__PURE__ */ new Map();\n    }\n    if (channel.filteredSubscriptions.has(realListener)) {\n      const realListenerMap = channel.filteredSubscriptions.get(realListener);\n      realListenerMap.set(filter, ((_a2 = realListenerMap == null ? void 0 : realListenerMap.get(filter)) == null ? void 0 : _a2.concat(filteredListener)) || [filteredListener]);\n    } else {\n      channel.filteredSubscriptions.set(\n        realListener,\n        /* @__PURE__ */ new Map([[filter, [filteredListener]]])\n      );\n    }\n  }\n  static getAndDeleteFilteredSubscriptions(channel, filter, realListener) {\n    if (!channel.filteredSubscriptions) {\n      return [];\n    }\n    if (!realListener && filter) {\n      return Array.from(channel.filteredSubscriptions.entries()).map(([key, filterMaps]) => {\n        var _a2;\n        let listenerMaps = filterMaps.get(filter);\n        filterMaps.delete(filter);\n        if (filterMaps.size === 0) {\n          (_a2 = channel.filteredSubscriptions) == null ? void 0 : _a2.delete(key);\n        }\n        return listenerMaps;\n      }).reduce(\n        (prev, cur) => cur ? prev.concat(...cur) : prev,\n        []\n      );\n    }\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\n      return [];\n    }\n    const realListenerMap = channel.filteredSubscriptions.get(realListener);\n    if (!filter) {\n      const listeners2 = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\n      channel.filteredSubscriptions.delete(realListener);\n      return listeners2;\n    }\n    let listeners = realListenerMap.get(filter);\n    realListenerMap.delete(filter);\n    return listeners || [];\n  }\n};\n\n// src/common/lib/client/defaultrealtime.ts\nvar _DefaultRealtime = class _DefaultRealtime extends baserealtime_default {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2;\n    const MsgPack = _DefaultRealtime._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRealtime._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Realtime\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRealtime.Crypto) != null ? _a2 : void 0,\n        MsgPack,\n        RealtimePresence: {\n          RealtimePresence: realtimepresence_default,\n          PresenceMessage: presencemessage_default,\n          WirePresenceMessage\n        },\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        },\n        WebSocketTransport: websockettransport_default,\n        MessageInteractions: FilteredSubscriptions\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRealtime.Utils = utils_exports;\n_DefaultRealtime.ConnectionManager = connectionmanager_default;\n_DefaultRealtime.ProtocolMessage = protocolmessage_default;\n_DefaultRealtime._Crypto = null;\n_DefaultRealtime.Message = DefaultMessage;\n_DefaultRealtime.PresenceMessage = DefaultPresenceMessage;\n_DefaultRealtime.Annotation = DefaultAnnotation;\n_DefaultRealtime._MsgPack = null;\n// Used by tests\n_DefaultRealtime._Http = Http;\n_DefaultRealtime._PresenceMap = PresenceMap;\n_DefaultRealtime._MessageEncoding = MessageEncoding;\nvar DefaultRealtime = _DefaultRealtime;\n\n// src/platform/nodejs/lib/util/bufferutils.ts\nvar import_crypto = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar BufferUtils = class {\n  constructor() {\n    this.base64CharSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    this.hexCharSet = \"0123456789abcdef\";\n  }\n  base64Decode(string) {\n    return Buffer.from(string, \"base64\");\n  }\n  base64Encode(buffer) {\n    return this.toBuffer(buffer).toString(\"base64\");\n  }\n  base64UrlEncode(buffer) {\n    return this.toBuffer(buffer).toString(\"base64url\");\n  }\n  areBuffersEqual(buffer1, buffer2) {\n    if (!buffer1 || !buffer2)\n      return false;\n    return this.toBuffer(buffer1).compare(this.toBuffer(buffer2)) == 0;\n  }\n  byteLength(buffer) {\n    return buffer.byteLength;\n  }\n  hexDecode(string) {\n    return Buffer.from(string, \"hex\");\n  }\n  hexEncode(buffer) {\n    return this.toBuffer(buffer).toString(\"hex\");\n  }\n  /* In node, BufferUtils methods that return binary objects return a Buffer\n   * for historical reasons; the browser equivalents return ArrayBuffers */\n  isBuffer(buffer) {\n    return Buffer.isBuffer(buffer) || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n  }\n  toArrayBuffer(buffer) {\n    const nodeBuffer = this.toBuffer(buffer);\n    return nodeBuffer.buffer.slice(nodeBuffer.byteOffset, nodeBuffer.byteOffset + nodeBuffer.byteLength);\n  }\n  toBuffer(buffer) {\n    if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return Buffer.from(buffer);\n    }\n    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  }\n  arrayBufferViewToBuffer(arrayBufferView) {\n    return this.toBuffer(arrayBufferView);\n  }\n  utf8Decode(buffer) {\n    if (!this.isBuffer(buffer)) {\n      throw new Error(\"Expected input of utf8Decode to be a buffer, arraybuffer, or view\");\n    }\n    return this.toBuffer(buffer).toString(\"utf8\");\n  }\n  utf8Encode(string) {\n    return Buffer.from(string, \"utf8\");\n  }\n  concat(buffers) {\n    return Buffer.concat(buffers.map((x) => this.toBuffer(x)));\n  }\n  sha256(message) {\n    const messageBuffer = this.toBuffer(message);\n    return import_crypto.default.createHash(\"SHA256\").update(messageBuffer).digest();\n  }\n  hmacSha256(message, key) {\n    const messageBuffer = this.toBuffer(message);\n    const keyBuffer = this.toBuffer(key);\n    return import_crypto.default.createHmac(\"SHA256\", keyBuffer).update(messageBuffer).digest();\n  }\n};\nvar bufferutils_default = new BufferUtils();\n\n// src/platform/nodejs/lib/util/crypto.ts\nvar import_crypto2 = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_util = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar createCryptoClass = function(bufferUtils) {\n  var DEFAULT_ALGORITHM = \"aes\";\n  var DEFAULT_KEYLENGTH = 256;\n  var DEFAULT_MODE = \"cbc\";\n  var DEFAULT_BLOCKLENGTH = 16;\n  async function generateRandom(bytes) {\n    return import_util.default.promisify(import_crypto2.default.randomBytes)(bytes);\n  }\n  function getPaddedLength(plaintextLength) {\n    return plaintextLength + DEFAULT_BLOCKLENGTH & -DEFAULT_BLOCKLENGTH;\n  }\n  function validateCipherParams(params) {\n    if (params.algorithm === \"aes\" && params.mode === \"cbc\") {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        \"Unsupported key length \" + params.keyLength + \" for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)\"\n      );\n    }\n  }\n  function normaliseBase64(string) {\n    return string.replace(\"_\", \"/\").replace(\"-\", \"+\");\n  }\n  function filledBuffer(length, value) {\n    var result = Buffer.alloc(length);\n    result.fill(value);\n    return result;\n  }\n  var pkcs5Padding = [filledBuffer(16, 16)];\n  for (var i = 1; i <= 16; i++)\n    pkcs5Padding.push(filledBuffer(i, i));\n  class CipherParams {\n    constructor(algorithm, keyLength, mode, key) {\n      this.algorithm = algorithm;\n      this.keyLength = keyLength;\n      this.mode = mode;\n      this.key = key;\n      this.iv = null;\n    }\n  }\n  function isInstCipherParams(params) {\n    return !!(params.algorithm && params.key && params.keyLength && params.mode);\n  }\n  class Crypto2 {\n    /**\n     * Obtain a complete CipherParams instance from the provided params, filling\n     * in any not provided with default values, calculating a keyLength from\n     * the supplied key, and validating the result.\n     * @param params an object containing at a minimum a `key` key with value the\n     * key, as either a binary or a base64-encoded string.\n     * May optionally also contain: algorithm (defaults to AES),\n     * mode (defaults to 'cbc')\n     */\n    static getDefaultParams(params) {\n      var key;\n      if (!params.key) {\n        throw new Error(\"Crypto.getDefaultParams: a key is required\");\n      }\n      if (typeof params.key === \"string\") {\n        key = bufferUtils.base64Decode(normaliseBase64(params.key));\n      } else if (params.key instanceof ArrayBuffer) {\n        key = Buffer.from(params.key);\n      } else {\n        key = params.key;\n      }\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n      var keyLength = key.length * 8;\n      var mode = params.mode || DEFAULT_MODE;\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n        throw new Error(\n          \"Crypto.getDefaultParams: a keyLength of \" + params.keyLength + \" was specified, but the key actually has length \" + cipherParams.keyLength\n        );\n      }\n      validateCipherParams(cipherParams);\n      return cipherParams;\n    }\n    /**\n     * Generate a random encryption key from the supplied keylength (or the\n     * default keyLength if none supplied) as a Buffer\n     * @param keyLength (optional) the required keyLength in bits\n     */\n    static async generateRandomKey(keyLength) {\n      try {\n        return generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8);\n      } catch (err) {\n        throw new ErrorInfo(\"Failed to generate random key: \" + err.message, 500, 5e4, err);\n      }\n    }\n    /**\n     * Internal; get a ChannelCipher instance based on the given cipherParams\n     * @param params either a CipherParams instance or some subset of its\n     * fields that includes a key\n     */\n    static getCipher(params, logger) {\n      var _a2;\n      var cipherParams = isInstCipherParams(params) ? params : this.getDefaultParams(params);\n      return {\n        cipherParams,\n        cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null, logger)\n      };\n    }\n  }\n  Crypto2.CipherParams = CipherParams;\n  Crypto2;\n  class CBCCipher {\n    constructor(params, iv, logger) {\n      this.logger = logger;\n      this.encryptCipher = null;\n      this.algorithm = params.algorithm + \"-\" + String(params.keyLength) + \"-\" + params.mode;\n      this.key = params.key;\n      this.iv = iv;\n    }\n    async encrypt(plaintext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.encrypt()\", \"\");\n      const iv = await this.getIv();\n      if (!this.encryptCipher) {\n        this.encryptCipher = import_crypto2.default.createCipheriv(this.algorithm, this.key, iv);\n      }\n      var plaintextBuffer = bufferUtils.toBuffer(plaintext);\n      var plaintextLength = plaintextBuffer.length, paddedLength = getPaddedLength(plaintextLength);\n      var cipherOut = this.encryptCipher.update(\n        Buffer.concat([plaintextBuffer, pkcs5Padding[paddedLength - plaintextLength]])\n      );\n      var ciphertext = Buffer.concat([iv, cipherOut]);\n      return ciphertext;\n    }\n    async decrypt(ciphertext) {\n      var decryptCipher = import_crypto2.default.createDecipheriv(this.algorithm, this.key, ciphertext.slice(0, DEFAULT_BLOCKLENGTH)), plaintext = decryptCipher.update(ciphertext.slice(DEFAULT_BLOCKLENGTH)), final = decryptCipher.final();\n      if (final && final.length)\n        plaintext = Buffer.concat([plaintext, final]);\n      return plaintext;\n    }\n    async getIv() {\n      if (this.iv) {\n        var iv = this.iv;\n        this.iv = null;\n        return iv;\n      }\n      var randomBlock = await generateRandom(DEFAULT_BLOCKLENGTH);\n      if (!this.encryptCipher) {\n        return randomBlock;\n      } else {\n        return this.encryptCipher.update(randomBlock);\n      }\n    }\n  }\n  return Crypto2;\n};\n\n// src/platform/nodejs/lib/util/http.ts\nvar import_got = __toESM(__webpack_require__(/*! got */ \"(rsc)/./node_modules/.pnpm/got@11.8.6/node_modules/got/dist/source/index.js\"));\nvar import_http5 = __toESM(__webpack_require__(/*! http */ \"http\"));\nvar import_https = __toESM(__webpack_require__(/*! https */ \"https\"));\nvar globalAgentPool = [];\nvar _a;\nvar Http2 = (_a = class {\n  constructor(client) {\n    this.agent = null;\n    this.supportsAuthHeaders = true;\n    this.supportsLinkHeaders = true;\n    this.checkConnectivity = async () => {\n      var _a2, _b, _c, _d, _e;\n      if ((_a2 = this.client) == null ? void 0 : _a2.options.disableConnectivityCheck) {\n        return true;\n      }\n      const connectivityCheckUrl = ((_b = this.client) == null ? void 0 : _b.options.connectivityCheckUrl) || defaults_default.connectivityCheckUrl;\n      const connectivityCheckParams = (_d = (_c = this.client) == null ? void 0 : _c.options.connectivityCheckParams) != null ? _d : null;\n      const connectivityUrlIsDefault = !((_e = this.client) == null ? void 0 : _e.options.connectivityCheckUrl);\n      const { error, statusCode, body } = await this.doUri(\n        HttpMethods_default.Get,\n        connectivityCheckUrl,\n        null,\n        null,\n        connectivityCheckParams\n      );\n      if (!error && !connectivityUrlIsDefault) {\n        return isSuccessCode(statusCode);\n      }\n      return !error && (body == null ? void 0 : body.toString().trim()) === \"yes\";\n    };\n    this.client = client != null ? client : null;\n  }\n  async doUri(method, uri, headers, body, params) {\n    var _a2;\n    const agentOptions = this.client && this.client.options.restAgentOptions || defaults_default.restAgentOptions;\n    const doOptions = { headers: headers || void 0, responseType: \"buffer\" };\n    if (!this.agent) {\n      const persistedAgent = (_a2 = globalAgentPool.find((x) => shallowEquals(agentOptions, x.options))) == null ? void 0 : _a2.agents;\n      if (persistedAgent) {\n        this.agent = persistedAgent;\n      } else {\n        this.agent = {\n          http: new import_http5.default.Agent(agentOptions),\n          https: new import_https.default.Agent(agentOptions)\n        };\n        globalAgentPool.push({\n          options: agentOptions,\n          agents: this.agent\n        });\n      }\n    }\n    if (body) {\n      doOptions.body = body;\n    }\n    if (params)\n      doOptions.searchParams = params;\n    doOptions.agent = this.agent;\n    doOptions.url = uri;\n    doOptions.timeout = {\n      request: (this.client && this.client.options.timeouts || defaults_default.TIMEOUTS).httpRequestTimeout\n    };\n    doOptions.retry = { limit: 0 };\n    try {\n      const res = await import_got.default[method](doOptions);\n      return this._handler(null, res, res.body);\n    } catch (err) {\n      if (err instanceof import_got.default.HTTPError) {\n        return this._handler(null, err.response, err.response.body);\n      }\n      return this._handler(err);\n    }\n  }\n  shouldFallback(err) {\n    const { code, statusCode } = err;\n    return code === \"ENETUNREACH\" || code === \"EHOSTUNREACH\" || code === \"EHOSTDOWN\" || code === \"ETIMEDOUT\" || code === \"ESOCKETTIMEDOUT\" || code === \"ENOTFOUND\" || code === \"ECONNRESET\" || code === \"ECONNREFUSED\" || statusCode >= 500 && statusCode <= 504;\n  }\n  _handler(err, response, body) {\n    var _a2;\n    if (err) {\n      return { error: err };\n    }\n    const statusCode = response.statusCode, headers = response.headers;\n    if (statusCode >= 300) {\n      switch (headers[\"content-type\"]) {\n        case \"application/json\":\n          body = JSON.parse(body);\n          break;\n        case \"application/x-msgpack\":\n          if (!((_a2 = this.client) == null ? void 0 : _a2._MsgPack)) {\n            return { error: createMissingPluginError(\"MsgPack\") };\n          }\n          body = this.client._MsgPack.decode(body);\n          break;\n      }\n      const error = body.error ? ErrorInfo.fromValues(body.error) : new ErrorInfo(\n        headers[\"x-ably-errormessage\"] || \"Error response received from server: \" + statusCode + \" body was: \" + Platform.Config.inspect(body),\n        Number(headers[\"x-ably-errorcode\"]),\n        statusCode\n      );\n      return { error, body, headers, unpacked: true, statusCode };\n    }\n    return { error: null, body, headers, unpacked: false, statusCode };\n  }\n}, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);\nvar http_default = Http2;\n\n// src/platform/nodejs/config.ts\nvar import_crypto3 = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_ws = __toESM(__webpack_require__(/*! ws */ \"(rsc)/./node_modules/.pnpm/ws@8.19.0/node_modules/ws/index.js\"));\nvar import_util2 = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar Config = {\n  agent: \"nodejs/\" + process.versions.node,\n  logTimestamps: true,\n  userAgent: null,\n  binaryType: \"nodebuffer\",\n  WebSocket: import_ws.default,\n  useProtocolHeartbeats: false,\n  supportsBinary: true,\n  preferBinary: true,\n  nextTick: process.nextTick,\n  inspect: import_util2.default.inspect,\n  stringByteSize: Buffer.byteLength,\n  inherits: import_util2.default.inherits,\n  addEventListener: null,\n  getRandomArrayBuffer: async function(byteLength) {\n    return import_util2.default.promisify(import_crypto3.default.randomBytes)(byteLength);\n  }\n};\nvar config_default = Config;\n\n// src/common/constants/XHRStates.ts\nvar XHRStates = /* @__PURE__ */ ((XHRStates2) => {\n  XHRStates2[XHRStates2[\"REQ_SEND\"] = 0] = \"REQ_SEND\";\n  XHRStates2[XHRStates2[\"REQ_RECV\"] = 1] = \"REQ_RECV\";\n  XHRStates2[XHRStates2[\"REQ_RECV_POLL\"] = 2] = \"REQ_RECV_POLL\";\n  XHRStates2[XHRStates2[\"REQ_RECV_STREAM\"] = 3] = \"REQ_RECV_STREAM\";\n  return XHRStates2;\n})(XHRStates || {});\nvar XHRStates_default = XHRStates;\n\n// src/common/lib/transport/comettransport.ts\nfunction shouldBeErrorAction(err) {\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n  if (err.code) {\n    if (auth_default.isTokenErr(err))\n      return false;\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code))\n      return true;\n    return err.code >= 4e4 && err.code < 5e4;\n  } else {\n    return false;\n  }\n}\nfunction protocolMessageFromRawError(err) {\n  if (shouldBeErrorAction(err)) {\n    return [fromValues({ action: actions.ERROR, error: err })];\n  } else {\n    return [fromValues({ action: actions.DISCONNECTED, error: err })];\n  }\n}\nvar CometTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(\n      connectionManager,\n      auth,\n      params,\n      /* binary not supported for comet so force JSON protocol */\n      true\n    );\n    /* Historical comment, back from when we supported JSONP:\n     *\n     * > For comet, we could do the auth update by aborting the current recv and\n     * > starting a new one with the new token, that'd be sufficient for realtime.\n     * > Problem is JSONP - you can't cancel truly abort a recv once started. So\n     * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\n     * > comet transports the same and do it for all of them. So we send the AUTH\n     * > instead, and don't need to abort the recv\n     *\n     * Now that weâ€™ve dropped JSONP support, we may be able to revisit the above;\n     * see https://github.com/ably/ably-js/issues/1214.\n     */\n    this.onAuthUpdated = (tokenDetails) => {\n      this.authParams = { access_token: tokenDetails.token };\n    };\n    this.stream = \"stream\" in params ? params.stream : true;\n    this.sendRequest = null;\n    this.recvRequest = null;\n    this.pendingCallback = null;\n    this.pendingItems = null;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const params = this.params;\n    const options = params.options;\n    const host = params.host || options.primaryDomain;\n    const port = defaults_default.getPort(options);\n    const cometScheme = options.tls ? \"https://\" : \"http://\";\n    this.baseUri = cometScheme + host + \":\" + port + \"/comet/\";\n    const connectUri = this.baseUri + \"connect\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"uri: \" + connectUri);\n    whenPromiseSettles(this.auth.getAuthParams(), (err, authParams) => {\n      if (err) {\n        this.disconnect(err);\n        return;\n      }\n      if (this.isDisposed) {\n        return;\n      }\n      this.authParams = authParams;\n      const connectParams = this.params.getConnectParams(authParams);\n      if (\"stream\" in connectParams)\n        this.stream = connectParams.stream;\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"CometTransport.connect()\",\n        \"connectParams:\" + toQueryString(connectParams)\n      );\n      let preconnected = false;\n      const connectRequest = this.recvRequest = this.createRequest(\n        connectUri,\n        null,\n        connectParams,\n        null,\n        this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV\n      );\n      connectRequest.on(\"data\", (data) => {\n        if (!this.recvRequest) {\n          return;\n        }\n        if (!preconnected) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onData(data);\n      });\n      connectRequest.on(\"complete\", (err2) => {\n        if (!this.recvRequest) {\n          err2 = err2 || new ErrorInfo(\"Request cancelled\", 80003, 400);\n        }\n        this.recvRequest = null;\n        if (!preconnected && !err2) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onActivity();\n        if (err2) {\n          if (err2.code) {\n            this.onData(protocolMessageFromRawError(err2));\n          } else {\n            this.disconnect(err2);\n          }\n          return;\n        }\n        Platform.Config.nextTick(() => {\n          this.recv();\n        });\n      });\n      connectRequest.exec();\n    });\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestClose()\");\n    this._requestCloseOrDisconnect(true);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestDisconnect()\");\n    this._requestCloseOrDisconnect(false);\n  }\n  _requestCloseOrDisconnect(closing) {\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n    if (closeOrDisconnectUri) {\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_default.REQ_SEND);\n      request.on(\"complete\", (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"CometTransport.request\" + (closing ? \"Close()\" : \"Disconnect()\"),\n            \"request returned err = \" + inspectError(err)\n          );\n          this.finish(\"disconnected\", err);\n        }\n      });\n      request.exec();\n    }\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"\");\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      if (this.recvRequest) {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"aborting recv request\");\n        this.recvRequest.abort();\n        this.recvRequest = null;\n      }\n      this.finish(\"disconnected\", connectionerrors_default.disconnected());\n      Platform.Config.nextTick(() => {\n        this.emit(\"disposed\");\n      });\n    }\n  }\n  onConnect(message) {\n    var _a2;\n    if (this.isDisposed) {\n      return;\n    }\n    const connectionStr = (_a2 = message.connectionDetails) == null ? void 0 : _a2.connectionKey;\n    transport_default.prototype.onConnect.call(this, message);\n    const baseConnectionUri = this.baseUri + connectionStr;\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CometTransport.onConnect()\", \"baseUri = \" + baseConnectionUri);\n    this.sendUri = baseConnectionUri + \"/send\";\n    this.recvUri = baseConnectionUri + \"/recv\";\n    this.closeUri = baseConnectionUri + \"/close\";\n    this.disconnectUri = baseConnectionUri + \"/disconnect\";\n  }\n  send(message) {\n    if (this.sendRequest) {\n      this.pendingItems = this.pendingItems || [];\n      this.pendingItems.push(message);\n      return;\n    }\n    const pendingItems = this.pendingItems || [];\n    pendingItems.push(message);\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendAnyPending() {\n    const pendingItems = this.pendingItems;\n    if (!pendingItems) {\n      return;\n    }\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendItems(items) {\n    const sendRequest = this.sendRequest = this.createRequest(\n      this.sendUri,\n      null,\n      this.authParams,\n      this.encodeRequest(items),\n      XHRStates_default.REQ_SEND\n    );\n    sendRequest.on(\"complete\", (err, data) => {\n      if (err)\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"CometTransport.sendItems()\",\n          \"on complete: err = \" + inspectError(err)\n        );\n      this.sendRequest = null;\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      if (data) {\n        this.onData(data);\n      }\n      if (this.pendingItems) {\n        Platform.Config.nextTick(() => {\n          if (!this.sendRequest) {\n            this.sendAnyPending();\n          }\n        });\n      }\n    });\n    sendRequest.exec();\n  }\n  recv() {\n    if (this.recvRequest)\n      return;\n    if (!this.isConnected)\n      return;\n    const recvRequest = this.recvRequest = this.createRequest(\n      this.recvUri,\n      null,\n      this.authParams,\n      null,\n      this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV_POLL\n    );\n    recvRequest.on(\"data\", (data) => {\n      this.onData(data);\n    });\n    recvRequest.on(\"complete\", (err) => {\n      this.recvRequest = null;\n      this.onActivity();\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      Platform.Config.nextTick(() => {\n        this.recv();\n      });\n    });\n    recvRequest.exec();\n  }\n  onData(responseData) {\n    try {\n      const items = this.decodeResponse(responseData);\n      if (items && items.length)\n        for (let i = 0; i < items.length; i++)\n          this.onProtocolMessage(\n            fromDeserialized(\n              items[i],\n              this.connectionManager.realtime._RealtimePresence,\n              this.connectionManager.realtime._Annotations,\n              this.connectionManager.realtime._liveObjectsPlugin\n            )\n          );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"CometTransport.onData()\",\n        \"Unexpected exception handing channel event: \" + e.stack\n      );\n    }\n  }\n  encodeRequest(requestItems) {\n    return JSON.stringify(requestItems);\n  }\n  decodeResponse(responseData) {\n    if (typeof responseData == \"string\")\n      return JSON.parse(responseData);\n    return responseData;\n  }\n};\nvar comettransport_default = CometTransport;\n\n// src/platform/nodejs/lib/transport/nodecomettransport.js\nvar import_http6 = __toESM(__webpack_require__(/*! http */ \"http\"));\nvar import_https2 = __toESM(__webpack_require__(/*! https */ \"https\"));\nvar import_url = __toESM(__webpack_require__(/*! url */ \"url\"));\nvar import_util3 = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar noop3 = function() {\n};\nvar shortName2 = TransportNames.Comet;\nvar NodeCometTransport = class extends comettransport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.httpAgent = null;\n    this.httpsAgent = null;\n    this.pendingRequests = 0;\n    this.shortName = shortName2;\n  }\n  static isAvailable() {\n    return true;\n  }\n  toString() {\n    return \"NodeCometTransport; uri=\" + this.baseUri + \"; isConnected=\" + this.isConnected + \"; format=\" + this.format + \"; stream=\" + this.stream;\n  }\n  getAgent(tls) {\n    var prop = tls ? \"httpsAgent\" : \"httpAgent\", agent2 = this[prop];\n    if (!agent2)\n      agent2 = this[prop] = new (tls ? import_https2.default : import_http6.default).Agent({ keepAlive: true });\n    return agent2;\n  }\n  dispose() {\n    var self2 = this;\n    this.onceNoPending(function() {\n      if (self2.httpAgent)\n        self2.httpAgent.destroy();\n      if (self2.httpsAgent)\n        self2.httpsAgent.destroy();\n    });\n    comettransport_default.prototype.dispose.call(this);\n  }\n  /* valid in non-streaming mode only, or data only contains last update */\n  request(uri, params, body, requestMode, callback) {\n    var req = this.createRequest(uri, params, body, requestMode);\n    req.once(\"complete\", callback);\n    req.exec();\n    return req;\n  }\n  createRequest(uri, headers, params, body, requestMode) {\n    return new Request(uri, headers, params, body, requestMode, this.format, this.timeouts, this);\n  }\n  addPending() {\n    ++this.pendingRequests;\n  }\n  removePending() {\n    if (--this.pendingRequests <= 0) {\n      this.emit(\"nopending\");\n    }\n  }\n  onceNoPending(listener) {\n    if (this.pendingRequests == 0) {\n      listener();\n      return;\n    }\n    this.once(\"nopending\", listener);\n  }\n};\nvar Request = class extends eventemitter_default {\n  constructor(uri, headers, params, body, requestMode, format, timeouts, transport) {\n    super(transport.logger);\n    if (typeof uri == \"string\")\n      uri = import_url.default.parse(uri);\n    var tls = uri.protocol == \"https:\";\n    this.client = tls ? import_https2.default : import_http6.default;\n    this.requestMode = requestMode;\n    this.timeouts = timeouts;\n    this.transport = transport;\n    this.requestComplete = false;\n    this.req = this.res = null;\n    var method = \"GET\", contentType = format == \"msgpack\" ? \"application/x-msgpack\" : \"application/json\";\n    headers = headers ? mixin({}, headers) : {};\n    headers[\"accept\"] = contentType;\n    if (body) {\n      method = \"POST\";\n      if (!Buffer.isBuffer(body)) {\n        if (typeof body == \"object\")\n          body = JSON.stringify(body);\n        body = Buffer.from(body);\n      }\n      this.body = body;\n      headers[\"Content-Length\"] = body.length;\n      headers[\"Content-Type\"] = contentType;\n    }\n    var requestOptions = this.requestOptions = {\n      hostname: uri.hostname,\n      port: uri.port,\n      path: uri.path + toQueryString(params),\n      method,\n      headers\n    };\n    if (transport)\n      requestOptions.agent = transport.getAgent(tls);\n  }\n  exec() {\n    var timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, self2 = this;\n    var timer = this.timer = setTimeout(function() {\n      self2.abort();\n    }, timeout), req = this.req = this.client.request(this.requestOptions);\n    req.on(\n      \"error\",\n      this.onReqError = function(err) {\n        err = new PartialErrorInfo(\"Request error: \" + err.message, null, 400);\n        clearTimeout(timer);\n        self2.timer = null;\n        self2.complete(err);\n      }\n    );\n    req.on(\"response\", function(res) {\n      clearTimeout(timer);\n      self2.timer = null;\n      var statusCode = res.statusCode;\n      if (statusCode == HttpStatusCodes_default.NoContent) {\n        res.resume();\n        self2.complete();\n        return;\n      }\n      res.on(\n        \"error\",\n        self2.onResError = function(err) {\n          err = new PartialErrorInfo(\"Response error: \" + err.message, null, 400);\n          self2.complete(err);\n        }\n      );\n      self2.res = res;\n      if (self2.requestMode == XHRStates_default.REQ_RECV_STREAM && statusCode < 400) {\n        self2.readStream();\n      } else {\n        self2.readFully();\n      }\n    });\n    if (this.transport)\n      this.transport.addPending();\n    req.end(this.body);\n  }\n  readStream() {\n    var res = this.res, self2 = this;\n    this.chunks = [];\n    this.streamComplete = false;\n    function onChunk(chunk) {\n      try {\n        chunk = JSON.parse(chunk);\n      } catch (e) {\n        var msg = \"Malformed response body from server: \" + e.message;\n        logger_default.logAction(self2.logger, logger_default.LOG_ERROR, \"NodeCometTransport.Request.readStream()\", msg);\n        self2.complete(new PartialErrorInfo(msg, null, 400));\n        return;\n      }\n      self2.emit(\"data\", chunk);\n    }\n    res.on(\n      \"data\",\n      this.ondata = function(data) {\n        var newChunks = String(data).split(\"\\n\"), chunks = self2.chunks;\n        if (newChunks.length > 1 && chunks.length > 0) {\n          chunks.push(newChunks.shift());\n          self2.chunks = [];\n          onChunk(chunks.join(\"\"));\n        }\n        var trailingNewChunk = newChunks.pop();\n        if (trailingNewChunk.length) {\n          self2.chunks.push(trailingNewChunk);\n        }\n        newChunks.map(onChunk);\n      }\n    );\n    res.on(\"end\", function() {\n      self2.streamComplete = true;\n      process.nextTick(function() {\n        self2.complete();\n      });\n    });\n  }\n  readFully() {\n    var res = this.res, chunks = [], self2 = this;\n    res.on(\"data\", function(chunk) {\n      chunks.push(chunk);\n    });\n    res.on(\"end\", function() {\n      process.nextTick(function() {\n        var body = Buffer.concat(chunks), statusCode = res.statusCode;\n        try {\n          body = JSON.parse(String(body));\n        } catch (e) {\n          var msg = \"Malformed response body from server: \" + e.message;\n          logger_default.logAction(self2.logger, logger_default.LOG_ERROR, \"NodeCometTransport.Request.readFully()\", msg);\n          self2.complete(new PartialErrorInfo(msg, null, 400));\n          return;\n        }\n        if (statusCode < 400 || Array.isArray(body)) {\n          self2.complete(null, body);\n          return;\n        }\n        var err = body.error && ErrorInfo.fromValues(body.error);\n        if (!err) {\n          err = new PartialErrorInfo(\n            \"Error response received from server: \" + statusCode + \", body was: \" + import_util3.default.inspect(body),\n            null,\n            statusCode\n          );\n        }\n        self2.complete(err);\n      });\n    });\n  }\n  complete(err, body) {\n    if (!this.requestComplete) {\n      this.requestComplete = true;\n      if (body)\n        this.emit(\"data\", body);\n      this.emit(\"complete\", err, body);\n      if (err) {\n        if (this.ondata && !this.streamComplete) {\n          if (this.ondata && this.res)\n            this.res.removeListener(\"data\", this.ondata);\n        }\n      }\n      if (this.transport) {\n        this.transport.removePending();\n      }\n    }\n  }\n  abort() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"NodeCometTransport.Request.abort()\", \"\");\n    var timer = this.timer;\n    if (timer) {\n      clearTimeout(timer);\n      this.timer = null;\n    }\n    var req = this.req;\n    if (req) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"NodeCometTransport.Request.abort()\", \"aborting request\");\n      req.removeListener(\"error\", this.onReqError);\n      req.on(\"error\", noop3);\n      req.abort();\n      this.req = null;\n    }\n    this.complete({ statusCode: 400, code: 80003, message: \"Cancelled\" });\n  }\n};\nvar nodecomettransport_default = NodeCometTransport;\n\n// src/platform/nodejs/lib/transport/index.ts\nvar transport_default2 = {\n  order: [TransportNames.Comet],\n  bundledImplementations: {\n    [TransportNames.WebSocket]: websockettransport_default,\n    [TransportNames.Comet]: nodecomettransport_default\n  }\n};\n\n// src/platform/nodejs/lib/util/defaults.ts\nvar Defaults2 = {\n  connectivityCheckUrl: \"https://internet-up.ably-realtime.com/is-the-internet-up.txt\",\n  wsConnectivityCheckUrl: \"wss://ws-up.ably-realtime.com\",\n  /* Note: order matters here: the base transport is the leftmost one in the\n   * intersection of baseTransportOrder and the transports clientOption that's supported. */\n  defaultTransports: [TransportNames.WebSocket],\n  restAgentOptions: { maxSockets: 40, keepAlive: true }\n};\nvar defaults_default2 = Defaults2;\n\n// src/platform/nodejs/index.ts\nvar msgpack = require_msgpack();\nvar Crypto = createCryptoClass(bufferutils_default);\nPlatform.Crypto = Crypto;\nPlatform.BufferUtils = bufferutils_default;\nPlatform.Http = http_default;\nPlatform.Config = config_default;\nPlatform.Transports = transport_default2;\nPlatform.WebStorage = null;\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\n  clientClass.Crypto = Crypto;\n  clientClass._MsgPack = msgpack;\n}\nlogger_default.initLogHandlers();\nPlatform.Defaults = getDefaults(defaults_default2);\nif (Platform.Config.agent) {\n  Platform.Defaults.agent += \" \" + Platform.Config.agent;\n}\nmodule.exports = {\n  ErrorInfo,\n  Rest: DefaultRest,\n  Realtime: DefaultRealtime,\n  msgpack: null,\n  makeProtocolMessageFromDeserialized: makeFromDeserializedWithDependencies\n};\nif (typeof module.exports == \"object\" && typeof exports == \"object\") {\n  var __cp = (to, from, except, desc) => {\n    if ((from && typeof from === \"object\") || typeof from === \"function\") {\n      for (let key of Object.getOwnPropertyNames(from)) {\n        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)\n        Object.defineProperty(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,\n        });\n      }\n    }\n    return to;\n  };\n  module.exports = __cp(module.exports, exports);\n}\nreturn module.exports;\n}))\n//# sourceMappingURL=ably-node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYWJseUAyLjE3LjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvYWJseS9idWlsZC9hYmx5LW5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBdUQ7QUFDL0QseUJBQXlCLG1CQUFPLENBQUMseUVBQUksR0FBRyxtQkFBTyxDQUFDLHdGQUFLO0FBQ3JELE1BQU0sS0FBSyxFQU1OO0FBQ0wsR0FBRztBQUNIO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsK0JBQStCLHNCQUFzQixnQkFBZ0I7QUFDbEwsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsa0JBQWtCLG1DQUFtQyxPQUFPO0FBQ3ZJO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxrQkFBa0Isc0NBQXNDLE9BQU87QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsa0JBQWtCLHNDQUFzQyxPQUFPO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGtCQUFrQixzQ0FBc0MsT0FBTztBQUMxSTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLHlEQUF5RCxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEseUNBQXlDLFFBQVEsdUNBQXVDLFFBQVEsZ0JBQWdCLFFBQVE7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVUsY0FBYyxRQUFRLGtDQUFrQyxRQUFRLHVDQUF1QyxRQUFRLGdCQUFnQixRQUFRO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb1FBQW9RLHdCQUF3QjtBQUM1UjtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtQkFBbUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsY0FBYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsWUFBWTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQixHQUFHLEdBQUcsWUFBWSxPQUFPO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCLGlHQUFpRyx1QkFBdUI7QUFDcEwsa0VBQWtFLHNCQUFzQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCLCtDQUErQztBQUM3RixzRUFBc0Usc0JBQXNCO0FBQzVGO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLHVCQUF1QixpREFBaUQ7QUFDL0Ysc0VBQXNFLHNCQUFzQjtBQUM1RjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUIseUNBQXlDLGlEQUFpRDtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxvQkFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtFQUFrRSxJQUFJO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtFQUFrRSxJQUFJO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSw0Q0FBNEM7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLDJCQUEyQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsMkJBQTJCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwrS0FBK0sscUJBQXFCLGVBQWUscUVBQXFFLGNBQWM7QUFDdFM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0IsNkJBQTZCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0Q7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0NBQXNDLDhDQUE4Qyx1Q0FBdUM7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseURBQXlELDJCQUEyQiwwQkFBMEIsb0JBQW9CO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4Riw2Q0FBNkM7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSxxREFBcUQsa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5REFBeUQsMkJBQTJCLDBCQUEwQixvQkFBb0I7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUsd0RBQXdELGtCQUFrQjtBQUN6RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQStDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU8sbUNBQW1DLFlBQVk7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLHlCQUF5QixVQUFVLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixRQUFRO0FBQ1IscUJBQXFCO0FBQ3JCLFFBQVE7QUFDUixxQkFBcUI7QUFDckI7QUFDQSxNQUFNO0FBQ04sbUJBQW1CO0FBQ25CLE1BQU07QUFDTixtQkFBbUI7QUFDbkIsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQixNQUFNO0FBQ04sbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0oscUJBQXFCLGVBQWU7QUFDNUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYSwwQkFBMEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVSxtRUFBbUU7QUFDN0U7QUFDQSwwQ0FBMEMsYUFBYSxzQkFBc0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQXVDO0FBQzlEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVDQUF1Qyw4Q0FBOEMsdUNBQXVDO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3TEFBd0wsUUFBUTtBQUNoTTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdMQUF3TCxRQUFRO0FBQ2hNO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsTUFBTSxPQUFPLFdBQVcsZ0JBQWdCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEVBQThFLDJCQUEyQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxtQ0FBbUMsK0RBQStELG1DQUFtQztBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLHlCQUF5QjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZSxHQUFHLGdCQUFnQjtBQUNsRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLE1BQU07QUFDOUc7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLG1CQUFtQiwrQ0FBK0M7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVEsNElBQTRJO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFDQUFxQyxDQUFVO0FBQ2hFO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixNQUFNLE9BQU8sV0FBVyxnQkFBZ0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGdCQUFnQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLGdCQUFnQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRDQUE0QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMENBQTBDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpS0FBaUs7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0pBQStKO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RCxxQ0FBcUMsNEJBQTRCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDREQUE0RDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdCQUFnQiw2RkFBNkY7QUFDN0csZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWiwrQkFBK0IsMENBQTBDO0FBQ3pFO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsaUNBQWlDLGtFQUFrRTtBQUNuRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCx5Q0FBeUM7QUFDeEs7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCLG1FQUFtRTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0NBQXNDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFxRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RCxNQUFNO0FBQ04seUJBQXlCLDZCQUE2QjtBQUN0RCxNQUFNO0FBQ04sMkVBQTJFO0FBQzNFO0FBQ0EseUJBQXlCLDZEQUE2RDtBQUN0RixNQUFNO0FBQ047QUFDQTtBQUNBLHlCQUF5Qix5RUFBeUU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxFQUFFLHFCQUFxQixHQUFHLGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLHNCQUFRO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLGtCQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsd0ZBQUs7QUFDdEMsMkJBQTJCLG1CQUFPLENBQUMsa0JBQU07QUFDekMsMkJBQTJCLG1CQUFPLENBQUMsb0JBQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLHNCQUFRO0FBQzdDLHdCQUF3QixtQkFBTyxDQUFDLHlFQUFJO0FBQ3BDLDJCQUEyQixtQkFBTyxDQUFDLGtCQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUNBQW1DO0FBQzVELElBQUk7QUFDSix5QkFBeUIsMENBQTBDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6Qyw0QkFBNEIsbUJBQU8sQ0FBQyxvQkFBTztBQUMzQyx5QkFBeUIsbUJBQU8sQ0FBQyxnQkFBSztBQUN0QywyQkFBMkIsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCLHNDQUFzQyw0QkFBNEI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsaUJBQWlCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21jcC1jaGVzcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9hYmx5QDIuMTcuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9hYmx5L2J1aWxkL2FibHktbm9kZS5qcz9hYmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMTUtMjAyMiBBYmx5IFJlYWwtdGltZSBMdGQgKGFibHkuY29tKVxuXG5BYmx5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4xNy4xXG5odHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzXG5cblJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5jZSB2Mi4wKi8oZnVuY3Rpb24gKGcsIGYpIHtcbiAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZihyZXF1aXJlKCd3cycpLCByZXF1aXJlKCdnb3QnKSk7XG4gICAgfSBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoWyd3cycsICdnb3QnXSwgZik7XG4gICAgfSBlbHNlIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzKSB7XG4gICAgICBleHBvcnRzW1wiQWJseVwiXSA9IGYocmVxdWlyZSgnd3MnKSwgcmVxdWlyZSgnZ290JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnW1wiQWJseVwiXSA9IGYoZ1tcIndzXCJdLCBnW1wiZ290XCJdKTtcbiAgICB9XG4gIH0odGhpcywgKF9fZGEsIF9fZGIpID0+IHtcbnZhciBleHBvcnRzID0ge307XG52YXIgbW9kdWxlID0geyBleHBvcnRzIH07XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fYXdhaXQgPSBmdW5jdGlvbihwcm9taXNlLCBpc1lpZWxkU3Rhcikge1xuICB0aGlzWzBdID0gcHJvbWlzZTtcbiAgdGhpc1sxXSA9IGlzWWllbGRTdGFyO1xufTtcbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICB2YXIgcmVzdW1lID0gKGssIHYsIHllcywgbm8pID0+IHtcbiAgICB0cnkge1xuICAgICAgdmFyIHggPSBnZW5lcmF0b3Jba10odiksIGlzQXdhaXQgPSAodiA9IHgudmFsdWUpIGluc3RhbmNlb2YgX19hd2FpdCwgZG9uZSA9IHguZG9uZTtcbiAgICAgIFByb21pc2UucmVzb2x2ZShpc0F3YWl0ID8gdlswXSA6IHYpLnRoZW4oKHkpID0+IGlzQXdhaXQgPyByZXN1bWUoayA9PT0gXCJyZXR1cm5cIiA/IGsgOiBcIm5leHRcIiwgdlsxXSA/IHsgZG9uZTogeS5kb25lLCB2YWx1ZTogeS52YWx1ZSB9IDogeSwgeWVzLCBubykgOiB5ZXMoeyB2YWx1ZTogeSwgZG9uZSB9KSkuY2F0Y2goKGUpID0+IHJlc3VtZShcInRocm93XCIsIGUsIHllcywgbm8pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBubyhlKTtcbiAgICB9XG4gIH07XG4gIHZhciBtZXRob2QgPSAoaykgPT4gaXRba10gPSAoeCkgPT4gbmV3IFByb21pc2UoKHllcywgbm8pID0+IHJlc3VtZShrLCB4LCB5ZXMsIG5vKSk7XG4gIHZhciBpdCA9IHt9O1xuICByZXR1cm4gZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpLCBpdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiBpdCwgbWV0aG9kKFwibmV4dFwiKSwgbWV0aG9kKFwidGhyb3dcIiksIG1ldGhvZChcInJldHVyblwiKSwgaXQ7XG59O1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9mcm9tLmpzXG52YXIgcmVxdWlyZV9mcm9tID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvZnJvbS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICB2YXIgdmVyc2lvbjIgPSAoKHByb2Nlc3MgfHwge30pLnZlcnNpb24gfHwgXCJ2MC4wLjBcIikuc2xpY2UoMSkuc3BsaXQoXCIuXCIpWzBdO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IE51bWJlcih2ZXJzaW9uMikgPCA2ID8gZnVuY3Rpb24gZnJvbShzb3VyY2UsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcjIoc291cmNlLCBlbmNvZGluZyk7XG4gICAgfSA6IGZ1bmN0aW9uIGZyb20oc291cmNlLCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIEJ1ZmZlcjIuZnJvbShzb3VyY2UsIGVuY29kaW5nKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvdG8uanNcbnZhciByZXF1aXJlX3RvID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvdG8uanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvdXJjZSwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBzb3VyY2UudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9pcy5qc1xudmFyIHJlcXVpcmVfaXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9pcy5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIyLmlzQnVmZmVyKGJ1ZmZlcik7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL3N1YmFycmF5LmpzXG52YXIgcmVxdWlyZV9zdWJhcnJheSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL3N1YmFycmF5LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihzb3VyY2UsIGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiA/IHNvdXJjZS5zbGljZShmcm9tKSA6IHNvdXJjZS5zbGljZShmcm9tLCB0byk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL2pvaW4uanNcbnZhciByZXF1aXJlX2pvaW4gPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9qb2luLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgQnVmZmVyMiA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldHMsIGhpbnQpIHtcbiAgICAgIHJldHVybiBoaW50ICE9PSB2b2lkIDAgPyBCdWZmZXIyLmNvbmNhdCh0YXJnZXRzLCBoaW50KSA6IEJ1ZmZlcjIuY29uY2F0KHRhcmdldHMpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9jb3B5LmpzXG52YXIgcmVxdWlyZV9jb3B5ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvY29weS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gY29weTI7XG4gICAgZnVuY3Rpb24gY29weTIoc291cmNlLCB0YXJnZXQsIHRhcmdldF9zdGFydCwgc291cmNlX3N0YXJ0LCBzb3VyY2VfZW5kKSB7XG4gICAgICByZXR1cm4gc291cmNlLmNvcHkodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHNvdXJjZV9zdGFydCwgc291cmNlX2VuZCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvY3JlYXRlLmpzXG52YXIgcmVxdWlyZV9jcmVhdGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9jcmVhdGUuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciBCdWZmZXIyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgdmFyIHZlcnNpb24yID0gKChwcm9jZXNzIHx8IHt9KS52ZXJzaW9uIHx8IFwidjAuMC4wXCIpLnNsaWNlKDEpLnNwbGl0KFwiLlwiKVswXTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBOdW1iZXIodmVyc2lvbjIpIDwgNiA/IGZ1bmN0aW9uIGNyZWF0ZShzaXplKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcjIoc2l6ZSk7XG4gICAgfSA6IGZ1bmN0aW9uIGNyZWF0ZShzaXplKSB7XG4gICAgICByZXR1cm4gQnVmZmVyMi5hbGxvYyhzaXplKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvcmVhZC5qc1xudmFyIHJlcXVpcmVfcmVhZCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL3JlYWQuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciBwcm90byA9IHt9O1xuICAgIHZhciByZXggPSAvcmVhZC4rLztcbiAgICB2YXIgYnVpbGRGbjtcbiAgICBidWlsZEZuID0gZnVuY3Rpb24oa2V5Mikge1xuICAgICAgdmFyIGNvZGUgPSBcInJldHVybiBidWYuXCIgKyBrZXkyICsgXCIoXCIgKyBbXCJhXCIsIFwiYlwiLCBcImNcIl0uam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oW1wiYnVmXCIsIFwiYVwiLCBcImJcIiwgXCJjXCJdLCBjb2RlKTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHByb3RvO1xuICAgIGZvciAoa2V5IGluIEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgIGlmIChyZXgudGVzdChrZXkpKSB7XG4gICAgICAgIHByb3RvW2tleV0gPSBidWlsZEZuKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy93cml0ZS5qc1xudmFyIHJlcXVpcmVfd3JpdGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy93cml0ZS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICB2YXIgcHJvdG8gPSB7fTtcbiAgICB2YXIgcmV4ID0gL3dyaXRlLisvO1xuICAgIHZhciBidWlsZEZuO1xuICAgIGJ1aWxkRm4gPSBmdW5jdGlvbihrZXkyKSB7XG4gICAgICB2YXIgY29kZSA9IFwicmV0dXJuIGJ1Zi5cIiArIGtleTIgKyBcIihcIiArIFtcImFcIiwgXCJiXCIsIFwiY1wiXS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihbXCJidWZcIiwgXCJhXCIsIFwiYlwiLCBcImNcIl0sIGNvZGUpO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcHJvdG87XG4gICAgZm9yIChrZXkgaW4gQnVmZmVyMi5wcm90b3R5cGUpIHtcbiAgICAgIGlmIChyZXgudGVzdChrZXkpKSB7XG4gICAgICAgIHByb3RvW2tleV0gPSBidWlsZEZuKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfYm9wcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL2luZGV4LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgcHJvdG8gPSB7fTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwcm90bztcbiAgICBwcm90by5mcm9tID0gcmVxdWlyZV9mcm9tKCk7XG4gICAgcHJvdG8udG8gPSByZXF1aXJlX3RvKCk7XG4gICAgcHJvdG8uaXMgPSByZXF1aXJlX2lzKCk7XG4gICAgcHJvdG8uc3ViYXJyYXkgPSByZXF1aXJlX3N1YmFycmF5KCk7XG4gICAgcHJvdG8uam9pbiA9IHJlcXVpcmVfam9pbigpO1xuICAgIHByb3RvLmNvcHkgPSByZXF1aXJlX2NvcHkoKTtcbiAgICBwcm90by5jcmVhdGUgPSByZXF1aXJlX2NyZWF0ZSgpO1xuICAgIG1peChyZXF1aXJlX3JlYWQoKSwgcHJvdG8pO1xuICAgIG1peChyZXF1aXJlX3dyaXRlKCksIHByb3RvKTtcbiAgICBmdW5jdGlvbiBtaXgoZnJvbSwgaW50bykge1xuICAgICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgICAgaW50b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AYWJseS9tc2dwYWNrLWpzL21zZ3BhY2suanNcbnZhciByZXF1aXJlX21zZ3BhY2sgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQGFibHkvbXNncGFjay1qcy9tc2dwYWNrLmpzXCIoZXhwb3J0czIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYm9wcyA9IHJlcXVpcmVfYm9wcygpO1xuICAgIGV4cG9ydHMyLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBzcGFyc2UpIHtcbiAgICAgIHZhciBzaXplID0gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgaWYgKHNpemUgPT0gMClcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHZhciBidWZmZXIgPSBib3BzLmNyZWF0ZShzaXplKTtcbiAgICAgIGVuY29kZTIodmFsdWUsIGJ1ZmZlciwgMCwgc3BhcnNlKTtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfTtcbiAgICBleHBvcnRzMi5kZWNvZGUgPSBkZWNvZGUyO1xuICAgIHZhciBTSF9MXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpO1xuICAgIHZhciBTSF9SXzMyID0gMSAvIFNIX0xfMzI7XG4gICAgZnVuY3Rpb24gcmVhZEludDY0QkUoYnVmLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkSW50MzJCRShvZmZzZXQgKyAwKSAqIFNIX0xfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVUludDY0QkUoYnVmLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgMCkgKiBTSF9MXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICAgIGlmICh2YWwgPCA5MjIzMzcyMDM2ODU0Nzc2ZTMpIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJCRShNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpLCBvZmZzZXQpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKDIxNDc0ODM2NDcsIG9mZnNldCk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKDQyOTQ5NjcyOTUsIG9mZnNldCArIDQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVVJbnQ2NEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICAgIGlmICh2YWwgPCAxODQ0Njc0NDA3MzcwOTU1MmUzKSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKE1hdGguZmxvb3IodmFsICogU0hfUl8zMiksIG9mZnNldCk7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoNDI5NDk2NzI5NSwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoNDI5NDk2NzI5NSwgb2Zmc2V0ICsgNCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIERlY29kZXIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgRGVjb2Rlci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoICogMiA+IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIG1lc3NhZ2VwYWNrIGRldGVjdGVkOiBidWZmZXIgc2l6ZSB3YXMgJHt0aGlzLmJ1ZmZlckxlbmd0aH0sIGJ1dCByZWZlcmVuY2VkIGEgbWFwIG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2UoKTtcbiAgICAgICAgdmFsdWVba2V5XSA9IHRoaXMucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIERlY29kZXIucHJvdG90eXBlLmJpbiA9IERlY29kZXIucHJvdG90eXBlLmJ1ZiA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIG1lc3NhZ2VwYWNrIGRldGVjdGVkOiBidWZmZXIgc2l6ZSB3YXMgJHt0aGlzLmJ1ZmZlckxlbmd0aH0sIGJ1dCByZWZlcmVuY2VkIGEgYmluYXJ5IG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBib3BzLnN1YmFycmF5KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgRGVjb2Rlci5wcm90b3R5cGUuc3RyID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID4gdGhpcy5idWZmZXJMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYWxmb3JtZWQgbWVzc2FnZXBhY2sgZGV0ZWN0ZWQ6IGJ1ZmZlciBzaXplIHdhcyAke3RoaXMuYnVmZmVyTGVuZ3RofSwgYnV0IHJlZmVyZW5jZWQgYSBzdHJpbmcgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGJvcHMudG8oYm9wcy5zdWJhcnJheSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgbGVuZ3RoKSk7XG4gICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIG1lc3NhZ2VwYWNrIGRldGVjdGVkOiBidWZmZXIgc2l6ZSB3YXMgJHt0aGlzLmJ1ZmZlckxlbmd0aH0sIGJ1dCByZWZlcmVuY2VkIGFuIGFycmF5IG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSB0aGlzLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLmJ1ZmZlclt0aGlzLm9mZnNldF07XG4gICAgICB2YXIgdmFsdWUsIGxlbmd0aCwgZXh0VHlwZTtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWFsZm9ybWVkIG1lc3NhZ2VwYWNrIChyZWZlcmVuY2VkIG9mZnNldCBpcyBvdXRzaWRlIGJ1ZmZlcilcIik7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAxMjgpID09PSAwKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjQwKSA9PT0gMTI4KSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAxNTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyNDApID09PSAxNDQpIHtcbiAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDE1O1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjI0KSA9PT0gMTYwKSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAzMTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyMjQpID09PSAyMjQpIHtcbiAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDE5MjpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDE5NDpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAxOTU6XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAxOTY6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTc6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTg6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTk6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDIpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDMpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcbiAgICAgICAgY2FzZSAyMDE6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDUpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDY7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcbiAgICAgICAgY2FzZSAyMDI6XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRGbG9hdEJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwMzpcbiAgICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZERvdWJsZUJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuYnVmZmVyW3RoaXMub2Zmc2V0ICsgMV07XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA1OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA2OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA3OlxuICAgICAgICAgIHZhbHVlID0gcmVhZFVJbnQ2NEJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwODpcbiAgICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZEludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA5OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMTA6XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRJbnQzMkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMTpcbiAgICAgICAgICB2YWx1ZSA9IHJlYWRJbnQ2NEJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMjpcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAyKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiBleHRUeXBlID09PSAwICYmIHZhbHVlID09PSAwID8gdm9pZCAwIDogW2V4dFR5cGUsIHZhbHVlXTtcbiAgICAgICAgY2FzZSAyMTM6XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbigyKV07XG4gICAgICAgIGNhc2UgMjE0OlxuICAgICAgICAgIGV4dFR5cGUgPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiBbZXh0VHlwZSwgdGhpcy5iaW4oNCldO1xuICAgICAgICBjYXNlIDIxNTpcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gW2V4dFR5cGUsIHRoaXMuYmluKDgpXTtcbiAgICAgICAgY2FzZSAyMTY6XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbigxNildO1xuICAgICAgICBjYXNlIDIxNzpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxODpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxOTpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MzJCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIyMDpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjIxOlxuICAgICAgICAgIGxlbmd0aCA9IGJvcHMucmVhZFVJbnQzMkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjI6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjM6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSAweFwiICsgdHlwZS50b1N0cmluZygxNikpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZGVjb2RlMihidWZmZXIpIHtcbiAgICAgIHZhciBkZWNvZGVyID0gbmV3IERlY29kZXIoYnVmZmVyKTtcbiAgICAgIHZhciB2YWx1ZSA9IGRlY29kZXIucGFyc2UoKTtcbiAgICAgIGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGJ1ZmZlci5sZW5ndGggLSBkZWNvZGVyLm9mZnNldCArIFwiIHRyYWlsaW5nIGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB2YWwgPSB2YWx1ZVtlXSwgdHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgICAgIHJldHVybiAoIXNwYXJzZSB8fCB2YWwgIT09IHZvaWQgMCAmJiB2YWwgIT09IG51bGwpICYmIChcImZ1bmN0aW9uXCIgIT09IHR5cGUgfHwgISF2YWwudG9KU09OKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUyKHZhbHVlLCBidWZmZXIsIG9mZnNldCwgc3BhcnNlLCBpc01hcEVsZW1lbnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdmFyIGxlbmd0aCwgc2l6ZTtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gYm9wcy5mcm9tKHZhbHVlKTtcbiAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IGxlbmd0aCB8IDE2MDtcbiAgICAgICAgICBib3BzLmNvcHkodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDEgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjE3O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50OChidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDIpO1xuICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjE4O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MTZCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDMpO1xuICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMTk7XG4gICAgICAgICAgYm9wcy53cml0ZVVJbnQzMkJFKGJ1ZmZlciwgbGVuZ3RoLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICBib3BzLmNvcHkodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0ICsgNSk7XG4gICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChib3BzLmlzKHZhbHVlKSkge1xuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDE5NjtcbiAgICAgICAgICBib3BzLndyaXRlVUludDgoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIGJvcHMuY29weSh2YWx1ZSwgYnVmZmVyLCBvZmZzZXQgKyAyKTtcbiAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDE5NztcbiAgICAgICAgICBib3BzLndyaXRlVUludDE2QkUoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIGJvcHMuY29weSh2YWx1ZSwgYnVmZmVyLCBvZmZzZXQgKyAzKTtcbiAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMTk4O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MzJCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDUpO1xuICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDM7XG4gICAgICAgICAgYm9wcy53cml0ZURvdWJsZUJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMTI4KSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA8IDI1Nikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDQ7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPCA2NTUzNikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDU7XG4gICAgICAgICAgICBib3BzLndyaXRlVUludDE2QkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gICAgICAgICAgICBib3BzLndyaXRlVUludDMyQkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMTg0NDY3NDQwNzM3MDk1NTJlMykge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDc7XG4gICAgICAgICAgICB3cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnIDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMzIpIHtcbiAgICAgICAgICBib3BzLndyaXRlSW50OChidWZmZXIsIHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMTI4KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDg7XG4gICAgICAgICAgYm9wcy53cml0ZUludDgoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IC0zMjc2OCkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjA5O1xuICAgICAgICAgIGJvcHMud3JpdGVJbnQxNkJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMjE0NzQ4MzY0OCkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjEwO1xuICAgICAgICAgIGJvcHMud3JpdGVJbnQzMkJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtOTIyMzM3MjAzNjg1NDc3NmUzKSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMTE7XG4gICAgICAgICAgd3JpdGVJbnQ2NEJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gc21hbGwgLTB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChzcGFyc2UgJiYgaXNNYXBFbGVtZW50KVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIxMjtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gMDtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDJdID0gMDtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNwYXJzZSAmJiBpc01hcEVsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMTkyO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlID8gMTk1IDogMTk0O1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG4gICAgICAgIHJldHVybiBlbmNvZGUyKHZhbHVlLnRvSlNPTigpLCBidWZmZXIsIG9mZnNldCwgc3BhcnNlKTtcbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHNpemUgPSAwO1xuICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gbGVuZ3RoIHwgKGlzQXJyYXkgPyAxNDQgOiAxMjgpO1xuICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSBpc0FycmF5ID8gMjIwIDogMjIyO1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MTZCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgc2l6ZSA9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gaXNBcnJheSA/IDIyMSA6IDIyMztcbiAgICAgICAgICBib3BzLndyaXRlVUludDMyQkUoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHNpemUgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSArPSBlbmNvZGUyKHZhbHVlW2ldLCBidWZmZXIsIG9mZnNldCArIHNpemUsIHNwYXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgc2l6ZSArPSBlbmNvZGUyKGtleSwgYnVmZmVyLCBvZmZzZXQgKyBzaXplKTtcbiAgICAgICAgICAgIHNpemUgKz0gZW5jb2RlMih2YWx1ZVtrZXldLCBidWZmZXIsIG9mZnNldCArIHNpemUsIHNwYXJzZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIiArIHR5cGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaXplb2YodmFsdWUsIHNwYXJzZSwgaXNNYXBFbGVtZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHZhciBsZW5ndGgsIHNpemU7XG4gICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsZW5ndGggPSBib3BzLmZyb20odmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIDEgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChib3BzLmlzKHZhbHVlKSkge1xuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDI1NilcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDY1NTM2KVxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5NilcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDE4NDQ2NzQ0MDczNzA5NTUyZTMpXG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZyAweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPj0gLTMyKVxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAodmFsdWUgPj0gLTEyOClcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgaWYgKHZhbHVlID49IC0zMjc2OClcbiAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KVxuICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICBpZiAodmFsdWUgPj0gLTkyMjMzNzIwMzY4NTQ3NzZlMylcbiAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHNwYXJzZSAmJiBpc01hcEVsZW1lbnQgPyAwIDogMTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gc3BhcnNlICYmIGlzTWFwRWxlbWVudCA/IDAgOiAzO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcbiAgICAgICAgcmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHNpemUgPSAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSArPSBzaXplb2YodmFsdWVbaV0sIHNwYXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSk7XG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBzaXplICs9IHNpemVvZihrZXkpICsgc2l6ZW9mKHZhbHVlW2tleV0sIHNwYXJzZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgICAgIHJldHVybiAxICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICByZXR1cm4gMyArIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgICByZXR1cm4gNSArIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgb3Igb2JqZWN0IHRvbyBsb25nIDB4XCIgKyBsZW5ndGgudG9TdHJpbmcoMTYpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgdHlwZSk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gc3JjL2NvbW1vbi9wbGF0Zm9ybS50c1xudmFyIFBsYXRmb3JtID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIudHNcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG5mdW5jdGlvbiBwYWQodGltZVNlZ21lbnQsIHRocmVlKSB7XG4gIHJldHVybiBgJHt0aW1lU2VnbWVudH1gLnBhZFN0YXJ0KHRocmVlID8gMyA6IDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZXIobG9nZ2VyKSB7XG4gIHJldHVybiBQbGF0Zm9ybS5Db25maWcubG9nVGltZXN0YW1wcyA/IGZ1bmN0aW9uKG1zZykge1xuICAgIGNvbnN0IHRpbWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBsb2dnZXIoXG4gICAgICBwYWQodGltZS5nZXRIb3VycygpKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0TWludXRlcygpKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0U2Vjb25kcygpKSArIFwiLlwiICsgcGFkKHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIDEpICsgXCIgXCIgKyBtc2dcbiAgICApO1xuICB9IDogZnVuY3Rpb24obXNnKSB7XG4gICAgbG9nZ2VyKG1zZyk7XG4gIH07XG59XG52YXIgZ2V0RGVmYXVsdExvZ2dlcnMgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIGxldCBjb25zb2xlTG9nZ2VyO1xuICBsZXQgZXJyb3JMb2dnZXI7XG4gIGlmICh0eXBlb2YgKChfYTIgPSBnbG9iYWxPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbE9iamVjdC5jb25zb2xlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvZykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGVMb2dnZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICAgIGVycm9yTG9nZ2VyID0gY29uc29sZS53YXJuID8gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH0gOiBjb25zb2xlTG9nZ2VyO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGVMb2dnZXIgPSBlcnJvckxvZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIFtjb25zb2xlTG9nZ2VyLCBlcnJvckxvZ2dlcl0ubWFwKGdldEhhbmRsZXIpO1xufTtcbnZhciBfTG9nZ2VyID0gY2xhc3MgX0xvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVwcmVjYXRlZCA9IChkZXNjcmlwdGlvbiwgbXNnKSA9PiB7XG4gICAgICB0aGlzLmRlcHJlY2F0aW9uV2FybmluZyhgJHtkZXNjcmlwdGlvbn0gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uICR7bXNnfWApO1xuICAgIH07XG4gICAgLyogV2hlcmUgYSBsb2dnaW5nIG9wZXJhdGlvbiBpcyBleHBlbnNpdmUsIHN1Y2ggYXMgc2VyaWFsaXNhdGlvbiBvZiBkYXRhLCB1c2Ugc2hvdWxkTG9nIHdpbGwgcHJldmVudFxuICAgICAgdGhlIG9iamVjdCBiZWluZyBzZXJpYWxpc2VkIGlmIHRoZSBsb2cgbGV2ZWwgd2lsbCBub3Qgb3V0cHV0IHRoZSBtZXNzYWdlICovXG4gICAgdGhpcy5zaG91bGRMb2cgPSAobGV2ZWwpID0+IHtcbiAgICAgIHJldHVybiBsZXZlbCA8PSB0aGlzLmxvZ0xldmVsO1xuICAgIH07XG4gICAgdGhpcy5zZXRMb2cgPSAobGV2ZWwsIGhhbmRsZXIpID0+IHtcbiAgICAgIGlmIChsZXZlbCAhPT0gdm9pZCAwKVxuICAgICAgICB0aGlzLmxvZ0xldmVsID0gbGV2ZWw7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gdm9pZCAwKVxuICAgICAgICB0aGlzLmxvZ0hhbmRsZXIgPSB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfTtcbiAgICB0aGlzLmxvZ0xldmVsID0gX0xvZ2dlci5kZWZhdWx0TG9nTGV2ZWw7XG4gICAgdGhpcy5sb2dIYW5kbGVyID0gX0xvZ2dlci5kZWZhdWx0TG9nSGFuZGxlcjtcbiAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IF9Mb2dnZXIuZGVmYXVsdExvZ0Vycm9ySGFuZGxlcjtcbiAgfVxuICBzdGF0aWMgaW5pdExvZ0hhbmRsZXJzKCkge1xuICAgIGNvbnN0IFtsb2dIYW5kbGVyLCBsb2dFcnJvckhhbmRsZXJdID0gZ2V0RGVmYXVsdExvZ2dlcnMoKTtcbiAgICB0aGlzLmRlZmF1bHRMb2dIYW5kbGVyID0gbG9nSGFuZGxlcjtcbiAgICB0aGlzLmRlZmF1bHRMb2dFcnJvckhhbmRsZXIgPSBsb2dFcnJvckhhbmRsZXI7XG4gICAgdGhpcy5kZWZhdWx0TG9nZ2VyID0gbmV3IF9Mb2dnZXIoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgdG8gdGhpcyBtZXRob2QgYXJlIG5ldmVyIHN0cmlwcGVkIGJ5IHRoZSBgc3RyaXBMb2dzYCBlc2J1aWxkIHBsdWdpbi4gVXNlIGl0IGZvciBsb2cgc3RhdGVtZW50cyB0aGF0IHlvdSB3aXNoIHRvIGFsd2F5cyBiZSBpbmNsdWRlZCBpbiB0aGUgbW9kdWxhciB2YXJpYW50IG9mIHRoZSBTREsuXG4gICAqL1xuICBzdGF0aWMgbG9nQWN0aW9uTm9TdHJpcChsb2dnZXIsIGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICBsb2dnZXIubG9nQWN0aW9uKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICB9XG4gIGxvZ0FjdGlvbihsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9nKGxldmVsKSkge1xuICAgICAgKGxldmVsID09PSAxIC8qIEVycm9yICovID8gdGhpcy5sb2dFcnJvckhhbmRsZXIgOiB0aGlzLmxvZ0hhbmRsZXIpKFwiQWJseTogXCIgKyBhY3Rpb24gKyBcIjogXCIgKyBtZXNzYWdlLCBsZXZlbCk7XG4gICAgfVxuICB9XG4gIHJlbmFtZWRDbGllbnRPcHRpb24ob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nKFxuICAgICAgYFRoZSBcXGAke29sZE5hbWV9XFxgIGNsaWVudCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGAke25ld05hbWV9XFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgXFxgJHtuZXdOYW1lfVxcYCBpbnN0ZWFkLiBcXGAke29sZE5hbWV9XFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLmBcbiAgICApO1xuICB9XG4gIHJlbmFtZWRNZXRob2QoY2xhc3NOYW1lLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBgXFxgJHtjbGFzc05hbWV9XFxgXFx1MjAxOXMgXFxgJHtvbGROYW1lfVxcYCBtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGAke25ld05hbWV9XFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgXFxgJHtuZXdOYW1lfVxcYCBpbnN0ZWFkLiBcXGAke29sZE5hbWV9XFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLmBcbiAgICApO1xuICB9XG4gIGRlcHJlY2F0aW9uV2FybmluZyhtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9nKDEgLyogRXJyb3IgKi8pKSB7XG4gICAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlcihgQWJseTogRGVwcmVjYXRpb24gd2FybmluZyAtICR7bWVzc2FnZX1gLCAxIC8qIEVycm9yICovKTtcbiAgICB9XG4gIH1cbn07XG5fTG9nZ2VyLmRlZmF1bHRMb2dMZXZlbCA9IDEgLyogRXJyb3IgKi87XG4vLyBwdWJsaWMgY29uc3RhbnRzXG5fTG9nZ2VyLkxPR19OT05FID0gMCAvKiBOb25lICovO1xuX0xvZ2dlci5MT0dfRVJST1IgPSAxIC8qIEVycm9yICovO1xuX0xvZ2dlci5MT0dfTUFKT1IgPSAyIC8qIE1ham9yICovO1xuX0xvZ2dlci5MT0dfTUlOT1IgPSAzIC8qIE1pbm9yICovO1xuX0xvZ2dlci5MT0dfTUlDUk8gPSA0IC8qIE1pY3JvICovO1xuLyogcHVibGljIHN0YXRpYyBmdW5jdGlvbnMgKi9cbi8qKlxuICogSW4gdGhlIG1vZHVsYXIgdmFyaWFudCBvZiB0aGUgU0RLLCB0aGUgYHN0cmlwTG9nc2AgZXNidWlsZCBwbHVnaW4gc3RyaXBzIG91dCBhbGwgY2FsbHMgdG8gdGhpcyBtZXRob2QgKHdoZW4gaW52b2tlZCBhcyBgTG9nZ2VyLmxvZ0FjdGlvbiguLi4pYCkgZXhjZXB0IHdoZW4gY2FsbGVkIHdpdGggbGV2ZWwgYExvZ2dlci5MT0dfRVJST1JgLiBJZiB5b3Ugd2lzaCBmb3IgYSBsb2cgc3RhdGVtZW50IHRvIG5ldmVyIGJlIHN0cmlwcGVkLCB1c2UgdGhlIHtAbGluayBsb2dBY3Rpb25Ob1N0cmlwfSBtZXRob2QgaW5zdGVhZC5cbiAqXG4gKiBUaGUgYWZvcmVtZW50aW9uZWQgcGx1Z2luIGV4cGVjdHMgYGxldmVsYCB0byBiZSBhbiBleHByZXNzaW9uIG9mIHRoZSBmb3JtIGBMb2dnZXIuTE9HXypgOyB0aGF0IGlzLCB5b3UgY2Fu4oCZdCBkeW5hbWljYWxseSBzcGVjaWZ5IHRoZSBsb2cgbGV2ZWwuXG4gKi9cbl9Mb2dnZXIubG9nQWN0aW9uID0gKGxvZ2dlciwgbGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkgPT4ge1xuICBfTG9nZ2VyLmxvZ0FjdGlvbk5vU3RyaXAobG9nZ2VyLCBsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKTtcbn07XG52YXIgTG9nZ2VyID0gX0xvZ2dlcjtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExvZ2dlcjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC91dGlscy50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgRm9ybWF0OiAoKSA9PiBGb3JtYXQsXG4gIGFsbFNhbWU6ICgpID0+IGFsbFNhbWUsXG4gIGFsbFRvTG93ZXJDYXNlOiAoKSA9PiBhbGxUb0xvd2VyQ2FzZSxcbiAgYWxsVG9VcHBlckNhc2U6ICgpID0+IGFsbFRvVXBwZXJDYXNlLFxuICBhcnJDaG9vc2VOOiAoKSA9PiBhcnJDaG9vc2VOLFxuICBhcnJEZWxldGVWYWx1ZTogKCkgPT4gYXJyRGVsZXRlVmFsdWUsXG4gIGFyckVxdWFsczogKCkgPT4gYXJyRXF1YWxzLFxuICBhcnJJbnRlcnNlY3Q6ICgpID0+IGFyckludGVyc2VjdCxcbiAgYXJySW50ZXJzZWN0T2I6ICgpID0+IGFyckludGVyc2VjdE9iLFxuICBhcnJQb3BSYW5kb21FbGVtZW50OiAoKSA9PiBhcnJQb3BSYW5kb21FbGVtZW50LFxuICBhcnJXaXRob3V0VmFsdWU6ICgpID0+IGFycldpdGhvdXRWYWx1ZSxcbiAgY2hlYXBSYW5kU3RyOiAoKSA9PiBjaGVhcFJhbmRTdHIsXG4gIGNvbnRhaW5zVmFsdWU6ICgpID0+IGNvbnRhaW5zVmFsdWUsXG4gIGNvcHk6ICgpID0+IGNvcHksXG4gIGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcjogKCkgPT4gY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yLFxuICBkYXRhU2l6ZUJ5dGVzOiAoKSA9PiBkYXRhU2l6ZUJ5dGVzLFxuICBkZWNvZGVCb2R5OiAoKSA9PiBkZWNvZGVCb2R5LFxuICBlbmNvZGVCb2R5OiAoKSA9PiBlbmNvZGVCb2R5LFxuICBlbnN1cmVBcnJheTogKCkgPT4gZW5zdXJlQXJyYXksXG4gIGZvckluT3duTm9uTnVsbFByb3BlcnRpZXM6ICgpID0+IGZvckluT3duTm9uTnVsbFByb3BlcnRpZXMsXG4gIGdldEJhY2tvZmZDb2VmZmljaWVudDogKCkgPT4gZ2V0QmFja29mZkNvZWZmaWNpZW50LFxuICBnZXRHbG9iYWxPYmplY3Q6ICgpID0+IGdldEdsb2JhbE9iamVjdCxcbiAgZ2V0Sml0dGVyQ29lZmZpY2llbnQ6ICgpID0+IGdldEppdHRlckNvZWZmaWNpZW50LFxuICBnZXRSZXRyeVRpbWU6ICgpID0+IGdldFJldHJ5VGltZSxcbiAgaW5oZXJpdHM6ICgpID0+IGluaGVyaXRzLFxuICBpbnNwZWN0Qm9keTogKCkgPT4gaW5zcGVjdEJvZHksXG4gIGluc3BlY3RFcnJvcjogKCkgPT4gaW5zcGVjdEVycm9yLFxuICBpbnRlcnNlY3Q6ICgpID0+IGludGVyc2VjdCxcbiAgaXNFbXB0eTogKCkgPT4gaXNFbXB0eSxcbiAgaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm86ICgpID0+IGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvLFxuICBpc05pbDogKCkgPT4gaXNOaWwsXG4gIGlzT2JqZWN0OiAoKSA9PiBpc09iamVjdCxcbiAga2V5c0FycmF5OiAoKSA9PiBrZXlzQXJyYXksXG4gIGxpc3RlbmVyVG9Bc3luY0l0ZXJhdG9yOiAoKSA9PiBsaXN0ZW5lclRvQXN5bmNJdGVyYXRvcixcbiAgbWF0Y2hEZXJpdmVkQ2hhbm5lbDogKCkgPT4gbWF0Y2hEZXJpdmVkQ2hhbm5lbCxcbiAgbWl4aW46ICgpID0+IG1peGluLFxuICBwYXJzZVF1ZXJ5U3RyaW5nOiAoKSA9PiBwYXJzZVF1ZXJ5U3RyaW5nLFxuICBwcm90b3R5cGljYWxDbG9uZTogKCkgPT4gcHJvdG90eXBpY2FsQ2xvbmUsXG4gIHJhbmRvbVN0cmluZzogKCkgPT4gcmFuZG9tU3RyaW5nLFxuICBzaGFsbG93Q2xvbmU6ICgpID0+IHNoYWxsb3dDbG9uZSxcbiAgc2hhbGxvd0VxdWFsczogKCkgPT4gc2hhbGxvd0VxdWFscyxcbiAgc3RyaW5naWZ5VmFsdWVzOiAoKSA9PiBzdHJpbmdpZnlWYWx1ZXMsXG4gIHRocm93TWlzc2luZ1BsdWdpbkVycm9yOiAoKSA9PiB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcixcbiAgdG9CYXNlNjQ6ICgpID0+IHRvQmFzZTY0LFxuICB0b1F1ZXJ5U3RyaW5nOiAoKSA9PiB0b1F1ZXJ5U3RyaW5nLFxuICB2YWx1ZXNBcnJheTogKCkgPT4gdmFsdWVzQXJyYXksXG4gIHdoZW5Qcm9taXNlU2V0dGxlczogKCkgPT4gd2hlblByb21pc2VTZXR0bGVzLFxuICB3aXRoVGltZW91dEFzeW5jOiAoKSA9PiB3aXRoVGltZW91dEFzeW5jXG59KTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZXJyb3JpbmZvLnRzXG5mdW5jdGlvbiB0b1N0cmluZyhlcnIpIHtcbiAgbGV0IHJlc3VsdCA9IFwiW1wiICsgZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChlcnIubWVzc2FnZSlcbiAgICByZXN1bHQgKz0gXCI6IFwiICsgZXJyLm1lc3NhZ2U7XG4gIGlmIChlcnIuc3RhdHVzQ29kZSlcbiAgICByZXN1bHQgKz0gXCI7IHN0YXR1c0NvZGU9XCIgKyBlcnIuc3RhdHVzQ29kZTtcbiAgaWYgKGVyci5jb2RlKVxuICAgIHJlc3VsdCArPSBcIjsgY29kZT1cIiArIGVyci5jb2RlO1xuICBpZiAoZXJyLmNhdXNlKVxuICAgIHJlc3VsdCArPSBcIjsgY2F1c2U9XCIgKyBpbnNwZWN0RXJyb3IoZXJyLmNhdXNlKTtcbiAgaWYgKGVyci5ocmVmICYmICEoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5kZXhPZihcImhlbHAuYWJseS5pb1wiKSA+IC0xKSlcbiAgICByZXN1bHQgKz0gXCI7IHNlZSBcIiArIGVyci5ocmVmICsgXCIgXCI7XG4gIHJlc3VsdCArPSBcIl1cIjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBFcnJvckluZm8gPSBjbGFzcyBfRXJyb3JJbmZvIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX0Vycm9ySW5mby5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUgfSA9IHZhbHVlcztcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNvZGUgIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHN0YXR1c0NvZGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9ySW5mby5mcm9tVmFsdWVzKCk6IGludmFsaWQgdmFsdWVzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KHZhbHVlcykpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKG5ldyBfRXJyb3JJbmZvKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpLCB2YWx1ZXMpO1xuICAgIGlmIChyZXN1bHQuY29kZSAmJiAhcmVzdWx0LmhyZWYpIHtcbiAgICAgIHJlc3VsdC5ocmVmID0gXCJodHRwczovL2hlbHAuYWJseS5pby9lcnJvci9cIiArIHJlc3VsdC5jb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xudmFyIFBhcnRpYWxFcnJvckluZm8gPSBjbGFzcyBfUGFydGlhbEVycm9ySW5mbyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBpZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIF9QYXJ0aWFsRXJyb3JJbmZvLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSB9ID0gdmFsdWVzO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIiB8fCAhaXNOaWwoY29kZSkgJiYgdHlwZW9mIGNvZGUgIT09IFwibnVtYmVyXCIgfHwgIWlzTmlsKHN0YXR1c0NvZGUpICYmIHR5cGVvZiBzdGF0dXNDb2RlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJ0aWFsRXJyb3JJbmZvLmZyb21WYWx1ZXMoKTogaW52YWxpZCB2YWx1ZXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QodmFsdWVzKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24obmV3IF9QYXJ0aWFsRXJyb3JJbmZvKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpLCB2YWx1ZXMpO1xuICAgIGlmIChyZXN1bHQuY29kZSAmJiAhcmVzdWx0LmhyZWYpIHtcbiAgICAgIHJlc3VsdC5ocmVmID0gXCJodHRwczovL2hlbHAuYWJseS5pby9lcnJvci9cIiArIHJlc3VsdC5jb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL3V0aWxzLnRzXG5mdW5jdGlvbiByYW5kb21Qb3NuKGFyck9yU3RyKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnJPclN0ci5sZW5ndGgpO1xufVxuZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCAuLi5hcmdzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3NbaV07XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBjb3B5KHNyYykge1xuICByZXR1cm4gbWl4aW4oe30sIHNyYyk7XG59XG5mdW5jdGlvbiBlbnN1cmVBcnJheShvYmopIHtcbiAgaWYgKGlzTmlsKG9iaikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmV0dXJuIFtvYmpdO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qob2IpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYikgPT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkob2IpIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc05pbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBPYmplY3QoKTtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKVxuICAgIHJlc3VsdFtwcm9wXSA9IG9iW3Byb3BdO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcHJvdG90eXBpY2FsQ2xvbmUob2IsIG93blByb3BlcnRpZXMpIHtcbiAgY2xhc3MgRiB7XG4gIH1cbiAgRi5wcm90b3R5cGUgPSBvYjtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEYoKTtcbiAgaWYgKG93blByb3BlcnRpZXMpXG4gICAgbWl4aW4ocmVzdWx0LCBvd25Qcm9wZXJ0aWVzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBpZiAoUGxhdGZvcm0uQ29uZmlnLmluaGVyaXRzKSB7XG4gICAgUGxhdGZvcm0uQ29uZmlnLmluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICBjdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwaWNhbENsb25lKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IGN0b3IgfSk7XG59O1xuZnVuY3Rpb24gY29udGFpbnNWYWx1ZShvYiwgdmFsKSB7XG4gIGZvciAoY29uc3QgaSBpbiBvYikge1xuICAgIGlmIChvYltpXSA9PSB2YWwpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3QoYXJyLCBvYikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYikgPyBhcnJJbnRlcnNlY3QoYXJyLCBvYikgOiBhcnJJbnRlcnNlY3RPYihhcnIsIG9iKTtcbn1cbmZ1bmN0aW9uIGFyckludGVyc2VjdChhcnIxLCBhcnIyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZW1iZXIgPSBhcnIxW2ldO1xuICAgIGlmIChhcnIyLmluZGV4T2YobWVtYmVyKSAhPSAtMSlcbiAgICAgIHJlc3VsdC5wdXNoKG1lbWJlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFyckludGVyc2VjdE9iKGFyciwgb2IpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWVtYmVyID0gYXJyW2ldO1xuICAgIGlmIChtZW1iZXIgaW4gb2IpXG4gICAgICByZXN1bHQucHVzaChtZW1iZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhcnJEZWxldGVWYWx1ZShhcnIsIHZhbCkge1xuICBjb25zdCBpZHggPSBhcnIuaW5kZXhPZih2YWwpO1xuICBjb25zdCByZXMgPSBpZHggIT0gLTE7XG4gIGlmIChyZXMpXG4gICAgYXJyLnNwbGljZShpZHgsIDEpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYXJyV2l0aG91dFZhbHVlKGFyciwgdmFsKSB7XG4gIGNvbnN0IG5ld0FyciA9IGFyci5zbGljZSgpO1xuICBhcnJEZWxldGVWYWx1ZShuZXdBcnIsIHZhbCk7XG4gIHJldHVybiBuZXdBcnI7XG59XG5mdW5jdGlvbiBrZXlzQXJyYXkob2IsIG93bk9ubHkpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYikge1xuICAgIGlmIChvd25Pbmx5ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKVxuICAgICAgY29udGludWU7XG4gICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbHVlc0FycmF5KG9iLCBvd25Pbmx5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpIHtcbiAgICBpZiAob3duT25seSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHJlc3VsdC5wdXNoKG9iW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyhvYiwgZm4pIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkgJiYgb2JbcHJvcF0pIHtcbiAgICAgIGZuKHByb3ApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWxsU2FtZShhcnIsIHByb3ApIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBmaXJzdCA9IGFyclswXVtwcm9wXTtcbiAgcmV0dXJuIGFyci5ldmVyeShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bcHJvcF0gPT09IGZpcnN0O1xuICB9KTtcbn1cbnZhciBGb3JtYXQgPSAvKiBAX19QVVJFX18gKi8gKChGb3JtYXQyKSA9PiB7XG4gIEZvcm1hdDJbXCJtc2dwYWNrXCJdID0gXCJtc2dwYWNrXCI7XG4gIEZvcm1hdDJbXCJqc29uXCJdID0gXCJqc29uXCI7XG4gIHJldHVybiBGb3JtYXQyO1xufSkoRm9ybWF0IHx8IHt9KTtcbmZ1bmN0aW9uIGFyclBvcFJhbmRvbUVsZW1lbnQoYXJyKSB7XG4gIHJldHVybiBhcnIuc3BsaWNlKHJhbmRvbVBvc24oYXJyKSwgMSlbMF07XG59XG5mdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBpZiAocGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKVxuICAgICAgcGFydHMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA/IFwiP1wiICsgcGFydHMuam9pbihcIiZcIikgOiBcIlwiO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWVzKHBhcmFtcykge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHBhcmFtcykubWFwKChbaywgdl0pID0+IFtrLCBTdHJpbmcodildKSk7XG59XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5KSB7XG4gIGxldCBtYXRjaDtcbiAgY29uc3Qgc2VhcmNoID0gLyhbXj8mPV0rKT0/KFteJl0qKS9nO1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgd2hpbGUgKG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpKVxuICAgIHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsyXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlcnIpIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnIgPT0gXCJvYmplY3RcIiAmJiBlcnIgIT09IG51bGwgJiYgKGVyciBpbnN0YW5jZW9mIEVycm9ySW5mbyB8fCBlcnIgaW5zdGFuY2VvZiBQYXJ0aWFsRXJyb3JJbmZvKTtcbn1cbmZ1bmN0aW9uIGluc3BlY3RFcnJvcihlcnIpIHtcbiAgdmFyIF9hMiwgX2I7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCAoKF9hMiA9IGVyciA9PSBudWxsID8gdm9pZCAwIDogZXJyLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm5hbWUpID09PSBcIkVycm9ySW5mb1wiIHx8ICgoX2IgPSBlcnIgPT0gbnVsbCA/IHZvaWQgMCA6IGVyci5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSBcIlBhcnRpYWxFcnJvckluZm9cIilcbiAgICByZXR1cm4gZXJyLnRvU3RyaW5nKCk7XG4gIHJldHVybiBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChlcnIpO1xufVxuZnVuY3Rpb24gaW5zcGVjdEJvZHkoYm9keSkge1xuICBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGJvZHkpO1xuICB9XG59XG5mdW5jdGlvbiBkYXRhU2l6ZUJ5dGVzKGRhdGEpIHtcbiAgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJ5dGVMZW5ndGgoZGF0YSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5zdHJpbmdCeXRlU2l6ZShkYXRhKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gODtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBFeHBlY3RlZCBpbnB1dCBvZiBVdGlscy5kYXRhU2l6ZUJ5dGVzIHRvIGJlIGEgc3RyaW5nLCBhIG51bWJlciwgYSBib29sZWFuIG9yIGEgYnVmZmVyLCBidXQgd2FzOiAke3R5cGVvZiBkYXRhfWBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNoZWFwUmFuZFN0cigpIHtcbiAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XG59XG52YXIgcmFuZG9tU3RyaW5nID0gYXN5bmMgKG51bUJ5dGVzKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IFBsYXRmb3JtLkNvbmZpZy5nZXRSYW5kb21BcnJheUJ1ZmZlcihudW1CeXRlcyk7XG4gIHJldHVybiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoYnVmZmVyKTtcbn07XG5mdW5jdGlvbiBhcnJDaG9vc2VOKGFyciwgbikge1xuICBjb25zdCBudW1JdGVtcyA9IE1hdGgubWluKG4sIGFyci5sZW5ndGgpLCBtdXRhYmxlQXJyID0gYXJyLnNsaWNlKCksIHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUl0ZW1zOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChhcnJQb3BSYW5kb21FbGVtZW50KG11dGFibGVBcnIpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2hlblByb21pc2VTZXR0bGVzKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gIHByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soZXJyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09IFwibXNncGFja1wiKSB7XG4gICAgaWYgKCFNc2dQYWNrKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgfVxuICAgIHJldHVybiBNc2dQYWNrLmRlY29kZShib2R5KTtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZShTdHJpbmcoYm9keSkpO1xufVxuZnVuY3Rpb24gZW5jb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PSBcIm1zZ3BhY2tcIikge1xuICAgIGlmICghTXNnUGFjaykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTXNnUGFjay5lbmNvZGUoYm9keSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJvZHkpO1xufVxuZnVuY3Rpb24gYWxsVG9Mb3dlckNhc2UoYXJyKSB7XG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWxsVG9VcHBlckNhc2UoYXJyKSB7XG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QmFja29mZkNvZWZmaWNpZW50KGNvdW50KSB7XG4gIHJldHVybiBNYXRoLm1pbigoY291bnQgKyAyKSAvIDMsIDIpO1xufVxuZnVuY3Rpb24gZ2V0Sml0dGVyQ29lZmZpY2llbnQoKSB7XG4gIHJldHVybiAxIC0gTWF0aC5yYW5kb20oKSAqIDAuMjtcbn1cbmZ1bmN0aW9uIGdldFJldHJ5VGltZShpbml0aWFsVGltZW91dCwgcmV0cnlBdHRlbXB0KSB7XG4gIHJldHVybiBpbml0aWFsVGltZW91dCAqIGdldEJhY2tvZmZDb2VmZmljaWVudChyZXRyeUF0dGVtcHQpICogZ2V0Sml0dGVyQ29lZmZpY2llbnQoKTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbE9iamVjdCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbHMoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkuZXZlcnkoKGtleSkgPT4gc291cmNlW2tleV0gPT09IHRhcmdldFtrZXldKSAmJiBPYmplY3Qua2V5cyh0YXJnZXQpLmV2ZXJ5KChrZXkpID0+IHRhcmdldFtrZXldID09PSBzb3VyY2Vba2V5XSk7XG59XG5mdW5jdGlvbiBtYXRjaERlcml2ZWRDaGFubmVsKG5hbWUpIHtcbiAgY29uc3QgcmVnZXggPSAvXihcXFsoW14/XSopKD86KC4qKSlcXF0pPyguKykkLztcbiAgY29uc3QgbWF0Y2ggPSBuYW1lLm1hdGNoKHJlZ2V4KTtcbiAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gubGVuZ3RoIHx8IG1hdGNoLmxlbmd0aCA8IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwicmVnZXggbWF0Y2ggZmFpbGVkXCIsIDQwMCwgNDAwMTApO1xuICB9XG4gIGlmIChtYXRjaFsyXSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oYGNhbm5vdCB1c2UgYSBkZXJpdmVkIG9wdGlvbiB3aXRoIGEgJHttYXRjaFsyXX0gY2hhbm5lbGAsIDQwMCwgNDAwMTApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcXVhbGlmaWVyUGFyYW06IG1hdGNoWzNdIHx8IFwiXCIsXG4gICAgY2hhbm5lbE5hbWU6IG1hdGNoWzRdXG4gIH07XG59XG5mdW5jdGlvbiB0b0Jhc2U2NChzdHIpIHtcbiAgY29uc3QgYnVmZmVyVXRpbHMgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscztcbiAgY29uc3QgdGV4dEJ1ZmZlciA9IGJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoc3RyKTtcbiAgcmV0dXJuIGJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSh0ZXh0QnVmZmVyKTtcbn1cbmZ1bmN0aW9uIGFyckVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbih2YWwsIGkpIHtcbiAgICByZXR1cm4gdmFsID09PSBiW2ldO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcihwbHVnaW5OYW1lKSB7XG4gIHJldHVybiBuZXcgRXJyb3JJbmZvKGAke3BsdWdpbk5hbWV9IHBsdWdpbiBub3QgcHJvdmlkZWRgLCA0MDAxOSwgNDAwKTtcbn1cbmZ1bmN0aW9uIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKHBsdWdpbk5hbWUpIHtcbiAgdGhyb3cgY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKHBsdWdpbk5hbWUpO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aFRpbWVvdXRBc3luYyhwcm9taXNlLCB0aW1lb3V0ID0gNWUzLCBlcnIgPSBcIlRpbWVvdXQgZXhwaXJlZFwiKSB7XG4gIGNvbnN0IGUgPSBuZXcgRXJyb3JJbmZvKGVyciwgNWU0LCA1MDApO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QoZSksIHRpbWVvdXQpKV0pO1xufVxuZnVuY3Rpb24gbGlzdGVuZXJUb0FzeW5jSXRlcmF0b3IocmVnaXN0ZXJMaXN0ZW5lcikge1xuICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGV2ZW50UXVldWUgPSBbXTtcbiAgICBsZXQgcmVzb2x2ZU5leHQgPSBudWxsO1xuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyMiA9IHJlZ2lzdGVyTGlzdGVuZXIoKGV2ZW50KSA9PiB7XG4gICAgICBpZiAocmVzb2x2ZU5leHQpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZSA9IHJlc29sdmVOZXh0O1xuICAgICAgICByZXNvbHZlTmV4dCA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnRRdWV1ZS5wdXNoKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGV2ZW50UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHlpZWxkIGV2ZW50UXVldWUuc2hpZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZU5leHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJDb25jdXJyZW50IG5leHQoKSBjYWxscyBhcmUgbm90IHN1cHBvcnRlZFwiLCA0ZTQsIDQwMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV2ZW50ID0geWllbGQgbmV3IF9fYXdhaXQobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVOZXh0ID0gcmVzb2x2ZTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIyKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gcGFja2FnZS5qc29uXG52YXIgdmVyc2lvbiA9IFwiMi4xNy4xXCI7XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvZGVmYXVsdHMudHNcbnZhciBhZ2VudCA9IFwiYWJseS1qcy9cIiArIHZlcnNpb247XG52YXIgRGVmYXVsdHMgPSB7XG4gIEVORFBPSU5UOiBcIm1haW5cIixcbiAgRU5WSVJPTk1FTlQ6IFwiXCIsXG4gIFJFU1RfSE9TVDogXCJyZXN0LmFibHkuaW9cIixcbiAgUkVBTFRJTUVfSE9TVDogXCJyZWFsdGltZS5hYmx5LmlvXCIsXG4gIEZBTExCQUNLX0hPU1RTOiBbXG4gICAgXCJtYWluLmEuZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIm1haW4uYi5mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwibWFpbi5jLmZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgXCJtYWluLmQuZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIm1haW4uZS5mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiXG4gIF0sXG4gIFBPUlQ6IDgwLFxuICBUTFNfUE9SVDogNDQzLFxuICBUSU1FT1VUUzoge1xuICAgIC8qIERvY3VtZW50ZWQgYXMgb3B0aW9ucyBwYXJhbXM6ICovXG4gICAgZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0OiAxNWUzLFxuICAgIHN1c3BlbmRlZFJldHJ5VGltZW91dDogM2U0LFxuICAgIC8qIFVuZG9jdW1lbnRlZCwgYnV0IHBhcnQgb2YgdGhlIGFwaSBhbmQgY2FuIGJlIHVzZWQgYnkgY3VzdG9tZXJzOiAqL1xuICAgIGh0dHBSZXF1ZXN0VGltZW91dDogMWU0LFxuICAgIGh0dHBNYXhSZXRyeUR1cmF0aW9uOiAxNWUzLFxuICAgIGNoYW5uZWxSZXRyeVRpbWVvdXQ6IDE1ZTMsXG4gICAgZmFsbGJhY2tSZXRyeVRpbWVvdXQ6IDZlNSxcbiAgICAvKiBGb3IgaW50ZXJuYWwgLyB0ZXN0IHVzZSBvbmx5OiAqL1xuICAgIGNvbm5lY3Rpb25TdGF0ZVR0bDogMTJlNCxcbiAgICByZWFsdGltZVJlcXVlc3RUaW1lb3V0OiAxZTQsXG4gICAgcmVjdlRpbWVvdXQ6IDllNCxcbiAgICB3ZWJTb2NrZXRDb25uZWN0VGltZW91dDogMWU0LFxuICAgIHdlYlNvY2tldFNsb3dUaW1lb3V0OiA0ZTNcbiAgfSxcbiAgaHR0cE1heFJldHJ5Q291bnQ6IDMsXG4gIG1heE1lc3NhZ2VTaXplOiA2NTUzNixcbiAgdmVyc2lvbixcbiAgcHJvdG9jb2xWZXJzaW9uOiA1LFxuICBhZ2VudCxcbiAgZ2V0UG9ydCxcbiAgZ2V0SHR0cFNjaGVtZSxcbiAgZ2V0UHJpbWFyeURvbWFpbkZyb21FbmRwb2ludCxcbiAgZ2V0RW5kcG9pbnRGYWxsYmFja0hvc3RzLFxuICBnZXRGYWxsYmFja0hvc3RzLFxuICBnZXRIb3N0cyxcbiAgY2hlY2tIb3N0LFxuICBvYmplY3RpZnlPcHRpb25zLFxuICBub3JtYWxpc2VPcHRpb25zLFxuICBkZWZhdWx0R2V0SGVhZGVycyxcbiAgZGVmYXVsdFBvc3RIZWFkZXJzXG59O1xuZnVuY3Rpb24gZ2V0UG9ydChvcHRpb25zLCB0bHMpIHtcbiAgcmV0dXJuIHRscyB8fCBvcHRpb25zLnRscyA/IG9wdGlvbnMudGxzUG9ydCA6IG9wdGlvbnMucG9ydDtcbn1cbmZ1bmN0aW9uIGdldEh0dHBTY2hlbWUob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy50bHMgPyBcImh0dHBzOi8vXCIgOiBcImh0dHA6Ly9cIjtcbn1cbmZ1bmN0aW9uIGlzRnFkbklwT3JMb2NhbGhvc3QoZW5kcG9pbnQpIHtcbiAgcmV0dXJuIGVuZHBvaW50LmluY2x1ZGVzKFwiLlwiKSB8fCBlbmRwb2ludC5pbmNsdWRlcyhcIjo6XCIpIHx8IGVuZHBvaW50ID09PSBcImxvY2FsaG9zdFwiO1xufVxuZnVuY3Rpb24gZ2V0UHJpbWFyeURvbWFpbkZyb21FbmRwb2ludChlbmRwb2ludCkge1xuICBpZiAoaXNGcWRuSXBPckxvY2FsaG9zdChlbmRwb2ludCkpXG4gICAgcmV0dXJuIGVuZHBvaW50O1xuICBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aChcIm5vbnByb2Q6XCIpKSB7XG4gICAgY29uc3Qgcm91dGluZ1BvbGljeUlkID0gZW5kcG9pbnQucmVwbGFjZShcIm5vbnByb2Q6XCIsIFwiXCIpO1xuICAgIHJldHVybiBgJHtyb3V0aW5nUG9saWN5SWR9LnJlYWx0aW1lLmFibHktbm9ucHJvZC5uZXRgO1xuICB9XG4gIHJldHVybiBgJHtlbmRwb2ludH0ucmVhbHRpbWUuYWJseS5uZXRgO1xufVxuZnVuY3Rpb24gZ2V0RW5kcG9pbnRGYWxsYmFja0hvc3RzKGVuZHBvaW50KSB7XG4gIGlmIChpc0ZxZG5JcE9yTG9jYWxob3N0KGVuZHBvaW50KSlcbiAgICByZXR1cm4gW107XG4gIGlmIChlbmRwb2ludC5zdGFydHNXaXRoKFwibm9ucHJvZDpcIikpIHtcbiAgICBjb25zdCByb3V0aW5nUG9saWN5SWQgPSBlbmRwb2ludC5yZXBsYWNlKFwibm9ucHJvZDpcIiwgXCJcIik7XG4gICAgcmV0dXJuIGVuZHBvaW50RmFsbGJhY2tzKHJvdXRpbmdQb2xpY3lJZCwgXCJhYmx5LXJlYWx0aW1lLW5vbnByb2QuY29tXCIpO1xuICB9XG4gIHJldHVybiBlbmRwb2ludEZhbGxiYWNrcyhlbmRwb2ludCwgXCJhYmx5LXJlYWx0aW1lLmNvbVwiKTtcbn1cbmZ1bmN0aW9uIGVuZHBvaW50RmFsbGJhY2tzKHJvdXRpbmdQb2xpY3lJZCwgZG9tYWluKSB7XG4gIHJldHVybiBbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiXS5tYXAoKGlkKSA9PiBgJHtyb3V0aW5nUG9saWN5SWR9LiR7aWR9LmZhbGxiYWNrLiR7ZG9tYWlufWApO1xufVxuZnVuY3Rpb24gZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSB7XG4gIGNvbnN0IGZhbGxiYWNrSG9zdHMgPSBvcHRpb25zLmZhbGxiYWNrSG9zdHMsIGh0dHBNYXhSZXRyeUNvdW50ID0gdHlwZW9mIG9wdGlvbnMuaHR0cE1heFJldHJ5Q291bnQgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50IDogRGVmYXVsdHMuaHR0cE1heFJldHJ5Q291bnQ7XG4gIHJldHVybiBmYWxsYmFja0hvc3RzID8gYXJyQ2hvb3NlTihmYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCkgOiBbXTtcbn1cbmZ1bmN0aW9uIGdldEhvc3RzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtvcHRpb25zLnByaW1hcnlEb21haW5dLmNvbmNhdChnZXRGYWxsYmFja0hvc3RzKG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0KSB7XG4gIGlmICh0eXBlb2YgaG9zdCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJob3N0IG11c3QgYmUgYSBzdHJpbmc7IHdhcyBhIFwiICsgdHlwZW9mIGhvc3QsIDRlNCwgNDAwKTtcbiAgfVxuICBpZiAoIWhvc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImhvc3QgbXVzdCBub3QgYmUgemVyby1sZW5ndGhcIiwgNGU0LCA0MDApO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0cyhvcHRpb25zKSB7XG4gIGNvbnN0IHRpbWVvdXRzID0ge307XG4gIGZvciAoY29uc3QgcHJvcCBpbiBEZWZhdWx0cy5USU1FT1VUUykge1xuICAgIHRpbWVvdXRzW3Byb3BdID0gb3B0aW9uc1twcm9wXSB8fCBEZWZhdWx0cy5USU1FT1VUU1twcm9wXTtcbiAgfVxuICByZXR1cm4gdGltZW91dHM7XG59XG5mdW5jdGlvbiBnZXRBZ2VudFN0cmluZyhvcHRpb25zKSB7XG4gIGxldCBhZ2VudFN0ciA9IERlZmF1bHRzLmFnZW50O1xuICBpZiAob3B0aW9ucy5hZ2VudHMpIHtcbiAgICBmb3IgKHZhciBhZ2VudDIgaW4gb3B0aW9ucy5hZ2VudHMpIHtcbiAgICAgIGFnZW50U3RyICs9IFwiIFwiICsgYWdlbnQyICsgXCIvXCIgKyBvcHRpb25zLmFnZW50c1thZ2VudDJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWdlbnRTdHI7XG59XG5mdW5jdGlvbiBvYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIGFsbG93S2V5T3JUb2tlbiwgc291cmNlRm9yRXJyb3JNZXNzYWdlLCBsb2dnZXIsIG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBjb25zdCBtc2cgPSBhbGxvd0tleU9yVG9rZW4gPyBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBlaXRoZXIgYSBjbGllbnQgb3B0aW9ucyBvYmplY3QsIGFuIEFibHkgQVBJIGtleSwgb3IgYW4gQWJseSBUb2tlbmAgOiBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGNsaWVudCBvcHRpb25zIG9iamVjdGA7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG4gIGxldCBvcHRpb25zT2JqO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob3B0aW9ucy5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xuICAgICAgaWYgKCFhbGxvd0tleU9yVG9rZW4pIHtcbiAgICAgICAgY29uc3QgbXNnID0gYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBqdXN0IGFuIEFibHkgVG9rZW47IHlvdSBtdXN0IHByb3ZpZGUgYSBjbGllbnQgb3B0aW9ucyBvYmplY3Qgd2l0aCBhIFxcYHBsdWdpbnNcXGAgcHJvcGVydHkuIChTZXQgdGhpcyBBYmx5IFRva2VuIGFzIHRoZSBvYmplY3RcXHUyMDE5cyBcXGB0b2tlblxcYCBwcm9wZXJ0eS4pYDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNPYmogPSB7IHRva2VuOiBvcHRpb25zIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYWxsb3dLZXlPclRva2VuKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGAke3NvdXJjZUZvckVycm9yTWVzc2FnZX0gY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGgganVzdCBhbiBBYmx5IEFQSSBrZXk7IHlvdSBtdXN0IHByb3ZpZGUgYSBjbGllbnQgb3B0aW9ucyBvYmplY3Qgd2l0aCBhIFxcYHBsdWdpbnNcXGAgcHJvcGVydHkuIChTZXQgdGhpcyBBYmx5IEFQSSBrZXkgYXMgdGhlIG9iamVjdFxcdTIwMTlzIFxcYGtleVxcYCBwcm9wZXJ0eS4pYDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNPYmogPSB7IGtleTogb3B0aW9ucyB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zT2JqID0gb3B0aW9ucztcbiAgfVxuICBpZiAobW9kdWxhclBsdWdpbnNUb0luY2x1ZGUpIHtcbiAgICBvcHRpb25zT2JqID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9uc09iaiksIHsgcGx1Z2luczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSwgb3B0aW9uc09iai5wbHVnaW5zKSB9KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc09iajtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZDbGllbnRPcHRpb25zQXJlVmFsaWQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5lbmRwb2ludCAmJiAob3B0aW9ucy5lbnZpcm9ubWVudCB8fCBvcHRpb25zLnJlc3RIb3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0KSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIlRoZSBgZW5kcG9pbnRgIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgZW52aXJvbm1lbnRgLCBgcmVzdEhvc3RgLCBvciBgcmVhbHRpbWVIb3N0YCBvcHRpb25zLlwiLFxuICAgICAgNDAxMDYsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG4gIGlmIChvcHRpb25zLmVudmlyb25tZW50ICYmIChvcHRpb25zLnJlc3RIb3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0KSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIlRoZSBgZW52aXJvbm1lbnRgIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgcmVzdEhvc3RgLCBvciBgcmVhbHRpbWVIb3N0YCBvcHRpb25zLlwiLFxuICAgICAgNDAxMDYsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpc2VPcHRpb25zKG9wdGlvbnMsIE1zZ1BhY2ssIGxvZ2dlcikge1xuICBjb25zdCBsb2dnZXJUb1VzZSA9IGxvZ2dlciAhPSBudWxsID8gbG9nZ2VyIDogbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcjtcbiAgaWYgKG9wdGlvbnMuZW52aXJvbm1lbnQpIHtcbiAgICBsb2dnZXJUb1VzZS5kZXByZWNhdGVkKFwiVGhlIGBlbnZpcm9ubWVudGAgY2xpZW50IG9wdGlvblwiLCBcIlVzZSB0aGUgYGVuZHBvaW50YCBjbGllbnQgb3B0aW9uIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLnJlc3RIb3N0KSB7XG4gICAgbG9nZ2VyVG9Vc2UuZGVwcmVjYXRlZChcIlRoZSBgcmVzdEhvc3RgIGNsaWVudCBvcHRpb25cIiwgXCJVc2UgdGhlIGBlbmRwb2ludGAgY2xpZW50IG9wdGlvbiBpbnN0ZWFkLlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZWFsdGltZUhvc3QpIHtcbiAgICBsb2dnZXJUb1VzZS5kZXByZWNhdGVkKFwiVGhlIGByZWFsdGltZUhvc3RgIGNsaWVudCBvcHRpb25cIiwgXCJVc2UgdGhlIGBlbmRwb2ludGAgY2xpZW50IG9wdGlvbiBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjaGVja0lmQ2xpZW50T3B0aW9uc0FyZVZhbGlkKG9wdGlvbnMpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlclRvVXNlLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zXCIsXG4gICAgICBcImNsb3NlT25VbmxvYWQgd2FzIHRydWUgYW5kIGEgc2Vzc2lvbiByZWNvdmVyeSBmdW5jdGlvbiB3YXMgc2V0IC0gdGhlc2UgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gdW5zZXR0aW5nIHRoZSBsYXR0ZXJcIlxuICAgICk7XG4gICAgb3B0aW9ucy5yZWNvdmVyID0gdm9pZCAwO1xuICB9XG4gIGlmICghKFwiY2xvc2VPblVubG9hZFwiIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID0gIW9wdGlvbnMucmVjb3ZlcjtcbiAgfVxuICBpZiAoIShcInF1ZXVlTWVzc2FnZXNcIiBpbiBvcHRpb25zKSlcbiAgICBvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSB0cnVlO1xuICBjb25zdCBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnQgfHwgRGVmYXVsdHMuRU5EUE9JTlQ7XG4gIGlmICghb3B0aW9ucy5mYWxsYmFja0hvc3RzICYmICFvcHRpb25zLnJlc3RIb3N0ICYmICFvcHRpb25zLnJlYWx0aW1lSG9zdCAmJiAhb3B0aW9ucy5wb3J0ICYmICFvcHRpb25zLnRsc1BvcnQpIHtcbiAgICBvcHRpb25zLmZhbGxiYWNrSG9zdHMgPSBnZXRFbmRwb2ludEZhbGxiYWNrSG9zdHMob3B0aW9ucy5lbnZpcm9ubWVudCB8fCBlbmRwb2ludCk7XG4gIH1cbiAgY29uc3QgcHJpbWFyeURvbWFpbkZyb21FbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQgJiYgYCR7b3B0aW9ucy5lbnZpcm9ubWVudH0ucmVhbHRpbWUuYWJseS5uZXRgO1xuICBjb25zdCBwcmltYXJ5RG9tYWluRnJvbUxlZ2FjeU9wdGlvbnMgPSBvcHRpb25zLnJlc3RIb3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0IHx8IHByaW1hcnlEb21haW5Gcm9tRW52aXJvbm1lbnQ7XG4gIGNvbnN0IHByaW1hcnlEb21haW4gPSBwcmltYXJ5RG9tYWluRnJvbUxlZ2FjeU9wdGlvbnMgfHwgZ2V0UHJpbWFyeURvbWFpbkZyb21FbmRwb2ludChlbmRwb2ludCk7XG4gIChvcHRpb25zLmZhbGxiYWNrSG9zdHMgfHwgW10pLmNvbmNhdChwcmltYXJ5RG9tYWluKS5mb3JFYWNoKGNoZWNrSG9zdCk7XG4gIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydCB8fCBEZWZhdWx0cy5QT1JUO1xuICBvcHRpb25zLnRsc1BvcnQgPSBvcHRpb25zLnRsc1BvcnQgfHwgRGVmYXVsdHMuVExTX1BPUlQ7XG4gIGlmICghKFwidGxzXCIgaW4gb3B0aW9ucykpXG4gICAgb3B0aW9ucy50bHMgPSB0cnVlO1xuICBjb25zdCB0aW1lb3V0cyA9IGdldFRpbWVvdXRzKG9wdGlvbnMpO1xuICBpZiAoTXNnUGFjaykge1xuICAgIGlmIChcInVzZUJpbmFyeVByb3RvY29sXCIgaW4gb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IFBsYXRmb3JtLkNvbmZpZy5zdXBwb3J0c0JpbmFyeSAmJiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gUGxhdGZvcm0uQ29uZmlnLnByZWZlckJpbmFyeTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKG9wdGlvbnMuY2xpZW50SWQpIHtcbiAgICBoZWFkZXJzW1wiWC1BYmx5LUNsaWVudElkXCJdID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUob3B0aW9ucy5jbGllbnRJZCkpO1xuICB9XG4gIGlmICghKFwiaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nXCIgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHRydWU7XG4gIH1cbiAgbGV0IGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gbnVsbDtcbiAgbGV0IGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgaWYgKG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwpIHtcbiAgICBsZXQgW3VyaSwgcXNdID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybC5zcGxpdChcIj9cIik7XG4gICAgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSBxcyA/IHBhcnNlUXVlcnlTdHJpbmcocXMpIDoge307XG4gICAgaWYgKHVyaS5pbmRleE9mKFwiOi8vXCIpID09PSAtMSkge1xuICAgICAgdXJpID0gXCJodHRwczovL1wiICsgdXJpO1xuICAgIH1cbiAgICBjb25uZWN0aXZpdHlDaGVja1VybCA9IHVyaTtcbiAgfVxuICBsZXQgd3NDb25uZWN0aXZpdHlDaGVja1VybCA9IG9wdGlvbnMud3NDb25uZWN0aXZpdHlDaGVja1VybDtcbiAgaWYgKHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgJiYgd3NDb25uZWN0aXZpdHlDaGVja1VybC5pbmRleE9mKFwiOi8vXCIpID09PSAtMSkge1xuICAgIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgPSBcIndzczovL1wiICsgd3NDb25uZWN0aXZpdHlDaGVja1VybDtcbiAgfVxuICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICBwcmltYXJ5RG9tYWluLFxuICAgIG1heE1lc3NhZ2VTaXplOiBvcHRpb25zLm1heE1lc3NhZ2VTaXplIHx8IERlZmF1bHRzLm1heE1lc3NhZ2VTaXplLFxuICAgIHRpbWVvdXRzLFxuICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zLFxuICAgIGNvbm5lY3Rpdml0eUNoZWNrVXJsLFxuICAgIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwsXG4gICAgaGVhZGVyc1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKENyeXB0bzIsIGxvZ2dlciwgb3B0aW9ucykge1xuICBjb25zdCBjaGFubmVsT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChjaGFubmVsT3B0aW9ucy5jaXBoZXIpIHtcbiAgICBpZiAoIUNyeXB0bzIpXG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIkNyeXB0b1wiKTtcbiAgICBjb25zdCBjaXBoZXIgPSBDcnlwdG8yLmdldENpcGhlcihjaGFubmVsT3B0aW9ucy5jaXBoZXIsIGxvZ2dlcik7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2lwaGVyID0gY2lwaGVyLmNpcGhlclBhcmFtcztcbiAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gY2lwaGVyLmNpcGhlcjtcbiAgfSBlbHNlIGlmIChcImNpcGhlclwiIGluIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2lwaGVyID0gdm9pZCAwO1xuICAgIGNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBudWxsO1xuICB9XG4gIHJldHVybiBjaGFubmVsT3B0aW9ucztcbn1cbnZhciBjb250ZW50VHlwZXMgPSB7XG4gIGpzb246IFwiYXBwbGljYXRpb24vanNvblwiLFxuICB4bWw6IFwiYXBwbGljYXRpb24veG1sXCIsXG4gIGh0bWw6IFwidGV4dC9odG1sXCIsXG4gIG1zZ3BhY2s6IFwiYXBwbGljYXRpb24veC1tc2dwYWNrXCIsXG4gIHRleHQ6IFwidGV4dC9wbGFpblwiXG59O1xudmFyIGRlZmF1bHRIZWFkZXJzT3B0aW9ucyA9IHtcbiAgZm9ybWF0OiBcImpzb25cIiAvKiBqc29uICovLFxuICBwcm90b2NvbFZlcnNpb246IERlZmF1bHRzLnByb3RvY29sVmVyc2lvblxufTtcbmZ1bmN0aW9uIGRlZmF1bHRHZXRIZWFkZXJzKG9wdGlvbnMsIHsgZm9ybWF0LCBwcm90b2NvbFZlcnNpb24gPSBkZWZhdWx0SGVhZGVyc09wdGlvbnMucHJvdG9jb2xWZXJzaW9uIH0gPSB7fSkge1xuICBjb25zdCBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0ICE9IG51bGwgPyBmb3JtYXQgOiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi9dO1xuICByZXR1cm4ge1xuICAgIGFjY2VwdCxcbiAgICBcIlgtQWJseS1WZXJzaW9uXCI6IHByb3RvY29sVmVyc2lvbi50b1N0cmluZygpLFxuICAgIFwiQWJseS1BZ2VudFwiOiBnZXRBZ2VudFN0cmluZyhvcHRpb25zKVxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdFBvc3RIZWFkZXJzKG9wdGlvbnMsIHsgZm9ybWF0LCBwcm90b2NvbFZlcnNpb24gPSBkZWZhdWx0SGVhZGVyc09wdGlvbnMucHJvdG9jb2xWZXJzaW9uIH0gPSB7fSkge1xuICBjb25zdCBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0ICE9IG51bGwgPyBmb3JtYXQgOiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi9dO1xuICBjb25zdCBjb250ZW50VHlwZSA9IGFjY2VwdDtcbiAgcmV0dXJuIHtcbiAgICBhY2NlcHQsXG4gICAgXCJjb250ZW50LXR5cGVcIjogY29udGVudFR5cGUsXG4gICAgXCJYLUFibHktVmVyc2lvblwiOiBwcm90b2NvbFZlcnNpb24udG9TdHJpbmcoKSxcbiAgICBcIkFibHktQWdlbnRcIjogZ2V0QWdlbnRTdHJpbmcob3B0aW9ucylcbiAgfTtcbn1cbnZhciBkZWZhdWx0c19kZWZhdWx0ID0gRGVmYXVsdHM7XG5mdW5jdGlvbiBnZXREZWZhdWx0cyhwbGF0Zm9ybURlZmF1bHRzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKERlZmF1bHRzLCBwbGF0Zm9ybURlZmF1bHRzKTtcbn1cblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9tdWx0aWNhc3Rlci50c1xudmFyIE11bHRpY2FzdGVyID0gY2xhc3MgX011bHRpY2FzdGVyIHtcbiAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlIHN0YXRpYyBNdWx0aWNhc3Rlci5jcmVhdGUgaW5zdGVhZFxuICBjb25zdHJ1Y3Rvcihsb2dnZXIsIG1lbWJlcnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzIHx8IFtdO1xuICB9XG4gIGNhbGwoZXJyLCByZXN1bHQpIHtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0aGlzLm1lbWJlcnMpIHtcbiAgICAgIGlmIChtZW1iZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZW1iZXIoZXJyLCByZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIk11bHRpY2FzdGVyIG11bHRpcGxlIGNhbGxiYWNrIGhhbmRsZXJcIixcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb246IFwiICsgZSArIFwiOyBzdGFjayA9IFwiICsgZS5zdGFja1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHVzaCguLi5hcmdzKSB7XG4gICAgdGhpcy5tZW1iZXJzLnB1c2goLi4uYXJncyk7XG4gIH1cbiAgY3JlYXRlUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wdXNoKChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlc29sdmVBbGwocmVzdWx0KSB7XG4gICAgdGhpcy5jYWxsKG51bGwsIHJlc3VsdCk7XG4gIH1cbiAgcmVqZWN0QWxsKGVycikge1xuICAgIHRoaXMuY2FsbChlcnIpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUobG9nZ2VyLCBtZW1iZXJzKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgX011bHRpY2FzdGVyKGxvZ2dlciwgbWVtYmVycyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKGVyciwgcmVzdWx0KSA9PiBpbnN0YW5jZS5jYWxsKGVyciwgcmVzdWx0KSwge1xuICAgICAgcHVzaDogKGZuKSA9PiBpbnN0YW5jZS5wdXNoKGZuKSxcbiAgICAgIGNyZWF0ZVByb21pc2U6ICgpID0+IGluc3RhbmNlLmNyZWF0ZVByb21pc2UoKSxcbiAgICAgIHJlc29sdmVBbGw6IChyZXN1bHQpID0+IGluc3RhbmNlLnJlc29sdmVBbGwocmVzdWx0KSxcbiAgICAgIHJlamVjdEFsbDogKGVycikgPT4gaW5zdGFuY2UucmVqZWN0QWxsKGVycilcbiAgICB9KTtcbiAgfVxufTtcbnZhciBtdWx0aWNhc3Rlcl9kZWZhdWx0ID0gTXVsdGljYXN0ZXI7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL0h0dHBNZXRob2RzLnRzXG52YXIgSHR0cE1ldGhvZHMgPSAvKiBAX19QVVJFX18gKi8gKChIdHRwTWV0aG9kczIpID0+IHtcbiAgSHR0cE1ldGhvZHMyW1wiR2V0XCJdID0gXCJnZXRcIjtcbiAgSHR0cE1ldGhvZHMyW1wiRGVsZXRlXCJdID0gXCJkZWxldGVcIjtcbiAgSHR0cE1ldGhvZHMyW1wiUG9zdFwiXSA9IFwicG9zdFwiO1xuICBIdHRwTWV0aG9kczJbXCJQdXRcIl0gPSBcInB1dFwiO1xuICBIdHRwTWV0aG9kczJbXCJQYXRjaFwiXSA9IFwicGF0Y2hcIjtcbiAgcmV0dXJuIEh0dHBNZXRob2RzMjtcbn0pKEh0dHBNZXRob2RzIHx8IHt9KTtcbnZhciBIdHRwTWV0aG9kc19kZWZhdWx0ID0gSHR0cE1ldGhvZHM7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL0h0dHBTdGF0dXNDb2Rlcy50c1xudmFyIEh0dHBTdGF0dXNDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKEh0dHBTdGF0dXNDb2RlczIpID0+IHtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiU3VjY2Vzc1wiXSA9IDIwMF0gPSBcIlN1Y2Nlc3NcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiTm9Db250ZW50XCJdID0gMjA0XSA9IFwiTm9Db250ZW50XCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIkJhZFJlcXVlc3RcIl0gPSA0MDBdID0gXCJCYWRSZXF1ZXN0XCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIlVuYXV0aG9yaXplZFwiXSA9IDQwMV0gPSBcIlVuYXV0aG9yaXplZFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJGb3JiaWRkZW5cIl0gPSA0MDNdID0gXCJGb3JiaWRkZW5cIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiUmVxdWVzdFRpbWVvdXRcIl0gPSA0MDhdID0gXCJSZXF1ZXN0VGltZW91dFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNTAwXSA9IFwiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiO1xuICByZXR1cm4gSHR0cFN0YXR1c0NvZGVzMjtcbn0pKEh0dHBTdGF0dXNDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBpc1N1Y2Nlc3NDb2RlKHN0YXR1c0NvZGUpIHtcbiAgcmV0dXJuIHN0YXR1c0NvZGUgPj0gMjAwIC8qIFN1Y2Nlc3MgKi8gJiYgc3RhdHVzQ29kZSA8IDQwMCAvKiBCYWRSZXF1ZXN0ICovO1xufVxudmFyIEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0ID0gSHR0cFN0YXR1c0NvZGVzO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYXV0aC50c1xudmFyIE1BWF9UT0tFTl9MRU5HVEggPSBNYXRoLnBvdygyLCAxNyk7XG5mdW5jdGlvbiByYW5kb20oKSB7XG4gIHJldHVybiAoXCIwMDAwMDBcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTYpKS5zbGljZSgtMTYpO1xufVxuZnVuY3Rpb24gaXNSZWFsdGltZShjbGllbnQpIHtcbiAgcmV0dXJuICEhY2xpZW50LmNvbm5lY3Rpb247XG59XG5mdW5jdGlvbiBub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpIHtcbiAgaWYgKCFpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlcnIpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvckluZm8oaW5zcGVjdEVycm9yKGVyciksIGVyci5jb2RlIHx8IDQwMTcwLCBlcnIuc3RhdHVzQ29kZSB8fCA0MDEpO1xuICB9XG4gIGlmICghZXJyLmNvZGUpIHtcbiAgICBpZiAoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xuICAgICAgZXJyLmNvZGUgPSA0MDMwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyLmNvZGUgPSA0MDE3MDtcbiAgICAgIGVyci5zdGF0dXNDb2RlID0gNDAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXJyO1xufVxudmFyIGhtYWMgPSAodGV4dCwga2V5KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlclV0aWxzID0gUGxhdGZvcm0uQnVmZmVyVXRpbHM7XG4gIGNvbnN0IHRleHRCdWZmZXIgPSBidWZmZXJVdGlscy51dGY4RW5jb2RlKHRleHQpO1xuICBjb25zdCBrZXlCdWZmZXIgPSBidWZmZXJVdGlscy51dGY4RW5jb2RlKGtleSk7XG4gIGNvbnN0IGRpZ2VzdCA9IGJ1ZmZlclV0aWxzLmhtYWNTaGEyNTYodGV4dEJ1ZmZlciwga2V5QnVmZmVyKTtcbiAgcmV0dXJuIGJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkaWdlc3QpO1xufTtcbmZ1bmN0aW9uIGMxNG4oY2FwYWJpbGl0eSkge1xuICBpZiAoIWNhcGFiaWxpdHkpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGlmICh0eXBlb2YgY2FwYWJpbGl0eSA9PSBcInN0cmluZ1wiKVxuICAgIGNhcGFiaWxpdHkgPSBKU09OLnBhcnNlKGNhcGFiaWxpdHkpO1xuICBjb25zdCBjMTRuQ2FwYWJpbGl0eSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBrZXlzID0ga2V5c0FycmF5KGNhcGFiaWxpdHksIHRydWUpO1xuICBpZiAoIWtleXMpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGtleXMuc29ydCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjMTRuQ2FwYWJpbGl0eVtrZXlzW2ldXSA9IGNhcGFiaWxpdHlba2V5c1tpXV0uc29ydCgpO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShjMTRuQ2FwYWJpbGl0eSk7XG59XG5mdW5jdGlvbiBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZChhdXRoT3B0aW9ucywgbG9nZ2VyKSB7XG4gIGlmIChhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFja1wiKTtcbiAgfSBlbHNlIGlmIChhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsXCIpO1xuICB9IGVsc2UgaWYgKGF1dGhPcHRpb25zLmtleSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZ1wiKTtcbiAgfSBlbHNlIGlmIChhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIHN1cHBsaWVkIHRva2VuIG9ubHlcIik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbXNnID0gXCJhdXRoT3B0aW9ucyBtdXN0IGluY2x1ZGUgdmFsaWQgYXV0aGVudGljYXRpb24gcGFyYW1ldGVyc1wiO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoKClcIiwgbXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gYmFzaWNBdXRoRm9yY2VkKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFwidXNlVG9rZW5BdXRoXCIgaW4gb3B0aW9ucyAmJiAhb3B0aW9ucy51c2VUb2tlbkF1dGg7XG59XG5mdW5jdGlvbiB1c2VUb2tlbkF1dGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy51c2VUb2tlbkF1dGggfHwgIWJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSAmJiAob3B0aW9ucy5hdXRoQ2FsbGJhY2sgfHwgb3B0aW9ucy5hdXRoVXJsIHx8IG9wdGlvbnMudG9rZW4gfHwgb3B0aW9ucy50b2tlbkRldGFpbHMpO1xufVxuZnVuY3Rpb24gbm9XYXlUb1JlbmV3KG9wdGlvbnMpIHtcbiAgcmV0dXJuICFvcHRpb25zLmtleSAmJiAhb3B0aW9ucy5hdXRoQ2FsbGJhY2sgJiYgIW9wdGlvbnMuYXV0aFVybDtcbn1cbnZhciB0cklkID0gMDtcbmZ1bmN0aW9uIGdldFRva2VuUmVxdWVzdElkKCkge1xuICByZXR1cm4gdHJJZCsrO1xufVxudmFyIEF1dGggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgb3B0aW9ucykge1xuICAgIC8vIFRoaXMgaW5pdGlhbGl6YXRpb24gaXMgYWx3YXlzIG92ZXJ3cml0dGVuIGFuZCBvbmx5IHVzZWQgdG8gcHJldmVudCBhIFR5cGVTY3JpcHQgY29tcGlsZXIgZXJyb3JcbiAgICB0aGlzLmF1dGhPcHRpb25zID0ge307XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy50b2tlblBhcmFtcyA9IG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zIHx8IHt9O1xuICAgIHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcbiAgICB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuICAgIGlmICh1c2VUb2tlbkF1dGgob3B0aW9ucykpIHtcbiAgICAgIGlmIChub1dheVRvUmVuZXcob3B0aW9ucykpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkF1dGgoKVwiLFxuICAgICAgICAgIFwiV2FybmluZzogbGlicmFyeSBpbml0aWFsaXplZCB3aXRoIGEgdG9rZW4gbGl0ZXJhbCB3aXRob3V0IGFueSB3YXkgdG8gcmVuZXcgdGhlIHRva2VuIHdoZW4gaXQgZXhwaXJlcyAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpLiBTZWUgaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvNDAxNzEgZm9yIGhlbHBcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyhvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcywgb3B0aW9ucyk7XG4gICAgICBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zLCB0aGlzLmxvZ2dlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghb3B0aW9ucy5rZXkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gXCJObyBhdXRoZW50aWNhdGlvbiBvcHRpb25zIHByb3ZpZGVkOyBuZWVkIG9uZSBvZjoga2V5LCBhdXRoVXJsLCBvciBhdXRoQ2FsbGJhY2sgKG9yIGZvciB0ZXN0aW5nIG9ubHksIHRva2VuIG9yIHRva2VuRGV0YWlscylcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aCgpXCIsIG1zZyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8obXNnLCA0MDE2MCwgNDAxKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcImFub255bW91cywgdXNpbmcgYmFzaWMgYXV0aFwiKTtcbiAgICAgIHRoaXMuX3NhdmVCYXNpY09wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBhc3luYyBhdXRob3JpemUodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhPcHRpb25zICYmIGF1dGhPcHRpb25zLmtleSAmJiB0aGlzLmF1dGhPcHRpb25zLmtleSAhPT0gYXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHVwZGF0ZSBhdXRoIG9wdGlvbnMgd2l0aCBpbmNvbXBhdGlibGUga2V5XCIsIDQwMTAyLCA0MDEpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHRva2VuRGV0YWlscyA9IGF3YWl0IHRoaXMuX2ZvcmNlTmV3VG9rZW4odG9rZW5QYXJhbXMgIT0gbnVsbCA/IHRva2VuUGFyYW1zIDogbnVsbCwgYXV0aE9wdGlvbnMgIT0gbnVsbCA/IGF1dGhPcHRpb25zIDogbnVsbCk7XG4gICAgICBpZiAoaXNSZWFsdGltZSh0aGlzLmNsaWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoXG4gICAgICAgICAgICB0b2tlbkRldGFpbHMsXG4gICAgICAgICAgICAoZXJyLCB0b2tlbkRldGFpbHMyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUodG9rZW5EZXRhaWxzMilcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbkRldGFpbHM7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5jbGllbnQuY29ubmVjdGlvbiAmJiBlcnIuc3RhdHVzQ29kZSA9PT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuRm9yYmlkZGVuKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgLyogRm9yIGludGVybmFsIHVzZSwgZWcgYnkgY29ubmVjdGlvbk1hbmFnZXIgLSB1c2VmdWwgd2hlbiB3YW50IHRvIGNhbGwgYmFja1xuICAgKiBhcyBzb29uIGFzIHdlIGhhdmUgdGhlIG5ldyB0b2tlbiwgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgaXQgdG8gdGFrZVxuICAgKiBlZmZlY3Qgb24gdGhlIGNvbm5lY3Rpb24gYXMgI2F1dGhvcml6ZSBkb2VzICovXG4gIGFzeW5jIF9mb3JjZU5ld1Rva2VuKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9zYXZlVG9rZW5PcHRpb25zKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucyk7XG4gICAgbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucywgdGhpcy5sb2dnZXIpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHModHJ1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRva2VuUGFyYW1zLnRpbWVzdGFtcDtcbiAgICAgIGRlbGV0ZSB0aGlzLmF1dGhPcHRpb25zLnF1ZXJ5VGltZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFRva2VuKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIGNvbnN0IHJlc29sdmVkQXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuICAgIGNvbnN0IHJlc29sdmVkVG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCBjb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuICAgIGxldCB0b2tlblJlcXVlc3RDYWxsYmFjaywgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFja1wiKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2s7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybFwiKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gKHBhcmFtcywgY2IpID0+IHtcbiAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBtaXhpbihcbiAgICAgICAgICB7IGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluXCIgfSxcbiAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhIZWFkZXJzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHVzZVBvc3QgPSByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhNZXRob2QgJiYgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoTWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwicG9zdFwiO1xuICAgICAgICBsZXQgcHJvdmlkZWRRc1BhcmFtcztcbiAgICAgICAgY29uc3QgcXVlcnlJZHggPSByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwuaW5kZXhPZihcIj9cIik7XG4gICAgICAgIGlmIChxdWVyeUlkeCA+IC0xKSB7XG4gICAgICAgICAgcHJvdmlkZWRRc1BhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKHF1ZXJ5SWR4KSk7XG4gICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKDAsIHF1ZXJ5SWR4KTtcbiAgICAgICAgICBpZiAoIXVzZVBvc3QpIHtcbiAgICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFBhcmFtcyA9IG1peGluKFxuICAgICAgICAgICAgICBwcm92aWRlZFFzUGFyYW1zLFxuICAgICAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhQYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGhQYXJhbXMgPSBtaXhpbih7fSwgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoUGFyYW1zIHx8IHt9LCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrID0gKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICAgIGxldCBib2R5ID0gKF9hMiA9IHJlc3VsdC5ib2R5KSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgICAgICAgICBsZXQgY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrXCIsXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnJvcilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlSGVhZGVyT3JIZWFkZXJzID0gKF9iID0gcmVzdWx0LmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pICE9IG51bGwgPyBfYiA6IG51bGw7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycykpIHtcbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycy5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlSGVhZGVyT3JIZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZDsgY29udGVudC10eXBlOiBcIiArIGNvbnRlbnRUeXBlICsgXCI7IGJvZHk6IFwiICsgaW5zcGVjdEJvZHkoYm9keSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGNiKHJlc3VsdC5lcnJvciwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQudW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkpXG4gICAgICAgICAgICBib2R5ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGNiKG5ldyBFcnJvckluZm8oXCJhdXRoVXJsIHJlc3BvbnNlIGlzIG1pc3NpbmcgYSBjb250ZW50LXR5cGUgaGVhZGVyXCIsIDQwMTcwLCA0MDEpLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QganNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID4gLTEsIHRleHQgPSBjb250ZW50VHlwZS5pbmRleE9mKFwidGV4dC9wbGFpblwiKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qd3RcIikgPiAtMTtcbiAgICAgICAgICBpZiAoIWpzb24gJiYgIXRleHQpIHtcbiAgICAgICAgICAgIGNiKFxuICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgIFwiYXV0aFVybCByZXNwb25kZWQgd2l0aCB1bmFjY2VwdGFibGUgY29udGVudC10eXBlIFwiICsgY29udGVudFR5cGUgKyBcIiwgc2hvdWxkIGJlIGVpdGhlciB0ZXh0L3BsYWluLCBhcHBsaWNhdGlvbi9qd3Qgb3IgYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID4gTUFYX1RPS0VOX0xFTkdUSCkge1xuICAgICAgICAgICAgICBjYihuZXcgRXJyb3JJbmZvKFwiYXV0aFVybCByZXNwb25zZSBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aFwiLCA0MDE3MCwgNDAxKSwgbnVsbCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjYihcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGVycm9yIHByb2Nlc3NpbmcgYXV0aFVSTCByZXNwb25zZTsgZXJyID0gXCIgKyBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNiKG51bGwsIGJvZHksIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2tcIixcbiAgICAgICAgICBcIlJlcXVlc3RpbmcgdG9rZW4gZnJvbSBcIiArIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCArIFwiOyBQYXJhbXM6IFwiICsgSlNPTi5zdHJpbmdpZnkoYXV0aFBhcmFtcykgKyBcIjsgbWV0aG9kOiBcIiArICh1c2VQb3N0ID8gXCJQT1NUXCIgOiBcIkdFVFwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodXNlUG9zdCkge1xuICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhdXRoSGVhZGVycyB8fCB7fTtcbiAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbiAgICAgICAgICBjb25zdCBib2R5ID0gdG9RdWVyeVN0cmluZyhhdXRoUGFyYW1zKS5zbGljZSgxKTtcbiAgICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgICAgICB0aGlzLmNsaWVudC5odHRwLmRvVXJpKFxuICAgICAgICAgICAgICBIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsXG4gICAgICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCxcbiAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgcHJvdmlkZWRRc1BhcmFtc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gYXV0aFVybFJlcXVlc3RDYWxsYmFjayhlcnIpIDogYXV0aFVybFJlcXVlc3RDYWxsYmFjayhyZXN1bHQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgICAgICB0aGlzLmNsaWVudC5odHRwLmRvVXJpKEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwsIGF1dGhIZWFkZXJzIHx8IHt9LCBudWxsLCBhdXRoUGFyYW1zKSxcbiAgICAgICAgICAgIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gYXV0aFVybFJlcXVlc3RDYWxsYmFjayhlcnIpIDogYXV0aFVybFJlcXVlc3RDYWxsYmFjayhyZXN1bHQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLFxuICAgICAgICBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nXCJcbiAgICAgICk7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IChwYXJhbXMsIGNiKSA9PiB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgICAgICB0aGlzLmNyZWF0ZVRva2VuUmVxdWVzdChwYXJhbXMsIHJlc29sdmVkQXV0aE9wdGlvbnMpLFxuICAgICAgICAgIChlcnIsIHJlc3VsdCkgPT4gY2IoZXJyLCByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IG51bGwpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBcIk5lZWQgYSBuZXcgdG9rZW4sIGJ1dCBhdXRoT3B0aW9ucyBkb2VzIG5vdCBpbmNsdWRlIGFueSB3YXkgdG8gcmVxdWVzdCBvbmUgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KVwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIkF1dGgoKVwiLFxuICAgICAgICBcImxpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwXCJcbiAgICAgICk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKG1zZywgNDAxNzEsIDQwMyk7XG4gICAgfVxuICAgIGlmIChcImNhcGFiaWxpdHlcIiBpbiByZXNvbHZlZFRva2VuUGFyYW1zKVxuICAgICAgcmVzb2x2ZWRUb2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bihcbiAgICAgICAgcmVzb2x2ZWRUb2tlblBhcmFtcy5jYXBhYmlsaXR5XG4gICAgICApO1xuICAgIGNvbnN0IHRva2VuUmVxdWVzdCA9IChzaWduZWRUb2tlblBhcmFtcywgdG9rZW5DYikgPT4ge1xuICAgICAgY29uc3Qga2V5TmFtZSA9IHNpZ25lZFRva2VuUGFyYW1zLmtleU5hbWUsIHBhdGggPSBcIi9rZXlzL1wiICsga2V5TmFtZSArIFwiL3JlcXVlc3RUb2tlblwiLCB0b2tlblVyaSA9IGZ1bmN0aW9uKGhvc3QpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5iYXNlVXJpKGhvc3QpICsgcGF0aDtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0OiBcImpzb25cIiAvKiBqc29uICovIH0pO1xuICAgICAgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpXG4gICAgICAgIG1peGluKHJlcXVlc3RIZWFkZXJzLCByZXNvbHZlZEF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnJlcXVlc3RUb2tlblwiLFxuICAgICAgICBcIlNlbmRpbmcgUE9TVCB0byBcIiArIHBhdGggKyBcIjsgVG9rZW4gcGFyYW1zOiBcIiArIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKVxuICAgICAgKTtcbiAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgICAgdGhpcy5jbGllbnQuaHR0cC5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIHRva2VuVXJpLCByZXF1ZXN0SGVhZGVycywgSlNPTi5zdHJpbmdpZnkoc2lnbmVkVG9rZW5QYXJhbXMpLCBudWxsKSxcbiAgICAgICAgKGVyciwgcmVzdWx0KSA9PiBlcnIgPyB0b2tlbkNiKGVycikgOiB0b2tlbkNiKHJlc3VsdC5lcnJvciwgcmVzdWx0LmJvZHksIHJlc3VsdC51bnBhY2tlZClcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSBmYWxzZSwgdGltZW91dExlbmd0aCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCwgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBtc2cgPSBcIlRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZW91dExlbmd0aCAvIDFlMyArIFwiIHNlY29uZHNcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBtc2cpO1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgIH0sIHRpbWVvdXRMZW5ndGgpO1xuICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2socmVzb2x2ZWRUb2tlblBhcmFtcywgKGVyciwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBjb250ZW50VHlwZSkgPT4ge1xuICAgICAgICBpZiAodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsZWFyVGltZW91dCh0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKClcIixcbiAgICAgICAgICAgIFwidG9rZW4gcmVxdWVzdCBzaWduaW5nIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlamVjdChub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJUb2tlbiBzdHJpbmcgaXMgZW1wdHlcIiwgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcIlRva2VuIHN0cmluZyBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCAod2FzIFwiICsgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCArIFwiIGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSBcInVuZGVmaW5lZFwiIHx8IHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVG9rZW4gc3RyaW5nIHdhcyBsaXRlcmFsIG51bGwvdW5kZWZpbmVkXCIsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlsc1swXSA9PT0gXCJ7XCIgJiYgIShjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vand0XCIpID4gLTEpKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJUb2tlbiB3YXMgZG91YmxlLWVuY29kZWQ7IG1ha2Ugc3VyZSB5b3UncmUgbm90IEpTT04tZW5jb2RpbmcgYW4gYWxyZWFkeSBlbmNvZGVkIHRva2VuIHJlcXVlc3Qgb3IgZGV0YWlsc1wiLFxuICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgdG9rZW46IHRva2VuUmVxdWVzdE9yRGV0YWlscyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzICE9PSBcIm9iamVjdFwiIHx8IHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IFwiRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZyBvciB0b2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0LCBidXQgZ290IGEgXCIgKyB0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgbXNnKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqZWN0U2l6ZSA9IEpTT04uc3RyaW5naWZ5KHRva2VuUmVxdWVzdE9yRGV0YWlscykubGVuZ3RoO1xuICAgICAgICBpZiAob2JqZWN0U2l6ZSA+IE1BWF9UT0tFTl9MRU5HVEggJiYgIXJlc29sdmVkQXV0aE9wdGlvbnMuc3VwcHJlc3NNYXhMZW5ndGhDaGVjaykge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgIFwiVG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCBleGNlZWRlZCBtYXggcGVybWl0dGVkIHN0cmluZ2lmaWVkIHNpemUgKHdhcyBcIiArIG9iamVjdFNpemUgKyBcIiBieXRlcylcIixcbiAgICAgICAgICAgICAgNDAxNzAsXG4gICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImlzc3VlZFwiIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykge1xuICAgICAgICAgIHJlc29sdmUodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJrZXlOYW1lXCIgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IFwiRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZywgdG9rZW4gcmVxdWVzdCBvYmplY3QsIG9yIHRva2VuIGRldGFpbHMgb2JqZWN0XCI7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBtc2cpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKG1zZywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0b2tlblJlcXVlc3QodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCAoZXJyMiwgdG9rZW5SZXNwb25zZSwgdW5wYWNrZWQpID0+IHtcbiAgICAgICAgICBpZiAoZXJyMikge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKClcIixcbiAgICAgICAgICAgICAgXCJ0b2tlbiByZXF1ZXN0IEFQSSBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlamVjdChub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIyKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdW5wYWNrZWQpXG4gICAgICAgICAgICB0b2tlblJlc3BvbnNlID0gSlNPTi5wYXJzZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLmdldFRva2VuKClcIiwgXCJ0b2tlbiByZWNlaXZlZFwiKTtcbiAgICAgICAgICByZXNvbHZlKHRva2VuUmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHNpZ24gYSB0b2tlbiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBOT1RFIHRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIHRoZSBrZXkgdmFsdWUgaXMgYXZhaWxhYmxlIGxvY2FsbHkuXG4gICAqIE90aGVyd2lzZSwgc2lnbmVkIHRva2VuIHJlcXVlc3RzIG11c3QgYmUgb2J0YWluZWQgZnJvbSB0aGUga2V5XG4gICAqIG93bmVyIChlaXRoZXIgdXNpbmcgdGhlIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgb3IgdXJsKS5cbiAgICpcbiAgICogQHBhcmFtIGF1dGhPcHRpb25zXG4gICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0IG9wdGlvbnM6XG4gICAqIC0ga2V5OiAgICAgICAgICAgdGhlIGtleSB0byB1c2UuIElmIG5vdCBzcGVjaWZpZWQsIGEga2V5IHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmdcbiAgICogICAgICAgICAgICAgICAgICB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG4gICAqXG4gICAqIC0gcXVlcnlUaW1lICAgICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgYWJseSBzeXN0ZW0gc2hvdWxkIGJlXG4gICAqICAgICAgICAgICAgICAgICAgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgdGltZSB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHlcbiAgICpcbiAgICogLSByZXF1ZXN0SGVhZGVycyAob3B0aW9uYWwsIHVuc3VwcG9ydGVkLCBmb3IgdGVzdGluZyBvbmx5KSBleHRyYSBoZWFkZXJzIHRvIGFkZCB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW4gcmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW5QYXJhbXNcbiAgICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XG4gICAqIC0gdHRsOiAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiB0aGUgdG9rZW4gaW4gbXMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXG4gICAqICAgICAgICAgICAgICAgICAgYSBkZWZhdWx0IG9mIDEgaG91ciBpcyBwcm92aWRlZC4gVGhlIG1heGltdW0gbGlmZXRpbWUgaXMgMjRob3VyczsgYW55IHJlcXVlc3RcbiAgICogICAgICAgICAgICAgICAgICBleGNlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXG4gICAqXG4gICAqIC0gY2FwYWJpbGl0eTogICAgKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxuICAgKiAgICAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICpcbiAgICogLSBjbGllbnRJZDogICAgICAob3B0aW9uYWwpIGEgY2xpZW50IElEIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlbjsgaWYgbm90XG4gICAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgKlxuICAgKiAtIHRpbWVzdGFtcDogICAgIChvcHRpb25hbCkgdGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGVwb2NoLiBJZiBub25lIGlzIHNwZWNpZmllZCxcbiAgICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRva2VuUmVxdWVzdCh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICBhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG4gICAgdG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCBjb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuICAgIGNvbnN0IGtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIk5vIGtleSBzcGVjaWZpZWRcIiwgNDAxMDEsIDQwMyk7XG4gICAgfVxuICAgIGNvbnN0IGtleVBhcnRzID0ga2V5LnNwbGl0KFwiOlwiKSwga2V5TmFtZSA9IGtleVBhcnRzWzBdLCBrZXlTZWNyZXQgPSBrZXlQYXJ0c1sxXTtcbiAgICBpZiAoIWtleVNlY3JldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIkludmFsaWQga2V5IHNwZWNpZmllZFwiLCA0MDEwMSwgNDAzKTtcbiAgICB9XG4gICAgaWYgKHRva2VuUGFyYW1zLmNsaWVudElkID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgY2FuXFx1MjAxOXQgYmUgYW4gZW1wdHkgc3RyaW5nXCIsIDQwMDEyLCA0MDApO1xuICAgIH1cbiAgICBpZiAoXCJjYXBhYmlsaXR5XCIgaW4gdG9rZW5QYXJhbXMpIHtcbiAgICAgIHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgPSBjMTRuKHRva2VuUGFyYW1zLmNhcGFiaWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gbWl4aW4oeyBrZXlOYW1lIH0sIHRva2VuUGFyYW1zKSwgY2xpZW50SWQgPSB0b2tlblBhcmFtcy5jbGllbnRJZCB8fCBcIlwiLCB0dGwgPSB0b2tlblBhcmFtcy50dGwgfHwgXCJcIiwgY2FwYWJpbGl0eSA9IHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgfHwgXCJcIjtcbiAgICBpZiAoIXJlcXVlc3QudGltZXN0YW1wKSB7XG4gICAgICByZXF1ZXN0LnRpbWVzdGFtcCA9IGF3YWl0IHRoaXMuX2dldFRpbWVzdGFtcChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5xdWVyeVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHJlcXVlc3Qubm9uY2UgfHwgKHJlcXVlc3Qubm9uY2UgPSByYW5kb20oKSksIHRpbWVzdGFtcCA9IHJlcXVlc3QudGltZXN0YW1wO1xuICAgIGNvbnN0IHNpZ25UZXh0ID0gcmVxdWVzdC5rZXlOYW1lICsgXCJcXG5cIiArIHR0bCArIFwiXFxuXCIgKyBjYXBhYmlsaXR5ICsgXCJcXG5cIiArIGNsaWVudElkICsgXCJcXG5cIiArIHRpbWVzdGFtcCArIFwiXFxuXCIgKyBub25jZSArIFwiXFxuXCI7XG4gICAgcmVxdWVzdC5tYWMgPSByZXF1ZXN0Lm1hYyB8fCBobWFjKHNpZ25UZXh0LCBrZXlTZWNyZXQpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGguZ2V0VG9rZW5SZXF1ZXN0KClcIiwgXCJnZW5lcmF0ZWQgc2lnbmVkIHJlcXVlc3RcIik7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYXV0aCBxdWVyeSBwYXJhbXMgdG8gdXNlIGZvciBhIHdlYnNvY2tldCBjb25uZWN0aW9uLFxuICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEF1dGhQYXJhbXMoKSB7XG4gICAgaWYgKHRoaXMubWV0aG9kID09IFwiYmFzaWNcIilcbiAgICAgIHJldHVybiB7IGtleTogdGhpcy5rZXkgfTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCB0b2tlbkRldGFpbHMgPSBhd2FpdCB0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSk7XG4gICAgICBpZiAoIXRva2VuRGV0YWlscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRoLmdldEF1dGhQYXJhbXMoKTogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIHJldHVybmVkIG5vIGVycm9yIG9yIHRva2VuRGV0YWlsc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGFjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VuIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyIHRvIHVzZSBmb3IgYSBSRVNUIG9yIGNvbWV0IHJlcXVlc3QsXG4gICAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0QXV0aEhlYWRlcnMoKSB7XG4gICAgaWYgKHRoaXMubWV0aG9kID09IFwiYmFzaWNcIikge1xuICAgICAgcmV0dXJuIHsgYXV0aG9yaXphdGlvbjogXCJCYXNpYyBcIiArIHRoaXMuYmFzaWNLZXkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG9rZW5EZXRhaWxzID0gYXdhaXQgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UpO1xuICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aC5nZXRBdXRoUGFyYW1zKCk6IF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyByZXR1cm5lZCBubyBlcnJvciBvciB0b2tlbkRldGFpbHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBhdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIiArIHRvQmFzZTY0KHRva2VuRGV0YWlscy50b2tlbikgfTtcbiAgICB9XG4gIH1cbiAgX3NhdmVCYXNpY09wdGlvbnMoYXV0aE9wdGlvbnMpIHtcbiAgICB0aGlzLm1ldGhvZCA9IFwiYmFzaWNcIjtcbiAgICB0aGlzLmtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICB0aGlzLmJhc2ljS2V5ID0gdG9CYXNlNjQoYXV0aE9wdGlvbnMua2V5KTtcbiAgICB0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwge307XG4gICAgaWYgKFwiY2xpZW50SWRcIiBpbiBhdXRoT3B0aW9ucykge1xuICAgICAgdGhpcy5fdXNlclNldENsaWVudElkKGF1dGhPcHRpb25zLmNsaWVudElkKTtcbiAgICB9XG4gIH1cbiAgX3NhdmVUb2tlbk9wdGlvbnModG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgdGhpcy5tZXRob2QgPSBcInRva2VuXCI7XG4gICAgaWYgKHRva2VuUGFyYW1zKSB7XG4gICAgICB0aGlzLnRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXM7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucykge1xuICAgICAgaWYgKGF1dGhPcHRpb25zLnRva2VuKSB7XG4gICAgICAgIGF1dGhPcHRpb25zLnRva2VuRGV0YWlscyA9IHR5cGVvZiBhdXRoT3B0aW9ucy50b2tlbiA9PT0gXCJzdHJpbmdcIiA/IHsgdG9rZW46IGF1dGhPcHRpb25zLnRva2VuIH0gOiBhdXRoT3B0aW9ucy50b2tlbjtcbiAgICAgIH1cbiAgICAgIGlmIChhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcbiAgICAgICAgdGhpcy50b2tlbkRldGFpbHMgPSBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHM7XG4gICAgICB9XG4gICAgICBpZiAoXCJjbGllbnRJZFwiIGluIGF1dGhPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnM7XG4gICAgfVxuICB9XG4gIC8qIEBwYXJhbSBmb3JjZVN1cGVyc2VkZTogZm9yY2UgYSBuZXcgdG9rZW4gcmVxdWVzdCBldmVuIGlmIHRoZXJlJ3Mgb25lIGluXG4gICAqIHByb2dyZXNzLCBtYWtpbmcgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIHdhaXQgZm9yIHRoZSBuZXcgb25lICovXG4gIGFzeW5jIF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmb3JjZVN1cGVyc2VkZSkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy50b2tlbkRldGFpbHM7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKHRva2VuLmNsaWVudElkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwiTWlzbWF0Y2ggYmV0d2VlbiBjbGllbnRJZCBpbiB0b2tlbiAoXCIgKyB0b2tlbi5jbGllbnRJZCArIFwiKSBhbmQgY3VycmVudCBjbGllbnRJZCAoXCIgKyB0aGlzLmNsaWVudElkICsgXCIpXCIsXG4gICAgICAgICAgNDAxMDIsXG4gICAgICAgICAgNDAzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2xpZW50LmlzVGltZU9mZnNldFNldCgpIHx8ICF0b2tlbi5leHBpcmVzIHx8IHRva2VuLmV4cGlyZXMgPj0gdGhpcy5jbGllbnQuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQXV0aC5nZXRUb2tlbigpXCIsXG4gICAgICAgICAgXCJ1c2luZyBjYWNoZWQgdG9rZW47IGV4cGlyZXMgPSBcIiArIHRva2VuLmV4cGlyZXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5nZXRUb2tlbigpXCIsIFwiZGVsZXRpbmcgZXhwaXJlZCB0b2tlblwiKTtcbiAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9ICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgfHwgKHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG11bHRpY2FzdGVyX2RlZmF1bHQuY3JlYXRlKHRoaXMubG9nZ2VyKSkpLmNyZWF0ZVByb21pc2UoKTtcbiAgICBpZiAodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgIT09IG51bGwgJiYgIWZvcmNlU3VwZXJzZWRlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5SZXF1ZXN0SWQgPSB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IGdldFRva2VuUmVxdWVzdElkKCk7XG4gICAgbGV0IHRva2VuUmVzcG9uc2UsIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdFRva2VuKHRoaXMudG9rZW5QYXJhbXMsIHRoaXMuYXV0aE9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2F1Z2h0RXJyb3IgPSBlcnI7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA+IHRva2VuUmVxdWVzdElkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoKVwiLFxuICAgICAgICBcIkRpc2NhcmRpbmcgdG9rZW4gcmVxdWVzdCByZXNwb25zZTsgb3ZlcnRha2VuIGJ5IG5ld2VyIG9uZVwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcbiAgICBjb25zdCBtdWx0aWNhc3RlciA9IHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdDtcbiAgICB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgbXVsdGljYXN0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11bHRpY2FzdGVyLnJlamVjdEFsbChjYXVnaHRFcnJvcik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgbXVsdGljYXN0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11bHRpY2FzdGVyLnJlc29sdmVBbGwodGhpcy50b2tlbkRldGFpbHMgPSB0b2tlblJlc3BvbnNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKiBVc2VyLXNldDogY2hlY2sgdHlwZXMsICcqJyBpcyBkaXNhbGxvd2VkLCB0aHJvdyBhbnkgZXJyb3JzICovXG4gIF91c2VyU2V0Q2xpZW50SWQoY2xpZW50SWQpIHtcbiAgICBpZiAoISh0eXBlb2YgY2xpZW50SWQgPT09IFwic3RyaW5nXCIgfHwgY2xpZW50SWQgPT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbFwiLCA0MDAxMiwgNDAwKTtcbiAgICB9IGVsc2UgaWYgKGNsaWVudElkID09PSBcIipcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgJ0NhblxcdTIwMTl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCBpbnN0YW50aWF0ZSB0aGUgbGlicmFyeSB3aXRoIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSksIG9yIGlmIGNhbGxpbmcgYXV0aG9yaXplKCksIHBhc3MgaXQgaW4gYXMgYSB0b2tlblBhcmFtOiBhdXRob3JpemUoe2NsaWVudElkOiBcIipcIn0sIGF1dGhPcHRpb25zKScsXG4gICAgICAgIDQwMDEyLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcbiAgICAgIGlmIChlcnIpXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgLyogQWJseS1zZXQ6IG5vIHR5cGVjaGVja2luZywgJyonIGlzIGFsbG93ZWQgYnV0IG5vdCBzZXQgb24gdGhpcy5jbGllbnRJZCksIHJldHVybiBlcnJvcnMgdG8gdGhlIGNhbGxlciAqL1xuICBfdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpIHtcbiAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKGNsaWVudElkKSkge1xuICAgICAgY29uc3QgbXNnID0gXCJVbmV4cGVjdGVkIGNsaWVudElkIG1pc21hdGNoOiBjbGllbnQgaGFzIFwiICsgdGhpcy5jbGllbnRJZCArIFwiLCByZXF1ZXN0ZWQgXCIgKyBjbGllbnRJZDtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckluZm8obXNnLCA0MDEwMiwgNDAxKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKClcIiwgbXNnKTtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xpZW50SWQgPSB0aGlzLnRva2VuUGFyYW1zLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbkNsaWVudElkKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuY2xpZW50SWQgJiYgdGhpcy5jbGllbnRJZCAhPT0gXCIqXCIgJiYgdG9rZW5DbGllbnRJZCAmJiB0b2tlbkNsaWVudElkICE9PSBcIipcIiAmJiB0aGlzLmNsaWVudElkICE9PSB0b2tlbkNsaWVudElkKTtcbiAgfVxuICBzdGF0aWMgaXNUb2tlbkVycihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlICYmIGVycm9yLmNvZGUgPj0gNDAxNDAgJiYgZXJyb3IuY29kZSA8IDQwMTUwO1xuICB9XG4gIHJldm9rZVRva2VucyhzcGVjaWZpZXJzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QucmV2b2tlVG9rZW5zKHNwZWNpZmllcnMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBCYXNlQ2xpZW50LmdldFRpbWVzdGFtcH0gYnV0IGFsc28gdGFrZXMgaW50byBhY2NvdW50IHtAbGluayBBdXRoLmF1dGhPcHRpb25zfVxuICAgKi9cbiAgYXN5bmMgX2dldFRpbWVzdGFtcChxdWVyeVRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZ2V0VGltZXN0YW1wKHF1ZXJ5VGltZSB8fCAhIXRoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lKTtcbiAgfVxufTtcbnZhciBhdXRoX2RlZmF1bHQgPSBBdXRoO1xuXG4vLyBzcmMvY29tbW9uL3R5cGVzL2h0dHAudHNcbmZ1bmN0aW9uIHBhcmFtU3RyaW5nKHBhcmFtcykge1xuICBjb25zdCBwYXJhbVBhaXJzID0gW107XG4gIGlmIChwYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IG5lZWRsZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtUGFpcnMucHVzaChuZWVkbGUgKyBcIj1cIiArIHBhcmFtc1tuZWVkbGVdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtUGFpcnMuam9pbihcIiZcIik7XG59XG5mdW5jdGlvbiBhcHBlbmRpbmdQYXJhbXModXJpLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHVyaSArIChwYXJhbXMgPyBcIj9cIiA6IFwiXCIpICsgcGFyYW1TdHJpbmcocGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGxvZ1Jlc3VsdChyZXN1bHQsIG1ldGhvZCwgdXJpLCBwYXJhbXMsIGxvZ2dlcikge1xuICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiSHR0cC5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQgRXJyb3I7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSArIFwiOyBFcnJvcjogXCIgKyBpbnNwZWN0RXJyb3IocmVzdWx0LmVycm9yKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiSHR0cC5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQ7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSArIFwiOyBIZWFkZXJzOiBcIiArIHBhcmFtU3RyaW5nKHJlc3VsdC5oZWFkZXJzKSArIFwiOyBTdGF0dXNDb2RlOiBcIiArIHJlc3VsdC5zdGF0dXNDb2RlICsgXCI7IEJvZHlcIiArIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihyZXN1bHQuYm9keSkgPyBcIiAoQmFzZTY0KTogXCIgKyBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUocmVzdWx0LmJvZHkpIDogXCI6IFwiICsgcmVzdWx0LmJvZHkpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbG9nUmVxdWVzdChtZXRob2QsIHVyaSwgYm9keSwgcGFyYW1zLCBsb2dnZXIpIHtcbiAgaWYgKGxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkh0dHAuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlNlbmRpbmc7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSArIFwiOyBCb2R5XCIgKyAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkgPyBcIiAoQmFzZTY0KTogXCIgKyBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoYm9keSkgOiBcIjogXCIgKyBib2R5KVxuICAgICk7XG4gIH1cbn1cbnZhciBIdHRwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnBsYXRmb3JtSHR0cCA9IG5ldyBQbGF0Zm9ybS5IdHRwKGNsaWVudCk7XG4gICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IHRoaXMucGxhdGZvcm1IdHRwLmNoZWNrQ29ubmVjdGl2aXR5ID8gKCkgPT4gdGhpcy5wbGF0Zm9ybUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKSA6IHZvaWQgMDtcbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EyID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9nZ2VyKSAhPSBudWxsID8gX2IgOiBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyO1xuICB9XG4gIGdldCBzdXBwb3J0c0F1dGhIZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXRmb3JtSHR0cC5zdXBwb3J0c0F1dGhIZWFkZXJzO1xuICB9XG4gIGdldCBzdXBwb3J0c0xpbmtIZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXRmb3JtSHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzO1xuICB9XG4gIF9nZXRIb3N0cyhjbGllbnQpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gY2xpZW50LmNvbm5lY3Rpb24sIGNvbm5lY3Rpb25Ib3N0ID0gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmhvc3Q7XG4gICAgaWYgKGNvbm5lY3Rpb25Ib3N0KSB7XG4gICAgICByZXR1cm4gW2Nvbm5lY3Rpb25Ib3N0XS5jb25jYXQoZGVmYXVsdHNfZGVmYXVsdC5nZXRGYWxsYmFja0hvc3RzKGNsaWVudC5vcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0c19kZWZhdWx0LmdldEhvc3RzKGNsaWVudC5vcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBub3QgdGhyb3cgYW55IGVycm9yczsgcmF0aGVyLCBpdCB3aWxsIGNvbW11bmljYXRlIGFueSBlcnJvciBieSBwb3B1bGF0aW5nIHRoZSB7QGxpbmsgUmVxdWVzdFJlc3VsdC5lcnJvcn0gcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIHtAbGluayBSZXF1ZXN0UmVzdWx0fS5cbiAgICovXG4gIGFzeW5jIGRvKG1ldGhvZCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBFcnJvckluZm8oXCJodHRwLmRvIGNhbGxlZCB3aXRob3V0IGNsaWVudFwiLCA1ZTQsIDUwMCkgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVyaUZyb21Ib3N0ID0gdHlwZW9mIHBhdGggPT09IFwiZnVuY3Rpb25cIiA/IHBhdGggOiBmdW5jdGlvbihob3N0KSB7XG4gICAgICAgIHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7XG4gICAgICB9O1xuICAgICAgY29uc3QgY3VycmVudEZhbGxiYWNrID0gY2xpZW50Ll9jdXJyZW50RmFsbGJhY2s7XG4gICAgICBpZiAoY3VycmVudEZhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjdXJyZW50RmFsbGJhY2sudmFsaWRVbnRpbCA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRvVXJpKG1ldGhvZCwgdXJpRnJvbUhvc3QoY3VycmVudEZhbGxiYWNrLmhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IgJiYgdGhpcy5wbGF0Zm9ybUh0dHAuc2hvdWxkRmFsbGJhY2socmVzdWx0LmVycm9yKSkge1xuICAgICAgICAgICAgY2xpZW50Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG8obWV0aG9kLCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWVudC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaG9zdHMgPSB0aGlzLl9nZXRIb3N0cyhjbGllbnQpO1xuICAgICAgaWYgKGhvc3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb1VyaShtZXRob2QsIHVyaUZyb21Ib3N0KGhvc3RzWzBdKSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIGxldCB0cnlBSG9zdFN0YXJ0ZWRBdCA9IG51bGw7XG4gICAgICBjb25zdCB0cnlBSG9zdCA9IGFzeW5jIChjYW5kaWRhdGVIb3N0cywgcGVyc2lzdE9uU3VjY2VzcykgPT4ge1xuICAgICAgICBjb25zdCBob3N0ID0gY2FuZGlkYXRlSG9zdHMuc2hpZnQoKTtcbiAgICAgICAgdHJ5QUhvc3RTdGFydGVkQXQgPSB0cnlBSG9zdFN0YXJ0ZWRBdCAhPSBudWxsID8gdHJ5QUhvc3RTdGFydGVkQXQgOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kb1VyaShtZXRob2QsIHVyaUZyb21Ib3N0KGhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yICYmIHRoaXMucGxhdGZvcm1IdHRwLnNob3VsZEZhbGxiYWNrKHJlc3VsdC5lcnJvcikgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gdHJ5QUhvc3RTdGFydGVkQXQuZ2V0VGltZSgpO1xuICAgICAgICAgIGlmIChlbGFwc2VkVGltZSA+IGNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmh0dHBNYXhSZXRyeUR1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBgVGltZW91dCBmb3IgdHJ5aW5nIGZhbGxiYWNrIGhvc3RzIHJldHJpZXMuIFRvdGFsIGVsYXBzZWQgdGltZSBleGNlZWRlZCB0aGUgJHtjbGllbnQub3B0aW9ucy50aW1lb3V0cy5odHRwTWF4UmV0cnlEdXJhdGlvbn1tcyBsaW1pdGAsXG4gICAgICAgICAgICAgICAgNTAwMDMsXG4gICAgICAgICAgICAgICAgNTAwXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnlBSG9zdChjYW5kaWRhdGVIb3N0cywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcnNpc3RPblN1Y2Nlc3MpIHtcbiAgICAgICAgICBjbGllbnQuX2N1cnJlbnRGYWxsYmFjayA9IHtcbiAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICB2YWxpZFVudGlsOiBEYXRlLm5vdygpICsgY2xpZW50Lm9wdGlvbnMudGltZW91dHMuZmFsbGJhY2tSZXRyeVRpbWVvdXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyeUFIb3N0KGhvc3RzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgRXJyb3JJbmZvKGBVbmV4cGVjdGVkIGVycm9yIGluIEh0dHAuZG86ICR7aW5zcGVjdEVycm9yKGVycil9YCwgNTAwLCA1ZTQpIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIG5vdCB0aHJvdyBhbnkgZXJyb3JzOyByYXRoZXIsIGl0IHdpbGwgY29tbXVuaWNhdGUgYW55IGVycm9yIGJ5IHBvcHVsYXRpbmcgdGhlIHtAbGluayBSZXF1ZXN0UmVzdWx0LmVycm9yfSBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQge0BsaW5rIFJlcXVlc3RSZXN1bHR9LlxuICAgKi9cbiAgYXN5bmMgZG9VcmkobWV0aG9kLCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBsb2dSZXF1ZXN0KG1ldGhvZCwgdXJpLCBib2R5LCBwYXJhbXMsIHRoaXMubG9nZ2VyKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGxhdGZvcm1IdHRwLmRvVXJpKG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgIGxvZ1Jlc3VsdChyZXN1bHQsIG1ldGhvZCwgdXJpLCBwYXJhbXMsIHRoaXMubG9nZ2VyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogbmV3IEVycm9ySW5mbyhgVW5leHBlY3RlZCBlcnJvciBpbiBIdHRwLmRvVXJpOiAke2luc3BlY3RFcnJvcihlcnIpfWAsIDUwMCwgNWU0KSB9O1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9ldmVudGVtaXR0ZXIudHNcbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsb2dnZXIsIGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICBsaXN0ZW5lci5hcHBseShldmVudFRoaXMsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJFdmVudEVtaXR0ZXIuZW1pdCgpXCIsXG4gICAgICBcIlVuZXhwZWN0ZWQgbGlzdGVuZXIgZXhjZXB0aW9uOiBcIiArIGUgKyBcIjsgc3RhY2sgPSBcIiArIChlICYmIGUuc3RhY2spXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodGFyZ2V0TGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnRGaWx0ZXIpIHtcbiAgbGV0IGxpc3RlbmVycztcbiAgbGV0IGluZGV4O1xuICBsZXQgZXZlbnROYW1lO1xuICBmb3IgKGxldCB0YXJnZXRMaXN0ZW5lcnNJbmRleCA9IDA7IHRhcmdldExpc3RlbmVyc0luZGV4IDwgdGFyZ2V0TGlzdGVuZXJzLmxlbmd0aDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXgrKykge1xuICAgIGxpc3RlbmVycyA9IHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF07XG4gICAgaWYgKGV2ZW50RmlsdGVyKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbZXZlbnRGaWx0ZXJdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICB3aGlsZSAoKGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRGaWx0ZXIgJiYgbGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0TGlzdGVuZXJzW3RhcmdldExpc3RlbmVyc0luZGV4XVtldmVudEZpbHRlcl07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0ZW5lcnMpKSB7XG4gICAgICBmb3IgKGV2ZW50TmFtZSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsaXN0ZW5lcnMsIGV2ZW50TmFtZSkgJiYgQXJyYXkuaXNBcnJheShsaXN0ZW5lcnNbZXZlbnROYW1lXSkpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcihbbGlzdGVuZXJzXSwgbGlzdGVuZXIsIGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBFdmVudEVtaXR0ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuYW55ID0gW107XG4gICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICB0aGlzLmV2ZW50c09uY2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBvbiguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGFyZ3NbMF07XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5hbnkucHVzaChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBbZXZlbnQsIGxpc3RlbmVyXSA9IGFyZ3M7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOaWwoZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBldmVudC5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgKHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtdKTtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvZmYoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAwIHx8IGlzTmlsKGFyZ3NbMF0pICYmIGlzTmlsKGFyZ3NbMV0pKSB7XG4gICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgICAgdGhpcy5ldmVudHNPbmNlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IGFyZ3M7XG4gICAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgICBsZXQgZXZlbnQgPSBudWxsO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSB8fCAhc2Vjb25kQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBmaXJzdEFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZmlyc3RBcmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czpcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICAgIFtldmVudCwgbGlzdGVuZXJdID0gW2ZpcnN0QXJnLCBzZWNvbmRBcmddO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXIgJiYgaXNOaWwoZXZlbnQpKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5hbnksIHRoaXMuZXZlbnRzLCB0aGlzLmFueU9uY2UsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBldmVudC5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBldmVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czpcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5ldmVudHMsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyLCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF07XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50OyBleGNsdWRlcyBvbmNlIGV2ZW50c1xuICAgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQsIG9yIG5vbmUgZm9yICdhbnknXG4gICAqIEByZXR1cm4gYXJyYXkgb2YgZXZlbnRzLCBvciBudWxsIGlmIG5vbmVcbiAgICovXG4gIGxpc3RlbmVycyhldmVudCkge1xuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgaWYgKHRoaXMuZXZlbnRzT25jZVtldmVudF0pXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5ldmVudHNPbmNlW2V2ZW50XSk7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aCA/IGxpc3RlbmVycyA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFueS5sZW5ndGggPyB0aGlzLmFueSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgYW4gZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAgICovXG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBldmVudFRoaXMgPSB7IGV2ZW50IH07XG4gICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgaWYgKHRoaXMuYW55T25jZS5sZW5ndGgpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnlPbmNlKTtcbiAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbnkubGVuZ3RoKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55KTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzT25jZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgaWYgKGV2ZW50c09uY2VMaXN0ZW5lcnMpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzT25jZUxpc3RlbmVycyk7XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzTGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgIGlmIChldmVudHNMaXN0ZW5lcnMpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzTGlzdGVuZXJzKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBjYWxsTGlzdGVuZXIodGhpcy5sb2dnZXIsIGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG4gIG9uY2UoLi4uYXJncykge1xuICAgIGNvbnN0IGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGFyZ0NvdW50ID09PSAwIHx8IGFyZ0NvdW50ID09PSAxICYmIHR5cGVvZiBhcmdzWzBdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLm9uY2UoZXZlbnQsIHJlc29sdmUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IGFyZ3M7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLmFueU9uY2UucHVzaChmaXJzdEFyZyk7XG4gICAgfSBlbHNlIGlmIChpc05pbChmaXJzdEFyZykpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFueU9uY2UucHVzaChzZWNvbmRBcmcpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdEFyZykpIHtcbiAgICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICAgIGNvbnN0IGxpc3RlbmVyV3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBpbm5lckFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBmaXJzdEFyZy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHNlbGYyLm9mZihldmVudE5hbWUsIGxpc3RlbmVyV3JhcHBlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vjb25kQXJnLmFwcGx5KHRoaXMsIGlubmVyQXJncyk7XG4gICAgICB9O1xuICAgICAgZmlyc3RBcmcuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgc2VsZjIub24oZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddIHx8ICh0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddID0gW10pO1xuICAgICAgaWYgKHNlY29uZEFyZykge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXJzLnB1c2goc2Vjb25kQXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgYSBzaW5nbGUgb2NjdXJyZW5jZSBvZiBhIHN0YXRlIGV2ZW50IGFuZCBmaXJlIGltbWVkaWF0ZWx5IGlmIGN1cnJlbnRTdGF0ZSBtYXRjaGVzIHRhcmdldFN0YXRlXG4gICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gICAqIEBwYXJhbSBjdXJyZW50U3RhdGUgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBvYmplY3RcbiAgICovXG4gIGFzeW5jIHdoZW5TdGF0ZSh0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRTdGF0ZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY3VycmVudFN0YXRlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3aGVuU3RhdGUgcmVxdWlyZXMgYSB2YWxpZCBzdGF0ZSBTdHJpbmcgYXJndW1lbnRcIik7XG4gICAgfVxuICAgIGlmICh0YXJnZXRTdGF0ZSA9PT0gY3VycmVudFN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub25jZSh0YXJnZXRTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xudmFyIGV2ZW50ZW1pdHRlcl9kZWZhdWx0ID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wcm90b2NvbG1lc3NhZ2Vjb21tb24udHNcbnZhciBhY3Rpb25zID0ge1xuICBIRUFSVEJFQVQ6IDAsXG4gIEFDSzogMSxcbiAgTkFDSzogMixcbiAgQ09OTkVDVDogMyxcbiAgQ09OTkVDVEVEOiA0LFxuICBESVNDT05ORUNUOiA1LFxuICBESVNDT05ORUNURUQ6IDYsXG4gIENMT1NFOiA3LFxuICBDTE9TRUQ6IDgsXG4gIEVSUk9SOiA5LFxuICBBVFRBQ0g6IDEwLFxuICBBVFRBQ0hFRDogMTEsXG4gIERFVEFDSDogMTIsXG4gIERFVEFDSEVEOiAxMyxcbiAgUFJFU0VOQ0U6IDE0LFxuICBNRVNTQUdFOiAxNSxcbiAgU1lOQzogMTYsXG4gIEFVVEg6IDE3LFxuICBBQ1RJVkFURTogMTgsXG4gIE9CSkVDVDogMTksXG4gIE9CSkVDVF9TWU5DOiAyMCxcbiAgQU5OT1RBVElPTjogMjFcbn07XG52YXIgQWN0aW9uTmFtZSA9IFtdO1xuT2JqZWN0LmtleXMoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIEFjdGlvbk5hbWVbYWN0aW9uc1tuYW1lXV0gPSBuYW1lO1xufSk7XG52YXIgZmxhZ3MgPSB7XG4gIC8qIENoYW5uZWwgYXR0YWNoIHN0YXRlIGZsYWdzICovXG4gIEhBU19QUkVTRU5DRTogMSA8PCAwLFxuICBIQVNfQkFDS0xPRzogMSA8PCAxLFxuICBSRVNVTUVEOiAxIDw8IDIsXG4gIFRSQU5TSUVOVDogMSA8PCA0LFxuICBBVFRBQ0hfUkVTVU1FOiAxIDw8IDUsXG4gIEhBU19PQkpFQ1RTOiAxIDw8IDcsXG4gIC8qIENoYW5uZWwgbW9kZSBmbGFncyAqL1xuICBQUkVTRU5DRTogMSA8PCAxNixcbiAgUFVCTElTSDogMSA8PCAxNyxcbiAgU1VCU0NSSUJFOiAxIDw8IDE4LFxuICBQUkVTRU5DRV9TVUJTQ1JJQkU6IDEgPDwgMTksXG4gIEFOTk9UQVRJT05fUFVCTElTSDogMSA8PCAyMSxcbiAgQU5OT1RBVElPTl9TVUJTQ1JJQkU6IDEgPDwgMjIsXG4gIE9CSkVDVF9TVUJTQ1JJQkU6IDEgPDwgMjQsXG4gIE9CSkVDVF9QVUJMSVNIOiAxIDw8IDI1XG59O1xudmFyIGZsYWdOYW1lcyA9IE9iamVjdC5rZXlzKGZsYWdzKTtcbmZsYWdzLk1PREVfQUxMID0gZmxhZ3MuUFJFU0VOQ0UgfCBmbGFncy5QVUJMSVNIIHwgZmxhZ3MuU1VCU0NSSUJFIHwgZmxhZ3MuUFJFU0VOQ0VfU1VCU0NSSUJFIHwgZmxhZ3MuQU5OT1RBVElPTl9QVUJMSVNIIHwgZmxhZ3MuQU5OT1RBVElPTl9TVUJTQ1JJQkUgfCBmbGFncy5PQkpFQ1RfU1VCU0NSSUJFIHwgZmxhZ3MuT0JKRUNUX1BVQkxJU0g7XG52YXIgY2hhbm5lbE1vZGVzID0gW1xuICBcIlBSRVNFTkNFXCIsXG4gIFwiUFVCTElTSFwiLFxuICBcIlNVQlNDUklCRVwiLFxuICBcIlBSRVNFTkNFX1NVQlNDUklCRVwiLFxuICBcIkFOTk9UQVRJT05fUFVCTElTSFwiLFxuICBcIkFOTk9UQVRJT05fU1VCU0NSSUJFXCIsXG4gIFwiT0JKRUNUX1NVQlNDUklCRVwiLFxuICBcIk9CSkVDVF9QVUJMSVNIXCJcbl07XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2Jhc2VtZXNzYWdlLnRzXG5mdW5jdGlvbiBub3JtYWxpc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgaWYgKCFjb250ZXh0IHx8ICFjb250ZXh0LmNoYW5uZWxPcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5uZWxPcHRpb25zOiBjb250ZXh0LFxuICAgICAgcGx1Z2luczoge30sXG4gICAgICBiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMoQ3J5cHRvMiwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2lwaGVyKSB7XG4gICAgaWYgKCFDcnlwdG8yKVxuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJDcnlwdG9cIik7XG4gICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvMi5nZXRDaXBoZXIob3B0aW9ucy5jaXBoZXIsIGxvZ2dlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpcGhlcjogY2lwaGVyLmNpcGhlclBhcmFtcyxcbiAgICAgIGNoYW5uZWxDaXBoZXI6IGNpcGhlci5jaXBoZXJcbiAgICB9O1xuICB9XG4gIHJldHVybiBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG59XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KG1zZywgY2lwaGVyT3B0aW9ucykge1xuICBjb25zdCB7IGRhdGEsIGVuY29kaW5nIH0gPSBhd2FpdCBlbmNyeXB0RGF0YShtc2cuZGF0YSwgbXNnLmVuY29kaW5nLCBjaXBoZXJPcHRpb25zKTtcbiAgbXNnLmRhdGEgPSBkYXRhO1xuICBtc2cuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIG1zZztcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHREYXRhKGRhdGEsIGVuY29kaW5nLCBjaXBoZXJPcHRpb25zKSB7XG4gIGxldCBjaXBoZXIgPSBjaXBoZXJPcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gIGxldCBkYXRhVG9FbmNyeXB0ID0gZGF0YTtcbiAgbGV0IGZpbmFsRW5jb2RpbmcgPSBlbmNvZGluZyA/IGVuY29kaW5nICsgXCIvXCIgOiBcIlwiO1xuICBpZiAoIVBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGFUb0VuY3J5cHQpKSB7XG4gICAgZGF0YVRvRW5jcnlwdCA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoU3RyaW5nKGRhdGFUb0VuY3J5cHQpKTtcbiAgICBmaW5hbEVuY29kaW5nID0gZmluYWxFbmNvZGluZyArIFwidXRmLTgvXCI7XG4gIH1cbiAgY29uc3QgY2lwaGVydGV4dCA9IGF3YWl0IGNpcGhlci5lbmNyeXB0KGRhdGFUb0VuY3J5cHQpO1xuICBmaW5hbEVuY29kaW5nID0gZmluYWxFbmNvZGluZyArIFwiY2lwaGVyK1wiICsgY2lwaGVyLmFsZ29yaXRobTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBjaXBoZXJ0ZXh0LFxuICAgIGVuY29kaW5nOiBmaW5hbEVuY29kaW5nXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBlbmNvZGUobXNnLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZGF0YSwgZW5jb2RpbmcgfSA9IGVuY29kZURhdGEobXNnLmRhdGEsIG1zZy5lbmNvZGluZyk7XG4gIG1zZy5kYXRhID0gZGF0YTtcbiAgbXNnLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5jaXBoZXIpIHtcbiAgICByZXR1cm4gZW5jcnlwdChtc2csIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtc2c7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZURhdGEoZGF0YSwgZW5jb2RpbmcpIHtcbiAgY29uc3QgbmF0aXZlRGF0YVR5cGUgPSB0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiIHx8IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwO1xuICBpZiAobmF0aXZlRGF0YVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGVuY29kaW5nXG4gICAgfTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YSkgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyA/IGVuY29kaW5nICsgXCIvanNvblwiIDogXCJqc29uXCJcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvckluZm8oXCJEYXRhIHR5cGUgaXMgdW5zdXBwb3J0ZWRcIiwgNDAwMTMsIDQwMCk7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNvZGUobWVzc2FnZSwgaW5wdXRDb250ZXh0KSB7XG4gIGNvbnN0IHsgZGF0YSwgZW5jb2RpbmcsIGVycm9yIH0gPSBhd2FpdCBkZWNvZGVEYXRhKG1lc3NhZ2UuZGF0YSwgbWVzc2FnZS5lbmNvZGluZywgaW5wdXRDb250ZXh0KTtcbiAgbWVzc2FnZS5kYXRhID0gZGF0YTtcbiAgbWVzc2FnZS5lbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlRGF0YShkYXRhLCBlbmNvZGluZywgaW5wdXRDb250ZXh0KSB7XG4gIGNvbnN0IGNvbnRleHQgPSBub3JtYWxpc2VDb250ZXh0KGlucHV0Q29udGV4dCk7XG4gIGxldCBsYXN0UGF5bG9hZCA9IGRhdGE7XG4gIGxldCBkZWNvZGVkRGF0YSA9IGRhdGE7XG4gIGxldCBmaW5hbEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGxldCBkZWNvZGluZ0Vycm9yO1xuICBpZiAoZW5jb2RpbmcpIHtcbiAgICBjb25zdCB4Zm9ybXMgPSBlbmNvZGluZy5zcGxpdChcIi9cIik7XG4gICAgbGV0IGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4O1xuICAgIGxldCBlbmNvZGluZ3NUb1Byb2Nlc3MgPSB4Zm9ybXMubGVuZ3RoO1xuICAgIGxldCB4Zm9ybSA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICgobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPSBlbmNvZGluZ3NUb1Byb2Nlc3MpID4gMCkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHhmb3Jtc1stLWVuY29kaW5nc1RvUHJvY2Vzc10ubWF0Y2goLyhbLVxcd10rKShcXCsoW1xcdy1dKykpPy8pO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB4Zm9ybSA9IG1hdGNoWzFdO1xuICAgICAgICBzd2l0Y2ggKHhmb3JtKSB7XG4gICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjREZWNvZGUoU3RyaW5nKGRlY29kZWREYXRhKSk7XG4gICAgICAgICAgICBpZiAobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPT0geGZvcm1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICBsYXN0UGF5bG9hZCA9IGRlY29kZWREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgICAgICBkZWNvZGVkRGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhEZWNvZGUoZGVjb2RlZERhdGEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgIGRlY29kZWREYXRhID0gSlNPTi5wYXJzZShkZWNvZGVkRGF0YSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiY2lwaGVyXCI6XG4gICAgICAgICAgICBpZiAoY29udGV4dC5jaGFubmVsT3B0aW9ucyAhPSBudWxsICYmIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2lwaGVyICYmIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcikge1xuICAgICAgICAgICAgICBjb25zdCB4Zm9ybUFsZ29yaXRobSA9IG1hdGNoWzNdLCBjaXBoZXIgPSBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gICAgICAgICAgICAgIGlmICh4Zm9ybUFsZ29yaXRobSAhPSBjaXBoZXIuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZSB3aXRoIGdpdmVuIGNpcGhlcjsgaW5jb21wYXRpYmxlIGNpcGhlciBwYXJhbXNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBhd2FpdCBjaXBoZXIuZGVjcnlwdChkZWNvZGVkRGF0YSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZTsgbm90IGFuIGVuY3J5cHRlZCBjaGFubmVsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ2Y2RpZmZcIjpcbiAgICAgICAgICAgIGlmICghY29udGV4dC5wbHVnaW5zIHx8ICFjb250ZXh0LnBsdWdpbnMudmNkaWZmKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJNaXNzaW5nIFZjZGlmZiBkZWNvZGVyIChodHRwczovL2dpdGh1Yi5jb20vYWJseS1mb3Jrcy92Y2RpZmYtZGVjb2RlcilcIiwgNDAwMTksIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcIkRlbHRhIGRlY29kaW5nIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyIChuZWVkIEFycmF5QnVmZmVyICYgVWludDhBcnJheSlcIixcbiAgICAgICAgICAgICAgICA0MDAyMCxcbiAgICAgICAgICAgICAgICA0MDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxldCBkZWx0YUJhc2UgPSBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlbHRhQmFzZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGRlbHRhQmFzZSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkZWx0YUJhc2VCdWZmZXIgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy50b0J1ZmZlcihkZWx0YUJhc2UpO1xuICAgICAgICAgICAgICBkZWNvZGVkRGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRlY29kZWREYXRhKTtcbiAgICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy5hcnJheUJ1ZmZlclZpZXdUb0J1ZmZlcihcbiAgICAgICAgICAgICAgICBjb250ZXh0LnBsdWdpbnMudmNkaWZmLmRlY29kZShkZWNvZGVkRGF0YSwgZGVsdGFCYXNlQnVmZmVyKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsYXN0UGF5bG9hZCA9IGRlY29kZWREYXRhO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVmNkaWZmIGRlbHRhIGRlY29kZSBmYWlsZWQgd2l0aCBcIiArIGUsIDQwMDE4LCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgZGVjb2RpbmdFcnJvciA9IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGBFcnJvciBwcm9jZXNzaW5nIHRoZSAke3hmb3JtfSBlbmNvZGluZywgZGVjb2RlciByZXR1cm5lZCBcXHUyMDE4JHtlcnIubWVzc2FnZX1cXHUyMDE5YCxcbiAgICAgICAgZXJyLmNvZGUgfHwgNDAwMTMsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZmluYWxFbmNvZGluZyA9IGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4IDw9IDAgPyBudWxsIDogeGZvcm1zLnNsaWNlKDAsIGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4KS5qb2luKFwiL1wiKTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlY29kaW5nRXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGRlY29kaW5nRXJyb3IsXG4gICAgICBkYXRhOiBkZWNvZGVkRGF0YSxcbiAgICAgIGVuY29kaW5nOiBmaW5hbEVuY29kaW5nXG4gICAgfTtcbiAgfVxuICBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkID0gbGFzdFBheWxvYWQ7XG4gIHJldHVybiB7XG4gICAgZGF0YTogZGVjb2RlZERhdGEsXG4gICAgZW5jb2Rpbmc6IGZpbmFsRW5jb2RpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHdpcmVUb0pTT04oLi4uYXJncykge1xuICBjb25zdCBmb3JtYXQgPSBhcmdzLmxlbmd0aCA+IDAgPyBcImpzb25cIiAvKiBqc29uICovIDogXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLztcbiAgY29uc3QgeyBkYXRhLCBlbmNvZGluZyB9ID0gZW5jb2RlRGF0YUZvcldpcmUodGhpcy5kYXRhLCB0aGlzLmVuY29kaW5nLCBmb3JtYXQpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgeyBlbmNvZGluZywgZGF0YSB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZURhdGFGb3JXaXJlKGRhdGEsIGVuY29kaW5nLCBmb3JtYXQpIHtcbiAgaWYgKCFkYXRhIHx8ICFQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZW5jb2RpbmdcbiAgICB9O1xuICB9XG4gIGlmIChmb3JtYXQgPT09IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogUGxhdGZvcm0uQnVmZmVyVXRpbHMudG9CdWZmZXIoZGF0YSksXG4gICAgICBlbmNvZGluZ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoZGF0YSksXG4gICAgZW5jb2Rpbmc6IGVuY29kaW5nID8gZW5jb2RpbmcgKyBcIi9iYXNlNjRcIiA6IFwiYmFzZTY0XCJcbiAgfTtcbn1cbnZhciBNZXNzYWdlRW5jb2RpbmcgPSB7XG4gIGVuY3J5cHREYXRhLFxuICBlbmNvZGVEYXRhLFxuICBlbmNvZGVEYXRhRm9yV2lyZSxcbiAgZGVjb2RlRGF0YVxufTtcbmZ1bmN0aW9uIHBvcHVsYXRlRmllbGRzRnJvbVBhcmVudChwYXJlbnQpIHtcbiAgY29uc3QgeyBpZCwgY29ubmVjdGlvbklkLCB0aW1lc3RhbXAgfSA9IHBhcmVudDtcbiAgbGV0IG1zZ3M7XG4gIHN3aXRjaCAocGFyZW50LmFjdGlvbikge1xuICAgIGNhc2UgYWN0aW9ucy5NRVNTQUdFOiB7XG4gICAgICBtc2dzID0gcGFyZW50Lm1lc3NhZ2VzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgYWN0aW9ucy5QUkVTRU5DRTpcbiAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgIG1zZ3MgPSBwYXJlbnQucHJlc2VuY2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFjdGlvbnMuQU5OT1RBVElPTjpcbiAgICAgIG1zZ3MgPSBwYXJlbnQuYW5ub3RhdGlvbnM7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFjdGlvbnMuT0JKRUNUOlxuICAgIGNhc2UgYWN0aW9ucy5PQkpFQ1RfU1lOQzpcbiAgICAgIG1zZ3MgPSBwYXJlbnQuc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuZXhwZWN0ZWQgYWN0aW9uIFwiICsgcGFyZW50LmFjdGlvbiwgNGU0LCA0MDApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbXNncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1zZyA9IG1zZ3NbaV07XG4gICAgaWYgKCFtc2cuY29ubmVjdGlvbklkKSB7XG4gICAgICBtc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgIH1cbiAgICBpZiAoIW1zZy50aW1lc3RhbXApIHtcbiAgICAgIG1zZy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgfVxuICAgIGlmIChpZCAmJiAhbXNnLmlkKSB7XG4gICAgICBtc2cuaWQgPSBpZCArIFwiOlwiICsgaTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN0ck1zZyhtLCBjbHMpIHtcbiAgbGV0IHJlc3VsdCA9IFwiW1wiICsgY2xzO1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gbSkge1xuICAgIGlmIChhdHRyID09PSBcImRhdGFcIikge1xuICAgICAgaWYgKHR5cGVvZiBtLmRhdGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQgKz0gXCI7IGRhdGE9XCIgKyBtLmRhdGE7XG4gICAgICB9IGVsc2UgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKG0uZGF0YSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhIChidWZmZXIpPVwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKG0uZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtLmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhIChqc29uKT1cIiArIEpTT04uc3RyaW5naWZ5KG0uZGF0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyICYmIChhdHRyID09PSBcImV4dHJhc1wiIHx8IGF0dHIgPT09IFwib3BlcmF0aW9uXCIpKSB7XG4gICAgICByZXN1bHQgKz0gXCI7IFwiICsgYXR0ciArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkobVthdHRyXSk7XG4gICAgfSBlbHNlIGlmIChhdHRyID09PSBcInZlcnNpb25cIikge1xuICAgICAgcmVzdWx0ICs9IFwiOyB2ZXJzaW9uPVwiICsgSlNPTi5zdHJpbmdpZnkobVthdHRyXSk7XG4gICAgfSBlbHNlIGlmIChhdHRyID09PSBcImFubm90YXRpb25zXCIpIHtcbiAgICAgIHJlc3VsdCArPSBcIjsgYW5ub3RhdGlvbnM9XCIgKyBKU09OLnN0cmluZ2lmeShtW2F0dHJdKTtcbiAgICB9IGVsc2UgaWYgKG1bYXR0cl0gIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0ICs9IFwiOyBcIiArIGF0dHIgKyBcIj1cIiArIG1bYXR0cl07XG4gICAgfVxuICB9XG4gIHJlc3VsdCArPSBcIl1cIjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBCYXNlTWVzc2FnZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9iYXNlY2xpZW50LnRzXG52YXIgQmFzZUNsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIFRoZXNlIGV4cG9ydHMgYXJlIGZvciB1c2UgYnkgVU1EIHBsdWdpbnM7IHJlYXNvbiBiZWluZyBzbyB0aGF0IGNvbnN0cnVjdG9ycyBhbmQgc3RhdGljIG1ldGhvZHMgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRoZXNlIHBsdWdpbnMgd2l0aG91dCBuZWVkaW5nIHRvIGltcG9ydCB0aGUgY2xhc3NlcyBkaXJlY3RseSBhbmQgcmVzdWx0IGluIHRoZSBjbGFzcyBleGlzdGluZyBpbiBib3RoIHRoZSBwbHVnaW4gYW5kIHRoZSBjb3JlIGxpYnJhcnkuXG4gICAgICovXG4gICAgdGhpcy5QbGF0Zm9ybSA9IFBsYXRmb3JtO1xuICAgIHRoaXMuRXJyb3JJbmZvID0gRXJyb3JJbmZvO1xuICAgIHRoaXMuTG9nZ2VyID0gbG9nZ2VyX2RlZmF1bHQ7XG4gICAgdGhpcy5EZWZhdWx0cyA9IGRlZmF1bHRzX2RlZmF1bHQ7XG4gICAgdGhpcy5VdGlscyA9IHV0aWxzX2V4cG9ydHM7XG4gICAgdGhpcy5FdmVudEVtaXR0ZXIgPSBldmVudGVtaXR0ZXJfZGVmYXVsdDtcbiAgICB0aGlzLk1lc3NhZ2VFbmNvZGluZyA9IE1lc3NhZ2VFbmNvZGluZztcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qO1xuICAgIHRoaXMuX2FkZGl0aW9uYWxIVFRQUmVxdWVzdEltcGxlbWVudGF0aW9ucyA9IChfYTIgPSBvcHRpb25zLnBsdWdpbnMpICE9IG51bGwgPyBfYTIgOiBudWxsO1xuICAgIHRoaXMubG9nZ2VyID0gbmV3IGxvZ2dlcl9kZWZhdWx0KCk7XG4gICAgdGhpcy5sb2dnZXIuc2V0TG9nKG9wdGlvbnMubG9nTGV2ZWwsIG9wdGlvbnMubG9nSGFuZGxlcik7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkJhc2VDbGllbnQoKVwiLFxuICAgICAgXCJpbml0aWFsaXplZCB3aXRoIGNsaWVudE9wdGlvbnMgXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChvcHRpb25zKVxuICAgICk7XG4gICAgdGhpcy5fTXNnUGFjayA9IChfYyA9IChfYiA9IG9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLk1zZ1BhY2spICE9IG51bGwgPyBfYyA6IG51bGw7XG4gICAgY29uc3Qgbm9ybWFsT3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IGRlZmF1bHRzX2RlZmF1bHQubm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zLCB0aGlzLl9Nc2dQYWNrLCB0aGlzLmxvZ2dlcik7XG4gICAgaWYgKG5vcm1hbE9wdGlvbnMua2V5KSB7XG4gICAgICBjb25zdCBrZXlNYXRjaCA9IG5vcm1hbE9wdGlvbnMua2V5Lm1hdGNoKC9eKFteOlxcc10rKTooW146Llxcc10rKSQvKTtcbiAgICAgIGlmICgha2V5TWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbXNnID0gXCJpbnZhbGlkIGtleSBwYXJhbWV0ZXJcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQmFzZUNsaWVudCgpXCIsIG1zZyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8obXNnLCA0MDQwMCwgNDA0KTtcbiAgICAgIH1cbiAgICAgIG5vcm1hbE9wdGlvbnMua2V5TmFtZSA9IGtleU1hdGNoWzFdO1xuICAgICAgbm9ybWFsT3B0aW9ucy5rZXlTZWNyZXQgPSBrZXlNYXRjaFsyXTtcbiAgICB9XG4gICAgaWYgKFwiY2xpZW50SWRcIiBpbiBub3JtYWxPcHRpb25zKSB7XG4gICAgICBpZiAoISh0eXBlb2Ygbm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gXCJzdHJpbmdcIiB8fCBub3JtYWxPcHRpb25zLmNsaWVudElkID09PSBudWxsKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGxcIiwgNDAwMTIsIDQwMCk7XG4gICAgICBlbHNlIGlmIChub3JtYWxPcHRpb25zLmNsaWVudElkID09PSBcIipcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAnQ2FuXFx1MjAxOXQgdXNlIFwiKlwiIGFzIGEgY2xpZW50SWQgYXMgdGhhdCBzdHJpbmcgaXMgcmVzZXJ2ZWQuIChUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgdG9rZW4gcmVxdWVzdCBiZWhhdmlvdXIgdG8gdXNlIGEgd2lsZGNhcmQgY2xpZW50SWQsIHVzZSB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pJyxcbiAgICAgICAgICA0MDAxMixcbiAgICAgICAgICA0MDBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQmFzZUNsaWVudCgpXCIsIFwic3RhcnRlZDsgdmVyc2lvbiA9IFwiICsgZGVmYXVsdHNfZGVmYXVsdC52ZXJzaW9uKTtcbiAgICB0aGlzLl9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuc2VydmVyVGltZU9mZnNldCA9IG51bGw7XG4gICAgdGhpcy5odHRwID0gbmV3IEh0dHAodGhpcyk7XG4gICAgdGhpcy5hdXRoID0gbmV3IGF1dGhfZGVmYXVsdCh0aGlzLCBub3JtYWxPcHRpb25zKTtcbiAgICB0aGlzLl9yZXN0ID0gKChfZCA9IG9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLlJlc3QpID8gbmV3IG9wdGlvbnMucGx1Z2lucy5SZXN0KHRoaXMpIDogbnVsbDtcbiAgICB0aGlzLl9DcnlwdG8gPSAoX2YgPSAoX2UgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5DcnlwdG8pICE9IG51bGwgPyBfZiA6IG51bGw7XG4gICAgdGhpcy5fX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucyA9IChfaCA9IChfZyA9IG9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLk1lc3NhZ2VJbnRlcmFjdGlvbnMpICE9IG51bGwgPyBfaCA6IG51bGw7XG4gICAgdGhpcy5fQW5ub3RhdGlvbnMgPSAoX2ogPSAoX2kgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfaS5Bbm5vdGF0aW9ucykgIT0gbnVsbCA/IF9qIDogbnVsbDtcbiAgfVxuICBnZXQgcmVzdCgpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3QpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUmVzdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3Q7XG4gIH1cbiAgZ2V0IF9GaWx0ZXJlZFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLl9fRmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1lc3NhZ2VJbnRlcmFjdGlvbnNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fRmlsdGVyZWRTdWJzY3JpcHRpb25zO1xuICB9XG4gIGdldCBjaGFubmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LmNoYW5uZWxzO1xuICB9XG4gIGdldCBwdXNoKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3QucHVzaDtcbiAgfVxuICAvKiogUlNIOCAqL1xuICBkZXZpY2UoKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoISgoX2EyID0gdGhpcy5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkgfHwgIXRoaXMucHVzaC5Mb2NhbERldmljZSkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RldmljZSkge1xuICAgICAgdGhpcy5fZGV2aWNlID0gdGhpcy5wdXNoLkxvY2FsRGV2aWNlLmxvYWQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kZXZpY2U7XG4gIH1cbiAgYmFzZVVyaShob3N0KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzX2RlZmF1bHQuZ2V0SHR0cFNjaGVtZSh0aGlzLm9wdGlvbnMpICsgaG9zdCArIFwiOlwiICsgZGVmYXVsdHNfZGVmYXVsdC5nZXRQb3J0KHRoaXMub3B0aW9ucywgZmFsc2UpO1xuICB9XG4gIGFzeW5jIHN0YXRzKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlc3Quc3RhdHMocGFyYW1zKTtcbiAgfVxuICBhc3luYyB0aW1lKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlc3QudGltZShwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QobWV0aG9kLCBwYXRoLCB2ZXJzaW9uMiwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5yZXF1ZXN0KG1ldGhvZCwgcGF0aCwgdmVyc2lvbjIsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycyk7XG4gIH1cbiAgYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5iYXRjaFB1Ymxpc2goc3BlY09yU3BlY3MpO1xuICB9XG4gIGJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LmJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpO1xuICB9XG4gIHNldExvZyhsb2dPcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIuc2V0TG9nKGxvZ09wdGlvbnMubGV2ZWwsIGxvZ09wdGlvbnMuaGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB0aW1lIGJhc2VkIG9uIHRoZSBsb2NhbCBjbG9jayxcbiAgICogb3IgaWYgdGhlIG9wdGlvbiBxdWVyeVRpbWUgaXMgdHJ1ZSwgcmV0dXJuIHRoZSBzZXJ2ZXIgdGltZS5cbiAgICogVGhlIHNlcnZlciB0aW1lIG9mZnNldCBmcm9tIHRoZSBsb2NhbCB0aW1lIGlzIHN0b3JlZCBzbyB0aGF0XG4gICAqIG9ubHkgb25lIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIHRpbWUgaXMgZXZlciBuZWVkZWRcbiAgICovXG4gIGFzeW5jIGdldFRpbWVzdGFtcChxdWVyeVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNUaW1lT2Zmc2V0U2V0KCkgJiYgcXVlcnlUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCk7XG4gIH1cbiAgZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCkgKyAodGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0IHx8IDApO1xuICB9XG4gIGlzVGltZU9mZnNldFNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ICE9PSBudWxsO1xuICB9XG59O1xuQmFzZUNsaWVudC5QbGF0Zm9ybSA9IFBsYXRmb3JtO1xudmFyIGJhc2VjbGllbnRfZGVmYXVsdCA9IEJhc2VDbGllbnQ7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2RldmljZWRldGFpbHMudHNcbnZhciBEZXZpY2VEZXRhaWxzID0gY2xhc3MgX0RldmljZURldGFpbHMge1xuICB0b0pTT04oKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRldmljZVNlY3JldDogdGhpcy5kZXZpY2VTZWNyZXQsXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIGZvcm1GYWN0b3I6IHRoaXMuZm9ybUZhY3RvcixcbiAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICBkZXZpY2VJZGVudGl0eVRva2VuOiB0aGlzLmRldmljZUlkZW50aXR5VG9rZW4sXG4gICAgICBwdXNoOiB7XG4gICAgICAgIHJlY2lwaWVudDogKF9hMiA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZWNpcGllbnQsXG4gICAgICAgIHN0YXRlOiAoX2IgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zdGF0ZSxcbiAgICAgICAgZXJyb3I6IChfYyA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmVycm9yXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICAgIGxldCByZXN1bHQgPSBcIltEZXZpY2VEZXRhaWxzXCI7XG4gICAgaWYgKHRoaXMuaWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGlkPVwiICsgdGhpcy5pZDtcbiAgICBpZiAodGhpcy5wbGF0Zm9ybSlcbiAgICAgIHJlc3VsdCArPSBcIjsgcGxhdGZvcm09XCIgKyB0aGlzLnBsYXRmb3JtO1xuICAgIGlmICh0aGlzLmZvcm1GYWN0b3IpXG4gICAgICByZXN1bHQgKz0gXCI7IGZvcm1GYWN0b3I9XCIgKyB0aGlzLmZvcm1GYWN0b3I7XG4gICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGNsaWVudElkPVwiICsgdGhpcy5jbGllbnRJZDtcbiAgICBpZiAodGhpcy5tZXRhZGF0YSlcbiAgICAgIHJlc3VsdCArPSBcIjsgbWV0YWRhdGE9XCIgKyB0aGlzLm1ldGFkYXRhO1xuICAgIGlmICh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pXG4gICAgICByZXN1bHQgKz0gXCI7IGRldmljZUlkZW50aXR5VG9rZW49XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pO1xuICAgIGlmICgoX2EyID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlY2lwaWVudClcbiAgICAgIHJlc3VsdCArPSBcIjsgcHVzaC5yZWNpcGllbnQ9XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2gucmVjaXBpZW50KTtcbiAgICBpZiAoKF9iID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc3RhdGUpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2guc3RhdGU9XCIgKyB0aGlzLnB1c2guc3RhdGU7XG4gICAgaWYgKChfYyA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmVycm9yKVxuICAgICAgcmVzdWx0ICs9IFwiOyBwdXNoLmVycm9yPVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLmVycm9yKTtcbiAgICBpZiAoKF9kID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2QubWV0YWRhdGEpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2gubWV0YWRhdGE9XCIgKyB0aGlzLnB1c2gubWV0YWRhdGE7XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIHRvUmVxdWVzdEJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgfVxuICBzdGF0aWMgZnJvbVJlc3BvbnNlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBib2R5ID0gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgICAgcmV0dXJuIF9EZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheShib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9EZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMoYm9keSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHZhbHVlcy5lcnJvciA9IHZhbHVlcy5lcnJvciAmJiBFcnJvckluZm8uZnJvbVZhbHVlcyh2YWx1ZXMuZXJyb3IpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfRGV2aWNlRGV0YWlscygpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tTG9jYWxEZXZpY2UoZGV2aWNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9EZXZpY2VEZXRhaWxzKCksIGRldmljZSk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICBjb25zdCBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgcmVzdWx0W2ldID0gX0RldmljZURldGFpbHMuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgZGV2aWNlZGV0YWlsc19kZWZhdWx0ID0gRGV2aWNlRGV0YWlscztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc291cmNlLnRzXG5hc3luYyBmdW5jdGlvbiB3aXRoQXV0aERldGFpbHMoY2xpZW50LCBoZWFkZXJzLCBwYXJhbXMsIG9wQ2FsbGJhY2spIHtcbiAgaWYgKGNsaWVudC5odHRwLnN1cHBvcnRzQXV0aEhlYWRlcnMpIHtcbiAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IGNsaWVudC5hdXRoLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgcmV0dXJuIG9wQ2FsbGJhY2sobWl4aW4oYXV0aEhlYWRlcnMsIGhlYWRlcnMpLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGF1dGhQYXJhbXMgPSBhd2FpdCBjbGllbnQuYXV0aC5nZXRBdXRoUGFyYW1zKCk7XG4gICAgcmV0dXJuIG9wQ2FsbGJhY2soaGVhZGVycywgbWl4aW4oYXV0aFBhcmFtcywgcGFyYW1zKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuZW52ZWxvcGUocmVzdWx0LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgaWYgKHJlc3VsdC5lcnIgJiYgIXJlc3VsdC5ib2R5KSB7XG4gICAgcmV0dXJuIHsgZXJyOiByZXN1bHQuZXJyIH07XG4gIH1cbiAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdC5Ob0NvbnRlbnQpIHtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVzdWx0KSwgeyBib2R5OiBbXSwgdW5wYWNrZWQ6IHRydWUgfSk7XG4gIH1cbiAgbGV0IGJvZHkgPSByZXN1bHQuYm9keTtcbiAgaWYgKCFyZXN1bHQudW5wYWNrZWQpIHtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBlcnI6IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKGluc3BlY3RFcnJvcihlKSwgbnVsbCkgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFib2R5KSB7XG4gICAgcmV0dXJuIHsgZXJyOiBuZXcgUGFydGlhbEVycm9ySW5mbyhcInVuZW52ZWxvcGUoKTogUmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nXCIsIG51bGwpIH07XG4gIH1cbiAgY29uc3QgeyBzdGF0dXNDb2RlOiB3cmFwcGVkU3RhdHVzQ29kZSwgcmVzcG9uc2UsIGhlYWRlcnM6IHdyYXBwZWRIZWFkZXJzIH0gPSBib2R5O1xuICBpZiAod3JhcHBlZFN0YXR1c0NvZGUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCByZXN1bHQpLCB7IGJvZHksIHVucGFja2VkOiB0cnVlIH0pO1xuICB9XG4gIGlmICh3cmFwcGVkU3RhdHVzQ29kZSA8IDIwMCB8fCB3cmFwcGVkU3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICBsZXQgd3JhcHBlZEVyciA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLmVycm9yIHx8IHJlc3VsdC5lcnI7XG4gICAgaWYgKCF3cmFwcGVkRXJyKSB7XG4gICAgICB3cmFwcGVkRXJyID0gbmV3IEVycm9yKFwiRXJyb3IgaW4gdW5lbnZlbG9waW5nIFwiICsgYm9keSk7XG4gICAgICB3cmFwcGVkRXJyLnN0YXR1c0NvZGUgPSB3cmFwcGVkU3RhdHVzQ29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyOiB3cmFwcGVkRXJyLCBib2R5OiByZXNwb25zZSwgaGVhZGVyczogd3JhcHBlZEhlYWRlcnMsIHVucGFja2VkOiB0cnVlLCBzdGF0dXNDb2RlOiB3cmFwcGVkU3RhdHVzQ29kZSB9O1xuICB9XG4gIHJldHVybiB7IGVycjogcmVzdWx0LmVyciwgYm9keTogcmVzcG9uc2UsIGhlYWRlcnM6IHdyYXBwZWRIZWFkZXJzLCB1bnBhY2tlZDogdHJ1ZSwgc3RhdHVzQ29kZTogd3JhcHBlZFN0YXR1c0NvZGUgfTtcbn1cbmZ1bmN0aW9uIGxvZ1Jlc3VsdDIocmVzdWx0LCBtZXRob2QsIHBhdGgsIHBhcmFtcywgbG9nZ2VyKSB7XG4gIGlmIChyZXN1bHQuZXJyKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQgRXJyb3I7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHBhdGgsIHBhcmFtcykgKyBcIjsgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnIpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJSZWNlaXZlZDsgXCIgKyBhcHBlbmRpbmdQYXJhbXMocGF0aCwgcGFyYW1zKSArIFwiOyBIZWFkZXJzOiBcIiArIHBhcmFtU3RyaW5nKHJlc3VsdC5oZWFkZXJzKSArIFwiOyBTdGF0dXNDb2RlOiBcIiArIHJlc3VsdC5zdGF0dXNDb2RlICsgXCI7IEJvZHk6IFwiICsgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKHJlc3VsdC5ib2R5KSA/IFwiIChCYXNlNjQpOiBcIiArIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShyZXN1bHQuYm9keSkgOiBcIjogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChyZXN1bHQuYm9keSkpXG4gICAgKTtcbiAgfVxufVxudmFyIFJlc291cmNlID0gY2xhc3MgX1Jlc291cmNlIHtcbiAgc3RhdGljIGFzeW5jIGdldChjbGllbnQsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBjbGllbnQsIHBhdGgsIG51bGwsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IgIT0gbnVsbCA/IHRocm93RXJyb3IgOiBmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlbGV0ZShjbGllbnQsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuRGVsZXRlLCBjbGllbnQsIHBhdGgsIG51bGwsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBwb3N0KGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBwYXRjaChjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuUGF0Y2gsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHB1dChjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuUHV0LCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkbyhtZXRob2QsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIGlmIChlbnZlbG9wZSkge1xuICAgICAgKHBhcmFtcyA9IHBhcmFtcyB8fCB7fSlbXCJlbnZlbG9wZVwiXSA9IGVudmVsb3BlO1xuICAgIH1cbiAgICBjb25zdCBsb2dnZXIgPSBjbGllbnQubG9nZ2VyO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGRvUmVxdWVzdChoZWFkZXJzMiwgcGFyYW1zMikge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmIChsb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgbGV0IGRlY29kZWRCb2R5ID0gYm9keTtcbiAgICAgICAgaWYgKCgoX2EyID0gaGVhZGVyczJbXCJjb250ZW50LXR5cGVcIl0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaW5kZXhPZihcIm1zZ3BhY2tcIikpID4gMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWNsaWVudC5fTXNnUGFjaykge1xuICAgICAgICAgICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQm9keSA9IGNsaWVudC5fTXNnUGFjay5kZWNvZGUoYm9keSk7XG4gICAgICAgICAgfSBjYXRjaCAoZGVjb2RlRXJyKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgICAgICAgICBcIlNlbmRpbmcgTXNnUGFjayBEZWNvZGluZyBFcnJvcjogXCIgKyBpbnNwZWN0RXJyb3IoZGVjb2RlRXJyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgICAgICBcIlNlbmRpbmc7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHBhdGgsIHBhcmFtczIpICsgXCI7IEJvZHk6IFwiICsgZGVjb2RlZEJvZHlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGh0dHBSZXN1bHQgPSBhd2FpdCBjbGllbnQuaHR0cC5kbyhtZXRob2QsIHBhdGgsIGhlYWRlcnMyLCBib2R5LCBwYXJhbXMyKTtcbiAgICAgIGlmIChodHRwUmVzdWx0LmVycm9yICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKGh0dHBSZXN1bHQuZXJyb3IpKSB7XG4gICAgICAgIGF3YWl0IGNsaWVudC5hdXRoLmF1dGhvcml6ZShudWxsLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHdpdGhBdXRoRGV0YWlscyhjbGllbnQsIGhlYWRlcnMyLCBwYXJhbXMyLCBkb1JlcXVlc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyOiBodHRwUmVzdWx0LmVycm9yLFxuICAgICAgICBib2R5OiBodHRwUmVzdWx0LmJvZHksXG4gICAgICAgIGhlYWRlcnM6IGh0dHBSZXN1bHQuaGVhZGVycyxcbiAgICAgICAgdW5wYWNrZWQ6IGh0dHBSZXN1bHQudW5wYWNrZWQsXG4gICAgICAgIHN0YXR1c0NvZGU6IGh0dHBSZXN1bHQuc3RhdHVzQ29kZVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHdpdGhBdXRoRGV0YWlscyhjbGllbnQsIGhlYWRlcnMsIHBhcmFtcywgZG9SZXF1ZXN0KTtcbiAgICBpZiAoZW52ZWxvcGUpIHtcbiAgICAgIHJlc3VsdCA9IHVuZW52ZWxvcGUocmVzdWx0LCBjbGllbnQuX01zZ1BhY2ssIGVudmVsb3BlKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgbG9nUmVzdWx0MihyZXN1bHQsIG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBsb2dnZXIpO1xuICAgIH1cbiAgICBpZiAodGhyb3dFcnJvcikge1xuICAgICAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdCk7XG4gICAgICAgIGRlbGV0ZSByZXNwb25zZS5lcnI7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciByZXNvdXJjZV9kZWZhdWx0ID0gUmVzb3VyY2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9wYWdpbmF0ZWRyZXNvdXJjZS50c1xuZnVuY3Rpb24gZ2V0UmVsUGFyYW1zKGxpbmtVcmwpIHtcbiAgY29uc3QgdXJsTWF0Y2ggPSBsaW5rVXJsLm1hdGNoKC9eXFwuXFwvKFxcdyspXFw/KC4qKSQvKTtcbiAgcmV0dXJuIHVybE1hdGNoICYmIHVybE1hdGNoWzJdICYmIHBhcnNlUXVlcnlTdHJpbmcodXJsTWF0Y2hbMl0pO1xufVxuZnVuY3Rpb24gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKSB7XG4gIGlmICh0eXBlb2YgbGlua0hlYWRlciA9PSBcInN0cmluZ1wiKVxuICAgIGxpbmtIZWFkZXIgPSBsaW5rSGVhZGVyLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgcmVsUGFyYW1zID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlua0hlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmtNYXRjaCA9IGxpbmtIZWFkZXJbaV0ubWF0Y2goL15cXHMqPCguKyk+O1xccypyZWw9XCIoXFx3KylcIiQvKTtcbiAgICBpZiAobGlua01hdGNoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBnZXRSZWxQYXJhbXMobGlua01hdGNoWzFdKTtcbiAgICAgIGlmIChwYXJhbXMpXG4gICAgICAgIHJlbFBhcmFtc1tsaW5rTWF0Y2hbMl1dID0gcGFyYW1zO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVsUGFyYW1zO1xufVxuZnVuY3Rpb24gcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHVzZUhQUikge1xuICByZXR1cm4gISh1c2VIUFIgJiYgKGJvZHkgfHwgdHlwZW9mIGVyci5jb2RlID09PSBcIm51bWJlclwiKSk7XG59XG52YXIgUGFnaW5hdGVkUmVzb3VyY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGJvZHlIYW5kbGVyLCB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlICE9IG51bGwgPyBlbnZlbG9wZSA6IG51bGw7XG4gICAgdGhpcy5ib2R5SGFuZGxlciA9IGJvZHlIYW5kbGVyO1xuICAgIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlIHx8IGZhbHNlO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5nZXQodGhpcy5jbGllbnQsIHRoaXMucGF0aCwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZGVsZXRlKHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIHBvc3QocGFyYW1zLCBib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIHB1dChwYXJhbXMsIGJvZHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnB1dCh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBwYXRjaChwYXJhbXMsIGJvZHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBhdGNoKHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIGhhbmRsZVBhZ2UocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5lcnIgJiYgcmV0dXJuRXJyT25seShyZXN1bHQuZXJyLCByZXN1bHQuYm9keSwgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiUGFnaW5hdGVkUmVzb3VyY2UuaGFuZGxlUGFnZSgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBlcnJvciBnZXR0aW5nIHJlc291cmNlOiBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihyZXN1bHQuZXJyKVxuICAgICAgKTtcbiAgICAgIHRocm93IHJlc3VsdC5lcnI7XG4gICAgfVxuICAgIGxldCBpdGVtcywgbGlua0hlYWRlciwgcmVsUGFyYW1zO1xuICAgIHRyeSB7XG4gICAgICBpdGVtcyA9IHJlc3VsdC5zdGF0dXNDb2RlID09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0Lk5vQ29udGVudCA/IFtdIDogYXdhaXQgdGhpcy5ib2R5SGFuZGxlcihyZXN1bHQuYm9keSwgcmVzdWx0LmhlYWRlcnMgfHwge30sIHJlc3VsdC51bnBhY2tlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgcmVzdWx0LmVyciB8fCBlO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmhlYWRlcnMgJiYgKGxpbmtIZWFkZXIgPSByZXN1bHQuaGVhZGVyc1tcIkxpbmtcIl0gfHwgcmVzdWx0LmhlYWRlcnNbXCJsaW5rXCJdKSkge1xuICAgICAgcmVsUGFyYW1zID0gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbmV3IEh0dHBQYWdpbmF0ZWRSZXNwb25zZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIHJlc3VsdC5oZWFkZXJzIHx8IHt9LFxuICAgICAgICByZXN1bHQuc3RhdHVzQ29kZSxcbiAgICAgICAgcmVsUGFyYW1zLFxuICAgICAgICByZXN1bHQuZXJyXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBhZ2luYXRlZFJlc3VsdCh0aGlzLCBpdGVtcywgcmVsUGFyYW1zKTtcbiAgICB9XG4gIH1cbn07XG52YXIgUGFnaW5hdGVkUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcykge1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgdGhpcy5fcmVsUGFyYW1zID0gcmVsUGFyYW1zO1xuICB9XG4gIGFzeW5jIGZpcnN0KCkge1xuICAgIGlmICh0aGlzLmhhc0ZpcnN0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLl9yZWxQYXJhbXMuZmlyc3QpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiTm8gbGluayB0byB0aGUgZmlyc3QgcGFnZSBvZiByZXN1bHRzXCIsIDQwNDAwLCA0MDQpO1xuICB9XG4gIGFzeW5jIGN1cnJlbnQoKSB7XG4gICAgaWYgKHRoaXMuaGFzQ3VycmVudCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5fcmVsUGFyYW1zLmN1cnJlbnQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiTm8gbGluayB0byB0aGUgY3VycmVudCBwYWdlIG9mIHJlc3VsdHNcIiwgNDA0MDAsIDQwNCk7XG4gIH1cbiAgYXN5bmMgbmV4dCgpIHtcbiAgICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLl9yZWxQYXJhbXMubmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhc0ZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxQYXJhbXMgIT0gbnVsbCAmJiBcImZpcnN0XCIgaW4gdGhpcy5fcmVsUGFyYW1zO1xuICB9XG4gIGhhc0N1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbFBhcmFtcyAhPSBudWxsICYmIFwiY3VycmVudFwiIGluIHRoaXMuX3JlbFBhcmFtcztcbiAgfVxuICBoYXNOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxQYXJhbXMgIT0gbnVsbCAmJiBcIm5leHRcIiBpbiB0aGlzLl9yZWxQYXJhbXM7XG4gIH1cbiAgaXNMYXN0KCkge1xuICAgIHJldHVybiAhdGhpcy5oYXNOZXh0KCk7XG4gIH1cbiAgLyogV2UgYXNzdW1lIHRoYXQgb25seSB0aGUgaW5pdGlhbCByZXF1ZXN0IGNhbiBiZSBhIFBPU1QsIGFuZCB0aGF0IGFjY2Vzc2luZ1xuICAgKiB0aGUgcmVzdCBvZiBhIG11bHRpcGFnZSBzZXQgb2YgcmVzdWx0cyBjYW4gYWx3YXlzIGJlIGRvbmUgd2l0aCBHRVQgKi9cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGNvbnN0IHJlcyA9IHRoaXMucmVzb3VyY2U7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5nZXQocmVzLmNsaWVudCwgcmVzLnBhdGgsIHJlcy5oZWFkZXJzLCBwYXJhbXMsIHJlcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiByZXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG59O1xudmFyIEh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgUGFnaW5hdGVkUmVzdWx0IHtcbiAgY29uc3RydWN0b3IocmVzb3VyY2UsIGl0ZW1zLCBoZWFkZXJzLCBzdGF0dXNDb2RlLCByZWxQYXJhbXMsIGVycikge1xuICAgIHN1cGVyKHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3VjY2VzcyA9IHN0YXR1c0NvZGUgPCAzMDAgJiYgc3RhdHVzQ29kZSA+PSAyMDA7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVyciAmJiBlcnIuY29kZTtcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgc3VjY2VzczogdGhpcy5zdWNjZXNzLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgZXJyb3JDb2RlOiB0aGlzLmVycm9yQ29kZSxcbiAgICAgIGVycm9yTWVzc2FnZTogdGhpcy5lcnJvck1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xudmFyIHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQgPSBQYWdpbmF0ZWRSZXNvdXJjZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24udHNcbnZhciBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSBjbGFzcyBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24ge1xuICAvKipcbiAgICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLFxuICAgICAgZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG4gICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZFxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiW1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uXCI7XG4gICAgaWYgKHRoaXMuY2hhbm5lbClcbiAgICAgIHJlc3VsdCArPSBcIjsgY2hhbm5lbD1cIiArIHRoaXMuY2hhbm5lbDtcbiAgICBpZiAodGhpcy5kZXZpY2VJZClcbiAgICAgIHJlc3VsdCArPSBcIjsgZGV2aWNlSWQ9XCIgKyB0aGlzLmRldmljZUlkO1xuICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBjbGllbnRJZD1cIiArIHRoaXMuY2xpZW50SWQ7XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGZyb21SZXNwb25zZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgYm9keSA9IGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYm9keSkpIHtcbiAgICAgIHJldHVybiBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMoYm9keSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24oKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIGNvbnN0IGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICByZXN1bHRbaV0gPSBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5fUHVzaENoYW5uZWxTdWJzY3JpcHRpb24udG9SZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHk7XG52YXIgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb247XG52YXIgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdCA9IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcHVzaC50c1xudmFyIFB1c2ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHZhciBfYTI7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5hZG1pbiA9IG5ldyBBZG1pbihjbGllbnQpO1xuICAgIGlmIChQbGF0Zm9ybS5Db25maWcucHVzaCAmJiAoKF9hMiA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkpIHtcbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5BY3RpdmF0aW9uU3RhdGVNYWNoaW5lKGNsaWVudCk7XG4gICAgICB0aGlzLkxvY2FsRGV2aWNlID0gY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLmxvY2FsRGV2aWNlRmFjdG9yeShkZXZpY2VkZXRhaWxzX2RlZmF1bHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBhY3RpdmF0ZShyZWdpc3RlckNhbGxiYWNrLCB1cGRhdGVGYWlsZWRDYWxsYmFjaykge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoISgoX2EyID0gdGhpcy5jbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpKSB7XG4gICAgICAgIHJlamVjdChjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlTWFjaGluZSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIlRoaXMgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZCBhcyBhIHRhcmdldCBvZiBwdXNoIG5vdGlmaWNhdGlvbnNcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGVNYWNoaW5lLmFjdGl2YXRlZENhbGxiYWNrKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiQWN0aXZhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLmFjdGl2YXRlZENhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS51cGRhdGVGYWlsZWRDYWxsYmFjayA9IHVwZGF0ZUZhaWxlZENhbGxiYWNrO1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuaGFuZGxlRXZlbnQoXG4gICAgICAgIG5ldyB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5DYWxsZWRBY3RpdmF0ZSh0aGlzLnN0YXRlTWFjaGluZSwgcmVnaXN0ZXJDYWxsYmFjaylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGVhY3RpdmF0ZShkZXJlZ2lzdGVyQ2FsbGJhY2spIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKCEoKF9hMiA9IHRoaXMuY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5QdXNoKSkge1xuICAgICAgICByZWplY3QoY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJUaGlzIHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYSB0YXJnZXQgb2YgcHVzaCBub3RpZmljYXRpb25zXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlTWFjaGluZS5kZWFjdGl2YXRlZENhbGxiYWNrKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiRGVhY3RpdmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuZGVhY3RpdmF0ZWRDYWxsYmFjayA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuaGFuZGxlRXZlbnQoXG4gICAgICAgIG5ldyB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5DYWxsZWREZWFjdGl2YXRlKHRoaXMuc3RhdGVNYWNoaW5lLCBkZXJlZ2lzdGVyQ2FsbGJhY2spXG4gICAgICApO1xuICAgIH0pO1xuICB9XG59O1xudmFyIEFkbWluID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmRldmljZVJlZ2lzdHJhdGlvbnMgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9ucyhjbGllbnQpO1xuICAgIHRoaXMuY2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBuZXcgQ2hhbm5lbFN1YnNjcmlwdGlvbnMoY2xpZW50KTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlY2lwaWVudCwgcGF5bG9hZCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucyksIHBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IGJvZHkgPSBtaXhpbih7IHJlY2lwaWVudCB9LCBwYXlsb2FkKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChjbGllbnQsIFwiL3B1c2gvcHVibGlzaFwiLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCB0cnVlKTtcbiAgfVxufTtcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICBhc3luYyBzYXZlKGRldmljZSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGJvZHkgPSBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVZhbHVlcyhkZXZpY2UpO1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucyksIHBhcmFtcyA9IHt9O1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnB1dChcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UuaWQpLFxuICAgICAgcmVxdWVzdEJvZHksXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zLFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICByZXNwb25zZS51bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0KGRldmljZUlkT3JEZXRhaWxzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKSwgZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcbiAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSBcInN0cmluZ1wiIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNnZXQgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzXCIsXG4gICAgICAgIDRlNCxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB7fSxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gZGV2aWNlZGV0YWlsc19kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgcmVzcG9uc2UudW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICApO1xuICB9XG4gIGFzeW5jIGxpc3QocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KGNsaWVudCwgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zXCIsIGhlYWRlcnMsIGVudmVsb3BlLCBhc3luYyBmdW5jdGlvbihib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpIHtcbiAgICAgIHJldHVybiBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgICB1bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICAgKTtcbiAgICB9KS5nZXQocGFyYW1zKTtcbiAgfVxuICBhc3luYyByZW1vdmUoZGV2aWNlSWRPckRldGFpbHMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpLCBwYXJhbXMgPSB7fSwgZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcbiAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSBcInN0cmluZ1wiIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNyZW1vdmUgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzXCIsXG4gICAgICAgIDRlNCxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0W1wiZGVsZXRlXCJdKFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlV2hlcmUocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0W1wiZGVsZXRlXCJdKGNsaWVudCwgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zXCIsIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgdHJ1ZSk7XG4gIH1cbn07XG52YXIgQ2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBjbGFzcyBfQ2hhbm5lbFN1YnNjcmlwdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAvKiBDaGFubmVsU3Vic2NyaXB0aW9ucyBoYXZlIG5vIHVuaXF1ZSBpZDsgcmVtb3Zpbmcgb25lIGlzIGVxdWl2YWxlbnQgdG8gcmVtb3ZlV2hlcmUgYnkgaXRzIHByb3BlcnRpZXMgKi9cbiAgICB0aGlzLnJlbW92ZSA9IF9DaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmU7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgYXN5bmMgc2F2ZShzdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBib2R5ID0gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdC5mcm9tVmFsdWVzKHN1YnNjcmlwdGlvbik7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zKSwgcGFyYW1zID0ge307XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnNcIixcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgIHJlc3BvbnNlLnVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgKTtcbiAgfVxuICBhc3luYyBsaXN0KHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIFwiL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgcmV0dXJuIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgICB1bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICAgKTtcbiAgICB9KS5nZXQocGFyYW1zKTtcbiAgfVxuICBhc3luYyByZW1vdmVXaGVyZShwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHRbXCJkZWxldGVcIl0oY2xpZW50LCBcIi9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zXCIsIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgdHJ1ZSk7XG4gIH1cbiAgYXN5bmMgbGlzdENoYW5uZWxzKHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIFwiL3B1c2gvY2hhbm5lbHNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgY29uc3QgcGFyc2VkQm9keSA9ICF1bnBhY2tlZCAmJiBmb3JtYXQgPyBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KSA6IGJvZHk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZEJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFyc2VkQm9keVtpXSA9IFN0cmluZyhwYXJzZWRCb2R5W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRCb2R5O1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG59O1xudmFyIHB1c2hfZGVmYXVsdCA9IFB1c2g7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3ByZXNlbmNlbWVzc2FnZS50c1xudmFyIGFjdGlvbnMyID0gW1wiYWJzZW50XCIsIFwicHJlc2VudFwiLCBcImVudGVyXCIsIFwibGVhdmVcIiwgXCJ1cGRhdGVcIl07XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZChsb2dnZXIsIENyeXB0bzIsIGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhDcnlwdG8yLCBsb2dnZXIsIGlucHV0T3B0aW9ucyAhPSBudWxsID8gaW5wdXRPcHRpb25zIDogbnVsbCk7XG4gIGNvbnN0IHdwbSA9IFdpcmVQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgcmV0dXJuIHdwbS5kZWNvZGUob3B0aW9ucywgbG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkQXJyYXkobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIGZyb21FbmNvZGVkKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZChlbmNvZGVkLCBjaGFubmVsKSB7XG4gIHJldHVybiBXaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCkuZGVjb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGNoYW5uZWwubG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZEFycmF5KGVuY29kZWRBcnJheSwgY2hhbm5lbCkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkKGVuY29kZWQsIGNoYW5uZWwpO1xuICAgIH0pXG4gICk7XG59XG52YXIgUHJlc2VuY2VNZXNzYWdlID0gY2xhc3MgX1ByZXNlbmNlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgLyogUmV0dXJucyB3aGV0aGVyIHRoaXMgcHJlc2VuY2VNZXNzYWdlIGlzIHN5bnRoZXNpemVkLCBpLmUuIHdhcyBub3QgYWN0dWFsbHlcbiAgICogc2VudCBieSB0aGUgY29ubmVjdGlvbiAodXN1YWxseSBtZWFucyBhIGxlYXZlIGV2ZW50IHNlbnQgMTVzIGFmdGVyIGFcbiAgICogZGlzY29ubmVjdGlvbikuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2Ugc3ludGhlc2l6ZWQgbWVzc2FnZXMgY2Fubm90IGJlXG4gICAqIGNvbXBhcmVkIGZvciBuZXduZXNzIGJ5IGlkIGxleGljb2dyYXBoaWNhbGx5IC0gUlRQMmIxXG4gICAqL1xuICBpc1N5bnRoZXNpemVkKCkge1xuICAgIGlmICghdGhpcy5pZCB8fCAhdGhpcy5jb25uZWN0aW9uSWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcodGhpcy5jb25uZWN0aW9uSWQubGVuZ3RoLCAwKSAhPT0gdGhpcy5jb25uZWN0aW9uSWQ7XG4gIH1cbiAgLyogUlRQMmIyICovXG4gIHBhcnNlSWQoKSB7XG4gICAgaWYgKCF0aGlzLmlkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFyc2VJZCgpOiBQcmVzZW5jZSBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYW4gaWRcIik7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLmlkLnNwbGl0KFwiOlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29ubmVjdGlvbklkOiBwYXJ0c1swXSxcbiAgICAgIG1zZ1NlcmlhbDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIGluZGV4OiBwYXJzZUludChwYXJ0c1syXSwgMTApXG4gICAgfTtcbiAgfVxuICBhc3luYyBlbmNvZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFdpcmVQcmVzZW5jZU1lc3NhZ2UoKSwgdGhpcywge1xuICAgICAgYWN0aW9uOiBhY3Rpb25zMi5pbmRleE9mKHRoaXMuYWN0aW9uIHx8IFwicHJlc2VudFwiKVxuICAgIH0pO1xuICAgIHJldHVybiBlbmNvZGUocmVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1ByZXNlbmNlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9QcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgc3RhdGljIGZyb21EYXRhKGRhdGEpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9QcmVzZW5jZU1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gX1ByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHtcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiUHJlc2VuY2VNZXNzYWdlXCIpO1xuICB9XG59O1xudmFyIFdpcmVQcmVzZW5jZU1lc3NhZ2UgPSBjbGFzcyBfV2lyZVByZXNlbmNlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgdG9KU09OKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gd2lyZVRvSlNPTi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfV2lyZVByZXNlbmNlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9XaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXModikpO1xuICB9XG4gIGFzeW5jIGRlY29kZShjaGFubmVsT3B0aW9ucywgbG9nZ2VyKSB7XG4gICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbihuZXcgUHJlc2VuY2VNZXNzYWdlKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMpLCB7XG4gICAgICBhY3Rpb246IGFjdGlvbnMyW3RoaXMuYWN0aW9uXVxuICAgIH0pKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZGVjb2RlKHJlcywgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXaXJlUHJlc2VuY2VNZXNzYWdlLmRlY29kZSgpXCIsIGluc3BlY3RFcnJvcihlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIldpcmVQcmVzZW5jZU1lc3NhZ2VcIik7XG4gIH1cbn07XG52YXIgcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQgPSBQcmVzZW5jZU1lc3NhZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0cHJlc2VuY2UudHNcbnZhciBSZXN0UHJlc2VuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5sb2dnZXI7XG4gIH1cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RQcmVzZW5jZS5nZXQoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMuY2hhbm5lbC5uYW1lKTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNoYW5uZWwuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2hhbm5lbC5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy5jaGFubmVsLmNsaWVudC5yZXN0LnByZXNlbmNlTWl4aW4uYmFzZVBhdGgodGhpcyksXG4gICAgICBoZWFkZXJzLFxuICAgICAgZW52ZWxvcGUsXG4gICAgICBhc3luYyAoYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZEFycmF5KGRlY29kZWQsIHRoaXMuY2hhbm5lbCk7XG4gICAgICB9XG4gICAgKS5nZXQocGFyYW1zKTtcbiAgfVxuICBhc3luYyBoaXN0b3J5KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RQcmVzZW5jZS5oaXN0b3J5KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5jbGllbnQucmVzdC5wcmVzZW5jZU1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgfVxufTtcbnZhciByZXN0cHJlc2VuY2VfZGVmYXVsdCA9IFJlc3RQcmVzZW5jZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvbWVzc2FnZS50c1xudmFyIGFjdGlvbnMzID0gW1xuICBcIm1lc3NhZ2UuY3JlYXRlXCIsXG4gIFwibWVzc2FnZS51cGRhdGVcIixcbiAgXCJtZXNzYWdlLmRlbGV0ZVwiLFxuICBcIm1ldGFcIixcbiAgXCJtZXNzYWdlLnN1bW1hcnlcIixcbiAgXCJtZXNzYWdlLmFwcGVuZFwiXG5dO1xuZnVuY3Rpb24gc3RyaW5naWZ5QWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gYWN0aW9uczNbYWN0aW9uIHx8IDBdIHx8IFwidW5rbm93blwiO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZVNpemUobXNnKSB7XG4gIGxldCBzaXplID0gMDtcbiAgaWYgKG1zZy5uYW1lKSB7XG4gICAgc2l6ZSArPSBtc2cubmFtZS5sZW5ndGg7XG4gIH1cbiAgaWYgKG1zZy5jbGllbnRJZCkge1xuICAgIHNpemUgKz0gbXNnLmNsaWVudElkLmxlbmd0aDtcbiAgfVxuICBpZiAobXNnLmV4dHJhcykge1xuICAgIHNpemUgKz0gSlNPTi5zdHJpbmdpZnkobXNnLmV4dHJhcykubGVuZ3RoO1xuICB9XG4gIGlmIChtc2cuZGF0YSkge1xuICAgIHNpemUgKz0gZGF0YVNpemVCeXRlcyhtc2cuZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZDIobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkLCBpbnB1dE9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMoQ3J5cHRvMiwgbG9nZ2VyLCBpbnB1dE9wdGlvbnMgIT0gbnVsbCA/IGlucHV0T3B0aW9ucyA6IG51bGwpO1xuICBjb25zdCB3bSA9IFdpcmVNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XG4gIHJldHVybiB3bS5kZWNvZGUob3B0aW9ucywgbG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkQXJyYXkyKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHJldHVybiBmcm9tRW5jb2RlZDIobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkLCBvcHRpb25zKTtcbiAgICB9KVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gX2Zyb21FbmNvZGVkMihlbmNvZGVkLCBjaGFubmVsKSB7XG4gIGNvbnN0IHdtID0gV2lyZU1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgcmV0dXJuIHdtLmRlY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zLCBjaGFubmVsLmxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWRBcnJheTIoZW5jb2RlZEFycmF5LCBjaGFubmVsKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHJldHVybiBfZnJvbUVuY29kZWQyKGVuY29kZWQsIGNoYW5uZWwpO1xuICAgIH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBlbmNvZGVBcnJheShtZXNzYWdlcywgb3B0aW9ucykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiBtZXNzYWdlLmVuY29kZShvcHRpb25zKSkpO1xufVxudmFyIHNlcmlhbGl6ZSA9IGVuY29kZUJvZHk7XG5mdW5jdGlvbiBnZXRNZXNzYWdlc1NpemUobWVzc2FnZXMpIHtcbiAgbGV0IG1zZywgdG90YWwgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbXNnID0gbWVzc2FnZXNbaV07XG4gICAgdG90YWwgKz0gbXNnLnNpemUgfHwgKG1zZy5zaXplID0gZ2V0TWVzc2FnZVNpemUobXNnKSk7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufVxudmFyIE1lc3NhZ2UgPSBjbGFzcyBfTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgZXhwYW5kRmllbGRzKCkge1xuICAgIGlmICghdGhpcy52ZXJzaW9uKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSB7fTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnZlcnNpb24uc2VyaWFsICYmIHRoaXMuc2VyaWFsKSB7XG4gICAgICB0aGlzLnZlcnNpb24uc2VyaWFsID0gdGhpcy5zZXJpYWw7XG4gICAgfVxuICAgIGlmICghdGhpcy52ZXJzaW9uLnRpbWVzdGFtcCAmJiB0aGlzLnRpbWVzdGFtcCkge1xuICAgICAgdGhpcy52ZXJzaW9uLnRpbWVzdGFtcCA9IHRoaXMudGltZXN0YW1wO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbnMpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSB7XG4gICAgICAgIHN1bW1hcnk6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuYW5ub3RhdGlvbnMuc3VtbWFyeSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucy5zdW1tYXJ5ID0ge307XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25zICYmIHRoaXMuYW5ub3RhdGlvbnMuc3VtbWFyeSkge1xuICAgICAgZm9yIChjb25zdCBbdHlwZSwgc3VtbWFyeUVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmFubm90YXRpb25zLnN1bW1hcnkpKSB7XG4gICAgICAgIGlmICh0eXBlLmVuZHNXaXRoKFwiOmRpc3RpbmN0LnYxXCIpIHx8IHR5cGUuZW5kc1dpdGgoXCI6dW5pcXVlLnYxXCIpIHx8IHR5cGUuZW5kc1dpdGgoXCI6bXVsdGlwbGUudjFcIikpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFssIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyhzdW1tYXJ5RW50cnkpKSB7XG4gICAgICAgICAgICBpZiAoIWVudHJ5LmNsaXBwZWQpIHtcbiAgICAgICAgICAgICAgZW50cnkuY2xpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLmVuZHNXaXRoKFwiOmZsYWcudjFcIikpIHtcbiAgICAgICAgICBpZiAoIXN1bW1hcnlFbnRyeS5jbGlwcGVkKSB7XG4gICAgICAgICAgICBzdW1tYXJ5RW50cnkuY2xpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBlbmNvZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFdpcmVNZXNzYWdlKCksIHRoaXMsIHtcbiAgICAgIGFjdGlvbjogYWN0aW9uczMuaW5kZXhPZih0aGlzLmFjdGlvbiB8fCBcIm1lc3NhZ2UuY3JlYXRlXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuIGVuY29kZShyZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9NZXNzYWdlLmZyb21WYWx1ZXModikpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJNc2codGhpcywgXCJNZXNzYWdlXCIpO1xuICB9XG59O1xudmFyIFdpcmVNZXNzYWdlID0gY2xhc3MgX1dpcmVNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAvLyBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICB0b0pTT04oLi4uYXJncykge1xuICAgIHJldHVybiB3aXJlVG9KU09OLmNhbGwodGhpcywgLi4uYXJncyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9XaXJlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9XaXJlTWVzc2FnZS5mcm9tVmFsdWVzKHYpKTtcbiAgfVxuICAvLyBmb3IgY29udGV4dHMgd2hlcmUgc29tZSBkZWNvZGluZyBlcnJvcnMgbmVlZCB0byBiZSBoYW5kbGVkIHNwZWNpYWxseSBieSB0aGUgY2FsbGVyXG4gIGFzeW5jIGRlY29kZVdpdGhFcnIoaW5wdXRDb250ZXh0LCBsb2dnZXIpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBNZXNzYWdlKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMpLCB7XG4gICAgICBhY3Rpb246IHN0cmluZ2lmeUFjdGlvbih0aGlzLmFjdGlvbilcbiAgICB9KSk7XG4gICAgbGV0IGVycjtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZGVjb2RlKHJlcywgaW5wdXRDb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2lyZU1lc3NhZ2UuZGVjb2RlKClcIiwgaW5zcGVjdEVycm9yKGUpKTtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHJlcy5leHBhbmRGaWVsZHMoKTtcbiAgICByZXR1cm4geyBkZWNvZGVkOiByZXMsIGVyciB9O1xuICB9XG4gIGFzeW5jIGRlY29kZShpbnB1dENvbnRleHQsIGxvZ2dlcikge1xuICAgIGNvbnN0IHsgZGVjb2RlZCB9ID0gYXdhaXQgdGhpcy5kZWNvZGVXaXRoRXJyKGlucHV0Q29udGV4dCwgbG9nZ2VyKTtcbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiV2lyZU1lc3NhZ2VcIik7XG4gIH1cbn07XG52YXIgbWVzc2FnZV9kZWZhdWx0ID0gTWVzc2FnZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3RjaGFubmVsLnRzXG52YXIgTVNHX0lEX0VOVFJPUFlfQllURVMgPSA5O1xuZnVuY3Rpb24gYWxsRW1wdHlJZHMobWVzc2FnZXMpIHtcbiAgcmV0dXJuIG1lc3NhZ2VzLmV2ZXJ5KGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gIW1lc3NhZ2UuaWQ7XG4gIH0pO1xufVxudmFyIFJlc3RDaGFubmVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBudWxsO1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihjbGllbnQubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVzdENoYW5uZWwoKVwiLCBcInN0YXJ0ZWQ7IG5hbWUgPSBcIiArIG5hbWUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVzZW5jZSA9IG5ldyByZXN0cHJlc2VuY2VfZGVmYXVsdCh0aGlzKTtcbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IGNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIGNoYW5uZWxPcHRpb25zKTtcbiAgICBpZiAoKF9iID0gY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLlB1c2gpIHtcbiAgICAgIHRoaXMuX3B1c2ggPSBuZXcgY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLlB1c2hDaGFubmVsKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50Ll9Bbm5vdGF0aW9ucykge1xuICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBuZXcgY2xpZW50Ll9Bbm5vdGF0aW9ucy5SZXN0QW5ub3RhdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBhbm5vdGF0aW9ucygpIHtcbiAgICBpZiAoIXRoaXMuX2Fubm90YXRpb25zKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIkFubm90YXRpb25zXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnM7XG4gIH1cbiAgZ2V0IHB1c2goKSB7XG4gICAgaWYgKCF0aGlzLl9wdXNoKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlB1c2hcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdXNoO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBub3JtYWxpc2VDaGFubmVsT3B0aW9ucygoX2EyID0gdGhpcy5jbGllbnQuX0NyeXB0bykgIT0gbnVsbCA/IF9hMiA6IG51bGwsIHRoaXMubG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBoaXN0b3J5KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF0sIHNlY29uZCA9IGFyZ3NbMV07XG4gICAgbGV0IG1lc3NhZ2VzO1xuICAgIGxldCBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiB8fCBmaXJzdCA9PT0gbnVsbCkge1xuICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoeyBuYW1lOiBmaXJzdCwgZGF0YTogc2Vjb25kIH0pXTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChmaXJzdCkpIHtcbiAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKGZpcnN0KV07XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIG1lc3NhZ2VzID0gbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShmaXJzdCk7XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIlRoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0c1wiLFxuICAgICAgICA0MDAxMyxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBvcHRpb25zID0gY2xpZW50Lm9wdGlvbnMsIGZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gY2xpZW50Lm9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyAmJiBhbGxFbXB0eUlkcyhtZXNzYWdlcykpIHtcbiAgICAgIGNvbnN0IG1zZ0lkQmFzZSA9IGF3YWl0IHJhbmRvbVN0cmluZyhNU0dfSURfRU5UUk9QWV9CWVRFUyk7XG4gICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBtc2dJZEJhc2UgKyBcIjpcIiArIGluZGV4LnRvU3RyaW5nKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2VzID0gYXdhaXQgZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMpO1xuICAgIGNvbnN0IHNpemUgPSBnZXRNZXNzYWdlc1NpemUod2lyZU1lc3NhZ2VzKSwgbWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgIGlmIChzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGBNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKHdhcyAke3NpemV9IGJ5dGVzOyBsaW1pdCBpcyAke21heE1lc3NhZ2VTaXplfSBieXRlcylgLFxuICAgICAgICA0MDAwOSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVibGlzaChzZXJpYWxpemUod2lyZU1lc3NhZ2VzLCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCksIGhlYWRlcnMsIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgX3B1Ymxpc2gocmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi87XG4gICAgY29uc3QgeyBib2R5LCB1bnBhY2tlZCB9ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KFxuICAgICAgY2xpZW50LFxuICAgICAgY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmJhc2VQYXRoKHRoaXMpICsgXCIvbWVzc2FnZXNcIixcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCBkZWNvZGVkID0gKHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpKSB8fCB7fTtcbiAgICBkZWxldGUgZGVjb2RlZFtcImNoYW5uZWxcIl07XG4gICAgZGVsZXRlIGRlY29kZWRbXCJtZXNzYWdlSWRcIl07XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbiAgYXN5bmMgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5zdGF0dXModGhpcyk7XG4gIH1cbiAgYXN5bmMgZ2V0TWVzc2FnZShzZXJpYWxPck1lc3NhZ2UpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0Q2hhbm5lbC5nZXRNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5nZXRNZXNzYWdlKHRoaXMsIHNlcmlhbE9yTWVzc2FnZSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLnVwZGF0ZU1lc3NhZ2UoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnVwZGF0ZURlbGV0ZU1lc3NhZ2UodGhpcywgXCJtZXNzYWdlLnVwZGF0ZVwiLCBtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLmRlbGV0ZU1lc3NhZ2UoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnVwZGF0ZURlbGV0ZU1lc3NhZ2UodGhpcywgXCJtZXNzYWdlLmRlbGV0ZVwiLCBtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgYXBwZW5kTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLmFwcGVuZE1lc3NhZ2UoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnVwZGF0ZURlbGV0ZU1lc3NhZ2UodGhpcywgXCJtZXNzYWdlLmFwcGVuZFwiLCBtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZ2V0TWVzc2FnZVZlcnNpb25zKHNlcmlhbE9yTWVzc2FnZSwgcGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVzdENoYW5uZWwuZ2V0TWVzc2FnZVZlcnNpb25zKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5nZXRNZXNzYWdlVmVyc2lvbnModGhpcywgc2VyaWFsT3JNZXNzYWdlLCBwYXJhbXMpO1xuICB9XG59O1xudmFyIHJlc3RjaGFubmVsX2RlZmF1bHQgPSBSZXN0Q2hhbm5lbDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvc3RhdHMudHNcbnZhciBTdGF0cyA9IGNsYXNzIF9TdGF0cyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgIHRoaXMuZW50cmllcyA9IHZhbHVlcyAmJiB2YWx1ZXMuZW50cmllcyB8fCB2b2lkIDA7XG4gICAgdGhpcy5zY2hlbWEgPSB2YWx1ZXMgJiYgdmFsdWVzLnNjaGVtYSB8fCB2b2lkIDA7XG4gICAgdGhpcy5hcHBJZCA9IHZhbHVlcyAmJiB2YWx1ZXMuYXBwSWQgfHwgdm9pZCAwO1xuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IHZhbHVlcyAmJiB2YWx1ZXMuaW5Qcm9ncmVzcyB8fCB2b2lkIDA7XG4gICAgdGhpcy51bml0ID0gdmFsdWVzICYmIHZhbHVlcy51bml0IHx8IHZvaWQgMDtcbiAgICB0aGlzLmludGVydmFsSWQgPSB2YWx1ZXMgJiYgdmFsdWVzLmludGVydmFsSWQgfHwgdm9pZCAwO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgX1N0YXRzKHZhbHVlcyk7XG4gIH1cbn07XG52YXIgc3RhdHNfZGVmYXVsdCA9IFN0YXRzO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdGNoYW5uZWxtaXhpbi50c1xudmFyIFJlc3RDaGFubmVsTWl4aW4gPSBjbGFzcyB7XG4gIHN0YXRpYyBiYXNlUGF0aChjaGFubmVsKSB7XG4gICAgcmV0dXJuIFwiL2NoYW5uZWxzL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGNoYW5uZWwubmFtZSk7XG4gIH1cbiAgc3RhdGljIGhpc3RvcnkoY2hhbm5lbCwgcGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gY2hhbm5lbC5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gY2hhbm5lbC5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KGNsaWVudCwgdGhpcy5iYXNlUGF0aChjaGFubmVsKSArIFwiL21lc3NhZ2VzXCIsIGhlYWRlcnMsIGVudmVsb3BlLCBhc3luYyBmdW5jdGlvbihib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpIHtcbiAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgIHJldHVybiBfZnJvbUVuY29kZWRBcnJheTIoZGVjb2RlZCwgY2hhbm5lbCk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHN0YXR1cyhjaGFubmVsKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gY2hhbm5lbC5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjaGFubmVsLmNsaWVudC5vcHRpb25zKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KFxuICAgICAgY2hhbm5lbC5jbGllbnQsXG4gICAgICB0aGlzLmJhc2VQYXRoKGNoYW5uZWwpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgZm9ybWF0LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldE1lc3NhZ2UoY2hhbm5lbCwgc2VyaWFsT3JNZXNzYWdlKSB7XG4gICAgY29uc3Qgc2VyaWFsID0gdHlwZW9mIHNlcmlhbE9yTWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHNlcmlhbE9yTWVzc2FnZSA6IHNlcmlhbE9yTWVzc2FnZS5zZXJpYWw7XG4gICAgaWYgKCFzZXJpYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICdUaGlzIG1lc3NhZ2UgbGFja3MgYSBzZXJpYWwuIE1ha2Ugc3VyZSB5b3UgaGF2ZSBlbmFibGVkIFwiTWVzc2FnZSBhbm5vdGF0aW9ucywgdXBkYXRlcywgYW5kIGRlbGV0ZXNcIiBpbiBjaGFubmVsIHNldHRpbmdzIG9uIHlvdXIgZGFzaGJvYXJkLicsXG4gICAgICAgIDQwMDAzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IGNoYW5uZWwuY2xpZW50O1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi87XG4gICAgY29uc3QgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHsgYm9keSwgdW5wYWNrZWQgfSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChjaGFubmVsKSArIFwiL21lc3NhZ2VzL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNlcmlhbCksXG4gICAgICBoZWFkZXJzLFxuICAgICAge30sXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3QgZGVjb2RlZCA9IHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIHJldHVybiBfZnJvbUVuY29kZWQyKGRlY29kZWQsIGNoYW5uZWwpO1xuICB9XG4gIHN0YXRpYyBhc3luYyB1cGRhdGVEZWxldGVNZXNzYWdlKGNoYW5uZWwsIGFjdGlvbiwgbWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpIHtcbiAgICBpZiAoIW1lc3NhZ2Uuc2VyaWFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAnVGhpcyBtZXNzYWdlIGxhY2tzIGEgc2VyaWFsIGFuZCBjYW5ub3QgYmUgdXBkYXRlZC4gTWFrZSBzdXJlIHlvdSBoYXZlIGVuYWJsZWQgXCJNZXNzYWdlIGFubm90YXRpb25zLCB1cGRhdGVzLCBhbmQgZGVsZXRlc1wiIGluIGNoYW5uZWwgc2V0dGluZ3Mgb24geW91ciBkYXNoYm9hcmQuJyxcbiAgICAgICAgNDAwMDMsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gY2hhbm5lbC5jbGllbnQ7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlcXVlc3RNZXNzYWdlID0gbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMobWVzc2FnZSk7XG4gICAgcmVxdWVzdE1lc3NhZ2UuYWN0aW9uID0gYWN0aW9uO1xuICAgIHJlcXVlc3RNZXNzYWdlLnZlcnNpb24gPSBvcGVyYXRpb247XG4gICAgY29uc3QgZW5jb2RlZCA9IGF3YWl0IHJlcXVlc3RNZXNzYWdlLmVuY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zKTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHNlcmlhbGl6ZShlbmNvZGVkLCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlc291cmNlX2RlZmF1bHQucGF0Y2g7XG4gICAgY29uc3QgeyBib2R5LCB1bnBhY2tlZCB9ID0gYXdhaXQgbWV0aG9kKFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChjaGFubmVsKSArIFwiL21lc3NhZ2VzL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KG1lc3NhZ2Uuc2VyaWFsKSxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyB8fCB7fSxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgcmV0dXJuIGRlY29kZWQgfHwgeyB2ZXJzaW9uU2VyaWFsOiBudWxsIH07XG4gIH1cbiAgc3RhdGljIGdldE1lc3NhZ2VWZXJzaW9ucyhjaGFubmVsLCBzZXJpYWxPck1lc3NhZ2UsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlcmlhbCA9IHR5cGVvZiBzZXJpYWxPck1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBzZXJpYWxPck1lc3NhZ2UgOiBzZXJpYWxPck1lc3NhZ2Uuc2VyaWFsO1xuICAgIGlmICghc2VyaWFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAnVGhpcyBtZXNzYWdlIGxhY2tzIGEgc2VyaWFsLiBNYWtlIHN1cmUgeW91IGhhdmUgZW5hYmxlZCBcIk1lc3NhZ2UgYW5ub3RhdGlvbnMsIHVwZGF0ZXMsIGFuZCBkZWxldGVzXCIgaW4gY2hhbm5lbCBzZXR0aW5ncyBvbiB5b3VyIGRhc2hib2FyZC4nLFxuICAgICAgICA0MDAwMyxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBjaGFubmVsLmNsaWVudDtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovO1xuICAgIGNvbnN0IGVudmVsb3BlID0gY2hhbm5lbC5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLmJhc2VQYXRoKGNoYW5uZWwpICsgXCIvbWVzc2FnZXMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoc2VyaWFsKSArIFwiL3ZlcnNpb25zXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgZW52ZWxvcGUsXG4gICAgICBhc3luYyAoYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZEFycmF5MihkZWNvZGVkLCBjaGFubmVsKTtcbiAgICAgIH1cbiAgICApLmdldChwYXJhbXMgfHwge30pO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdHByZXNlbmNlbWl4aW4udHNcbnZhciBSZXN0UHJlc2VuY2VNaXhpbiA9IGNsYXNzIHtcbiAgc3RhdGljIGJhc2VQYXRoKHByZXNlbmNlKSB7XG4gICAgcmV0dXJuIFJlc3RDaGFubmVsTWl4aW4uYmFzZVBhdGgocHJlc2VuY2UuY2hhbm5lbCkgKyBcIi9wcmVzZW5jZVwiO1xuICB9XG4gIHN0YXRpYyBhc3luYyBoaXN0b3J5KHByZXNlbmNlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLmJhc2VQYXRoKHByZXNlbmNlKSArIFwiL2hpc3RvcnlcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnZlbG9wZSxcbiAgICAgIGFzeW5jIChib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpID0+IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgICAgICByZXR1cm4gX2Zyb21FbmNvZGVkQXJyYXkoZGVjb2RlZCwgcHJlc2VuY2UuY2hhbm5lbCk7XG4gICAgICB9XG4gICAgKS5nZXQocGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3QudHNcbnZhciBSZXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNoYW5uZWxNaXhpbiA9IFJlc3RDaGFubmVsTWl4aW47XG4gICAgdGhpcy5wcmVzZW5jZU1peGluID0gUmVzdFByZXNlbmNlTWl4aW47XG4gICAgLy8gZXhwb3NlZCBmb3IgcGx1Z2lucyBidXQgc2hvdWxkbid0IGJlIGJ1bmRsZWQgd2l0aCBtaW5pbWFsIHJlYWx0aW1lXG4gICAgdGhpcy5SZXNvdXJjZSA9IHJlc291cmNlX2RlZmF1bHQ7XG4gICAgdGhpcy5QYWdpbmF0ZWRSZXNvdXJjZSA9IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQ7XG4gICAgdGhpcy5EZXZpY2VEZXRhaWxzID0gZGV2aWNlZGV0YWlsc19kZWZhdWx0O1xuICAgIHRoaXMuUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0O1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcy5jbGllbnQpO1xuICAgIHRoaXMucHVzaCA9IG5ldyBwdXNoX2RlZmF1bHQodGhpcy5jbGllbnQpO1xuICB9XG4gIGFzeW5jIHN0YXRzKHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpLCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KHRoaXMuY2xpZW50LCBcIi9zdGF0c1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgKGJvZHksIF8sIHVucGFja2VkKSA9PiB7XG4gICAgICBjb25zdCBzdGF0c1ZhbHVlcyA9IHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRzVmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdGF0c1ZhbHVlc1tpXSA9IHN0YXRzX2RlZmF1bHQuZnJvbVZhbHVlcyhzdGF0c1ZhbHVlc1tpXSk7XG4gICAgICByZXR1cm4gc3RhdHNWYWx1ZXM7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgdGltZShwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdDogXCJqc29uXCIgLyoganNvbiAqLyB9KTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCB0aW1lVXJpID0gKGhvc3QpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5iYXNlVXJpKGhvc3QpICsgXCIvdGltZVwiO1xuICAgIH07XG4gICAgbGV0IHsgZXJyb3IsIGJvZHksIHVucGFja2VkIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5odHRwLmRvKFxuICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsXG4gICAgICB0aW1lVXJpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG51bGwsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICghdW5wYWNrZWQpXG4gICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICBjb25zdCB0aW1lID0gYm9keVswXTtcbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJJbnRlcm5hbCBlcnJvciAodW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIEdFVCAvdGltZSlcIiwgNWU0LCA1MDApO1xuICAgIH1cbiAgICB0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0ID0gdGltZSAtIERhdGUubm93KCk7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChtZXRob2QsIHBhdGgsIHZlcnNpb24yLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IFtlbmNvZGVyLCBkZWNvZGVyLCBmb3JtYXRdID0gKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQuX01zZ1BhY2spIHtcbiAgICAgICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLmNsaWVudC5fTXNnUGFjay5lbmNvZGUsIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLmRlY29kZSwgXCJtc2dwYWNrXCIgLyogbXNncGFjayAqL107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW0pTT04uc3RyaW5naWZ5LCBKU09OLnBhcnNlLCBcImpzb25cIiAvKiBqc29uICovXTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIGNvbnN0IGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb25zdCBfbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IF9tZXRob2QgPT0gXCJnZXRcIiA/IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQsIHByb3RvY29sVmVyc2lvbjogdmVyc2lvbjIgfSkgOiBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCwgcHJvdG9jb2xWZXJzaW9uOiB2ZXJzaW9uMiB9KTtcbiAgICBpZiAodHlwZW9mIGJvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJvZHkgPSAoX2EyID0gZW5jb2Rlcihib2R5KSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgfVxuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGN1c3RvbUhlYWRlcnMpIHtcbiAgICAgIG1peGluKGhlYWRlcnMsIGN1c3RvbUhlYWRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgdGhpcy5jbGllbnQsXG4gICAgICBwYXRoLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgZnVuY3Rpb24ocmVzYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVBcnJheSh1bnBhY2tlZCA/IHJlc2JvZHkgOiBkZWNvZGVyKHJlc2JvZHkpKTtcbiAgICAgIH0sXG4gICAgICAvKiB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2U6ICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAoIVBsYXRmb3JtLkh0dHAubWV0aG9kcy5pbmNsdWRlcyhfbWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuc3VwcG9ydGVkIG1ldGhvZCBcIiArIF9tZXRob2QsIDQwNTAwLCA0MDUpO1xuICAgIH1cbiAgICBpZiAoUGxhdGZvcm0uSHR0cC5tZXRob2RzV2l0aEJvZHkuaW5jbHVkZXMoX21ldGhvZCkpIHtcbiAgICAgIHJldHVybiBwYWdpbmF0ZWRSZXNvdXJjZVtfbWV0aG9kXShwYXJhbXMsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKSB7XG4gICAgbGV0IHJlcXVlc3RCb2R5RFRPO1xuICAgIGxldCBzaW5nbGVTcGVjTW9kZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjT3JTcGVjcykpIHtcbiAgICAgIHJlcXVlc3RCb2R5RFRPID0gc3BlY09yU3BlY3M7XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0Qm9keURUTyA9IFtzcGVjT3JTcGVjc107XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpO1xuICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QodGhpcy5jbGllbnQsIFwiL21lc3NhZ2VzXCIsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB7fSwgbnVsbCwgdHJ1ZSk7XG4gICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBpZiAoc2luZ2xlU3BlY01vZGUpIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHM7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpO1xuICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IGNoYW5uZWxzUGFyYW0gPSBjaGFubmVscy5qb2luKFwiLFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KHRoaXMuY2xpZW50LCBcIi9wcmVzZW5jZVwiLCBoZWFkZXJzLCB7IGNoYW5uZWxzOiBjaGFubmVsc1BhcmFtIH0sIG51bGwsIHRydWUpO1xuICAgIHJldHVybiByZXNwb25zZS51bnBhY2tlZCA/IHJlc3BvbnNlLmJvZHkgOiBkZWNvZGVCb2R5KHJlc3BvbnNlLmJvZHksIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICB9XG4gIGFzeW5jIHJldm9rZVRva2VucyhzcGVjaWZpZXJzLCBvcHRpb25zKSB7XG4gICAgaWYgKHVzZVRva2VuQXV0aCh0aGlzLmNsaWVudC5vcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIkNhbm5vdCByZXZva2UgdG9rZW5zIHdoZW4gdXNpbmcgdG9rZW4gYXV0aFwiLCA0MDE2MiwgNDAxKTtcbiAgICB9XG4gICAgY29uc3Qga2V5TmFtZSA9IHRoaXMuY2xpZW50Lm9wdGlvbnMua2V5TmFtZTtcbiAgICBsZXQgcmVzb2x2ZWRPcHRpb25zID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5RFRPID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgdGFyZ2V0czogc3BlY2lmaWVycy5tYXAoKHNwZWNpZmllcikgPT4gYCR7c3BlY2lmaWVyLnR5cGV9OiR7c3BlY2lmaWVyLnZhbHVlfWApXG4gICAgfSwgcmVzb2x2ZWRPcHRpb25zKTtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkocmVxdWVzdEJvZHlEVE8sIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KFxuICAgICAgdGhpcy5jbGllbnQsXG4gICAgICBgL2tleXMvJHtrZXlOYW1lfS9yZXZva2VUb2tlbnNgLFxuICAgICAgcmVxdWVzdEJvZHksXG4gICAgICBoZWFkZXJzLFxuICAgICAge30sXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnVucGFja2VkID8gcmVzcG9uc2UuYm9keSA6IGRlY29kZUJvZHkocmVzcG9uc2UuYm9keSwgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gIH1cbn07XG52YXIgQ2hhbm5lbHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuYWxsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZ2V0KG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICBsZXQgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgdGhpcy5hbGxbbmFtZV0gPSBjaGFubmVsID0gbmV3IHJlc3RjaGFubmVsX2RlZmF1bHQodGhpcy5jbGllbnQsIG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICBjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbm5lbDtcbiAgfVxuICAvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cbiAgICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cbiAgcmVsZWFzZShuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuYWxsW1N0cmluZyhuYW1lKV07XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9iYXNlcmVzdC50c1xudmFyIEJhc2VSZXN0ID0gY2xhc3MgZXh0ZW5kcyBiYXNlY2xpZW50X2RlZmF1bHQge1xuICAvKlxuICAgKiBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgb25seSBhY2NlcHRzIGFuIG9iamVjdCwgYnV0IHNpbmNlIHdlIHdhbnQgdG8gZW1pdCBhIGdvb2QgZXJyb3IgbWVzc2FnZSBpbiB0aGUgY2FzZSB3aGVyZSBhIG5vbi1UeXBlU2NyaXB0IHVzZXIgZG9lcyBvbmUgb2YgdGhlc2UgdGhpbmdzOlxuICAgKlxuICAgKiAxLiBwYXNzZXMgYSBzdHJpbmcgKHdoaWNoIGlzIHF1aXRlIGxpa2VseSBpZiB0aGV54oCZcmUgZS5nLiBtaWdyYXRpbmcgZnJvbSB0aGUgZGVmYXVsdCB2YXJpYW50IHRvIHRoZSBtb2R1bGFyIHZhcmlhbnQpXG4gICAqIDIuIHBhc3NlcyBubyBhcmd1bWVudCBhdCBhbGxcbiAgICpcbiAgICogdGVsbCB0aGUgY29tcGlsZXIgdGhhdCB0aGVzZSBjYXNlcyBhcmUgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIHRoZW0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIGZhbHNlLCBcIkJhc2VSZXN0XCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIHsgUmVzdCB9KSk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9tb2R1bGFycGx1Z2lucy50c1xudmFyIGFsbENvbW1vbk1vZHVsYXJQbHVnaW5zID0geyBSZXN0IH07XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2RlZmF1bHRtZXNzYWdlLnRzXG52YXIgRGVmYXVsdE1lc3NhZ2UgPSBjbGFzcyBleHRlbmRzIG1lc3NhZ2VfZGVmYXVsdCB7XG4gIHN0YXRpYyBhc3luYyBmcm9tRW5jb2RlZChlbmNvZGVkLCBpbnB1dE9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWQyKGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIFBsYXRmb3JtLkNyeXB0bywgZW5jb2RlZCwgaW5wdXRPcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWRBcnJheTIobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgUGxhdGZvcm0uQ3J5cHRvLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyh2YWx1ZXMpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZWZhdWx0cHJlc2VuY2VtZXNzYWdlLnRzXG52YXIgRGVmYXVsdFByZXNlbmNlTWVzc2FnZSA9IGNsYXNzIGV4dGVuZHMgcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQge1xuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWQoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkKGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIFBsYXRmb3JtLkNyeXB0bywgZW5jb2RlZCwgaW5wdXRPcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWRBcnJheShsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWRBcnJheSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXModmFsdWVzKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvYW5ub3RhdGlvbi50c1xudmFyIGFjdGlvbnM0ID0gW1wiYW5ub3RhdGlvbi5jcmVhdGVcIiwgXCJhbm5vdGF0aW9uLmRlbGV0ZVwiXTtcbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkMyhsb2dnZXIsIGVuY29kZWQsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2EgPSBXaXJlQW5ub3RhdGlvbi5mcm9tVmFsdWVzKGVuY29kZWQpO1xuICByZXR1cm4gd2EuZGVjb2RlKG9wdGlvbnMgfHwge30sIGxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZEFycmF5Myhsb2dnZXIsIGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gZnJvbUVuY29kZWQzKGxvZ2dlciwgZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZDMoZW5jb2RlZCwgY2hhbm5lbCkge1xuICByZXR1cm4gV2lyZUFubm90YXRpb24uZnJvbVZhbHVlcyhlbmNvZGVkKS5kZWNvZGUoY2hhbm5lbC5jaGFubmVsT3B0aW9ucywgY2hhbm5lbC5sb2dnZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gX2Zyb21FbmNvZGVkQXJyYXkzKGVuY29kZWRBcnJheSwgY2hhbm5lbCkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkMyhlbmNvZGVkLCBjaGFubmVsKTtcbiAgICB9KVxuICApO1xufVxudmFyIEFubm90YXRpb24gPSBjbGFzcyBfQW5ub3RhdGlvbiBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgYXN5bmMgZW5jb2RlKCkge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFdpcmVBbm5vdGF0aW9uKCksIHRoaXMsIHtcbiAgICAgIGFjdGlvbjogYWN0aW9uczQuaW5kZXhPZih0aGlzLmFjdGlvbiB8fCBcImFubm90YXRpb24uY3JlYXRlXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuIGVuY29kZShyZXMsIHt9KTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX0Fubm90YXRpb24oKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfQW5ub3RhdGlvbi5mcm9tVmFsdWVzKHYpKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiQW5ub3RhdGlvblwiKTtcbiAgfVxufTtcbnZhciBXaXJlQW5ub3RhdGlvbiA9IGNsYXNzIF9XaXJlQW5ub3RhdGlvbiBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgdG9KU09OKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gd2lyZVRvSlNPTi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfV2lyZUFubm90YXRpb24oKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfV2lyZUFubm90YXRpb24uZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgYXN5bmMgZGVjb2RlKGNoYW5uZWxPcHRpb25zLCBsb2dnZXIpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBBbm5vdGF0aW9uKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMpLCB7XG4gICAgICBhY3Rpb246IGFjdGlvbnM0W3RoaXMuYWN0aW9uXVxuICAgIH0pKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZGVjb2RlKHJlcywgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXaXJlQW5ub3RhdGlvbi5kZWNvZGUoKVwiLCBpbnNwZWN0RXJyb3IoZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJNc2codGhpcywgXCJXaXJlQW5ub3RhdGlvblwiKTtcbiAgfVxufTtcbnZhciBhbm5vdGF0aW9uX2RlZmF1bHQgPSBBbm5vdGF0aW9uO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZWZhdWx0YW5ub3RhdGlvbi50c1xudmFyIERlZmF1bHRBbm5vdGF0aW9uID0gY2xhc3MgZXh0ZW5kcyBhbm5vdGF0aW9uX2RlZmF1bHQge1xuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWQoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkMyhsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBlbmNvZGVkLCBpbnB1dE9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tRW5jb2RlZEFycmF5KGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZEFycmF5Myhsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBhbm5vdGF0aW9uX2RlZmF1bHQuZnJvbVZhbHVlcyh2YWx1ZXMpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdGFubm90YXRpb25zLnRzXG5mdW5jdGlvbiBzZXJpYWxGcm9tTXNnT3JTZXJpYWwobXNnT3JTZXJpYWwpIHtcbiAgbGV0IG1lc3NhZ2VTZXJpYWw7XG4gIHN3aXRjaCAodHlwZW9mIG1zZ09yU2VyaWFsKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgbWVzc2FnZVNlcmlhbCA9IG1zZ09yU2VyaWFsO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgbWVzc2FnZVNlcmlhbCA9IG1zZ09yU2VyaWFsLnNlcmlhbDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICghbWVzc2FnZVNlcmlhbCB8fCB0eXBlb2YgbWVzc2FnZVNlcmlhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIkZpcnN0IGFyZ3VtZW50IG9mIGFubm90YXRpb25zLnB1Ymxpc2goKSBtdXN0IGJlIGVpdGhlciBhIE1lc3NhZ2UgKG9yIGF0IGxlYXN0IGFuIG9iamVjdCB3aXRoIGEgc3RyaW5nIGBzZXJpYWxgIHByb3BlcnR5KSBvciBhIG1lc3NhZ2Ugc2VyaWFsIChzdHJpbmcpXCIsXG4gICAgICA0MDAwMyxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VTZXJpYWw7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RWYWxpZGF0ZUFubm90YXRpb24obXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgY29uc3QgbWVzc2FnZVNlcmlhbCA9IHNlcmlhbEZyb21Nc2dPclNlcmlhbChtc2dPclNlcmlhbCk7XG4gIGlmICghYW5ub3RhdGlvblZhbHVlcyB8fCB0eXBlb2YgYW5ub3RhdGlvblZhbHVlcyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIlNlY29uZCBhcmd1bWVudCBvZiBhbm5vdGF0aW9ucy5wdWJsaXNoKCkgbXVzdCBiZSBhbiBvYmplY3QgKHRoZSBpbnRlbmRlZCBhbm5vdGF0aW9uIHRvIHB1Ymxpc2gpXCIsXG4gICAgICA0MDAwMyxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgY29uc3QgYW5ub3RhdGlvbiA9IGFubm90YXRpb25fZGVmYXVsdC5mcm9tVmFsdWVzKGFubm90YXRpb25WYWx1ZXMpO1xuICBhbm5vdGF0aW9uLm1lc3NhZ2VTZXJpYWwgPSBtZXNzYWdlU2VyaWFsO1xuICBpZiAoIWFubm90YXRpb24uYWN0aW9uKSB7XG4gICAgYW5ub3RhdGlvbi5hY3Rpb24gPSBcImFubm90YXRpb24uY3JlYXRlXCI7XG4gIH1cbiAgcmV0dXJuIGFubm90YXRpb247XG59XG5mdW5jdGlvbiBiYXNlUGF0aEZvclNlcmlhbChjaGFubmVsLCBzZXJpYWwpIHtcbiAgcmV0dXJuIGNoYW5uZWwuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmJhc2VQYXRoKGNoYW5uZWwpICsgXCIvbWVzc2FnZXMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoc2VyaWFsKSArIFwiL2Fubm90YXRpb25zXCI7XG59XG52YXIgUmVzdEFubm90YXRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgfVxuICBhc3luYyBwdWJsaXNoKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKSB7XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IGNvbnN0cnVjdFZhbGlkYXRlQW5ub3RhdGlvbihtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcyk7XG4gICAgY29uc3Qgd2lyZUFubm90YXRpb24gPSBhd2FpdCBhbm5vdGF0aW9uLmVuY29kZSgpO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2hhbm5lbC5jbGllbnQsIG9wdGlvbnMgPSBjbGllbnQub3B0aW9ucywgZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpLCBwYXJhbXMgPSB7fTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoW3dpcmVBbm5vdGF0aW9uXSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIGNsaWVudCxcbiAgICAgIGJhc2VQYXRoRm9yU2VyaWFsKHRoaXMuY2hhbm5lbCwgYW5ub3RhdGlvbi5tZXNzYWdlU2VyaWFsKSxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuICBhc3luYyBkZWxldGUobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgICBhbm5vdGF0aW9uVmFsdWVzLmFjdGlvbiA9IFwiYW5ub3RhdGlvbi5kZWxldGVcIjtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKTtcbiAgfVxuICBhc3luYyBnZXQobXNnT3JTZXJpYWwsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2hhbm5lbC5jbGllbnQsIG1lc3NhZ2VTZXJpYWwgPSBzZXJpYWxGcm9tTXNnT3JTZXJpYWwobXNnT3JTZXJpYWwpLCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IGNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICBiYXNlUGF0aEZvclNlcmlhbCh0aGlzLmNoYW5uZWwsIG1lc3NhZ2VTZXJpYWwpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgKGJvZHksIF8sIHVucGFja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZEFycmF5MyhkZWNvZGVkLCB0aGlzLmNoYW5uZWwpO1xuICAgICAgfVxuICAgICkuZ2V0KHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcmVzdGFubm90YXRpb25zX2RlZmF1bHQgPSBSZXN0QW5ub3RhdGlvbnM7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3Byb3RvY29sbWVzc2FnZS50c1xudmFyIHNlcmlhbGl6ZTIgPSBlbmNvZGVCb2R5O1xuZnVuY3Rpb24gdG9TdHJpbmdBcnJheShhcnJheSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0udG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlsgXCIgKyByZXN1bHQuam9pbihcIiwgXCIpICsgXCIgXVwiO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCwgTXNnUGFjaywgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBhbm5vdGF0aW9uc1BsdWdpbiwgb2JqZWN0c1BsdWdpbiwgZm9ybWF0KSB7XG4gIGNvbnN0IGRlc2VyaWFsaXplZCA9IGRlY29kZUJvZHkoc2VyaWFsaXplZCwgTXNnUGFjaywgZm9ybWF0KTtcbiAgcmV0dXJuIGZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4sIGFubm90YXRpb25zUGx1Z2luLCBvYmplY3RzUGx1Z2luKTtcbn1cbmZ1bmN0aW9uIGZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4sIGFubm90YXRpb25zUGx1Z2luLCBvYmplY3RzUGx1Z2luKSB7XG4gIGxldCBlcnJvcjtcbiAgaWYgKGRlc2VyaWFsaXplZC5lcnJvcikge1xuICAgIGVycm9yID0gRXJyb3JJbmZvLmZyb21WYWx1ZXMoZGVzZXJpYWxpemVkLmVycm9yKTtcbiAgfVxuICBsZXQgbWVzc2FnZXM7XG4gIGlmIChkZXNlcmlhbGl6ZWQubWVzc2FnZXMpIHtcbiAgICBtZXNzYWdlcyA9IFdpcmVNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShkZXNlcmlhbGl6ZWQubWVzc2FnZXMpO1xuICB9XG4gIGxldCBwcmVzZW5jZTtcbiAgaWYgKHByZXNlbmNlTWVzc2FnZVBsdWdpbiAmJiBkZXNlcmlhbGl6ZWQucHJlc2VuY2UpIHtcbiAgICBwcmVzZW5jZSA9IHByZXNlbmNlTWVzc2FnZVBsdWdpbi5XaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShcbiAgICAgIGRlc2VyaWFsaXplZC5wcmVzZW5jZVxuICAgICk7XG4gIH1cbiAgbGV0IGFubm90YXRpb25zO1xuICBpZiAoYW5ub3RhdGlvbnNQbHVnaW4gJiYgZGVzZXJpYWxpemVkLmFubm90YXRpb25zKSB7XG4gICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9uc1BsdWdpbi5XaXJlQW5ub3RhdGlvbi5mcm9tVmFsdWVzQXJyYXkoXG4gICAgICBkZXNlcmlhbGl6ZWQuYW5ub3RhdGlvbnNcbiAgICApO1xuICB9XG4gIGxldCBzdGF0ZTtcbiAgaWYgKG9iamVjdHNQbHVnaW4gJiYgZGVzZXJpYWxpemVkLnN0YXRlKSB7XG4gICAgc3RhdGUgPSBvYmplY3RzUGx1Z2luLldpcmVPYmplY3RNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShcbiAgICAgIGRlc2VyaWFsaXplZC5zdGF0ZSxcbiAgICAgIHV0aWxzX2V4cG9ydHMsXG4gICAgICBNZXNzYWdlRW5jb2RpbmdcbiAgICApO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQcm90b2NvbE1lc3NhZ2UoKSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVzZXJpYWxpemVkKSwgeyBwcmVzZW5jZSwgbWVzc2FnZXMsIGFubm90YXRpb25zLCBzdGF0ZSwgZXJyb3IgfSkpO1xufVxuZnVuY3Rpb24gbWFrZUZyb21EZXNlcmlhbGl6ZWRXaXRoRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcykge1xuICByZXR1cm4gKGRlc2VyaWFsaXplZCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIGZyb21EZXNlcmlhbGl6ZWQoXG4gICAgICBkZXNlcmlhbGl6ZWQsXG4gICAgICB7XG4gICAgICAgIFByZXNlbmNlTWVzc2FnZTogcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQsXG4gICAgICAgIFdpcmVQcmVzZW5jZU1lc3NhZ2VcbiAgICAgIH0sXG4gICAgICB7IEFubm90YXRpb246IGFubm90YXRpb25fZGVmYXVsdCwgV2lyZUFubm90YXRpb24sIFJlYWx0aW1lQW5ub3RhdGlvbnM6IHJlYWx0aW1lYW5ub3RhdGlvbnNfZGVmYXVsdCwgUmVzdEFubm90YXRpb25zOiByZXN0YW5ub3RhdGlvbnNfZGVmYXVsdCB9LFxuICAgICAgKF9hMiA9IGRlcGVuZGVuY2llcyA9PSBudWxsID8gdm9pZCAwIDogZGVwZW5kZW5jaWVzLkxpdmVPYmplY3RzUGx1Z2luKSAhPSBudWxsID8gX2EyIDogbnVsbFxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tVmFsdWVzKHZhbHVlcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkobXNnLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4sIGFubm90YXRpb25zUGx1Z2luLCBvYmplY3RzUGx1Z2luKSB7XG4gIGxldCByZXN1bHQgPSBcIltQcm90b2NvbE1lc3NhZ2VcIjtcbiAgaWYgKG1zZy5hY3Rpb24gIT09IHZvaWQgMClcbiAgICByZXN1bHQgKz0gXCI7IGFjdGlvbj1cIiArIEFjdGlvbk5hbWVbbXNnLmFjdGlvbl0gfHwgbXNnLmFjdGlvbjtcbiAgY29uc3Qgc2ltcGxlQXR0cmlidXRlcyA9IFtcImlkXCIsIFwiY2hhbm5lbFwiLCBcImNoYW5uZWxTZXJpYWxcIiwgXCJjb25uZWN0aW9uSWRcIiwgXCJjb3VudFwiLCBcIm1zZ1NlcmlhbFwiLCBcInRpbWVzdGFtcFwiXTtcbiAgbGV0IGF0dHJpYnV0ZTtcbiAgZm9yIChsZXQgYXR0cmliSW5kZXggPSAwOyBhdHRyaWJJbmRleCA8IHNpbXBsZUF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyaWJJbmRleCsrKSB7XG4gICAgYXR0cmlidXRlID0gc2ltcGxlQXR0cmlidXRlc1thdHRyaWJJbmRleF07XG4gICAgaWYgKG1zZ1thdHRyaWJ1dGVdICE9PSB2b2lkIDApXG4gICAgICByZXN1bHQgKz0gXCI7IFwiICsgYXR0cmlidXRlICsgXCI9XCIgKyBtc2dbYXR0cmlidXRlXTtcbiAgfVxuICBpZiAobXNnLm1lc3NhZ2VzKVxuICAgIHJlc3VsdCArPSBcIjsgbWVzc2FnZXM9XCIgKyB0b1N0cmluZ0FycmF5KFdpcmVNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShtc2cubWVzc2FnZXMpKTtcbiAgaWYgKG1zZy5wcmVzZW5jZSAmJiBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4pXG4gICAgcmVzdWx0ICs9IFwiOyBwcmVzZW5jZT1cIiArIHRvU3RyaW5nQXJyYXkocHJlc2VuY2VNZXNzYWdlUGx1Z2luLldpcmVQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KG1zZy5wcmVzZW5jZSkpO1xuICBpZiAobXNnLmFubm90YXRpb25zICYmIGFubm90YXRpb25zUGx1Z2luKSB7XG4gICAgcmVzdWx0ICs9IFwiOyBhbm5vdGF0aW9ucz1cIiArIHRvU3RyaW5nQXJyYXkoYW5ub3RhdGlvbnNQbHVnaW4uV2lyZUFubm90YXRpb24uZnJvbVZhbHVlc0FycmF5KG1zZy5hbm5vdGF0aW9ucykpO1xuICB9XG4gIGlmIChtc2cuc3RhdGUgJiYgb2JqZWN0c1BsdWdpbikge1xuICAgIHJlc3VsdCArPSBcIjsgc3RhdGU9XCIgKyB0b1N0cmluZ0FycmF5KG9iamVjdHNQbHVnaW4uV2lyZU9iamVjdE1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KG1zZy5zdGF0ZSwgdXRpbHNfZXhwb3J0cywgTWVzc2FnZUVuY29kaW5nKSk7XG4gIH1cbiAgaWYgKG1zZy5lcnJvcilcbiAgICByZXN1bHQgKz0gXCI7IGVycm9yPVwiICsgRXJyb3JJbmZvLmZyb21WYWx1ZXMobXNnLmVycm9yKS50b1N0cmluZygpO1xuICBpZiAobXNnLmF1dGggJiYgbXNnLmF1dGguYWNjZXNzVG9rZW4pXG4gICAgcmVzdWx0ICs9IFwiOyB0b2tlbj1cIiArIG1zZy5hdXRoLmFjY2Vzc1Rva2VuO1xuICBpZiAobXNnLmZsYWdzKVxuICAgIHJlc3VsdCArPSBcIjsgZmxhZ3M9XCIgKyBmbGFnTmFtZXMuZmlsdGVyKG1zZy5oYXNGbGFnKS5qb2luKFwiLFwiKTtcbiAgaWYgKG1zZy5wYXJhbXMpIHtcbiAgICBsZXQgc3RyaW5naWZpZWRQYXJhbXMgPSBcIlwiO1xuICAgIGZvckluT3duTm9uTnVsbFByb3BlcnRpZXMobXNnLnBhcmFtcywgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgaWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyaW5naWZpZWRQYXJhbXMgKz0gXCI7IFwiO1xuICAgICAgfVxuICAgICAgc3RyaW5naWZpZWRQYXJhbXMgKz0gcHJvcCArIFwiPVwiICsgbXNnLnBhcmFtc1twcm9wXTtcbiAgICB9KTtcbiAgICBpZiAoc3RyaW5naWZpZWRQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0ICs9IFwiOyBwYXJhbXM9W1wiICsgc3RyaW5naWZpZWRQYXJhbXMgKyBcIl1cIjtcbiAgICB9XG4gIH1cbiAgcmVzdWx0ICs9IFwiXVwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFByb3RvY29sTWVzc2FnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYXNGbGFnID0gKGZsYWcpID0+IHtcbiAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIGZsYWdzW2ZsYWddKSA+IDA7XG4gICAgfTtcbiAgfVxuICBzZXRGbGFnKGZsYWcpIHtcbiAgICByZXR1cm4gdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBmbGFnc1tmbGFnXTtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyB8fCAwKSAmIGZsYWdzLk1PREVfQUxMO1xuICB9XG4gIGVuY29kZU1vZGVzVG9GbGFncyhtb2Rlcykge1xuICAgIG1vZGVzLmZvckVhY2goKG1vZGUpID0+IHRoaXMuc2V0RmxhZyhtb2RlKSk7XG4gIH1cbiAgZGVjb2RlTW9kZXNGcm9tRmxhZ3MoKSB7XG4gICAgY29uc3QgbW9kZXMgPSBbXTtcbiAgICBjaGFubmVsTW9kZXMuZm9yRWFjaCgobW9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzRmxhZyhtb2RlKSkge1xuICAgICAgICBtb2Rlcy5wdXNoKG1vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2Rlcy5sZW5ndGggPiAwID8gbW9kZXMgOiB2b2lkIDA7XG4gIH1cbn07XG52YXIgcHJvdG9jb2xtZXNzYWdlX2RlZmF1bHQgPSBQcm90b2NvbE1lc3NhZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jaGFubmVsc3RhdGVjaGFuZ2UudHNcbnZhciBDaGFubmVsU3RhdGVDaGFuZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBjdXJyZW50LCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pIHtcbiAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICBpZiAoY3VycmVudCA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICB0aGlzLnJlc3VtZWQgPSByZXN1bWVkO1xuICAgICAgdGhpcy5oYXNCYWNrbG9nID0gaGFzQmFja2xvZztcbiAgICB9XG4gICAgaWYgKHJlYXNvbilcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59O1xudmFyIGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0ID0gQ2hhbm5lbFN0YXRlQ2hhbmdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWVjaGFubmVsLnRzXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBcInBhcmFtc1wiIGluIG9wdGlvbnMgJiYgIWlzT2JqZWN0KG9wdGlvbnMucGFyYW1zKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKFwib3B0aW9ucy5wYXJhbXMgbXVzdCBiZSBhbiBvYmplY3RcIiwgNGU0LCA0MDApO1xuICB9XG4gIGlmIChvcHRpb25zICYmIFwibW9kZXNcIiBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMubW9kZXMpKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcIm9wdGlvbnMubW9kZXMgbXVzdCBiZSBhbiBhcnJheVwiLCA0ZTQsIDQwMCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5tb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudE1vZGUgPSBvcHRpb25zLm1vZGVzW2ldO1xuICAgICAgaWYgKCFjdXJyZW50TW9kZSB8fCB0eXBlb2YgY3VycmVudE1vZGUgIT09IFwic3RyaW5nXCIgfHwgIWNoYW5uZWxNb2Rlcy5pbmNsdWRlcyhTdHJpbmcucHJvdG90eXBlLnRvVXBwZXJDYXNlLmNhbGwoY3VycmVudE1vZGUpKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcIkludmFsaWQgY2hhbm5lbCBtb2RlOiBcIiArIGN1cnJlbnRNb2RlLCA0ZTQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgUmVhbHRpbWVDaGFubmVsID0gY2xhc3MgX1JlYWx0aW1lQ2hhbm5lbCBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgIHN1cGVyKGNsaWVudC5sb2dnZXIpO1xuICAgIHRoaXMuX2Fubm90YXRpb25zID0gbnVsbDtcbiAgICB0aGlzLl9tb2RlID0gMDtcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMuaGlzdG9yeSA9IGFzeW5jIGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgICBjb25zdCByZXN0TWl4aW4gPSB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbjtcbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkXCIsIDRlNCwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgXCJ1bnRpbEF0dGFjaCB3YXMgc3BlY2lmaWVkIGFuZCBjaGFubmVsIGlzIGF0dGFjaGVkLCBidXQgYXR0YWNoU2VyaWFsIGlzIG5vdCBkZWZpbmVkXCIsXG4gICAgICAgICAgICA0ZTQsXG4gICAgICAgICAgICA0MDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG4gICAgICAgIHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdE1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgICB9O1xuICAgIHRoaXMud2hlblN0YXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRlbWl0dGVyX2RlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lQ2hhbm5lbCgpXCIsIFwic3RhcnRlZDsgbmFtZSA9IFwiICsgbmFtZSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IGNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuX3ByZXNlbmNlID0gY2xpZW50Ll9SZWFsdGltZVByZXNlbmNlID8gbmV3IGNsaWVudC5fUmVhbHRpbWVQcmVzZW5jZS5SZWFsdGltZVByZXNlbmNlKHRoaXMpIDogbnVsbDtcbiAgICBpZiAoY2xpZW50Ll9Bbm5vdGF0aW9ucykge1xuICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBuZXcgY2xpZW50Ll9Bbm5vdGF0aW9ucy5SZWFsdGltZUFubm90YXRpb25zKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5zdGF0ZSA9IFwiaW5pdGlhbGl6ZWRcIjtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgYXR0YWNoU2VyaWFsOiB2b2lkIDAsXG4gICAgICBjaGFubmVsU2VyaWFsOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWNvZGluZ0NvbnRleHQgPSB7XG4gICAgICBjaGFubmVsT3B0aW9uczogdGhpcy5jaGFubmVsT3B0aW9ucyxcbiAgICAgIHBsdWdpbnM6IGNsaWVudC5vcHRpb25zLnBsdWdpbnMgfHwge30sXG4gICAgICBiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLl9sYXN0UGF5bG9hZCA9IHtcbiAgICAgIG1lc3NhZ2VJZDogbnVsbCxcbiAgICAgIHByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw6IG51bGwsXG4gICAgICBkZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcyA9IG5ldyBldmVudGVtaXR0ZXJfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gICAgaWYgKChfYiA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5QdXNoKSB7XG4gICAgICB0aGlzLl9wdXNoID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5QdXNoQ2hhbm5lbCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKChfYyA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5MaXZlT2JqZWN0cykge1xuICAgICAgdGhpcy5fb2JqZWN0ID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuTGl2ZU9iamVjdHMuUmVhbHRpbWVPYmplY3QodGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBwcmVzZW5jZSgpIHtcbiAgICBpZiAoIXRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlJlYWx0aW1lUHJlc2VuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmVzZW5jZTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLl9hbm5vdGF0aW9ucykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJBbm5vdGF0aW9uc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Fubm90YXRpb25zO1xuICB9XG4gIGdldCBwdXNoKCkge1xuICAgIGlmICghdGhpcy5fcHVzaCkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVzaDtcbiAgfVxuICAvKiogQHNwZWMgUlRMMjcgKi9cbiAgZ2V0IG9iamVjdCgpIHtcbiAgICBpZiAoIXRoaXMuX29iamVjdCkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJMaXZlT2JqZWN0c1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdDtcbiAgfVxuICBpbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2hhbm5lbCBvcGVyYXRpb24gZmFpbGVkIGFzIGNoYW5uZWwgc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlLFxuICAgICAgOTAwMDEsXG4gICAgICA0MDAsXG4gICAgICB0aGlzLmVycm9yUmVhc29uIHx8IHZvaWQgMFxuICAgICk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncykge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuICBhc3luYyBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgIGNvbnN0IGVyciA9IHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IHRoaXMuY2xpZW50Ll9DcnlwdG8pICE9IG51bGwgPyBfYTIgOiBudWxsLCB0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuX2RlY29kaW5nQ29udGV4dClcbiAgICAgIHRoaXMuX2RlY29kaW5nQ29udGV4dC5jaGFubmVsT3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgaWYgKHRoaXMuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMsIHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMpKSB7XG4gICAgICB0aGlzLmF0dGFjaEltcGwoKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLm9uY2UoXG4gICAgICAgICAgW1wiYXR0YWNoZWRcIiwgXCJ1cGRhdGVcIiwgXCJkZXRhY2hlZFwiLCBcImZhaWxlZFwiXSxcbiAgICAgICAgICBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdChzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMob3B0aW9ucywgcHJldk9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ZWRQYXJhbXMgPSBvbWl0QWdlbnQob3B0aW9ucy5wYXJhbXMpO1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbXMgPSBvbWl0QWdlbnQocHJldk9wdGlvbnMucGFyYW1zKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQYXJhbXMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoZXhpc3RpbmdQYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2hhbGxvd0VxdWFscyhleGlzdGluZ1BhcmFtcywgcmVxdWVzdGVkUGFyYW1zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZXMpIHtcbiAgICAgIGlmICghcHJldk9wdGlvbnMubW9kZXMgfHwgIWFyckVxdWFscyhvcHRpb25zLm1vZGVzLCBwcmV2T3B0aW9ucy5tb2RlcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF0sIHNlY29uZCA9IGFyZ3NbMV07XG4gICAgbGV0IG1lc3NhZ2VzO1xuICAgIGxldCBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiB8fCBmaXJzdCA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXNzYWdlcyA9IFttZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyh7IG5hbWU6IGZpcnN0LCBkYXRhOiBzZWNvbmQgfSldO1xuICAgICAgcGFyYW1zID0gYXJnc1syXTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpcnN0KSkge1xuICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoZmlyc3QpXTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpcnN0KSkge1xuICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlc0FycmF5KGZpcnN0KTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzXCIsXG4gICAgICAgIDQwMDEzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG1heE1lc3NhZ2VTaXplID0gdGhpcy5jbGllbnQub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICBjb25zdCB3aXJlTWVzc2FnZXMgPSBhd2FpdCBlbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucyk7XG4gICAgY29uc3Qgc2l6ZSA9IGdldE1lc3NhZ2VzU2l6ZSh3aXJlTWVzc2FnZXMpO1xuICAgIGlmIChzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGBNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKHdhcyAke3NpemV9IGJ5dGVzOyBsaW1pdCBpcyAke21heE1lc3NhZ2VTaXplfSBieXRlcylgLFxuICAgICAgICA0MDAwOSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnRocm93SWZVbnB1Ymxpc2hhYmxlU3RhdGUoKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKVwiLFxuICAgICAgXCJzZW5kaW5nIG1lc3NhZ2U7IGNoYW5uZWwgc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlICsgXCIsIG1lc3NhZ2UgY291bnQgPSBcIiArIHdpcmVNZXNzYWdlcy5sZW5ndGhcbiAgICApO1xuICAgIGNvbnN0IHBtID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuTUVTU0FHRSxcbiAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2VzOiB3aXJlTWVzc2FnZXMsXG4gICAgICBwYXJhbXM6IHBhcmFtcyA/IHN0cmluZ2lmeVZhbHVlcyhwYXJhbXMpIDogdm9pZCAwXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShwbSk7XG4gICAgcmV0dXJuIHJlcyB8fCB7IHNlcmlhbHM6IFtdIH07XG4gIH1cbiAgdGhyb3dJZlVucHVibGlzaGFibGVTdGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmYWlsZWRcIiB8fCB0aGlzLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICB0aHJvdyB0aGlzLmludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgfVxuICB9XG4gIG9uRXZlbnQobWVzc2FnZXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwub25FdmVudCgpXCIsIFwicmVjZWl2ZWQgbWVzc2FnZVwiKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tpXTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuZW1pdChtZXNzYWdlLm5hbWUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9hdHRhY2goZmFsc2UsIG51bGwsIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG4gIF9hdHRhY2goZm9yY2VSZWF0dGFjaCwgYXR0YWNoUmVhc29uLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5fYXR0YWNoKClcIixcbiAgICAgICAgICAgIFwiQ2hhbm5lbCBhdHRhY2ggZmFpbGVkOiBcIiArIGVyci50b1N0cmluZygpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgY2FsbGJhY2soY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImF0dGFjaGluZ1wiIHx8IGZvcmNlUmVhdHRhY2gpIHtcbiAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIsIGF0dGFjaFJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMub25jZShmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhudWxsLCBzdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soXG4gICAgICAgICAgICBzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGF0dGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gXCIgKyB0aGlzLmV2ZW50LCA5ZTQsIDUwMClcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICAgICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKG5ldyBFcnJvckluZm8oXCJBdHRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBkZXRhY2ggcmVxdWVzdFwiLCA5ZTQsIDQwOSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaEltcGwoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmF0dGFjaEltcGwoKVwiLCBcInNlbmRpbmcgQVRUQUNIIG1lc3NhZ2VcIik7XG4gICAgY29uc3QgYXR0YWNoTXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuQVRUQUNILFxuICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgcGFyYW1zOiB0aGlzLmNoYW5uZWxPcHRpb25zLnBhcmFtcyxcbiAgICAgIC8vIFJUTDRjMTogSW5jbHVkZXMgdGhlIGNoYW5uZWwgc2VyaWFsIHRvIHJlc3VtZSBmcm9tIGEgcHJldmlvdXMgbWVzc2FnZVxuICAgICAgLy8gb3IgYXR0YWNobWVudC5cbiAgICAgIGNoYW5uZWxTZXJpYWw6IHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpIHtcbiAgICAgIGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3MoYWxsVG9VcHBlckNhc2UodGhpcy5jaGFubmVsT3B0aW9ucy5tb2RlcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYXR0YWNoUmVzdW1lKSB7XG4gICAgICBhdHRhY2hNc2cuc2V0RmxhZyhcIkFUVEFDSF9SRVNVTUVcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG4gICAgICBhdHRhY2hNc2cuY2hhbm5lbFNlcmlhbCA9IHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw7XG4gICAgfVxuICAgIHRoaXMuc2VuZE1lc3NhZ2UoYXR0YWNoTXNnKS5jYXRjaChub29wKTtcbiAgfVxuICBhc3luYyBkZXRhY2goKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiZGV0YWNoZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gZGV0YWNoOyBjaGFubmVsIHN0YXRlID0gZmFpbGVkXCIsIDkwMDAxLCA0MDApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImRldGFjaGVkXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZShcImRldGFjaGluZ1wiKTtcbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLm9uY2UoZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGRldGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gXCIgKyB0aGlzLmV2ZW50LCA5ZTQsIDUwMClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJEZXRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBhdHRhY2ggcmVxdWVzdFwiLCA5ZTQsIDQwOSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoSW1wbCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwuZGV0YWNoKClcIiwgXCJzZW5kaW5nIERFVEFDSCBtZXNzYWdlXCIpO1xuICAgIGNvbnN0IG1zZyA9IGZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuREVUQUNILCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgdGhpcy5zZW5kTWVzc2FnZShtc2cpLmNhdGNoKG5vb3ApO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZSguLi5hcmdzKSB7XG4gICAgY29uc3QgW2V2ZW50LCBsaXN0ZW5lcl0gPSBfUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncyk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKHRoaXMuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICAgIGlmIChldmVudCAmJiB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICB0aGlzLmNsaWVudC5fRmlsdGVyZWRTdWJzY3JpcHRpb25zLnN1YnNjcmliZUZpbHRlcih0aGlzLCBldmVudCwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hhbm5lbE9wdGlvbnMuYXR0YWNoT25TdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHVuc3Vic2NyaWJlKC4uLmFyZ3MpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IFtldmVudCwgbGlzdGVuZXJdID0gX1JlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgIWxpc3RlbmVyIHx8ICgoX2EyID0gdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGFzKGxpc3RlbmVyKSkpIHtcbiAgICAgIHRoaXMuY2xpZW50Ll9GaWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcikuZm9yRWFjaCgobCkgPT4gdGhpcy5zdWJzY3JpcHRpb25zLm9mZihsKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBzeW5jKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgdGhyb3cgbmV3IFBhcnRpYWxFcnJvckluZm8oXCJVbmFibGUgdG8gc3luYyB0byBjaGFubmVsOyBub3QgYXR0YWNoZWRcIiwgNGU0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IHN5bmNNZXNzYWdlID0gZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5TWU5DLCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgaWYgKHRoaXMuc3luY0NoYW5uZWxTZXJpYWwpIHtcbiAgICAgIHN5bmNNZXNzYWdlLmNoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsO1xuICAgIH1cbiAgICBjb25uZWN0aW9uTWFuYWdlci5zZW5kKHN5bmNNZXNzYWdlKTtcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZShtc2cpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZW5kKG1zZywgdGhpcy5jbGllbnQub3B0aW9ucy5xdWV1ZU1lc3NhZ2VzLCAoZXJyLCBwdWJsaXNoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocHVibGlzaFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2VuZFByZXNlbmNlKHByZXNlbmNlKSB7XG4gICAgY29uc3QgbXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuUFJFU0VOQ0UsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBwcmVzZW5jZVxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UobXNnKTtcbiAgfVxuICBhc3luYyBzZW5kU3RhdGUob2JqZWN0TWVzc2FnZXMpIHtcbiAgICBjb25zdCBtc2cgPSBmcm9tVmFsdWVzKHtcbiAgICAgIGFjdGlvbjogYWN0aW9ucy5PQkpFQ1QsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBzdGF0ZTogb2JqZWN0TWVzc2FnZXNcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlKG1zZyk7XG4gIH1cbiAgLy8gQWNjZXNzIHRvIHRoaXMgbWV0aG9kIGlzIHN5bmNocm9uaXNlZCBieSBDb25uZWN0aW9uTWFuYWdlciNwcm9jZXNzQ2hhbm5lbE1lc3NhZ2UsIGluIG9yZGVyIHRvIHN5bmNocm9uaXNlIGFjY2VzcyB0byB0aGUgc3RhdGUgc3RvcmVkIGluIF9kZWNvZGluZ0NvbnRleHQuXG4gIGFzeW5jIHByb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuQVRUQUNIRUQgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuTUVTU0FHRSB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5QUkVTRU5DRSB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5PQkpFQ1QgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuQU5OT1RBVElPTikge1xuICAgICAgdGhpcy5zZXRDaGFubmVsU2VyaWFsKG1lc3NhZ2UuY2hhbm5lbFNlcmlhbCk7XG4gICAgfVxuICAgIGxldCBzeW5jQ2hhbm5lbFNlcmlhbCwgaXNTeW5jID0gZmFsc2U7XG4gICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgY2FzZSBhY3Rpb25zLkFUVEFDSEVEOiB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgIHRoaXMuX21vZGUgPSBtZXNzYWdlLmdldE1vZGUoKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBtZXNzYWdlLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgY29uc3QgbW9kZXNGcm9tRmxhZ3MgPSBtZXNzYWdlLmRlY29kZU1vZGVzRnJvbUZsYWdzKCk7XG4gICAgICAgIHRoaXMubW9kZXMgPSBtb2Rlc0Zyb21GbGFncyAmJiBhbGxUb0xvd2VyQ2FzZShtb2Rlc0Zyb21GbGFncykgfHwgdm9pZCAwO1xuICAgICAgICBjb25zdCByZXN1bWVkID0gbWVzc2FnZS5oYXNGbGFnKFwiUkVTVU1FRFwiKTtcbiAgICAgICAgY29uc3QgaGFzUHJlc2VuY2UgPSBtZXNzYWdlLmhhc0ZsYWcoXCJIQVNfUFJFU0VOQ0VcIik7XG4gICAgICAgIGNvbnN0IGhhc0JhY2tsb2cgPSBtZXNzYWdlLmhhc0ZsYWcoXCJIQVNfQkFDS0xPR1wiKTtcbiAgICAgICAgY29uc3QgaGFzT2JqZWN0cyA9IG1lc3NhZ2UuaGFzRmxhZyhcIkhBU19PQkpFQ1RTXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJlc2VuY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJlc2VuY2Uub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX29iamVjdC5vbkF0dGFjaGVkKGhhc09iamVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlX2RlZmF1bHQodGhpcy5zdGF0ZSwgdGhpcy5zdGF0ZSwgcmVzdW1lZCwgaGFzQmFja2xvZywgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMuZW1pdChcInVwZGF0ZVwiLCBjaGFuZ2UpO1xuICAgICAgICAgIGlmICghcmVzdW1lZCB8fCB0aGlzLmNoYW5uZWxPcHRpb25zLnVwZGF0ZU9uQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBjaGFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJhdHRhY2hlZFwiLCBtZXNzYWdlLmVycm9yLCByZXN1bWVkLCBoYXNQcmVzZW5jZSwgaGFzQmFja2xvZywgaGFzT2JqZWN0cyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuREVUQUNIRUQ6IHtcbiAgICAgICAgY29uc3QgZGV0YWNoRXJyID0gbWVzc2FnZS5lcnJvciA/IEVycm9ySW5mby5mcm9tVmFsdWVzKG1lc3NhZ2UuZXJyb3IpIDogbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgZGV0YWNoZWRcIiwgOTAwMDEsIDQwNCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImRldGFjaGVkXCIsIGRldGFjaEVycik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJzdXNwZW5kZWRcIiwgZGV0YWNoRXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIsIGRldGFjaEVycik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgICAgaXNTeW5jID0gdHJ1ZTtcbiAgICAgICAgc3luY0NoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICBpZiAoIW1lc3NhZ2UucHJlc2VuY2UpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuUFJFU0VOQ0U6IHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnByZXNlbmNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGVGaWVsZHNGcm9tUGFyZW50KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICAgICAgY29uc3QgcHJlc2VuY2VNZXNzYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgbWVzc2FnZS5wcmVzZW5jZS5tYXAoKHdwbSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gd3BtLmRlY29kZShvcHRpb25zLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fcHJlc2VuY2Uuc2V0UHJlc2VuY2UocHJlc2VuY2VNZXNzYWdlcywgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuT0JKRUNUOlxuICAgICAgY2FzZSBhY3Rpb25zLk9CSkVDVF9TWU5DOiB7XG4gICAgICAgIGlmICghdGhpcy5fb2JqZWN0IHx8ICFtZXNzYWdlLnN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlRmllbGRzRnJvbVBhcmVudChtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5nZXRBY3RpdmVUcmFuc3BvcnRGb3JtYXQoKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0TWVzc2FnZXMgPSBtZXNzYWdlLnN0YXRlLm1hcCgob20pID0+IG9tLmRlY29kZSh0aGlzLmNsaWVudCwgZm9ybWF0KSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5PQkpFQ1QpIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3QuaGFuZGxlT2JqZWN0TWVzc2FnZXMob2JqZWN0TWVzc2FnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29iamVjdC5oYW5kbGVPYmplY3RTeW5jTWVzc2FnZXMob2JqZWN0TWVzc2FnZXMsIG1lc3NhZ2UuY2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuTUVTU0FHRToge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgICAgICAnTWVzc2FnZSBcIicgKyBtZXNzYWdlLmlkICsgJ1wiIHNraXBwZWQgYXMgdGhpcyBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIiBzdGF0ZSBpcyBub3QgXCJhdHRhY2hlZFwiIChzdGF0ZSBpcyBcIicgKyB0aGlzLnN0YXRlICsgJ1wiKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGVGaWVsZHNGcm9tUGFyZW50KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gbWVzc2FnZS5tZXNzYWdlcywgZmlyc3RNZXNzYWdlID0gZW5jb2RlZFswXSwgbGFzdE1lc3NhZ2UgPSBlbmNvZGVkW2VuY29kZWQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChmaXJzdE1lc3NhZ2UuZXh0cmFzICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEgJiYgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YS5mcm9tICE9PSB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnRGVsdGEgbWVzc2FnZSBkZWNvZGUgZmFpbHVyZSAtIHByZXZpb3VzIG1lc3NhZ2Ugbm90IGF2YWlsYWJsZSBmb3IgbWVzc2FnZSBcIicgKyBtZXNzYWdlLmlkICsgJ1wiIG9uIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIuJztcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJSZWFsdGltZUNoYW5uZWwucHJvY2Vzc01lc3NhZ2UoKVwiLCBtc2cpO1xuICAgICAgICAgIHRoaXMuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KG5ldyBFcnJvckluZm8obXNnLCA0MDAxOCwgNDAwKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHsgZGVjb2RlZCwgZXJyIH0gPSBhd2FpdCBlbmNvZGVkW2ldLmRlY29kZVdpdGhFcnIodGhpcy5fZGVjb2RpbmdDb250ZXh0LCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgbWVzc2FnZXNbaV0gPSBkZWNvZGVkO1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA0MDAxODpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY2FzZSA0MDAxOTpcbiAgICAgICAgICAgICAgY2FzZSA0MDAyMTpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiZmFpbGVkXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQgPSBsYXN0TWVzc2FnZS5pZDtcbiAgICAgICAgdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgdGhpcy5vbkV2ZW50KG1lc3NhZ2VzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuQU5OT1RBVElPTjoge1xuICAgICAgICBwb3B1bGF0ZUZpZWxkc0Zyb21QYXJlbnQobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5fYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgKG1lc3NhZ2UuYW5ub3RhdGlvbnMgfHwgW10pLm1hcCgod3BtKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB3cG0uZGVjb2RlKG9wdGlvbnMsIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl9hbm5vdGF0aW9ucy5fcHJvY2Vzc0luY29taW5nKGFubm90YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgYWN0aW9ucy5FUlJPUjoge1xuICAgICAgICBjb25zdCBlcnIgPSBtZXNzYWdlLmVycm9yO1xuICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09IDgwMDE2KSB7XG4gICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJmYWlsZWRcIiwgRXJyb3JJbmZvLmZyb21WYWx1ZXMoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgICBcIlByb3RvY29sIGVycm9yOiB1bnJlY29nbmlzZWQgbWVzc2FnZSBhY3Rpb24gKFwiICsgbWVzc2FnZS5hY3Rpb24gKyBcIilcIlxuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBfc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgXCJTdGFydGluZyBkZWNvZGUgZmFpbHVyZSByZWNvdmVyeSBwcm9jZXNzLlwiXG4gICAgICApO1xuICAgICAgdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICB0aGlzLl9hdHRhY2godHJ1ZSwgcmVhc29uLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkF0dGFjaGVkKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwub25BdHRhY2hlZFwiLFxuICAgICAgXCJhY3RpdmF0aW5nIGNoYW5uZWw7IG5hbWUgPSBcIiArIHRoaXMubmFtZVxuICAgICk7XG4gIH1cbiAgbm90aWZ5U3RhdGUoc3RhdGUsIHJlYXNvbiwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2csIGhhc09iamVjdHMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLm5vdGlmeVN0YXRlXCIsXG4gICAgICBcIm5hbWUgPSBcIiArIHRoaXMubmFtZSArIFwiLCBjdXJyZW50IHN0YXRlID0gXCIgKyB0aGlzLnN0YXRlICsgXCIsIG5vdGlmeWluZyBzdGF0ZSBcIiArIHN0YXRlXG4gICAgKTtcbiAgICB0aGlzLmNsZWFyU3RhdGVUaW1lcigpO1xuICAgIGlmIChbXCJkZXRhY2hlZFwiLCBcInN1c3BlbmRlZFwiLCBcImZhaWxlZFwiXS5pbmNsdWRlcyhzdGF0ZSkpIHtcbiAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgdGhpcy5fcHJlc2VuY2UuYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc1ByZXNlbmNlLCByZWFzb24pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb2JqZWN0KSB7XG4gICAgICB0aGlzLl9vYmplY3QuYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc09iamVjdHMpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHJlYXNvbjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuc3RhdGUsIHN0YXRlLCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pO1xuICAgIGNvbnN0IGFjdGlvbiA9ICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIic7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YXRlICsgKHJlYXNvbiA/IFwiOyByZWFzb246IFwiICsgcmVhc29uIDogXCJcIik7XG4gICAgaWYgKHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYWN0aW9uLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSAhPT0gXCJhdHRhY2hpbmdcIiAmJiBzdGF0ZSAhPT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIHRoaXMub25BdHRhY2hlZCgpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImRldGFjaGluZ1wiIHx8IHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG4gICAgdGhpcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuICB9XG4gIHJlcXVlc3RTdGF0ZShzdGF0ZSwgcmVhc29uKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5yZXF1ZXN0U3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyBzdGF0ZVxuICAgICk7XG4gICAgdGhpcy5ub3RpZnlTdGF0ZShzdGF0ZSwgcmVhc29uKTtcbiAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gIH1cbiAgY2hlY2tQZW5kaW5nU3RhdGUoKSB7XG4gICAgY29uc3QgY21TdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGU7XG4gICAgaWYgKCFjbVN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgICAgXCJzZW5kRXZlbnRzIGlzIGZhbHNlOyBzdGF0ZSBpcyBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyB0aGlzLnN0YXRlXG4gICAgKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgICB0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuICAgICAgICB0aGlzLmRldGFjaEltcGwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRpbWVvdXRQZW5kaW5nU3RhdGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgYXR0YWNoIHRpbWVkIG91dFwiLCA5MDAwNywgNDA4KTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcInN1c3BlbmRlZFwiLCBlcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjoge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiQ2hhbm5lbCBkZXRhY2ggdGltZWQgb3V0XCIsIDkwMDA3LCA0MDgpO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiYXR0YWNoZWRcIiwgZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlVGltZXIpIHtcbiAgICAgIHRoaXMuc3RhdGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZUNoYW5uZWwuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nXCIsIFwidGltZXIgZXhwaXJlZFwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0UGVuZGluZ1N0YXRlKCk7XG4gICAgICB9LCB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBjbGVhclN0YXRlVGltZXIoKSB7XG4gICAgY29uc3Qgc3RhdGVUaW1lciA9IHRoaXMuc3RhdGVUaW1lcjtcbiAgICBpZiAoc3RhdGVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xuICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRSZXRyeVRpbWVyKCkge1xuICAgIGlmICh0aGlzLnJldHJ5VGltZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZXRyeUNvdW50Kys7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IGdldFJldHJ5VGltZSh0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmNoYW5uZWxSZXRyeVRpbWVvdXQsIHRoaXMucmV0cnlDb3VudCk7XG4gICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiAmJiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbCByZXRyeSB0aW1lciBleHBpcmVkXCIsXG4gICAgICAgICAgXCJhdHRlbXB0aW5nIGEgbmV3IGF0dGFjaFwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIpO1xuICAgICAgfVxuICAgIH0sIHJldHJ5RGVsYXkpO1xuICB9XG4gIGNhbmNlbFJldHJ5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKiBAcmV0dXJucyBudWxsIChpZiBjYW4gc2FmZWx5IGJlIHJlbGVhc2VkKSB8IEVycm9ySW5mbyAoaWYgY2Fubm90KSAqL1xuICBnZXRSZWxlYXNlRXJyKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzID09PSBcImluaXRpYWxpemVkXCIgfHwgcyA9PT0gXCJkZXRhY2hlZFwiIHx8IHMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2FuIG9ubHkgcmVsZWFzZSBhIGNoYW5uZWwgaW4gYSBzdGF0ZSB3aGVyZSB0aGVyZSBpcyBubyBwb3NzaWJpbGl0eSBvZiBmdXJ0aGVyIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyIGJlaW5nIHJlY2VpdmVkIChpbml0aWFsaXplZCwgZGV0YWNoZWQsIG9yIGZhaWxlZCk7IHdhcyBcIiArIHMsXG4gICAgICA5MDAwMSxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgc2V0Q2hhbm5lbFNlcmlhbChjaGFubmVsU2VyaWFsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5zZXRDaGFubmVsU2VyaWFsKClcIixcbiAgICAgIFwiVXBkYXRpbmcgY2hhbm5lbCBzZXJpYWw7IHNlcmlhbCA9IFwiICsgY2hhbm5lbFNlcmlhbCArIFwiOyBwcmV2aW91cyA9IFwiICsgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWxcbiAgICApO1xuICAgIGlmIChjaGFubmVsU2VyaWFsKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWw7XG4gICAgfVxuICB9XG4gIGFzeW5jIHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uc3RhdHVzKHRoaXMpO1xuICB9XG4gIGFzeW5jIGdldE1lc3NhZ2Uoc2VyaWFsT3JNZXNzYWdlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmdldE1lc3NhZ2UoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgY29uc3QgcmVzdE1peGluID0gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW47XG4gICAgcmV0dXJuIHJlc3RNaXhpbi5nZXRNZXNzYWdlKHRoaXMsIHNlcmlhbE9yTWVzc2FnZSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC51cGRhdGVNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbmRVcGRhdGUobWVzc2FnZSwgXCJtZXNzYWdlLnVwZGF0ZVwiLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5kZWxldGVNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbmRVcGRhdGUobWVzc2FnZSwgXCJtZXNzYWdlLmRlbGV0ZVwiLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgYXBwZW5kTWVzc2FnZShtZXNzYWdlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5hcHBlbmRNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbmRVcGRhdGUobWVzc2FnZSwgXCJtZXNzYWdlLmFwcGVuZFwiLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgc2VuZFVwZGF0ZShtZXNzYWdlLCBhY3Rpb24sIG9wZXJhdGlvbiwgcGFyYW1zKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgaWYgKCFtZXNzYWdlLnNlcmlhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgJ1RoaXMgbWVzc2FnZSBsYWNrcyBhIHNlcmlhbCBhbmQgY2Fubm90IGJlIHVwZGF0ZWQuIE1ha2Ugc3VyZSB5b3UgaGF2ZSBlbmFibGVkIFwiTWVzc2FnZSBhbm5vdGF0aW9ucywgdXBkYXRlcywgYW5kIGRlbGV0ZXNcIiBpbiBjaGFubmVsIHNldHRpbmdzIG9uIHlvdXIgZGFzaGJvYXJkLicsXG4gICAgICAgIDQwMDAzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMudGhyb3dJZlVucHVibGlzaGFibGVTdGF0ZSgpO1xuICAgIGNvbnN0IHVwZGF0ZURlbGV0ZU1zZyA9IG1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1lc3NhZ2UpLCB7XG4gICAgICBhY3Rpb24sXG4gICAgICB2ZXJzaW9uOiBvcGVyYXRpb25cbiAgICB9KSk7XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2UgPSBhd2FpdCB1cGRhdGVEZWxldGVNc2cuZW5jb2RlKHRoaXMuY2hhbm5lbE9wdGlvbnMpO1xuICAgIGNvbnN0IHBtID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuTUVTU0FHRSxcbiAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2VzOiBbd2lyZU1lc3NhZ2VdLFxuICAgICAgcGFyYW1zOiBwYXJhbXMgPyBzdHJpbmdpZnlWYWx1ZXMocGFyYW1zKSA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGNvbnN0IHB1Ymxpc2hSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UocG0pO1xuICAgIHJldHVybiB7IHZlcnNpb25TZXJpYWw6IChfYiA9IChfYTIgPSBwdWJsaXNoUmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHB1Ymxpc2hSZXNwb25zZS5zZXJpYWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyWzBdKSAhPSBudWxsID8gX2IgOiBudWxsIH07XG4gIH1cbiAgYXN5bmMgZ2V0TWVzc2FnZVZlcnNpb25zKHNlcmlhbE9yTWVzc2FnZSwgcGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmdldE1lc3NhZ2VWZXJzaW9ucygpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICBjb25zdCByZXN0TWl4aW4gPSB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbjtcbiAgICByZXR1cm4gcmVzdE1peGluLmdldE1lc3NhZ2VWZXJzaW9ucyh0aGlzLCBzZXJpYWxPck1lc3NhZ2UsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhlIGNoYW5uZWwgaXMgYXR0YWNoZWQsIGF0dGFjaGluZyBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciB1c2UgYnkgZmVhdHVyZXMgbGlrZSBQcmVzZW5jZSBvciBPYmplY3RzIHRoYXQgbmVlZCB0b1xuICAgKiBpbXBsaWNpdGx5IGF0dGFjaCB0aGUgY2hhbm5lbCB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYWxsZWQgKGUuZy4sIGBwcmVzZW5jZS5nZXQoKWAgcGVyIFJUUDExYixcbiAgICogb3IgYG9iamVjdHMuZ2V0KClgKS4gVGhpcyBndWFyYW50ZWVzIHRoYXQgdGhlIGNvcnJlc3BvbmRpbmcgc3luYyBzZXF1ZW5jZSB3aWxsIHN0YXJ0IGFuZFxuICAgKiB0aGF0IHRoZSBvcGVyYXRpb24gd2lsbCByZXNvbHZlIGZvciBjYWxsZXJzIGV2ZW4gaWYgdGhleSBkaWQgbm90IGV4cGxpY2l0bHkgYXR0YWNoIGJlZm9yZWhhbmQuXG4gICAqL1xuICBhc3luYyBlbnN1cmVBdHRhY2hlZCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgIGF3YWl0IHRoaXMuYXR0YWNoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3JJbmZvLmZyb21WYWx1ZXModGhpcy5pbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBvbWl0QWdlbnQoY2hhbm5lbFBhcmFtcykge1xuICBjb25zdCBfYTIgPSBjaGFubmVsUGFyYW1zIHx8IHt9LCB7IGFnZW50OiBfIH0gPSBfYTIsIHBhcmFtc1dpdGhvdXRBZ2VudCA9IF9fb2JqUmVzdChfYTIsIFtcImFnZW50XCJdKTtcbiAgcmV0dXJuIHBhcmFtc1dpdGhvdXRBZ2VudDtcbn1cbnZhciByZWFsdGltZWNoYW5uZWxfZGVmYXVsdCA9IFJlYWx0aW1lQ2hhbm5lbDtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lYW5ub3RhdGlvbnMudHNcbnZhciBSZWFsdGltZUFubm90YXRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICB0aGlzLmxvZ2dlciA9IGNoYW5uZWwubG9nZ2VyO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBldmVudGVtaXR0ZXJfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcykge1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gdGhpcy5jaGFubmVsLm5hbWU7XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IGNvbnN0cnVjdFZhbGlkYXRlQW5ub3RhdGlvbihtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcyk7XG4gICAgY29uc3Qgd2lyZUFubm90YXRpb24gPSBhd2FpdCBhbm5vdGF0aW9uLmVuY29kZSgpO1xuICAgIHRoaXMuY2hhbm5lbC50aHJvd0lmVW5wdWJsaXNoYWJsZVN0YXRlKCk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQW5ub3RhdGlvbnMucHVibGlzaCgpXCIsXG4gICAgICBcImNoYW5uZWxOYW1lID0gXCIgKyBjaGFubmVsTmFtZSArIFwiLCBzZW5kaW5nIGFubm90YXRpb24gd2l0aCBtZXNzYWdlU2VyaWFsID0gXCIgKyBhbm5vdGF0aW9uLm1lc3NhZ2VTZXJpYWwgKyBcIiwgdHlwZSA9IFwiICsgYW5ub3RhdGlvbi50eXBlXG4gICAgKTtcbiAgICBjb25zdCBwbSA9IGZyb21WYWx1ZXMoe1xuICAgICAgYWN0aW9uOiBhY3Rpb25zLkFOTk9UQVRJT04sXG4gICAgICBjaGFubmVsOiBjaGFubmVsTmFtZSxcbiAgICAgIGFubm90YXRpb25zOiBbd2lyZUFubm90YXRpb25dXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5jaGFubmVsLnNlbmRNZXNzYWdlKHBtKTtcbiAgfVxuICBhc3luYyBkZWxldGUobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgICBhbm5vdGF0aW9uVmFsdWVzLmFjdGlvbiA9IFwiYW5ub3RhdGlvbi5kZWxldGVcIjtcbiAgICBhd2FpdCB0aGlzLnB1Ymxpc2gobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIGlmICh0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnMuYXR0YWNoT25TdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBjaGFubmVsLmF0dGFjaCgpO1xuICAgIH1cbiAgICBpZiAoKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiICYmIHRoaXMuY2hhbm5lbC5fbW9kZSAmIGZsYWdzLkFOTk9UQVRJT05fU1VCU0NSSUJFKSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byBhZGQgYW4gYW5ub3RhdGlvbiBsaXN0ZW5lciwgYnV0IHlvdSBoYXZlbid0IHJlcXVlc3RlZCB0aGUgYW5ub3RhdGlvbl9zdWJzY3JpYmUgY2hhbm5lbCBtb2RlIGluIENoYW5uZWxPcHRpb25zLCBzbyB0aGlzIHdvbid0IGRvIGFueXRoaW5nICh3ZSBvbmx5IGRlbGl2ZXIgYW5ub3RhdGlvbnMgdG8gY2xpZW50cyB3aG8gaGF2ZSBleHBsaWNpdGx5IHJlcXVlc3RlZCB0aGVtKVwiLFxuICAgICAgICA5MzAwMSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB1bnN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBfcHJvY2Vzc0luY29taW5nKGFubm90YXRpb25zKSB7XG4gICAgZm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIGFubm90YXRpb25zKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZW1pdChhbm5vdGF0aW9uLnR5cGUgfHwgXCJcIiwgYW5ub3RhdGlvbik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldChtc2dPclNlcmlhbCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHJlc3Rhbm5vdGF0aW9uc19kZWZhdWx0LnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBtc2dPclNlcmlhbCwgcGFyYW1zKTtcbiAgfVxufTtcbnZhciByZWFsdGltZWFubm90YXRpb25zX2RlZmF1bHQgPSBSZWFsdGltZUFubm90YXRpb25zO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvZGVmYXVsdHJlc3QudHNcbnZhciBfRGVmYXVsdFJlc3QgPSBjbGFzcyBfRGVmYXVsdFJlc3QgZXh0ZW5kcyBCYXNlUmVzdCB7XG4gIC8vIFRoZSBwdWJsaWMgdHlwaW5ncyBkZWNsYXJlIHRoYXQgdGhpcyByZXF1aXJlcyBhbiBhcmd1bWVudCB0byBiZSBwYXNzZWQsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgbm90IHBhc3MgYW4gYXJndW1lbnQsIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhpcyBpcyBwb3NzaWJsZSBzbyB0aGF0IGl0IGZvcmNlcyB1cyB0byBoYW5kbGUgaXQuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBjb25zdCBNc2dQYWNrID0gX0RlZmF1bHRSZXN0Ll9Nc2dQYWNrO1xuICAgIGlmICghTXNnUGFjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGVmYXVsdFJlc3QuX01zZ1BhY2sgdG8gaGF2ZSBiZWVuIHNldFwiKTtcbiAgICB9XG4gICAgc3VwZXIoXG4gICAgICBkZWZhdWx0c19kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucywgdHJ1ZSwgXCJSZXN0XCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGFsbENvbW1vbk1vZHVsYXJQbHVnaW5zKSwge1xuICAgICAgICBDcnlwdG86IChfYTIgPSBfRGVmYXVsdFJlc3QuQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogdm9pZCAwLFxuICAgICAgICBNc2dQYWNrOiAoX2IgPSBfRGVmYXVsdFJlc3QuX01zZ1BhY2spICE9IG51bGwgPyBfYiA6IHZvaWQgMCxcbiAgICAgICAgQW5ub3RhdGlvbnM6IHtcbiAgICAgICAgICBBbm5vdGF0aW9uOiBhbm5vdGF0aW9uX2RlZmF1bHQsXG4gICAgICAgICAgV2lyZUFubm90YXRpb24sXG4gICAgICAgICAgUmVhbHRpbWVBbm5vdGF0aW9uczogcmVhbHRpbWVhbm5vdGF0aW9uc19kZWZhdWx0LFxuICAgICAgICAgIFJlc3RBbm5vdGF0aW9uczogcmVzdGFubm90YXRpb25zX2RlZmF1bHRcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IENyeXB0bygpIHtcbiAgICBpZiAodGhpcy5fQ3J5cHRvID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9DcnlwdG87XG4gIH1cbiAgc3RhdGljIHNldCBDcnlwdG8obmV3VmFsdWUpIHtcbiAgICB0aGlzLl9DcnlwdG8gPSBuZXdWYWx1ZTtcbiAgfVxufTtcbl9EZWZhdWx0UmVzdC5fQ3J5cHRvID0gbnVsbDtcbl9EZWZhdWx0UmVzdC5NZXNzYWdlID0gRGVmYXVsdE1lc3NhZ2U7XG5fRGVmYXVsdFJlc3QuUHJlc2VuY2VNZXNzYWdlID0gRGVmYXVsdFByZXNlbmNlTWVzc2FnZTtcbl9EZWZhdWx0UmVzdC5Bbm5vdGF0aW9uID0gRGVmYXVsdEFubm90YXRpb247XG5fRGVmYXVsdFJlc3QuX01zZ1BhY2sgPSBudWxsO1xuLy8gVXNlZCBieSB0ZXN0c1xuX0RlZmF1bHRSZXN0Ll9IdHRwID0gSHR0cDtcbnZhciBEZWZhdWx0UmVzdCA9IF9EZWZhdWx0UmVzdDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L21lc3NhZ2VxdWV1ZS50c1xudmFyIE1lc3NhZ2VRdWV1ZSA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICBzdXBlcihsb2dnZXIpO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgfVxuICBjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG4gIH1cbiAgcHVzaChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLnNoaWZ0KCk7XG4gIH1cbiAgbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1t0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGNvcHlBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuc2xpY2UoKTtcbiAgfVxuICBhcHBlbmQobWVzc2FnZXMpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2guYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuICB9XG4gIHByZXBlbmQobWVzc2FnZXMpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLnVuc2hpZnQuYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuICB9XG4gIC8qKlxuICAgKiBGb3IgYWxsIG1lc3NhZ2VzIHRhcmdldGVkIGJ5IHRoZSBzZWxlY3RvciwgY2FsbHMgdGhlaXIgY2FsbGJhY2sgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gRGVzY3JpYmVzIHdoaWNoIG1lc3NhZ2VzIHRvIHRhcmdldC4gJ2FsbCcgbWVhbnMgYWxsIG1lc3NhZ2VzIGluIHRoZSBxdWV1ZSAocmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXkgaGF2ZSBoYWQgYSBgbXNnU2VyaWFsYCBhc3NpZ25lZCk7IGBzZXJpYWxgIC8gYGNvdW50YCB0YXJnZXRzIGEgcmFuZ2Ugb2YgbWVzc2FnZXMgZGVzY3JpYmVkIGJ5IGFuIGBBQ0tgIG9yIGBOQUNLYCByZWNlaXZlZCBmcm9tIEFibHkgKHRoaXMgYXNzdW1lcyB0aGF0IGFsbCB0aGUgbWVzc2FnZXMgaW4gdGhlIHF1ZXVlIGhhdmUgaGFkIGEgYG1zZ1NlcmlhbGAgYXNzaWduZWQpLlxuICAgKi9cbiAgY29tcGxldGVNZXNzYWdlcyhzZWxlY3RvciwgZXJyLCByZXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKVwiLFxuICAgICAgc2VsZWN0b3IgPT0gXCJhbGxcIiA/IFwiKGFsbClcIiA6IFwic2VyaWFsID0gXCIgKyBzZWxlY3Rvci5zZXJpYWwgKyBcIjsgY291bnQgPSBcIiArIHNlbGVjdG9yLmNvdW50XG4gICAgKTtcbiAgICBlcnIgPSBlcnIgfHwgbnVsbDtcbiAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMubWVzc2FnZXM7XG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKTogY29tcGxldGVNZXNzYWdlcyBjYWxsZWQgb24gYW55IGVtcHR5IE1lc3NhZ2VRdWV1ZVwiKTtcbiAgICB9XG4gICAgbGV0IGNvbXBsZXRlTWVzc2FnZXMgPSBbXTtcbiAgICBpZiAoc2VsZWN0b3IgPT09IFwiYWxsXCIpIHtcbiAgICAgIGNvbXBsZXRlTWVzc2FnZXMgPSBtZXNzYWdlcy5zcGxpY2UoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gbWVzc2FnZXNbMF07XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTZXJpYWwgPSBmaXJzdC5tZXNzYWdlLm1zZ1NlcmlhbDtcbiAgICAgICAgY29uc3QgZW5kU2VyaWFsID0gc2VsZWN0b3Iuc2VyaWFsICsgc2VsZWN0b3IuY291bnQ7XG4gICAgICAgIGlmIChlbmRTZXJpYWwgPiBzdGFydFNlcmlhbCkge1xuICAgICAgICAgIGNvbXBsZXRlTWVzc2FnZXMgPSBtZXNzYWdlcy5zcGxpY2UoMCwgZW5kU2VyaWFsIC0gc3RhcnRTZXJpYWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcGxldGVNZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGNvbXBsZXRlTWVzc2FnZXNbaV07XG4gICAgICBjb25zdCBwdWJsaXNoUmVzcG9uc2UgPSByZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc1tpXTtcbiAgICAgIG1lc3NhZ2UuY2FsbGJhY2soZXJyLCBwdWJsaXNoUmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09IDApXG4gICAgICB0aGlzLmVtaXQoXCJpZGxlXCIpO1xuICB9XG4gIGNvbXBsZXRlQWxsTWVzc2FnZXMoZXJyKSB7XG4gICAgdGhpcy5jb21wbGV0ZU1lc3NhZ2VzKFwiYWxsXCIsIGVycik7XG4gIH1cbiAgcmVzZXRTZW5kQXR0ZW1wdGVkKCkge1xuICAgIGZvciAobGV0IG1zZyBvZiB0aGlzLm1lc3NhZ2VzKSB7XG4gICAgICBtc2cuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiTWVzc2FnZVF1ZXVlLmNsZWFyKClcIixcbiAgICAgIFwiY2xlYXJpbmcgXCIgKyB0aGlzLm1lc3NhZ2VzLmxlbmd0aCArIFwiIG1lc3NhZ2VzXCJcbiAgICApO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLmVtaXQoXCJpZGxlXCIpO1xuICB9XG59O1xudmFyIG1lc3NhZ2VxdWV1ZV9kZWZhdWx0ID0gTWVzc2FnZVF1ZXVlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvcHJvdG9jb2wudHNcbnZhciBQZW5kaW5nTWVzc2FnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLm1lcmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdGlvbiA9IG1lc3NhZ2UuYWN0aW9uO1xuICAgIHRoaXMuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuYWNrUmVxdWlyZWQgPSB0eXBlb2YgYWN0aW9uID09PSBcIm51bWJlclwiICYmIFthY3Rpb25zLk1FU1NBR0UsIGFjdGlvbnMuUFJFU0VOQ0UsIGFjdGlvbnMuQU5OT1RBVElPTiwgYWN0aW9ucy5PQkpFQ1RdLmluY2x1ZGVzKGFjdGlvbik7XG4gIH1cbn07XG52YXIgUHJvdG9jb2wgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgc3VwZXIodHJhbnNwb3J0LmxvZ2dlcik7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgbWVzc2FnZXF1ZXVlX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRyYW5zcG9ydC5vbihcImFja1wiLCAoc2VyaWFsLCBjb3VudCwgcmVzKSA9PiB7XG4gICAgICB0aGlzLm9uQWNrKHNlcmlhbCwgY291bnQsIHJlcyk7XG4gICAgfSk7XG4gICAgdHJhbnNwb3J0Lm9uKFwibmFja1wiLCAoc2VyaWFsLCBjb3VudCwgZXJyKSA9PiB7XG4gICAgICB0aGlzLm9uTmFjayhzZXJpYWwsIGNvdW50LCBlcnIpO1xuICAgIH0pO1xuICB9XG4gIG9uQWNrKHNlcmlhbCwgY291bnQsIHJlcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlByb3RvY29sLm9uQWNrKClcIiwgXCJzZXJpYWwgPSBcIiArIHNlcmlhbCArIFwiOyBjb3VudCA9IFwiICsgY291bnQpO1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoeyBzZXJpYWwsIGNvdW50IH0sIG51bGwsIHJlcyk7XG4gIH1cbiAgb25OYWNrKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJQcm90b2NvbC5vbk5hY2soKVwiLFxuICAgICAgXCJzZXJpYWwgPSBcIiArIHNlcmlhbCArIFwiOyBjb3VudCA9IFwiICsgY291bnQgKyBcIjsgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICk7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gc2VuZCBtZXNzYWdlOyBjaGFubmVsIG5vdCByZXNwb25kaW5nXCIsIDUwMDAxLCA1MDApO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHsgc2VyaWFsLCBjb3VudCB9LCBlcnIpO1xuICB9XG4gIG9uY2VJZGxlKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbWVzc2FnZVF1ZXVlID0gdGhpcy5tZXNzYWdlUXVldWU7XG4gICAgaWYgKG1lc3NhZ2VRdWV1ZS5jb3VudCgpID09PSAwKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXNzYWdlUXVldWUub25jZShcImlkbGVcIiwgbGlzdGVuZXIpO1xuICB9XG4gIHNlbmQocGVuZGluZ01lc3NhZ2UpIHtcbiAgICBpZiAocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQpIHtcbiAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gocGVuZGluZ01lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiUHJvdG9jb2wuc2VuZCgpXCIsXG4gICAgICAgIFwic2VuZGluZyBtc2c7IFwiICsgc3RyaW5naWZ5KFxuICAgICAgICAgIHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgICAgdGhpcy50cmFuc3BvcnQuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsXG4gICAgICAgICAgdGhpcy50cmFuc3BvcnQuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX0Fubm90YXRpb25zLFxuICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9saXZlT2JqZWN0c1BsdWdpblxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xuICB9XG4gIGdldFRyYW5zcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQ7XG4gIH1cbiAgZ2V0UGVuZGluZ01lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jb3B5QWxsKCk7XG4gIH1cbiAgY2xlYXJQZW5kaW5nTWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNsZWFyKCk7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0O1xuICAgIHRoaXMub25jZUlkbGUoZnVuY3Rpb24oKSB7XG4gICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHByb3RvY29sX2RlZmF1bHQgPSBQcm90b2NvbDtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZS50c1xudmFyIENvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJldmlvdXMsIGN1cnJlbnQsIHJldHJ5SW4sIHJlYXNvbikge1xuICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgIGlmIChyZXRyeUluKVxuICAgICAgdGhpcy5yZXRyeUluID0gcmV0cnlJbjtcbiAgICBpZiAocmVhc29uKVxuICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIH1cbn07XG52YXIgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQgPSBDb25uZWN0aW9uU3RhdGVDaGFuZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9uZXJyb3JzLnRzXG52YXIgQ29ubmVjdGlvbkVycm9yQ29kZXMgPSB7XG4gIERJU0NPTk5FQ1RFRDogODAwMDMsXG4gIFNVU1BFTkRFRDogODAwMDIsXG4gIEZBSUxFRDogOGU0LFxuICBDTE9TSU5HOiA4MDAxNyxcbiAgQ0xPU0VEOiA4MDAxNyxcbiAgVU5LTk9XTl9DT05ORUNUSU9OX0VSUjogNTAwMDIsXG4gIFVOS05PV05fQ0hBTk5FTF9FUlI6IDUwMDAxXG59O1xudmFyIENvbm5lY3Rpb25FcnJvcnMgPSB7XG4gIGRpc2Nvbm5lY3RlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5ESVNDT05ORUNURUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIHRvIHNlcnZlciB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZVwiXG4gIH0pLFxuICBzdXNwZW5kZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuU1VTUEVOREVELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdW5hdmFpbGFibGVcIlxuICB9KSxcbiAgZmFpbGVkOiAoKSA9PiBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG4gICAgc3RhdHVzQ29kZTogNDAwLFxuICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLkZBSUxFRCxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gZmFpbGVkIG9yIGRpc2Nvbm5lY3RlZCBieSBzZXJ2ZXJcIlxuICB9KSxcbiAgY2xvc2luZzogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TSU5HLFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBjbG9zaW5nXCJcbiAgfSksXG4gIGNsb3NlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TRUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIGNsb3NlZFwiXG4gIH0pLFxuICB1bmtub3duQ29ubmVjdGlvbkVycjogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvclwiXG4gIH0pLFxuICB1bmtub3duQ2hhbm5lbEVycjogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgY2hhbm5lbCBlcnJvclwiXG4gIH0pXG59O1xuZnVuY3Rpb24gaXNSZXRyaWFibGUoZXJyKSB7XG4gIGlmICghZXJyLnN0YXR1c0NvZGUgfHwgIWVyci5jb2RlIHx8IGVyci5zdGF0dXNDb2RlID49IDUwMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBPYmplY3QudmFsdWVzKENvbm5lY3Rpb25FcnJvckNvZGVzKS5pbmNsdWRlcyhlcnIuY29kZSk7XG59XG52YXIgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0ID0gQ29ubmVjdGlvbkVycm9ycztcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L3RyYW5zcG9ydC50c1xudmFyIGNsb3NlTWVzc2FnZSA9IGZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuQ0xPU0UgfSk7XG52YXIgZGlzY29ubmVjdE1lc3NhZ2UgPSBmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkRJU0NPTk5FQ1QgfSk7XG52YXIgVHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGZvcmNlSnNvblByb3RvY29sKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIubG9nZ2VyKTtcbiAgICBpZiAoZm9yY2VKc29uUHJvdG9jb2wpIHtcbiAgICAgIHBhcmFtcy5mb3JtYXQgPSB2b2lkIDA7XG4gICAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMudGltZW91dHMgPSBwYXJhbXMub3B0aW9ucy50aW1lb3V0cztcbiAgICB0aGlzLmZvcm1hdCA9IHBhcmFtcy5mb3JtYXQ7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgdGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVxdWVzdENsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKFwiY2xvc2VkXCIsIGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC5jbG9zZWQoKSk7XG4gIH1cbiAgZGlzY29ubmVjdChlcnIpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgfVxuICBmYWlsKGVycikge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKFwiZmFpbGVkXCIsIGVyciB8fCBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQuZmFpbGVkKCkpO1xuICB9XG4gIGZpbmlzaChldmVudCwgZXJyKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQoKF9hMiA9IHRoaXMuaWRsZVRpbWVyKSAhPSBudWxsID8gX2EyIDogdm9pZCAwKTtcbiAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCBlcnIpO1xuICAgIHRoaXMuZGlzcG9zZSgpO1xuICB9XG4gIG9uUHJvdG9jb2xNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgXCJyZWNlaXZlZCBvbiBcIiArIHRoaXMuc2hvcnROYW1lICsgXCI6IFwiICsgc3RyaW5naWZ5KFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Bbm5vdGF0aW9ucyxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9saXZlT2JqZWN0c1BsdWdpblxuICAgICAgICApICsgXCI7IGNvbm5lY3Rpb25JZCA9IFwiICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWRcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgIHN3aXRjaCAobWVzc2FnZS5hY3Rpb24pIHtcbiAgICAgIGNhc2UgYWN0aW9ucy5IRUFSVEJFQVQ6XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgICB0aGlzLnNob3J0TmFtZSArIFwiIGhlYXJ0YmVhdDsgY29ubmVjdGlvbklkID0gXCIgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVtaXQoXCJoZWFydGJlYXRcIiwgbWVzc2FnZS5pZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLkNPTk5FQ1RFRDpcbiAgICAgICAgdGhpcy5vbkNvbm5lY3QobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RlZFwiLCBtZXNzYWdlLmVycm9yLCBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscywgbWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLkNMT1NFRDpcbiAgICAgICAgdGhpcy5vbkNsb3NlKG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5ESVNDT05ORUNURUQ6XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0KG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5BQ0s6XG4gICAgICAgIHRoaXMuZW1pdChcImFja1wiLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5yZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5OQUNLOlxuICAgICAgICB0aGlzLmVtaXQoXCJuYWNrXCIsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50LCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5BQ1RJVkFURTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuQVVUSDpcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMuYXV0aC5hdXRob3JpemUoKSwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICAgICAgICBcIkFibHkgcmVxdWVzdGVkIHJlLWF1dGhlbnRpY2F0aW9uLCBidXQgdW5hYmxlIHRvIG9idGFpbiBhIG5ldyB0b2tlbjogXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5FUlJPUjpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIlRyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpXCIsXG4gICAgICAgICAgXCJyZWNlaXZlZCBlcnJvciBhY3Rpb247IGNvbm5lY3Rpb25JZCA9IFwiICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQgKyBcIjsgZXJyID0gXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChtZXNzYWdlLmVycm9yKSArIChtZXNzYWdlLmNoYW5uZWwgPyBcIiwgY2hhbm5lbDogXCIgKyBtZXNzYWdlLmNoYW5uZWwgOiBcIlwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAobWVzc2FnZS5jaGFubmVsID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLm9uRmF0YWxFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgIH1cbiAgfVxuICBvbkNvbm5lY3QobWVzc2FnZSkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIGlmICghbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0Lm9uQ29ubmVjdCgpOiBDb25uZWN0IG1lc3NhZ2UgcmVjaWV2ZWQgd2l0aG91dCBjb25uZWN0aW9uRGV0YWlsc1wiKTtcbiAgICB9XG4gICAgY29uc3QgbWF4UHJvbWlzZWRJZGxlID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG4gICAgaWYgKG1heFByb21pc2VkSWRsZSkge1xuICAgICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBtYXhQcm9taXNlZElkbGUgKyB0aGlzLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cbiAgb25EaXNjb25uZWN0KG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0Lm9uRGlzY29ubmVjdCgpXCIsIFwiZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyKTtcbiAgfVxuICBvbkZhdGFsRXJyb3IobWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQub25GYXRhbEVycm9yKClcIiwgXCJlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpKTtcbiAgICB0aGlzLmZpbmlzaChcImZhaWxlZFwiLCBlcnIpO1xuICB9XG4gIG9uQ2xvc2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQub25DbG9zZSgpXCIsIFwiZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgdGhpcy5maW5pc2goXCJjbG9zZWRcIiwgZXJyKTtcbiAgfVxuICByZXF1ZXN0Q2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpXCIsIFwiXCIpO1xuICAgIHRoaXMuc2VuZChjbG9zZU1lc3NhZ2UpO1xuICB9XG4gIHJlcXVlc3REaXNjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpXCIsIFwiXCIpO1xuICAgIHRoaXMuc2VuZChkaXNjb25uZWN0TWVzc2FnZSk7XG4gIH1cbiAgcGluZyhpZCkge1xuICAgIGNvbnN0IG1zZyA9IHsgYWN0aW9uOiBhY3Rpb25zLkhFQVJUQkVBVCB9O1xuICAgIGlmIChpZClcbiAgICAgIG1zZy5pZCA9IGlkO1xuICAgIHRoaXMuc2VuZChmcm9tVmFsdWVzKG1zZykpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIHRoaXMub2ZmKCk7XG4gIH1cbiAgb25BY3Rpdml0eSgpIHtcbiAgICBpZiAoIXRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEFjdGl2aXR5ID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5sYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRoaXMubWF4SWRsZUludGVydmFsICsgMTAwKTtcbiAgfVxuICBzZXRJZGxlVGltZXIodGltZW91dCkge1xuICAgIGlmICghdGhpcy5pZGxlVGltZXIpIHtcbiAgICAgIHRoaXMuaWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub25JZGxlVGltZXJFeHBpcmUoKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBvbklkbGVUaW1lckV4cGlyZSgpIHtcbiAgICBpZiAoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKCk6IGxhc3RBY3Rpdml0eS9tYXhJZGxlSW50ZXJ2YWwgbm90IHNldFwiKTtcbiAgICB9XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIGNvbnN0IHNpbmNlTGFzdCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICBjb25zdCB0aW1lUmVtYWluaW5nID0gdGhpcy5tYXhJZGxlSW50ZXJ2YWwgLSBzaW5jZUxhc3Q7XG4gICAgaWYgKHRpbWVSZW1haW5pbmcgPD0gMCkge1xuICAgICAgY29uc3QgbXNnID0gXCJObyBhY3Rpdml0eSBzZWVuIGZyb20gcmVhbHRpbWUgaW4gXCIgKyBzaW5jZUxhc3QgKyBcIm1zOyBhc3N1bWluZyBjb25uZWN0aW9uIGhhcyBkcm9wcGVkXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJUcmFuc3BvcnQub25JZGxlVGltZXJFeHBpcmUoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KG5ldyBFcnJvckluZm8obXNnLCA4MDAwMywgNDA4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRpbWVSZW1haW5pbmcgKyAxMDApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdHJ5Q29ubmVjdCh0cmFuc3BvcnRDdG9yLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRDdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgIGxldCB0cmFuc3BvcnRBdHRlbXB0VGltZXI7XG4gICAgY29uc3QgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zcG9ydEF0dGVtcHRUaW1lcik7XG4gICAgICBjYWxsYmFjayh7IGV2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCA9IGNvbm5lY3Rpb25NYW5hZ2VyLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICB0cmFuc3BvcnRBdHRlbXB0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRyYW5zcG9ydC5vZmYoW1wicHJlY29ubmVjdFwiLCBcImRpc2Nvbm5lY3RlZFwiLCBcImZhaWxlZFwiXSk7XG4gICAgICB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgZXJyb3JDYi5jYWxsKFxuICAgICAgICB7IGV2ZW50OiBcImRpc2Nvbm5lY3RlZFwiIH0sXG4gICAgICAgIG5ldyBFcnJvckluZm8oXCJUaW1lb3V0IHdhaXRpbmcgZm9yIHRyYW5zcG9ydCB0byBpbmRpY2F0ZSBpdHNlbGYgdmlhYmxlXCIsIDVlNCwgNTAwKVxuICAgICAgKTtcbiAgICB9LCByZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICB0cmFuc3BvcnQub24oW1wiZmFpbGVkXCIsIFwiZGlzY29ubmVjdGVkXCJdLCBlcnJvckNiKTtcbiAgICB0cmFuc3BvcnQub24oXCJwcmVjb25uZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJUcmFuc3BvcnQudHJ5Q29ubmVjdCgpXCIsXG4gICAgICAgIFwidmlhYmxlIHRyYW5zcG9ydCBcIiArIHRyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc3BvcnRBdHRlbXB0VGltZXIpO1xuICAgICAgdHJhbnNwb3J0Lm9mZihbXCJmYWlsZWRcIiwgXCJkaXNjb25uZWN0ZWRcIl0sIGVycm9yQ2IpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcbiAgICB9KTtcbiAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gIH1cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJpc0F2YWlsYWJsZSBub3QgaW1wbGVtZW50ZWQgZm9yIHRyYW5zcG9ydFwiLCA1ZTQsIDUwMCk7XG4gIH1cbn07XG52YXIgdHJhbnNwb3J0X2RlZmF1bHQgPSBUcmFuc3BvcnQ7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL1RyYW5zcG9ydE5hbWUudHNcbnZhciBUcmFuc3BvcnROYW1lcztcbigoVHJhbnNwb3J0TmFtZXMyKSA9PiB7XG4gIFRyYW5zcG9ydE5hbWVzMi5XZWJTb2NrZXQgPSBcIndlYl9zb2NrZXRcIjtcbiAgVHJhbnNwb3J0TmFtZXMyLkNvbWV0ID0gXCJjb21ldFwiO1xuICBUcmFuc3BvcnROYW1lczIuWGhyUG9sbGluZyA9IFwieGhyX3BvbGxpbmdcIjtcbn0pKFRyYW5zcG9ydE5hbWVzIHx8IChUcmFuc3BvcnROYW1lcyA9IHt9KSk7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9ubWFuYWdlci50c1xudmFyIGdsb2JhbE9iamVjdDIgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG52YXIgaGF2ZVdlYlN0b3JhZ2UgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiB0eXBlb2YgUGxhdGZvcm0uV2ViU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9jYWxTdXBwb3J0ZWQpO1xufTtcbnZhciBoYXZlU2Vzc2lvblN0b3JhZ2UgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiB0eXBlb2YgUGxhdGZvcm0uV2ViU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Vzc2lvblN1cHBvcnRlZCk7XG59O1xudmFyIG5vb3AyID0gZnVuY3Rpb24oKSB7XG59O1xudmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gXCJhYmx5LXRyYW5zcG9ydC1wcmVmZXJlbmNlXCI7XG5mdW5jdGlvbiBkZWNvZGVSZWNvdmVyeUtleShyZWNvdmVyeUtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJlY292ZXJ5S2V5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG52YXIgVHJhbnNwb3J0UGFyYW1zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBob3N0LCBtb2RlLCBjb25uZWN0aW9uS2V5KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbktleTtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgfVxuICBnZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBhdXRoUGFyYW1zID8gY29weShhdXRoUGFyYW1zKSA6IHt9O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgIGNhc2UgXCJyZXN1bWVcIjpcbiAgICAgICAgcGFyYW1zLnJlc3VtZSA9IHRoaXMuY29ubmVjdGlvbktleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVjb3ZlclwiOiB7XG4gICAgICAgIGNvbnN0IHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KG9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICBwYXJhbXMucmVjb3ZlciA9IHJlY292ZXJ5Q29udGV4dC5jb25uZWN0aW9uS2V5O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50SWQgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnRJZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZWNob01lc3NhZ2VzID09PSBmYWxzZSkge1xuICAgICAgcGFyYW1zLmVjaG8gPSBcImZhbHNlXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvcm1hdCAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmVhbSAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuc3RyZWFtID0gdGhpcy5zdHJlYW07XG4gICAgfVxuICAgIGlmICh0aGlzLmhlYXJ0YmVhdHMgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSB0aGlzLmhlYXJ0YmVhdHM7XG4gICAgfVxuICAgIHBhcmFtcy52ID0gZGVmYXVsdHNfZGVmYXVsdC5wcm90b2NvbFZlcnNpb247XG4gICAgcGFyYW1zLmFnZW50ID0gZ2V0QWdlbnRTdHJpbmcodGhpcy5vcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc3BvcnRQYXJhbXMgIT09IHZvaWQgMCkge1xuICAgICAgbWl4aW4ocGFyYW1zLCBvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiW21vZGU9XCIgKyB0aGlzLm1vZGU7XG4gICAgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgcmVzdWx0ICs9IFwiLGhvc3Q9XCIgKyB0aGlzLmhvc3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHJlc3VsdCArPSBcIixjb25uZWN0aW9uS2V5PVwiICsgdGhpcy5jb25uZWN0aW9uS2V5O1xuICAgIH1cbiAgICBpZiAodGhpcy5mb3JtYXQpIHtcbiAgICAgIHJlc3VsdCArPSBcIixmb3JtYXQ9XCIgKyB0aGlzLmZvcm1hdDtcbiAgICB9XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSBjbGFzcyBfQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHJlYWx0aW1lLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocmVhbHRpbWUubG9nZ2VyKTtcbiAgICB0aGlzLnN1cHBvcnRlZFRyYW5zcG9ydHMgPSB7fTtcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlID0geyBpc1Byb2Nlc3Npbmc6IGZhbHNlLCBxdWV1ZTogW10gfTtcbiAgICB0aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG4gICAgdGhpcy5pbml0VHJhbnNwb3J0cygpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY29uc3QgdGltZW91dHMgPSBvcHRpb25zLnRpbWVvdXRzO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUaW1lb3V0ID0gdGltZW91dHMud2ViU29ja2V0Q29ubmVjdFRpbWVvdXQgKyB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgIHRoaXMuc3RhdGVzID0ge1xuICAgICAgaW5pdGlhbGl6ZWQ6IHtcbiAgICAgICAgc3RhdGU6IFwiaW5pdGlhbGl6ZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIGNvbm5lY3Rpbmc6IHtcbiAgICAgICAgc3RhdGU6IFwiY29ubmVjdGluZ1wiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogY29ubmVjdGluZ1RpbWVvdXQsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZDoge1xuICAgICAgICBzdGF0ZTogXCJjb25uZWN0ZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHNlbmRFdmVudHM6IHRydWUsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZDoge1xuICAgICAgICBzdGF0ZTogXCJkaXNjb25uZWN0ZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLmRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICB9LFxuICAgICAgc3VzcGVuZGVkOiB7XG4gICAgICAgIHN0YXRlOiBcInN1c3BlbmRlZFwiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnN1c3BlbmRlZFJldHJ5VGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcInN1c3BlbmRlZFwiXG4gICAgICB9LFxuICAgICAgY2xvc2luZzoge1xuICAgICAgICBzdGF0ZTogXCJjbG9zaW5nXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcImNsb3NlZFwiXG4gICAgICB9LFxuICAgICAgY2xvc2VkOiB7IHN0YXRlOiBcImNsb3NlZFwiLCB0ZXJtaW5hbDogdHJ1ZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiBcImNsb3NlZFwiIH0sXG4gICAgICBmYWlsZWQ6IHsgc3RhdGU6IFwiZmFpbGVkXCIsIHRlcm1pbmFsOiB0cnVlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6IFwiZmFpbGVkXCIgfVxuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLmluaXRpYWxpemVkO1xuICAgIHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgIHRoaXMucXVldWVkTWVzc2FnZXMgPSBuZXcgbWVzc2FnZXF1ZXVlX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMubXNnU2VyaWFsID0gMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvbklkID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvbktleSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IHRpbWVvdXRzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnRzID0gaW50ZXJzZWN0KG9wdGlvbnMudHJhbnNwb3J0cyB8fCBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRUcmFuc3BvcnRzLCB0aGlzLnN1cHBvcnRlZFRyYW5zcG9ydHMpO1xuICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG4gICAgaWYgKHRoaXMudHJhbnNwb3J0cy5pbmNsdWRlcyhUcmFuc3BvcnROYW1lcy5XZWJTb2NrZXQpKSB7XG4gICAgICB0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXMoVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZykpIHtcbiAgICAgIHRoaXMuYmFzZVRyYW5zcG9ydCA9IFRyYW5zcG9ydE5hbWVzLlhoclBvbGxpbmc7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXMoVHJhbnNwb3J0TmFtZXMuQ29tZXQpKSB7XG4gICAgICB0aGlzLmJhc2VUcmFuc3BvcnQgPSBUcmFuc3BvcnROYW1lcy5Db21ldDtcbiAgICB9XG4gICAgdGhpcy5kb21haW5zID0gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0cyhvcHRpb25zKTtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbnVsbDtcbiAgICB0aGlzLmhvc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG4gICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgIHRoaXMuY29ubmVjdENvdW50ZXIgPSAwO1xuICAgIHRoaXMud3NDaGVja1Jlc3VsdCA9IG51bGw7XG4gICAgdGhpcy53ZWJTb2NrZXRTbG93VGltZXIgPSBudWxsO1xuICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBudWxsO1xuICAgIHRoaXMuYWJhbmRvbmVkV2ViU29ja2V0ID0gZmFsc2U7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLCBcInN0YXJ0ZWRcIik7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgIFwicmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbXCIgKyAob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFRyYW5zcG9ydHMpICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImF2YWlsYWJsZSB0cmFuc3BvcnRzID0gW1wiICsgdGhpcy50cmFuc3BvcnRzICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImh0dHAgZG9tYWlucyA9IFtcIiArIHRoaXMuZG9tYWlucyArIFwiXVwiXG4gICAgKTtcbiAgICBpZiAoIXRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwibm8gcmVxdWVzdGVkIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJyZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsIG1zZyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IFBsYXRmb3JtLkNvbmZpZy5hZGRFdmVudExpc3RlbmVyO1xuICAgIGlmIChhZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAoaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgdHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgdGhpcy5wZXJzaXN0Q29ubmVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgICAgICAgIFwiYmVmb3JldW5sb2FkIGV2ZW50IGhhcyB0cmlnZ2VyZWQgdGhlIGNvbm5lY3Rpb24gdG8gY2xvc2UgYXMgY2xvc2VPblVubG9hZCBpcyB0cnVlXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY2xvc2luZ1wiIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQgfHwgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zdXNwZW5kZWQpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIgXFx1MjAxOG9ubGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwicmVhdHRlbXB0aW5nIGNvbm5lY3Rpb25cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgKF9hMiA9IHRoaXMucGVuZGluZ1RyYW5zcG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vZmYoKTtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciBcXHUyMDE4b2ZmbGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwiZGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKioqKioqKioqKioqKioqKioqKipcbiAgICogdHJhbnNwb3J0IG1hbmFnZW1lbnRcbiAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgLy8gVXNlZCBieSB0ZXN0c1xuICBzdGF0aWMgc3VwcG9ydGVkVHJhbnNwb3J0cyhhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHsgc3VwcG9ydGVkVHJhbnNwb3J0czoge30gfTtcbiAgICB0aGlzLmluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpO1xuICAgIHJldHVybiBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHM7XG4gIH1cbiAgc3RhdGljIGluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpIHtcbiAgICBjb25zdCBpbXBsZW1lbnRhdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgUGxhdGZvcm0uVHJhbnNwb3J0cy5idW5kbGVkSW1wbGVtZW50YXRpb25zKSwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucyk7XG4gICAgW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldCwgLi4uUGxhdGZvcm0uVHJhbnNwb3J0cy5vcmRlcl0uZm9yRWFjaCgodHJhbnNwb3J0TmFtZSkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gaW1wbGVtZW50YXRpb25zW3RyYW5zcG9ydE5hbWVdO1xuICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0cmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHNbdHJhbnNwb3J0TmFtZV0gPSB0cmFuc3BvcnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW5pdFRyYW5zcG9ydHMoKSB7XG4gICAgX0Nvbm5lY3Rpb25NYW5hZ2VyLmluaXRUcmFuc3BvcnRzKHRoaXMucmVhbHRpbWUuX2FkZGl0aW9uYWxUcmFuc3BvcnRJbXBsZW1lbnRhdGlvbnMsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhob3N0LCBtb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc3BvcnRQYXJhbXModGhpcy5vcHRpb25zLCBob3N0LCBtb2RlLCB0aGlzLmNvbm5lY3Rpb25LZXkpO1xuICB9XG4gIGdldFRyYW5zcG9ydFBhcmFtcyhjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlY2lkZU1vZGUgPSAobW9kZUNiKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICAgIG1vZGVDYihcInJlc3VtZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVjb3ZlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWNvdmVyRm4gPSB0aGlzLm9wdGlvbnMucmVjb3ZlciwgbGFzdFNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uUmVjb3ZlckRhdGEoKSwgc2Vzc2lvblJlY292ZXJ5TmFtZSA9IHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpO1xuICAgICAgaWYgKGxhc3RTZXNzaW9uRGF0YSAmJiB0eXBlb2YgcmVjb3ZlckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpXCIsXG4gICAgICAgICAgXCJDYWxsaW5nIGNsaWVudE9wdGlvbnMtcHJvdmlkZWQgcmVjb3ZlciBmdW5jdGlvbiB3aXRoIGxhc3Qgc2Vzc2lvbiBkYXRhIChyZWNvdmVyeSBzY29wZTogXCIgKyBzZXNzaW9uUmVjb3ZlcnlOYW1lICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmVjb3ZlckZuKGxhc3RTZXNzaW9uRGF0YSwgKHNob3VsZFJlY292ZXIpID0+IHtcbiAgICAgICAgICBpZiAoc2hvdWxkUmVjb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XG4gICAgICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICB9O1xuICAgIGRlY2lkZU1vZGUoKG1vZGUpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydFBhcmFtcyA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKG51bGwsIG1vZGUpO1xuICAgICAgaWYgKG1vZGUgPT09IFwicmVjb3ZlclwiKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKVwiLFxuICAgICAgICAgIFwiVHJhbnNwb3J0IHJlY292ZXJ5IG1vZGUgPSByZWNvdmVyOyByZWNvdmVyeUtleSA9IFwiICsgdGhpcy5vcHRpb25zLnJlY292ZXJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkodGhpcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5tc2dTZXJpYWwgPSByZWNvdmVyeUNvbnRleHQubXNnU2VyaWFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKClcIixcbiAgICAgICAgICBcIlRyYW5zcG9ydCBwYXJhbXMgPSBcIiArIHRyYW5zcG9ydFBhcmFtcy50b1N0cmluZygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayh0cmFuc3BvcnRQYXJhbXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGNvbm5lY3QgdXNpbmcgYSBnaXZlbiB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgKiBAcGFyYW0gY2FuZGlkYXRlLCB0aGUgdHJhbnNwb3J0IHRvIHRyeVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpXCIsIFwidHJ5aW5nIFwiICsgY2FuZGlkYXRlKTtcbiAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0ID0gdHJhbnNwb3J0X2RlZmF1bHQudHJ5Q29ubmVjdChcbiAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNwb3J0c1tjYW5kaWRhdGVdLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMucmVhbHRpbWUuYXV0aCxcbiAgICAgIHRyYW5zcG9ydFBhcmFtcyxcbiAgICAgICh3cmFwcGVkRXJyLCB0cmFuc3BvcnQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2luZyB8fCBzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZmFpbGVkKSB7XG4gICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgICAgICBcImNvbm5lY3Rpb24gXCIgKyBzdGF0ZS5zdGF0ZSArIFwiIHdoaWxlIHdlIHdlcmUgYXR0ZW1wdGluZyB0aGUgdHJhbnNwb3J0OyBjbG9zaW5nIFwiICsgdHJhbnNwb3J0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBlZEVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KClcIixcbiAgICAgICAgICAgIFwidHJhbnNwb3J0IFwiICsgY2FuZGlkYXRlICsgXCIgXCIgKyB3cmFwcGVkRXJyLmV2ZW50ICsgXCIsIGVycjogXCIgKyB3cmFwcGVkRXJyLmVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih3cmFwcGVkRXJyLmVycm9yKSAmJiAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gd3JhcHBlZEVyci5lcnJvcjtcbiAgICAgICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLnJlYWx0aW1lLmF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCksIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXRyaWFibGUod3JhcHBlZEVyci5lcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgIFwidmlhYmxlIHRyYW5zcG9ydCBcIiArIGNhbmRpZGF0ZSArIFwiOyBzZXR0aW5nIHBlbmRpbmdcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGluZGljYXRlZCB0byBiZSB2aWFibGUsIGFuZCB0aGUgQ29ubmVjdGlvbk1hbmFnZXJcbiAgICogZXhwZWN0cyB0byBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCBhcyBzb29uIGFzIGl0IGlzIGNvbm5lY3RlZC5cbiAgICogQHBhcmFtIHRyYW5zcG9ydFxuICAgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG4gICAqL1xuICBzZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgY29uc3QgbW9kZSA9IHRyYW5zcG9ydFBhcmFtcy5tb2RlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFuc3BvcnRQZW5kaW5nKClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnQgKyBcIjsgbW9kZSA9IFwiICsgbW9kZVxuICAgICk7XG4gICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRyYW5zcG9ydC5vbmNlKFwiY29ubmVjdGVkXCIsIChlcnJvciwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgIGlmIChtb2RlID09PSBcInJlY292ZXJcIiAmJiB0aGlzLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnJlY292ZXI7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICB0cmFuc3BvcnQub24oW1wiZGlzY29ubmVjdGVkXCIsIFwiY2xvc2VkXCIsIFwiZmFpbGVkXCJdLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZjIuZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRoaXMuZXZlbnQsIGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnQucGVuZGluZ1wiLCB0cmFuc3BvcnQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsIGFuZCB0aGUgY29ubmVjdGlvbm1hbmFnZXIgZGVjaWRlcyB0aGF0XG4gICAqIGl0IHdpbGwgbm93IGJlIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGl0IGFjdGl2YXRlZFxuICAgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0IHRoZSB0cmFuc3BvcnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCB0aGUgaWQgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKi9cbiAgYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcInRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0XG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIiwgXCJlcnJvciA9IFwiICsgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbklkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25JZCA9ICBcIiArIGNvbm5lY3Rpb25JZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25EZXRhaWxzID0gIFwiICsgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbkRldGFpbHMpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydCk7XG4gICAgY29uc3QgZXhpc3RpbmdTdGF0ZSA9IHRoaXMuc3RhdGUsIGNvbm5lY3RlZFN0YXRlID0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcImN1cnJlbnQgc3RhdGUgPSBcIiArIGV4aXN0aW5nU3RhdGUuc3RhdGVcbiAgICApO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3Npbmcuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5mYWlsZWQuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGlzY29ubmVjdGluZyB0cmFuc3BvcnQgYW5kIGFiYW5kb25pbmdcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQ7XG4gICAgaWYgKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGVjbGluaW5nIHRvIGFjdGl2YXRlIHRyYW5zcG9ydCBcIiArIHRyYW5zcG9ydCArIFwiIHNpbmNlIGl0IGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIGNvbm5lY3RlZFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0FjdGl2ZVByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbDtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbmV3IHByb3RvY29sX2RlZmF1bHQodHJhbnNwb3J0KTtcbiAgICB0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG4gICAgY29uc3QgY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gICAgaWYgKGNvbm5lY3Rpb25LZXkgJiYgdGhpcy5jb25uZWN0aW9uS2V5ICE9IGNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCAhIWVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0cmFuc3BvcnQub24oXG4gICAgICAgIFwiY29ubmVjdGVkXCIsXG4gICAgICAgIChjb25uZWN0ZWRFcnIsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzMikgPT4ge1xuICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlsczIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfZGVmYXVsdChjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGNvbm5lY3RlZEVycikpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3I7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBlcnJvcikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGVkXCIsIGVycm9yIH0pO1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yIHx8IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5hY3RpdmVcIiwgdHJhbnNwb3J0KTtcbiAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgPiAwKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgICAgXCJQcmV2aW91cyBhY3RpdmUgcHJvdG9jb2wgKGZvciB0cmFuc3BvcnQgXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIiwgbmV3IG9uZSBpcyBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIikgZmluaXNoaW5nIHdpdGggXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgXCIgbWVzc2FnZXMgc3RpbGwgcGVuZGluZ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkFzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCB3YXMgYWxzbyB0aGUgdHJhbnNwb3J0IGZvciB0aGUgcHJldmlvdXMgYWN0aXZlIHByb3RvY29sOyB0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIjsgc3RhY2sgPSBcIiArIG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsIG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0FjdGl2ZVByb3RvY29sLmZpbmlzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBUaGlzIGNhbiBvY2N1clxuICAgKiBpbiBhbnkgdHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICovXG4gIGRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCBzdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBjdXJyZW50UHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sLCB3YXNBY3RpdmUgPSBjdXJyZW50UHJvdG9jb2wgJiYgY3VycmVudFByb3RvY29sLmdldFRyYW5zcG9ydCgpID09PSB0cmFuc3BvcnQsIHdhc1BlbmRpbmcgPSB0cmFuc3BvcnQgPT09IHRoaXMucGVuZGluZ1RyYW5zcG9ydCwgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IHRoaXMubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnRcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwic3RhdGUgPSBcIiArIHN0YXRlICsgKHdhc0FjdGl2ZSA/IFwiOyB3YXMgYWN0aXZlXCIgOiB3YXNQZW5kaW5nID8gXCI7IHdhcyBwZW5kaW5nXCIgOiBcIlwiKSArIChub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID8gXCJcIiA6IFwiOyBhbm90aGVyIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb25cIilcbiAgICApO1xuICAgIGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlKVxuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcInJlYXNvbiA9ICBcIiArIGVycm9yLm1lc3NhZ2VcbiAgICAgICk7XG4gICAgaWYgKHdhc0FjdGl2ZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcIkdldHRpbmcsIGNsZWFyaW5nLCBhbmQgcmVxdWV1aW5nIFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArIFwiIHBlbmRpbmcgbWVzc2FnZXNcIlxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcbiAgICAgIGN1cnJlbnRQcm90b2NvbC5jbGVhclBlbmRpbmdNZXNzYWdlcygpO1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbCA9IHRoaXMuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5pbmFjdGl2ZVwiLCB0cmFuc3BvcnQpO1xuICAgIGlmICh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiB8fCB3YXNBY3RpdmUgJiYgc3RhdGUgPT09IFwiZmFpbGVkXCIgfHwgc3RhdGUgPT09IFwiY2xvc2VkXCIgfHwgY3VycmVudFByb3RvY29sID09PSBudWxsICYmIHdhc1BlbmRpbmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiBlcnJvciAmJiBlcnJvci5zdGF0dXNDb2RlID4gNTAwICYmIHRoaXMuZG9tYWlucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICB0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlLCBlcnJvciwgcmV0cnlJbW1lZGlhdGVseTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3Q29ubmVjdGlvblN0YXRlID0gc3RhdGUgPT09IFwiZmFpbGVkXCIgJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoZXJyb3IpID8gXCJkaXNjb25uZWN0ZWRcIiA6IHN0YXRlO1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBuZXdDb25uZWN0aW9uU3RhdGUsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvKiBIZWxwZXIgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMgd2hpY2ggYXJlIHBlbmRpbmcsXG4gICAqIGhhdmUgYmVlbiBjb25uZWN0ZWQsIGFuZCBhcmUganVzdCB3YWl0aW5nIGZvciBvbmNlTm9QZW5kaW5nIHRvIGZpcmUgYmVmb3JlXG4gICAqIGJlaW5nIGFjdGl2YXRlZCAqL1xuICBub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5wZW5kaW5nVHJhbnNwb3J0IHx8ICF0aGlzLnBlbmRpbmdUcmFuc3BvcnQuaXNDb25uZWN0ZWQ7XG4gIH1cbiAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBoYXNDb25uZWN0aW9uRXJyb3IpIHtcbiAgICBjb25zdCBwcmV2Q29ubklkID0gdGhpcy5jb25uZWN0aW9uSWQsIGNvbm5JZENoYW5nZWQgPSBwcmV2Q29ubklkICYmIHByZXZDb25uSWQgIT09IGNvbm5lY3Rpb25JZCwgcmVjb3ZlckZhaWx1cmUgPSAhcHJldkNvbm5JZCAmJiBoYXNDb25uZWN0aW9uRXJyb3I7XG4gICAgaWYgKGNvbm5JZENoYW5nZWQgfHwgcmVjb3ZlckZhaWx1cmUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKVwiLCBcIlJlc2V0dGluZyBtc2dTZXJpYWxcIik7XG4gICAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnJlc2V0U2VuZEF0dGVtcHRlZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uSWQgIT09IGNvbm5lY3Rpb25JZCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKVwiLFxuICAgICAgICBcIk5ldyBjb25uZWN0aW9uSWQ7IHJlYXR0YWNoaW5nIGFueSBhdHRhY2hlZCBjaGFubmVsc1wiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvbktleTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmlkID0gdGhpcy5jb25uZWN0aW9uSWQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IHZvaWQgMDtcbiAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5yZXNldFNlbmRBdHRlbXB0ZWQoKTtcbiAgICB0aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcbiAgfVxuICBjcmVhdGVSZWNvdmVyeUtleSgpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG4gICAgICBtc2dTZXJpYWw6IHRoaXMubXNnU2VyaWFsLFxuICAgICAgY2hhbm5lbFNlcmlhbHM6IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuY2hhbm5lbFNlcmlhbHMoKVxuICAgIH0pO1xuICB9XG4gIGNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCkge1xuICAgIGlmICghdGhpcy5sYXN0QWN0aXZpdHkgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpbmNlTGFzdCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICBpZiAoc2luY2VMYXN0ID4gdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgKyB0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKClcIixcbiAgICAgICAgXCJMYXN0IGtub3duIGFjdGl2aXR5IGZyb20gcmVhbHRpbWUgd2FzIFwiICsgc2luY2VMYXN0ICsgXCJtcyBhZ287IGRpc2NhcmRpbmcgY29ubmVjdGlvbiBzdGF0ZVwiXG4gICAgICApO1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICAgIHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gXCJzdXNwZW5kZWRcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgKi9cbiAgcGVyc2lzdENvbm5lY3Rpb24oKSB7XG4gICAgaWYgKGhhdmVTZXNzaW9uU3RvcmFnZSgpKSB7XG4gICAgICBjb25zdCByZWNvdmVyeUtleSA9IHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgICAgIGlmIChyZWNvdmVyeUtleSkge1xuICAgICAgICB0aGlzLnNldFNlc3Npb25SZWNvdmVyRGF0YSh7XG4gICAgICAgICAgcmVjb3ZlcnlLZXksXG4gICAgICAgICAgZGlzY29ubmVjdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgbG9jYXRpb246IGdsb2JhbE9iamVjdDIubG9jYXRpb24sXG4gICAgICAgICAgY2xpZW50SWQ6IHRoaXMucmVhbHRpbWUuYXV0aC5jbGllbnRJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgKi9cbiAgdW5wZXJzaXN0Q29ubmVjdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCk7XG4gIH1cbiAgZ2V0QWN0aXZlVHJhbnNwb3J0Rm9ybWF0KCkge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIChfYTIgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYW5zcG9ydCgpLmZvcm1hdDtcbiAgfVxuICAvKioqKioqKioqKioqKioqKioqKioqXG4gICAqIHN0YXRlIG1hbmFnZW1lbnRcbiAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgZ2V0RXJyb3IoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3JSZWFzb24pIHtcbiAgICAgIGNvbnN0IG5ld0Vycm9yID0gUGFydGlhbEVycm9ySW5mby5mcm9tVmFsdWVzKHRoaXMuZXJyb3JSZWFzb24pO1xuICAgICAgbmV3RXJyb3IuY2F1c2UgPSB0aGlzLmVycm9yUmVhc29uO1xuICAgICAgcmV0dXJuIG5ld0Vycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZUVycm9yKCk7XG4gIH1cbiAgZ2V0U3RhdGVFcnJvcigpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbdGhpcy5zdGF0ZS5zdGF0ZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMik7XG4gIH1cbiAgYWN0aXZlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucXVldWVFdmVudHMgfHwgdGhpcy5zdGF0ZS5zZW5kRXZlbnRzO1xuICB9XG4gIGVuYWN0U3RhdGVDaGFuZ2Uoc3RhdGVDaGFuZ2UpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBcIkNvbm5lY3Rpb24gc3RhdGVcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gc3RhdGVDaGFuZ2UuY3VycmVudCArIChzdGF0ZUNoYW5nZS5yZWFzb24gPyBcIjsgcmVhc29uOiBcIiArIHN0YXRlQ2hhbmdlLnJlYXNvbiA6IFwiXCIpO1xuICAgIGlmIChzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSBcImZhaWxlZFwiKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYWN0aW9uLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5lbmFjdFN0YXRlQ2hhbmdlXCIsXG4gICAgICBcInNldHRpbmcgbmV3IHN0YXRlOiBcIiArIHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyBcIjsgcmVhc29uID0gXCIgKyAoc3RhdGVDaGFuZ2UucmVhc29uICYmIHN0YXRlQ2hhbmdlLnJlYXNvbi5tZXNzYWdlKVxuICAgICk7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVDaGFuZ2UuY3VycmVudF07XG4gICAgaWYgKHN0YXRlQ2hhbmdlLnJlYXNvbikge1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcbiAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcbiAgICB9XG4gICAgaWYgKG5ld1N0YXRlLnRlcm1pbmFsIHx8IG5ld1N0YXRlLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uc3RhdGVcIiwgc3RhdGVDaGFuZ2UpO1xuICB9XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIENvbm5lY3Rpb25NYW5hZ2VyIGNvbm5lY3Rpb24gbGlmZWN5Y2xlXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICBzdGFydFRyYW5zaXRpb25UaW1lcih0cmFuc2l0aW9uU3RhdGUpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKVwiLFxuICAgICAgXCJ0cmFuc2l0aW9uU3RhdGU6IFwiICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlXG4gICAgKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zdGFydFRyYW5zaXRpb25UaW1lcigpXCIsXG4gICAgICAgIFwiY2xlYXJpbmcgYWxyZWFkeS1ydW5uaW5nIHRpbWVyXCJcbiAgICAgICk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFwiICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlICsgXCIgdGltZXIgZXhwaXJlZFwiLFxuICAgICAgICAgIFwicmVxdWVzdGluZyBuZXcgc3RhdGU6IFwiICsgdHJhbnNpdGlvblN0YXRlLmZhaWxTdGF0ZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGUgfSk7XG4gICAgICB9XG4gICAgfSwgdHJhbnNpdGlvblN0YXRlLnJldHJ5RGVsYXkpO1xuICB9XG4gIGNhbmNlbFRyYW5zaXRpb25UaW1lcigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKVwiLCBcIlwiKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25UaW1lcik7XG4gICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0U3VzcGVuZFRpbWVyKCkge1xuICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnN1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3VzcGVuZFRpbWVyKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIHN1c3BlbmQgdGltZXIgZXhwaXJlZFwiLFxuICAgICAgICAgIFwicmVxdWVzdGluZyBuZXcgc3RhdGU6IHN1c3BlbmRlZFwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gXCJzdXNwZW5kZWRcIjtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcInN1c3BlbmRlZFwiIH0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsKTtcbiAgfVxuICBjaGVja1N1c3BlbmRUaW1lcihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAhPT0gXCJkaXNjb25uZWN0ZWRcIiAmJiBzdGF0ZSAhPT0gXCJzdXNwZW5kZWRcIiAmJiBzdGF0ZSAhPT0gXCJjb25uZWN0aW5nXCIpXG4gICAgICB0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xuICB9XG4gIGNhbmNlbFN1c3BlbmRUaW1lcigpIHtcbiAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gICAgaWYgKHRoaXMuc3VzcGVuZFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zdXNwZW5kVGltZXIpO1xuICAgICAgdGhpcy5zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFJldHJ5VGltZXIoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyIHJldHJ5IHRpbWVyIGV4cGlyZWRcIiwgXCJyZXRyeWluZ1wiKTtcbiAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH1cbiAgY2FuY2VsUmV0cnlUaW1lcigpIHtcbiAgICBpZiAodGhpcy5yZXRyeVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcbiAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0V2ViU29ja2V0U2xvd1RpbWVyKCkge1xuICAgIHRoaXMud2ViU29ja2V0U2xvd1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgXCJjaGVja2luZyBjb25uZWN0aXZpdHlcIlxuICAgICAgKTtcbiAgICAgIHRoaXMuY2hlY2tXc0Nvbm5lY3Rpdml0eSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgICBcIndzIGNvbm5lY3Rpdml0eSBjaGVjayBzdWNjZWVkZWRcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLndzQ2hlY2tSZXN1bHQgPSB0cnVlO1xuICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgICBcIndzIGNvbm5lY3Rpdml0eSBjaGVjayBmYWlsZWRcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLndzQ2hlY2tSZXN1bHQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSkge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXModGhpcy5yZWFsdGltZS5odHRwLmNoZWNrQ29ubmVjdGl2aXR5KCksIChlcnIsIGNvbm5lY3Rpdml0eSkgPT4ge1xuICAgICAgICAgIGlmIChlcnIgfHwgIWNvbm5lY3Rpdml0eSkge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgICAgIFwiaHR0cCBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHtcbiAgICAgICAgICAgICAgc3RhdGU6IFwiZGlzY29ubmVjdGVkXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGNvbm5lY3QgKG5ldHdvcmsgdW5yZWFjaGFibGUpXCIsIDgwMDAzLCA0MDQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgICAgIFwiaHR0cCBjb25uZWN0aXZpdHkgY2hlY2sgc3VjY2VlZGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dHMud2ViU29ja2V0U2xvd1RpbWVvdXQpO1xuICB9XG4gIGNhbmNlbFdlYlNvY2tldFNsb3dUaW1lcigpIHtcbiAgICBpZiAodGhpcy53ZWJTb2NrZXRTbG93VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndlYlNvY2tldFNsb3dUaW1lcik7XG4gICAgICB0aGlzLndlYlNvY2tldFNsb3dUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0V2ViU29ja2V0R2l2ZVVwVGltZXIodHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgdGhpcy53ZWJTb2NrZXRHaXZlVXBUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICBpZiAoIXRoaXMud3NDaGVja1Jlc3VsdCkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IGdpdmUgdXAgdGltZXJcIixcbiAgICAgICAgICBcIndlYnNvY2tldCBjb25uZWN0aW9uIHRvb2sgbW9yZSB0aGFuIDEwczsgXCIgKyAodGhpcy5iYXNlVHJhbnNwb3J0ID8gXCJ0cnlpbmcgYmFzZSB0cmFuc3BvcnRcIiA6IFwiXCIpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0aGlzLmJhc2VUcmFuc3BvcnQpIHtcbiAgICAgICAgICB0aGlzLmFiYW5kb25lZFdlYlNvY2tldCA9IHRydWU7XG4gICAgICAgICAgKF9hMiA9IHRoaXMucHJvcG9zZWRUcmFuc3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZGlzcG9zZSgpO1xuICAgICAgICAgIChfYiA9IHRoaXMucGVuZGluZ1RyYW5zcG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RCYXNlKHRyYW5zcG9ydFBhcmFtcywgKyt0aGlzLmNvbm5lY3RDb3VudGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IGdpdmUgdXAgdGltZXJcIixcbiAgICAgICAgICAgIFwid2Vic29ja2V0IGNvbm5lY3Rpdml0eSBhcHBlYXJzIHRvIGJlIHVuYXZhaWxhYmxlIGJ1dCBubyBvdGhlciB0cmFuc3BvcnRzIHRvIHRyeVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy53ZWJTb2NrZXRDb25uZWN0VGltZW91dCk7XG4gIH1cbiAgY2FuY2VsV2ViU29ja2V0R2l2ZVVwVGltZXIoKSB7XG4gICAgaWYgKHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyKTtcbiAgICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBub3RpZnlTdGF0ZShpbmRpY2F0ZWQpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBjb25zdCBzdGF0ZSA9IGluZGljYXRlZC5zdGF0ZTtcbiAgICBjb25zdCByZXRyeUltbWVkaWF0ZWx5ID0gc3RhdGUgPT09IFwiZGlzY29ubmVjdGVkXCIgJiYgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCB8fCBpbmRpY2F0ZWQucmV0cnlJbW1lZGlhdGVseSB8fCB0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nICYmIGluZGljYXRlZC5lcnJvciAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycihpbmRpY2F0ZWQuZXJyb3IpICYmICEodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpXCIsXG4gICAgICBcIm5ldyBzdGF0ZTogXCIgKyBzdGF0ZSArIChyZXRyeUltbWVkaWF0ZWx5ID8gXCI7IHdpbGwgcmV0cnkgY29ubmVjdGlvbiBpbW1lZGlhdGVseVwiIDogXCJcIilcbiAgICApO1xuICAgIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRTbG93VGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCk7XG4gICAgdGhpcy5jaGVja1N1c3BlbmRUaW1lcihpbmRpY2F0ZWQuc3RhdGUpO1xuICAgIGlmIChzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiB8fCBzdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUudGVybWluYWwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tpbmRpY2F0ZWQuc3RhdGVdO1xuICAgIGxldCByZXRyeURlbGF5ID0gbmV3U3RhdGUucmV0cnlEZWxheTtcbiAgICBpZiAobmV3U3RhdGUuc3RhdGUgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCsrO1xuICAgICAgcmV0cnlEZWxheSA9IGdldFJldHJ5VGltZShuZXdTdGF0ZS5yZXRyeURlbGF5LCB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQpO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2UgPSBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoXG4gICAgICB0aGlzLnN0YXRlLnN0YXRlLFxuICAgICAgbmV3U3RhdGUuc3RhdGUsXG4gICAgICByZXRyeURlbGF5LFxuICAgICAgaW5kaWNhdGVkLmVycm9yIHx8ICgoX2IgPSAoX2EyID0gY29ubmVjdGlvbmVycm9yc19kZWZhdWx0KVtuZXdTdGF0ZS5zdGF0ZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMikpXG4gICAgKTtcbiAgICBpZiAocmV0cnlJbW1lZGlhdGVseSkge1xuICAgICAgY29uc3QgYXV0b1JlY29ubmVjdCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNpbmNlTGFzdCA9IHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICYmIERhdGUubm93KCkgLSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCArIDE7XG4gICAgICBpZiAoc2luY2VMYXN0ICYmIHNpbmNlTGFzdCA8IDFlMykge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgICAgIFwiTGFzdCByZWNvbm5lY3QgYXR0ZW1wdCB3YXMgb25seSBcIiArIHNpbmNlTGFzdCArIFwibXMgYWdvLCB3YWl0aW5nIGFub3RoZXIgXCIgKyAoMWUzIC0gc2luY2VMYXN0KSArIFwibXMgYmVmb3JlIHRyeWluZyBhZ2FpblwiXG4gICAgICAgICk7XG4gICAgICAgIHNldFRpbWVvdXQoYXV0b1JlY29ubmVjdCwgMWUzIC0gc2luY2VMYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljayhhdXRvUmVjb25uZWN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiIHx8IHN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcihyZXRyeURlbGF5KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiICYmICFyZXRyeUltbWVkaWF0ZWx5IHx8IHN0YXRlID09PSBcInN1c3BlbmRlZFwiIHx8IG5ld1N0YXRlLnRlcm1pbmFsKSB7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGVkXCIgJiYgIXRoaXMuYWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpXCIsXG4gICAgICAgIFwiQnJva2VuIGludmFyaWFudDogYXR0ZW1wdGVkIHRvIGdvIGludG8gY29ubmVjdGVkIHN0YXRlLCBidXQgdGhlcmUgaXMgbm8gYWN0aXZlIHByb3RvY29sXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW5hY3RTdGF0ZUNoYW5nZShjaGFuZ2UpO1xuICAgIGlmICh0aGlzLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIHRoaXMuc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cykge1xuICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKHN0YXRlLCBjaGFuZ2UucmVhc29uKTtcbiAgICAgIHRoaXMuZmFpbFF1ZXVlZE1lc3NhZ2VzKGNoYW5nZS5yZWFzb24pO1xuICAgIH1cbiAgfVxuICByZXF1ZXN0U3RhdGUocmVxdWVzdCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGNvbnN0IHN0YXRlID0gcmVxdWVzdC5zdGF0ZTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKClcIixcbiAgICAgIFwicmVxdWVzdGVkIHN0YXRlOiBcIiArIHN0YXRlICsgXCI7IGN1cnJlbnQgc3RhdGU6IFwiICsgdGhpcy5zdGF0ZS5zdGF0ZVxuICAgICk7XG4gICAgaWYgKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRTbG93VGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICB0aGlzLmNoZWNrU3VzcGVuZFRpbWVyKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT0gXCJjb25uZWN0aW5nXCIgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSBcImNvbm5lY3RlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzdGF0ZSA9PSBcImNsb3NpbmdcIiAmJiB0aGlzLnN0YXRlLnN0YXRlID09IFwiY2xvc2VkXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZV0sIGNoYW5nZSA9IG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfZGVmYXVsdChcbiAgICAgIHRoaXMuc3RhdGUuc3RhdGUsXG4gICAgICBuZXdTdGF0ZS5zdGF0ZSxcbiAgICAgIG51bGwsXG4gICAgICByZXF1ZXN0LmVycm9yIHx8ICgoX2IgPSAoX2EyID0gY29ubmVjdGlvbmVycm9yc19kZWZhdWx0KVtuZXdTdGF0ZS5zdGF0ZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMikpXG4gICAgKTtcbiAgICB0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcbiAgICBpZiAoc3RhdGUgPT0gXCJjb25uZWN0aW5nXCIpIHtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhcnRDb25uZWN0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09IFwiY2xvc2luZ1wiKSB7XG4gICAgICB0aGlzLmNsb3NlSW1wbCgpO1xuICAgIH1cbiAgfVxuICBzdGFydENvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKVwiLFxuICAgICAgICBcIk11c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0LCBidXQgd2FzIFwiICsgdGhpcy5zdGF0ZS5zdGF0ZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXV0aCA9IHRoaXMucmVhbHRpbWUuYXV0aDtcbiAgICBjb25zdCBjb25uZWN0Q291bnQgPSArK3RoaXMuY29ubmVjdENvdW50ZXI7XG4gICAgY29uc3QgY29ubmVjdCA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKTtcbiAgICAgIHRoaXMuZ2V0VHJhbnNwb3J0UGFyYW1zKCh0cmFuc3BvcnRQYXJhbXMpID0+IHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydFBhcmFtcy5tb2RlID09PSBcInJlY292ZXJcIiAmJiB0cmFuc3BvcnRQYXJhbXMub3B0aW9ucy5yZWNvdmVyKSB7XG4gICAgICAgICAgY29uc3QgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkodHJhbnNwb3J0UGFyYW1zLm9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgICAgaWYgKHJlY292ZXJ5Q29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5yZWNvdmVyQ2hhbm5lbHMocmVjb3ZlcnlDb250ZXh0LmNoYW5uZWxTZXJpYWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KClcIiwgXCJzdGFydGluZyBjb25uZWN0aW9uXCIpO1xuICAgIHRoaXMuc3RhcnRTdXNwZW5kVGltZXIoKTtcbiAgICB0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpO1xuICAgIGlmIChhdXRoLm1ldGhvZCA9PT0gXCJiYXNpY1wiKSB7XG4gICAgICBjb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGF1dGhDYiA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmVycm9yUmVhc29uICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhhdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwpLCBhdXRoQ2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKGF1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlKSwgYXV0aENiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLypcbiAgICogdGhlcmUgYXJlLCBhdCBtb3N0LCB0d28gdHJhbnNwb3J0cyBhdmFpbGFibGUgd2l0aCB3aGljaCBhIGNvbm5lY3Rpb24gbWF5XG4gICAqIGJlIGF0dGVtcHRlZDogd2ViX3NvY2tldCBhbmQvb3IgYSBiYXNlIHRyYW5zcG9ydCAoeGhyX3BvbGxpbmcgaW4gYnJvd3NlcnMsXG4gICAqIGNvbWV0IGluIG5vZGVqcykuIHdlYl9zb2NrZXQgaXMgYWx3YXlzIHByZWZlcnJlZCwgYW5kIHRoZSBiYXNlIHRyYW5zcG9ydCBpc1xuICAgKiBvbmx5IHVzZWQgaW4gY2FzZSB3ZWJfc29ja2V0IGNvbm5lY3Rpdml0eSBhcHBlYXJzIHRvIGJlIHVuYXZhaWxhYmxlLlxuICAgKlxuICAgKiBjb25uZWN0SW1wbCBiZWdpbnMgdGhlIHRyYW5zcG9ydCBzZWxlY3Rpb24gcHJvY2VzcyBieSBjaGVja2luZyB3aGljaCB0cmFuc3BvcnRzXG4gICAqIGFyZSBhdmFpbGFibGUsIGFuZCBpZiB0aGVyZSBpcyBhIGNhY2hlZCBwcmVmZXJlbmNlLiBJdCB0aGVuIGRlZmVycyB0byB0aGVcbiAgICogdHJhbnNwb3J0LXNwZWNpZmljIGNvbm5lY3QgbWV0aG9kczogY29ubmVjdFdzIGFuZCBjb25uZWN0QmFzZS5cbiAgICpcbiAgICogSXQgaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgaW52YWxpZGF0aW5nIHRoZSBjYWNoZSBpbiB0aGUgY2FzZSB0aGF0IGEgYmFzZVxuICAgKiB0cmFuc3BvcnQgcHJlZmVyZW5jZSBpcyBzdG9yZWQgYnV0IHdlYiBzb2NrZXQgY29ubmVjdGl2aXR5IGlzIG5vdyBhdmFpbGFibGUuXG4gICAqXG4gICAqIGhhbmRsaW5nIG9mIHRoZSBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gZmFpbG92ZXIgZnJvbSB3ZWJfc29ja2V0IHRvIHRoZSBiYXNlXG4gICAqIHRyYW5zcG9ydCBpcyBpbXBsZW1lbnRlZCBpbiB0aGUgY29ubmVjdFdzIG1ldGhvZC5cbiAgICovXG4gIGNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnN0YXRlO1xuICAgIGlmIChzdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5zdGF0ZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RJbXBsKClcIixcbiAgICAgICAgXCJNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCwgYnV0IHdhcyBcIiArIHN0YXRlXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc3BvcnRQcmVmZXJlbmNlID0gdGhpcy5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgaWYgKHRyYW5zcG9ydFByZWZlcmVuY2UgJiYgdHJhbnNwb3J0UHJlZmVyZW5jZSA9PT0gdGhpcy5iYXNlVHJhbnNwb3J0ICYmIHRoaXMud2ViU29ja2V0VHJhbnNwb3J0QXZhaWxhYmxlKSB7XG4gICAgICB0aGlzLmNoZWNrV3NDb25uZWN0aXZpdHkoKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RJbXBsKCk6XCIsXG4gICAgICAgICAgICBcIndlYiBzb2NrZXQgY29ubmVjdGl2aXR5IGF2YWlsYWJsZSwgY2FuY2VsbGluZyBjb25uZWN0aW9uIGF0dGVtcHQgd2l0aCBcIiArIHRoaXMuYmFzZVRyYW5zcG9ydFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgIHRoaXMuY29ubmVjdFdzKHRyYW5zcG9ydFBhcmFtcywgKyt0aGlzLmNvbm5lY3RDb3VudGVyKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2gobm9vcDIpO1xuICAgIH1cbiAgICBpZiAodHJhbnNwb3J0UHJlZmVyZW5jZSAmJiB0cmFuc3BvcnRQcmVmZXJlbmNlID09PSB0aGlzLmJhc2VUcmFuc3BvcnQgfHwgdGhpcy5iYXNlVHJhbnNwb3J0ICYmICF0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29ubmVjdFdzKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICB9XG4gIH1cbiAgLypcbiAgICogY29ubmVjdFdzIHN0YXJ0cyB0d28gdGltZXJzIHRvIG1vbml0b3IgdGhlIHN1Y2Nlc3Mgb2YgYSB3ZWJfc29ja2V0IGNvbm5lY3Rpb24gYXR0ZW1wdDpcbiAgICogLSB3ZWJTb2NrZXRTbG93VGltZXI6IGlmIHRoaXMgdGltZXIgZmlyZXMgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHN1Y2NlZWRzLFxuICAgKiAgIGNtIHdpbGwgc2ltdWx0YW5lb3VzbHkgY2hlY2sgd2Vic29ja2V0IGFuZCBodHRwL3hociBjb25uZWN0aXZpdHkuIGlmIHRoZSBodHRwXG4gICAqICAgY29ubmVjdGl2aXR5IGNoZWNrIGZhaWxzLCB3ZSBnaXZlIHVwIHRoZSBjb25uZWN0aW9uIHNlcXVlbmNlIGVudGlyZWx5IGFuZFxuICAgKiAgIHRyYW5zaXRpb24gdG8gZGlzY29ubmVjdGVkLiBpZiB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpdml0eSBjaGVjayBmYWlscyB0aGVuXG4gICAqICAgd2UgYXNzdW1lIG5vIHdzIGNvbm5lY3Rpdml0eSBhbmQgZmFpbG92ZXIgdG8gYmFzZSB0cmFuc3BvcnQuIGluIHRoZSBjYXNlIHRoYXRcbiAgICogICB0aGUgY2hlY2tzIHN1Y2NlZWQsIHdlIGNvbnRpbnVlIHdpdGggd2Vic29ja2V0IGFuZCB3YWl0IGZvciBpdCB0byB0cnkgZmFsbGJhY2sgaG9zdHNcbiAgICogICBhbmQsIGlmIHVuc3VjY2Vzc2Z1bCwgdWx0aW1hdGVseSB0cmFuc2l0aW9uIHRvIGRpc2Nvbm5lY3RlZC5cbiAgICogLSB3ZWJTb2NrZXRHaXZlVXBUaW1lcjogaWYgdGhpcyB0aW1lciBmaXJlcywgYW5kIHRoZSBwcmVjZWRpbmcgd2Vic29ja2V0XG4gICAqICAgY29ubmVjdGl2aXR5IGNoZWNrIGlzIHN0aWxsIHBlbmRpbmcgdGhlbiB3ZSBhc3N1bWUgdGhhdCB0aGVyZSBpcyBhbiBpc3N1ZVxuICAgKiAgIHdpdGggdGhlIHRyYW5zcG9ydCBhbmQgZmFsbGJhY2sgdG8gYmFzZSB0cmFuc3BvcnQuXG4gICAqL1xuICBjb25uZWN0V3ModHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0V3MoKVwiKTtcbiAgICB0aGlzLndzQ2hlY2tSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMuYWJhbmRvbmVkV2ViU29ja2V0ID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFdlYlNvY2tldFNsb3dUaW1lcigpO1xuICAgIHRoaXMuc3RhcnRXZWJTb2NrZXRHaXZlVXBUaW1lcih0cmFuc3BvcnRQYXJhbXMpO1xuICAgIHRoaXMudHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcyhcIndlYl9zb2NrZXRcIiwgdHJhbnNwb3J0UGFyYW1zLCB0cnVlLCBjb25uZWN0Q291bnQsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLndzQ2hlY2tSZXN1bHQgIT09IGZhbHNlICYmICF0aGlzLmFiYW5kb25lZFdlYlNvY2tldDtcbiAgICB9KTtcbiAgfVxuICBjb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RCYXNlKClcIik7XG4gICAgaWYgKHRoaXMuYmFzZVRyYW5zcG9ydCkge1xuICAgICAgdGhpcy50cnlUcmFuc3BvcnRXaXRoRmFsbGJhY2tzKHRoaXMuYmFzZVRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zLCBmYWxzZSwgY29ubmVjdENvdW50LCAoKSA9PiB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7XG4gICAgICAgIHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcIk5vIHRyYW5zcG9ydHMgbGVmdCB0byB0cnlcIiwgOGU0LCA0MDQpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcyh0cmFuc3BvcnROYW1lLCB0cmFuc3BvcnRQYXJhbXMsIHdzLCBjb25uZWN0Q291bnQsIHNob3VsZENvbnRpbnVlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3MoKVwiLFxuICAgICAgdHJhbnNwb3J0TmFtZVxuICAgICk7XG4gICAgY29uc3QgZ2l2ZVVwID0gKGVycikgPT4ge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IGVyciB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbmRpZGF0ZUhvc3RzID0gdGhpcy5kb21haW5zLnNsaWNlKCk7XG4gICAgY29uc3QgaG9zdEF0dGVtcHRDYiA9IChmYXRhbCwgdHJhbnNwb3J0KSA9PiB7XG4gICAgICBpZiAoY29ubmVjdENvdW50ICE9PSB0aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghc2hvdWxkQ29udGludWUoKSkge1xuICAgICAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcbiAgICAgICAgdHJ5RmFsbGJhY2tIb3N0cygpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICBnaXZlVXAobmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChubyBhdmFpbGFibGUgaG9zdClcIiwgODAwMDMsIDQwNCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IGhvc3Q7XG4gICAgY29uc3QgdHJ5RmFsbGJhY2tIb3N0cyA9ICgpID0+IHtcbiAgICAgIGlmICghY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICAgIGdpdmVVcChuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGNvbm5lY3QgKGFuZCBubyBtb3JlIGZhbGxiYWNrIGhvc3RzIHRvIHRyeSlcIiwgODAwMDMsIDQwNCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSkge1xuICAgICAgICBnaXZlVXAobmV3IFBhcnRpYWxFcnJvckluZm8oXCJJbnRlcm5hbCBlcnJvcjogSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSBub3Qgc2V0XCIsIG51bGwsIDUwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgIHRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpLFxuICAgICAgICAoZXJyLCBjb25uZWN0aXZpdHkpID0+IHtcbiAgICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSB0aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2hvdWxkQ29udGludWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBnaXZlVXAoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGdpdmVVcChuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGNvbm5lY3QgKG5ldHdvcmsgdW5yZWFjaGFibGUpXCIsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBhcnJQb3BSYW5kb21FbGVtZW50KGNhbmRpZGF0ZUhvc3RzKTtcbiAgICAgICAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnROYW1lLCBob3N0QXR0ZW1wdENiKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgICAgdHJ5RmFsbGJhY2tIb3N0cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnROYW1lLCBob3N0QXR0ZW1wdENiKTtcbiAgfVxuICBjbG9zZUltcGwoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKClcIiwgXCJjbG9zaW5nIGNvbm5lY3Rpb25cIik7XG4gICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgICB0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNsb3NpbmcpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdUcmFuc3BvcnQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKVwiLFxuICAgICAgICBcIkNsb3NpbmcgcGVuZGluZyB0cmFuc3BvcnQ6IFwiICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0XG4gICAgICApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKClcIixcbiAgICAgICAgXCJDbG9zaW5nIGFjdGl2ZSB0cmFuc3BvcnQ6IFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKVxuICAgICAgKTtcbiAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImNsb3NlZFwiIH0pO1xuICB9XG4gIG9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzLCBjYWxsYmFjaykge1xuICAgIHZhciBfYTI7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdGVkXCI6IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKVwiLFxuICAgICAgICAgIFwiU2VuZGluZyBBVVRIIG1lc3NhZ2Ugb24gYWN0aXZlIHRyYW5zcG9ydFwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRyYW5zcG9ydCA9IChfYTIgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYW5zcG9ydCgpO1xuICAgICAgICBpZiAoYWN0aXZlVHJhbnNwb3J0ICYmIGFjdGl2ZVRyYW5zcG9ydC5vbkF1dGhVcGRhdGVkKSB7XG4gICAgICAgICAgYWN0aXZlVHJhbnNwb3J0Lm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoTXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25zLkFVVEgsXG4gICAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRva2VuRGV0YWlscy50b2tlblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZChhdXRoTXNnKTtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc0xpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMub2ZmKGZhaWx1cmVMaXN0ZW5lcik7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmFpbHVyZUxpc3RlbmVyID0gKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHN1Y2Nlc3NMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLm9mZihmYWlsdXJlTGlzdGVuZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IHRoaXMuZ2V0U3RhdGVFcnJvcigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25jZShcImNvbm5lY3Rpb25kZXRhaWxzXCIsIHN1Y2Nlc3NMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMub24oXCJjb25uZWN0aW9uc3RhdGVcIiwgZmFpbHVyZUxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpXCIsXG4gICAgICAgICAgXCJBYm9ydGluZyBjdXJyZW50IGNvbm5lY3Rpb24gYXR0ZW1wdHMgaW4gb3JkZXIgdG8gc3RhcnQgYWdhaW4gd2l0aCB0aGUgbmV3IGF1dGggZGV0YWlsc1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKVwiLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbiBzdGF0ZSBpcyBcIiArIHRoaXMuc3RhdGUuc3RhdGUgKyBcIjsgd2FpdGluZyB1bnRpbCBlaXRoZXIgY29ubmVjdGVkIG9yIGZhaWxlZFwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChzdGF0ZUNoYW5nZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwiY29ubmVjdGVkXCI6XG4gICAgICAgICAgICAgIHRoaXMub2ZmKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgICAgICAgIHRoaXMub2ZmKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IHRoaXMuZ2V0U3RhdGVFcnJvcigpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub24oXCJjb25uZWN0aW9uc3RhdGVcIiwgbGlzdGVuZXIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0ZSA9PT0gXCJjb25uZWN0aW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGluZ1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpXCIsXG4gICAgICBcIkRpc2Nvbm5lY3RpbmcgYWxsIHRyYW5zcG9ydHNcIlxuICAgICk7XG4gICAgdGhpcy5jb25uZWN0Q291bnRlcisrO1xuICAgIGlmICh0aGlzLnBlbmRpbmdUcmFuc3BvcnQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpXCIsXG4gICAgICAgIFwiRGlzY29ubmVjdGluZyBwZW5kaW5nIHRyYW5zcG9ydDogXCIgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRcbiAgICAgICk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhbnNwb3J0O1xuICAgIGlmICh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgcHJvcG9zZWQgdHJhbnNwb3J0OiBcIiArIHRoaXMucGVuZGluZ1RyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIHRoaXMucHJvcG9zZWRUcmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhbnNwb3J0O1xuICAgIGlmICh0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgYWN0aXZlIHRyYW5zcG9ydDogXCIgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpXG4gICAgICApO1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG4gIC8qKioqKioqKioqKioqKioqKipcbiAgICogZXZlbnQgcXVldWVpbmdcbiAgICoqKioqKioqKioqKioqKioqKi9cbiAgc2VuZChtc2csIHF1ZXVlRXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wMjtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKVwiLCBcInNlbmRpbmcgZXZlbnRcIik7XG4gICAgICB0aGlzLnNlbmRJbXBsKG5ldyBQZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFF1ZXVlID0gcXVldWVFdmVudCAmJiBzdGF0ZS5xdWV1ZUV2ZW50cztcbiAgICBpZiAoIXNob3VsZFF1ZXVlKSB7XG4gICAgICBjb25zdCBlcnIgPSBcInJlamVjdGluZyBldmVudCwgcXVldWVFdmVudCB3YXMgXCIgKyBxdWV1ZUV2ZW50ICsgXCIsIHN0YXRlIHdhcyBcIiArIHN0YXRlLnN0YXRlO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpXCIsIGVycik7XG4gICAgICBjYWxsYmFjayh0aGlzLmVycm9yUmVhc29uIHx8IG5ldyBFcnJvckluZm8oZXJyLCA5ZTQsIDQwMCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kKClcIixcbiAgICAgICAgXCJxdWV1ZWluZyBtc2c7IFwiICsgc3RyaW5naWZ5KFxuICAgICAgICAgIG1zZyxcbiAgICAgICAgICB0aGlzLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlLFxuICAgICAgICAgIHRoaXMucmVhbHRpbWUuX0Fubm90YXRpb25zLFxuICAgICAgICAgIHRoaXMucmVhbHRpbWUuX2xpdmVPYmplY3RzUGx1Z2luXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucXVldWUobXNnLCBjYWxsYmFjayk7XG4gIH1cbiAgc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpIHtcbiAgICBjb25zdCBtc2cgPSBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlO1xuICAgIGlmIChwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCAmJiAhcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCkge1xuICAgICAgbXNnLm1zZ1NlcmlhbCA9IHRoaXMubXNnU2VyaWFsKys7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLnNlbmQocGVuZGluZ01lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kSW1wbCgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb24gaW4gdHJhbnNwb3J0LnNlbmQoKTogXCIgKyBlLnN0YWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBxdWV1ZShtc2csIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIucXVldWUoKVwiLCBcInF1ZXVlaW5nIGV2ZW50XCIpO1xuICAgIHRoaXMucXVldWVkTWVzc2FnZXMucHVzaChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICB9XG4gIHNlbmRRdWV1ZWRNZXNzYWdlcygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZFF1ZXVlZE1lc3NhZ2VzKClcIixcbiAgICAgIFwic2VuZGluZyBcIiArIHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKSArIFwiIHF1ZXVlZCBtZXNzYWdlc1wiXG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ01lc3NhZ2U7XG4gICAgd2hpbGUgKHBlbmRpbmdNZXNzYWdlID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5zaGlmdCgpKVxuICAgICAgdGhpcy5zZW5kSW1wbChwZW5kaW5nTWVzc2FnZSk7XG4gIH1cbiAgcXVldWVQZW5kaW5nTWVzc2FnZXMocGVuZGluZ01lc3NhZ2VzKSB7XG4gICAgaWYgKHBlbmRpbmdNZXNzYWdlcyAmJiBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIucXVldWVQZW5kaW5nTWVzc2FnZXMoKVwiLFxuICAgICAgICBcInF1ZXVlaW5nIFwiICsgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCArIFwiIHBlbmRpbmcgbWVzc2FnZXNcIlxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucHJlcGVuZChwZW5kaW5nTWVzc2FnZXMpO1xuICAgIH1cbiAgfVxuICBmYWlsUXVldWVkTWVzc2FnZXMoZXJyKSB7XG4gICAgY29uc3QgbnVtUXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpO1xuICAgIGlmIChudW1RdWV1ZWQgPiAwKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZmFpbFF1ZXVlZE1lc3NhZ2VzKClcIixcbiAgICAgICAgXCJmYWlsaW5nIFwiICsgbnVtUXVldWVkICsgXCIgcXVldWVkIG1lc3NhZ2VzLCBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICApO1xuICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb21wbGV0ZUFsbE1lc3NhZ2VzKGVycik7XG4gICAgfVxuICB9XG4gIG9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUucXVldWUucHVzaCh7IG1lc3NhZ2UsIHRyYW5zcG9ydCB9KTtcbiAgICBpZiAoIXRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLmlzUHJvY2Vzc2luZykge1xuICAgICAgdGhpcy5wcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpO1xuICAgIH1cbiAgfVxuICBwcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBlbmRpbmdDaGFubmVsTWVzc2FnZSA9IHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICB0aGlzLnByb2Nlc3NDaGFubmVsTWVzc2FnZShwZW5kaW5nQ2hhbm5lbE1lc3NhZ2UubWVzc2FnZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIucHJvY2Vzc05leHRQZW5kaW5nQ2hhbm5lbE1lc3NhZ2UoKSByZWNlaXZlZCBlcnJvciBcIixcbiAgICAgICAgICBlcnJcbiAgICAgICAgKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHByb2Nlc3NDaGFubmVsTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgYXdhaXQgdGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgYXN5bmMgcGluZygpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXRlICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHBpbmcgc2VydmljZTsgbm90IGNvbm5lY3RlZFwiLCA0ZTQsIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IChfYTIgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYW5zcG9ydCgpO1xuICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICB0aHJvdyB0aGlzLmdldFN0YXRlRXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIucGluZygpXCIsIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnQpO1xuICAgIGNvbnN0IHBpbmdTdGFydCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaWQgPSBjaGVhcFJhbmRTdHIoKTtcbiAgICByZXR1cm4gd2l0aFRpbWVvdXRBc3luYyhcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9uSGVhcnRiZWF0ID0gKHJlc3BvbnNlSWQpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2VJZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoXCJoZWFydGJlYXRcIiwgb25IZWFydGJlYXQpO1xuICAgICAgICAgICAgcmVzb2x2ZShEYXRlLm5vdygpIC0gcGluZ1N0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5vbihcImhlYXJ0YmVhdFwiLCBvbkhlYXJ0YmVhdCk7XG4gICAgICAgIHRyYW5zcG9ydC5waW5nKGlkKTtcbiAgICAgIH0pLFxuICAgICAgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG4gICAgICBcIlRpbWVvdXQgd2FpdGluZyBmb3IgaGVhcnRiZWF0IHJlc3BvbnNlXCJcbiAgICApO1xuICB9XG4gIGFib3J0KGVycm9yKSB7XG4gICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5mYWlsKGVycm9yKTtcbiAgfVxuICBnZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgfHwgaGF2ZVdlYlN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKSk7XG4gIH1cbiAgcGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0KSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gdHJhbnNwb3J0LnNob3J0TmFtZTtcbiAgICBpZiAoaGF2ZVdlYlN0b3JhZ2UoKSkge1xuICAgICAgKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lLCB0cmFuc3BvcnQuc2hvcnROYW1lKTtcbiAgICB9XG4gIH1cbiAgdW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuICAgIGlmIChoYXZlV2ViU3RvcmFnZSgpKSB7XG4gICAgICAoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpO1xuICAgIH1cbiAgfVxuICAvKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZHVyaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdHMsIHNvIGltcGxlbWVudHMgUlNBNGMxLCBSU0E0YzIsXG4gICAqIGFuZCBSU0E0ZC4gSXQgaXMgZ2VuZXJhbGx5IG5vdCBpbnZva2VkIGZvciBzZXJ2ZXJzaWRlLXRyaWdnZXJlZCByZWF1dGhzIG9yIG1hbnVhbFxuICAgKiByZWF1dGhzLCBzbyBSU0E0YzMgZG9lcyBub3QgYXBwbHksIGV4Y2VwdCAocGVyIHBlciBSU0E0ZDEpIGluIHRoZSBjYXNlIHRoYXQgdGhlIGF1dGhcbiAgICogc2VydmVyIHJldHVybnMgNDAzLiAqL1xuICBhY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09IDQwMTcxKSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiZmFpbGVkXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gNDAxMDIpIHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IGVyciB9KTtcbiAgICB9IGVsc2UgaWYgKGVyci5zdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdC5Gb3JiaWRkZW4pIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmV0dXJuZWQgNDAzOyBmYWlsaW5nIHRoZSBjb25uZWN0aW9uXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSgpXCIsIG1zZyk7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiZmFpbGVkXCIsIGVycm9yOiBuZXcgRXJyb3JJbmZvKG1zZywgODAwMTksIDQwMywgZXJyKSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gXCJDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXF1ZXN0IGZhaWxlZFwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemVcIiwgbXNnKTtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogdGhpcy5zdGF0ZS5mYWlsU3RhdGUsIGVycm9yOiBuZXcgRXJyb3JJbmZvKG1zZywgODAwMTksIDQwMSwgZXJyKSB9KTtcbiAgICB9XG4gIH1cbiAgb25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KSB7XG4gICAgaWYgKCFjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gY29ubmVjdGlvbkRldGFpbHM7XG4gICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemUgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50SWQgPSBjb25uZWN0aW9uRGV0YWlscy5jbGllbnRJZDtcbiAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMucmVhbHRpbWUuYXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKClcIiwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB0cmFuc3BvcnQuZmFpbChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICBpZiAoY29ubmVjdGlvblN0YXRlVHRsKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICB9XG4gICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG4gICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbmRldGFpbHNcIiwgY29ubmVjdGlvbkRldGFpbHMpO1xuICB9XG4gIGNoZWNrV3NDb25uZWN0aXZpdHkoKSB7XG4gICAgY29uc3Qgd3NDb25uZWN0aXZpdHlDaGVja1VybCA9IHRoaXMub3B0aW9ucy53c0Nvbm5lY3Rpdml0eUNoZWNrVXJsIHx8IGRlZmF1bHRzX2RlZmF1bHQud3NDb25uZWN0aXZpdHlDaGVja1VybDtcbiAgICBjb25zdCB3cyA9IG5ldyBQbGF0Zm9ybS5Db25maWcuV2ViU29ja2V0KHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdzLm9uY2xvc2UgPSB3cy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHNlc3Npb25SZWNvdmVyeU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZWNvdmVyeUtleVN0b3JhZ2VOYW1lIHx8IFwiYWJseS1jb25uZWN0aW9uLXJlY292ZXJ5XCI7XG4gIH1cbiAgZ2V0U2Vzc2lvblJlY292ZXJEYXRhKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0U2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0aGlzLnNlc3Npb25SZWNvdmVyeU5hbWUoKSkpO1xuICB9XG4gIHNldFNlc3Npb25SZWNvdmVyRGF0YSh2YWx1ZSkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2V0U2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0aGlzLnNlc3Npb25SZWNvdmVyeU5hbWUoKSwgdmFsdWUpKTtcbiAgfVxuICBjbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlbW92ZVNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCkpKTtcbiAgfVxufTtcbnZhciBjb25uZWN0aW9ubWFuYWdlcl9kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jb25uZWN0aW9uLnRzXG52YXIgQ29ubmVjdGlvbiA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihhYmx5LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoYWJseS5sb2dnZXIpO1xuICAgIHRoaXMud2hlblN0YXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRlbWl0dGVyX2RlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIHRoaXMuYWJseSA9IGFibHk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBjb25uZWN0aW9ubWFuYWdlcl9kZWZhdWx0KGFibHksIG9wdGlvbnMpO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbihcImNvbm5lY3Rpb25zdGF0ZVwiLCAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQ7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoc3RhdGUsIHN0YXRlQ2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oXCJ1cGRhdGVcIiwgKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgc3RhdGVDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uLmNvbm5lY3QoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgfVxuICBhc3luYyBwaW5nKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb24ucGluZygpXCIsIFwiXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnBpbmcoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uLmNsb3NlKClcIiwgXCJjb25uZWN0aW9uS2V5ID0gXCIgKyB0aGlzLmtleSk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjbG9zaW5nXCIgfSk7XG4gIH1cbiAgZ2V0IHJlY292ZXJ5S2V5KCkge1xuICAgIHRoaXMubG9nZ2VyLmRlcHJlY2F0aW9uV2FybmluZyhcbiAgICAgIFwiVGhlIGBDb25uZWN0aW9uLnJlY292ZXJ5S2V5YCBhdHRyaWJ1dGUgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIGBDb25uZWN0aW9uLmNyZWF0ZVJlY292ZXJ5S2V5KClgIG1ldGhvZC4gUmVwbGFjZSB5b3VyIHVzYWdlIG9mIGByZWNvdmVyeUtleWAgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIGBjcmVhdGVSZWNvdmVyeUtleSgpYC4gYHJlY292ZXJ5S2V5YCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgfVxuICBjcmVhdGVSZWNvdmVyeUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICB9XG59O1xudmFyIGNvbm5lY3Rpb25fZGVmYXVsdCA9IENvbm5lY3Rpb247XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9iYXNlcmVhbHRpbWUudHNcbnZhciBfQmFzZVJlYWx0aW1lID0gY2xhc3MgX0Jhc2VSZWFsdGltZSBleHRlbmRzIGJhc2VjbGllbnRfZGVmYXVsdCB7XG4gIC8qXG4gICAqIFRoZSBwdWJsaWMgdHlwaW5ncyBkZWNsYXJlIHRoYXQgdGhpcyBvbmx5IGFjY2VwdHMgYW4gb2JqZWN0LCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG9uZSBvZiB0aGVzZSB0aGluZ3M6XG4gICAqXG4gICAqIDEuIHBhc3NlcyBhIHN0cmluZyAod2hpY2ggaXMgcXVpdGUgbGlrZWx5IGlmIHRoZXnigJlyZSBlLmcuIG1pZ3JhdGluZyBmcm9tIHRoZSBkZWZhdWx0IHZhcmlhbnQgdG8gdGhlIG1vZHVsYXIgdmFyaWFudClcbiAgICogMi4gcGFzc2VzIG5vIGFyZ3VtZW50IGF0IGFsbFxuICAgKlxuICAgKiB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoZXNlIGNhc2VzIGFyZSBwb3NzaWJsZSBzbyB0aGF0IGl0IGZvcmNlcyB1cyB0byBoYW5kbGUgdGhlbS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICAgIHN1cGVyKGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCBmYWxzZSwgXCJCYXNlUmVhbHRpbWVcIiwgbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcikpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lKClcIiwgXCJcIik7XG4gICAgaWYgKHR5cGVvZiBFZGdlUnVudGltZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgYEFibHkuUmVhbHRpbWUgaW5zdGFuY2UgY2Fubm90IGJlIHVzZWQgaW4gVmVyY2VsIEVkZ2UgcnVudGltZS4gSWYgeW91IGFyZSBydW5uaW5nIFZlcmNlbCBFZGdlIGZ1bmN0aW9ucywgcGxlYXNlIHJlcGxhY2UgeW91ciBcIm5ldyBBYmx5LlJlYWx0aW1lKClcIiB3aXRoIFwibmV3IEFibHkuUmVzdCgpXCIgYW5kIHVzZSBBYmx5IFJlc3QgQVBJIGluc3RlYWQgb2YgdGhlIFJlYWx0aW1lIEFQSS4gSWYgeW91IGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHlvdXIgYXBwbGljYXRpb24gaW4gdGhlIFZlcmNlbCBFZGdlIHJ1bnRpbWUsIHBsZWFzZSB1c2UgdGhlIGNvbmRpdGlvbiBcImlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgPT09ICdzdHJpbmcnKVwiIHRvIHByZXZlbnQgaW5zdGFudGlhdGluZyBBYmx5LlJlYWx0aW1lIGluc3RhbmNlIGR1cmluZyBTU1IgaW4gdGhlIFZlcmNlbCBFZGdlIHJ1bnRpbWUuYCxcbiAgICAgICAgNGU0LFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuX2FkZGl0aW9uYWxUcmFuc3BvcnRJbXBsZW1lbnRhdGlvbnMgPSBfQmFzZVJlYWx0aW1lLnRyYW5zcG9ydEltcGxlbWVudGF0aW9uc0Zyb21QbHVnaW5zKHRoaXMub3B0aW9ucy5wbHVnaW5zKTtcbiAgICB0aGlzLl9SZWFsdGltZVByZXNlbmNlID0gKF9iID0gKF9hMiA9IHRoaXMub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlJlYWx0aW1lUHJlc2VuY2UpICE9IG51bGwgPyBfYiA6IG51bGw7XG4gICAgdGhpcy5fbGl2ZU9iamVjdHNQbHVnaW4gPSAoX2QgPSAoX2MgPSB0aGlzLm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLkxpdmVPYmplY3RzKSAhPSBudWxsID8gX2QgOiBudWxsO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBjb25uZWN0aW9uX2RlZmF1bHQodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLl9jaGFubmVscyA9IG5ldyBDaGFubmVsczIodGhpcyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvQ29ubmVjdCAhPT0gZmFsc2UpXG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBzdGF0aWMgdHJhbnNwb3J0SW1wbGVtZW50YXRpb25zRnJvbVBsdWdpbnMocGx1Z2lucykge1xuICAgIGNvbnN0IHRyYW5zcG9ydHMgPSB7fTtcbiAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5XZWJTb2NrZXRUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydHNbVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0XSA9IHBsdWdpbnMuV2ViU29ja2V0VHJhbnNwb3J0O1xuICAgIH1cbiAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5YSFJQb2xsaW5nKSB7XG4gICAgICB0cmFuc3BvcnRzW1RyYW5zcG9ydE5hbWVzLlhoclBvbGxpbmddID0gcGx1Z2lucy5YSFJQb2xsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuICBnZXQgY2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWxzO1xuICB9XG4gIGdldCBjbGllbnRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoLmNsaWVudElkO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuY29ubmVjdCgpXCIsIFwiXCIpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuY2xvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgfVxufTtcbi8vIGludGVybmFsIEFQSSB0byBtYWtlIEV2ZW50RW1pdHRlciB1c2FibGUgaW4gb3RoZXIgU0RLc1xuX0Jhc2VSZWFsdGltZS5FdmVudEVtaXR0ZXIgPSBldmVudGVtaXR0ZXJfZGVmYXVsdDtcbnZhciBCYXNlUmVhbHRpbWUgPSBfQmFzZVJlYWx0aW1lO1xudmFyIENoYW5uZWxzMiA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihyZWFsdGltZSkge1xuICAgIHN1cGVyKHJlYWx0aW1lLmxvZ2dlcik7XG4gICAgdGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuICAgIHRoaXMuYWxsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVhbHRpbWUuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbihcInRyYW5zcG9ydC5hY3RpdmVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vblRyYW5zcG9ydEFjdGl2ZSgpO1xuICAgIH0pO1xuICB9XG4gIGNoYW5uZWxTZXJpYWxzKCkge1xuICAgIGxldCBzZXJpYWxzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGtleXNBcnJheSh0aGlzLmFsbCwgdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICAgIGlmIChjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCkge1xuICAgICAgICBzZXJpYWxzW25hbWVdID0gY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxzO1xuICB9XG4gIC8vIHJlY292ZXJDaGFubmVscyBnZXRzIHRoZSBnaXZlbiBjaGFubmVscyBhbmQgc2V0cyB0aGVpciBjaGFubmVsIHNlcmlhbHMuXG4gIHJlY292ZXJDaGFubmVscyhjaGFubmVsU2VyaWFscykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBrZXlzQXJyYXkoY2hhbm5lbFNlcmlhbHMsIHRydWUpKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICBjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWxzW25hbWVdO1xuICAgIH1cbiAgfVxuICAvLyBBY2Nlc3MgdG8gdGhpcyBtZXRob2QgaXMgc3luY2hyb25pc2VkIGJ5IENvbm5lY3Rpb25NYW5hZ2VyI3Byb2Nlc3NDaGFubmVsTWVzc2FnZS5cbiAgYXN5bmMgcHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1zZykge1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gbXNnLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWxOYW1lID09PSB2b2lkIDApIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UoKVwiLFxuICAgICAgICBcInJlY2VpdmVkIGV2ZW50IHVuc3BlY2lmaWVkIGNoYW5uZWwsIGFjdGlvbiA9IFwiICsgbXNnLmFjdGlvblxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UoKVwiLFxuICAgICAgICBcInJlY2VpdmVkIGV2ZW50IGZvciBub24tZXhpc3RlbnQgY2hhbm5lbDogXCIgKyBjaGFubmVsTmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgY2hhbm5lbC5wcm9jZXNzTWVzc2FnZShtc2cpO1xuICB9XG4gIC8qIGNhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGJlY29tZXMgY29ubmVjdGVkOyByZWF0dGVtcHQgYXR0YWNoL2RldGFjaFxuICAgKiBmb3IgY2hhbm5lbHMgdGhhdCBhcmUgYXR0YWNoaW5nIG9yIGRldGFjaGluZy4gKi9cbiAgb25UcmFuc3BvcnRBY3RpdmUoKSB7XG4gICAgZm9yIChjb25zdCBjaGFubmVsTmFtZSBpbiB0aGlzLmFsbCkge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICAgIGlmIChjaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGluZ1wiIHx8IGNoYW5uZWwuc3RhdGUgPT09IFwiZGV0YWNoaW5nXCIpIHtcbiAgICAgICAgY2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICAgIGNoYW5uZWwuX2F0dGFjaChmYWxzZSwgbnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICBjaGFubmVsLnJlcXVlc3RTdGF0ZShcImF0dGFjaGluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogQ29ubmVjdGlvbiBpbnRlcnJ1cHRpb25zIChpZSB3aGVuIHRoZSBjb25uZWN0aW9uIHdpbGwgbm8gbG9uZ2VyIHF1ZXVlXG4gICAqIGV2ZW50cykgaW1wbHkgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzIGZvciBhbnkgY2hhbm5lbCB3aGljaCBpcyBlaXRoZXJcbiAgICogYXR0YWNoZWQsIHBlbmRpbmcsIG9yIHdpbGwgYXR0ZW1wdCB0byBiZWNvbWUgYXR0YWNoZWQgaW4gdGhlIGZ1dHVyZSAqL1xuICBwcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKGNvbm5lY3Rpb25TdGF0ZSwgcmVhc29uKSB7XG4gICAgY29uc3QgY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGUgPSB7XG4gICAgICBjbG9zaW5nOiBcImRldGFjaGVkXCIsXG4gICAgICBjbG9zZWQ6IFwiZGV0YWNoZWRcIixcbiAgICAgIGZhaWxlZDogXCJmYWlsZWRcIixcbiAgICAgIHN1c3BlbmRlZDogXCJzdXNwZW5kZWRcIlxuICAgIH07XG4gICAgY29uc3QgZnJvbUNoYW5uZWxTdGF0ZXMgPSBbXCJhdHRhY2hpbmdcIiwgXCJhdHRhY2hlZFwiLCBcImRldGFjaGluZ1wiLCBcInN1c3BlbmRlZFwiXTtcbiAgICBjb25zdCB0b0NoYW5uZWxTdGF0ZSA9IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlW2Nvbm5lY3Rpb25TdGF0ZV07XG4gICAgZm9yIChjb25zdCBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuICAgICAgaWYgKGZyb21DaGFubmVsU3RhdGVzLmluY2x1ZGVzKGNoYW5uZWwuc3RhdGUpKSB7XG4gICAgICAgIGNoYW5uZWwubm90aWZ5U3RhdGUodG9DaGFubmVsU3RhdGUsIHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXSA9IG5ldyByZWFsdGltZWNoYW5uZWxfZGVmYXVsdCh0aGlzLnJlYWx0aW1lLCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgaWYgKGNoYW5uZWwuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zLCBjaGFubmVsLmNoYW5uZWxPcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwiQ2hhbm5lbHMuZ2V0KCkgY2Fubm90IGJlIHVzZWQgdG8gc2V0IGNoYW5uZWwgb3B0aW9ucyB0aGF0IHdvdWxkIGNhdXNlIHRoZSBjaGFubmVsIHRvIHJlYXR0YWNoLiBQbGVhc2UsIHVzZSBSZWFsdGltZUNoYW5uZWwuc2V0T3B0aW9ucygpIGluc3RlYWQuXCIsXG4gICAgICAgICAgNGU0LFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cbiAgZ2V0RGVyaXZlZChuYW1lLCBkZXJpdmVPcHRpb25zLCBjaGFubmVsT3B0aW9ucykge1xuICAgIGlmIChkZXJpdmVPcHRpb25zLmZpbHRlcikge1xuICAgICAgY29uc3QgZmlsdGVyID0gdG9CYXNlNjQoZGVyaXZlT3B0aW9ucy5maWx0ZXIpO1xuICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaERlcml2ZWRDaGFubmVsKG5hbWUpO1xuICAgICAgbmFtZSA9IGBbZmlsdGVyPSR7ZmlsdGVyfSR7bWF0Y2gucXVhbGlmaWVyUGFyYW19XSR7bWF0Y2guY2hhbm5lbE5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgfVxuICAvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cbiAgICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cbiAgcmVsZWFzZShuYW1lKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGVhc2VFcnIgPSBjaGFubmVsLmdldFJlbGVhc2VFcnIoKTtcbiAgICBpZiAocmVsZWFzZUVycikge1xuICAgICAgdGhyb3cgcmVsZWFzZUVycjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuYWxsW25hbWVdO1xuICB9XG59O1xudmFyIGJhc2VyZWFsdGltZV9kZWZhdWx0ID0gQmFzZVJlYWx0aW1lO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcHJlc2VuY2VtYXAudHNcbmZ1bmN0aW9uIG5ld2VyVGhhbihpdGVtLCBleGlzdGluZykge1xuICBpZiAoaXRlbS5pc1N5bnRoZXNpemVkKCkgfHwgZXhpc3RpbmcuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgcmV0dXJuIGl0ZW0udGltZXN0YW1wID49IGV4aXN0aW5nLnRpbWVzdGFtcDtcbiAgfVxuICBjb25zdCBpdGVtT3JkZXJpbmdzID0gaXRlbS5wYXJzZUlkKCksIGV4aXN0aW5nT3JkZXJpbmdzID0gZXhpc3RpbmcucGFyc2VJZCgpO1xuICBpZiAoaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPT09IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbCkge1xuICAgIHJldHVybiBpdGVtT3JkZXJpbmdzLmluZGV4ID4gZXhpc3RpbmdPcmRlcmluZ3MuaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID4gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsO1xuICB9XG59XG52YXIgUHJlc2VuY2VNYXAgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocHJlc2VuY2UsIG1lbWJlcktleSwgbmV3ZXIgPSBuZXdlclRoYW4pIHtcbiAgICBzdXBlcihwcmVzZW5jZS5sb2dnZXIpO1xuICAgIHRoaXMucHJlc2VuY2UgPSBwcmVzZW5jZTtcbiAgICB0aGlzLm1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgdGhpcy5tZW1iZXJLZXkgPSBtZW1iZXJLZXk7XG4gICAgdGhpcy5uZXdlclRoYW4gPSBuZXdlcjtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW2tleV07XG4gIH1cbiAgZ2V0Q2xpZW50KGNsaWVudElkKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgY29uc3QgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgaWYgKGl0ZW0uY2xpZW50SWQgPT0gY2xpZW50SWQgJiYgaXRlbS5hY3Rpb24gIT0gXCJhYnNlbnRcIilcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGlzdChwYXJhbXMpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgY2xpZW50SWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNsaWVudElkLCBjb25uZWN0aW9uSWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbm5lY3Rpb25JZCwgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFwKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWFwW2tleV07XG4gICAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiYWJzZW50XCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNsaWVudElkICYmIGNsaWVudElkICE9IGl0ZW0uY2xpZW50SWQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNvbm5lY3Rpb25JZCAmJiBjb25uZWN0aW9uSWQgIT0gaXRlbS5jb25uZWN0aW9uSWQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHV0KGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiZW50ZXJcIiB8fCBpdGVtLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgaXRlbSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoaXRlbSk7XG4gICAgICBpdGVtLmFjdGlvbiA9IFwicHJlc2VudFwiO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwga2V5ID0gdGhpcy5tZW1iZXJLZXkoaXRlbSk7XG4gICAgaWYgKHRoaXMucmVzaWR1YWxNZW1iZXJzKVxuICAgICAgZGVsZXRlIHRoaXMucmVzaWR1YWxNZW1iZXJzW2tleV07XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAmJiAhdGhpcy5uZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXBba2V5XSA9IGl0ZW07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFsdWVzKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgIGlmIChpdGVtLmFjdGlvbiAhPSBcImFic2VudFwiKVxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZW1vdmUoaXRlbSkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCBrZXkgPSB0aGlzLm1lbWJlcktleShpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICYmICF0aGlzLm5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICBpdGVtID0gcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyhpdGVtKTtcbiAgICAgIGl0ZW0uYWN0aW9uID0gXCJhYnNlbnRcIjtcbiAgICAgIG1hcFtrZXldID0gaXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG1hcFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gISFleGlzdGluZ0l0ZW07XG4gIH1cbiAgc3RhcnRTeW5jKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlByZXNlbmNlTWFwLnN0YXJ0U3luYygpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgXCI7IHN5bmNJblByb2dyZXNzID0gXCIgKyBzeW5jSW5Qcm9ncmVzc1xuICAgICk7XG4gICAgaWYgKCF0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IGNvcHkobWFwKTtcbiAgICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyh0cnVlKTtcbiAgICB9XG4gIH1cbiAgZW5kU3luYygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJQcmVzZW5jZU1hcC5lbmRTeW5jKClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyBcIjsgc3luY0luUHJvZ3Jlc3MgPSBcIiArIHN5bmNJblByb2dyZXNzXG4gICAgKTtcbiAgICBpZiAoc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyS2V5IGluIG1hcCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG1hcFttZW1iZXJLZXldO1xuICAgICAgICBpZiAoZW50cnkuYWN0aW9uID09PSBcImFic2VudFwiKSB7XG4gICAgICAgICAgZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnByZXNlbmNlLl9zeW50aGVzaXplTGVhdmVzKHZhbHVlc0FycmF5KHRoaXMucmVzaWR1YWxNZW1iZXJzKSk7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlcktleSBpbiB0aGlzLnJlc2lkdWFsTWVtYmVycykge1xuICAgICAgICBkZWxldGUgbWFwW21lbWJlcktleV07XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJzeW5jXCIpO1xuICB9XG4gIGFzeW5jIHdhaXRTeW5jKCkge1xuICAgIGNvbnN0IHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUHJlc2VuY2VNYXAud2FpdFN5bmMoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArIFwiOyBzeW5jSW5Qcm9ncmVzcyA9IFwiICsgc3luY0luUHJvZ3Jlc3NcbiAgICApO1xuICAgIGlmICghc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5vbmNlKFwic3luY1wiKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyhmYWxzZSk7XG4gICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICB9XG4gIHNldEluUHJvZ3Jlc3MoaW5Qcm9ncmVzcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlByZXNlbmNlTWFwLnNldEluUHJvZ3Jlc3MoKVwiLCBcImluUHJvZ3Jlc3MgPSBcIiArIGluUHJvZ3Jlc3MpO1xuICAgIHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBpblByb2dyZXNzO1xuICAgIHRoaXMucHJlc2VuY2Uuc3luY0NvbXBsZXRlID0gIWluUHJvZ3Jlc3M7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZXByZXNlbmNlLnRzXG5mdW5jdGlvbiBnZXRDbGllbnRJZChyZWFsdGltZVByZXNlbmNlKSB7XG4gIHJldHVybiByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwuY2xpZW50LmF1dGguY2xpZW50SWQ7XG59XG5mdW5jdGlvbiBpc0Fub255bW91c09yV2lsZGNhcmQocmVhbHRpbWVQcmVzZW5jZSkge1xuICBjb25zdCByZWFsdGltZSA9IHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5jbGllbnQ7XG4gIGNvbnN0IGNsaWVudElkID0gcmVhbHRpbWUuYXV0aC5jbGllbnRJZDtcbiAgcmV0dXJuICghY2xpZW50SWQgfHwgY2xpZW50SWQgPT09IFwiKlwiKSAmJiByZWFsdGltZS5jb25uZWN0aW9uLnN0YXRlID09PSBcImNvbm5lY3RlZFwiO1xufVxudmFyIFJlYWx0aW1lUHJlc2VuY2UgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgIHN1cGVyKGNoYW5uZWwubG9nZ2VyKTtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgIHRoaXMuc3luY0NvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5tZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMsIChpdGVtKSA9PiBpdGVtLmNsaWVudElkICsgXCI6XCIgKyBpdGVtLmNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5fbXlNZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMsIChpdGVtKSA9PiBpdGVtLmNsaWVudElkKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gIH1cbiAgYXN5bmMgZW50ZXIoZGF0YSkge1xuICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byBlbnRlciBhIHByZXNlbmNlIGNoYW5uZWxcIiwgNDAwMTIsIDQwMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHZvaWQgMCwgdm9pZCAwLCBkYXRhLCBcImVudGVyXCIpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZShkYXRhKSB7XG4gICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIHVwZGF0ZSBwcmVzZW5jZSBkYXRhXCIsIDQwMDEyLCA0MDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIHZvaWQgMCwgZGF0YSwgXCJ1cGRhdGVcIik7XG4gIH1cbiAgYXN5bmMgZW50ZXJDbGllbnQoY2xpZW50SWQsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIGNsaWVudElkLCBkYXRhLCBcImVudGVyXCIpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUNsaWVudChjbGllbnRJZCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHZvaWQgMCwgY2xpZW50SWQsIGRhdGEsIFwidXBkYXRlXCIpO1xuICB9XG4gIGFzeW5jIF9lbnRlck9yVXBkYXRlQ2xpZW50KGlkLCBjbGllbnRJZCwgZGF0YSwgYWN0aW9uKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICBpZiAoIWNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5cIiArIGFjdGlvbiArIFwiQ2xpZW50KClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgY2hhbm5lbC5uYW1lICsgXCIsIGlkID0gXCIgKyBpZCArIFwiLCBjbGllbnQgPSBcIiArIChjbGllbnRJZCB8fCBcIihpbXBsaWNpdCkgXCIgKyBnZXRDbGllbnRJZCh0aGlzKSlcbiAgICApO1xuICAgIGNvbnN0IHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQuZnJvbURhdGEoZGF0YSk7XG4gICAgcHJlc2VuY2UuYWN0aW9uID0gYWN0aW9uO1xuICAgIGlmIChpZCkge1xuICAgICAgcHJlc2VuY2UuaWQgPSBpZDtcbiAgICB9XG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgIH1cbiAgICBjb25zdCB3aXJlUHJlc01zZyA9IGF3YWl0IHByZXNlbmNlLmVuY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zKTtcbiAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICByZXR1cm4gY2hhbm5lbC5zZW5kUHJlc2VuY2UoW3dpcmVQcmVzTXNnXSk7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZWRcIjpcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICBjaGFubmVsLmF0dGFjaCgpO1xuICAgICAgY2FzZSBcImF0dGFjaGluZ1wiOlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuICAgICAgICAgICAgcHJlc2VuY2U6IHdpcmVQcmVzTXNnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgUGFydGlhbEVycm9ySW5mbyhcbiAgICAgICAgICBcIlVuYWJsZSB0byBcIiArIGFjdGlvbiArIFwiIHByZXNlbmNlIGNoYW5uZWwgd2hpbGUgaW4gXCIgKyBjaGFubmVsLnN0YXRlICsgXCIgc3RhdGVcIixcbiAgICAgICAgICA5MDAwMVxuICAgICAgICApO1xuICAgICAgICBlcnIuY29kZSA9IDkwMDAxO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGxlYXZlKGRhdGEpIHtcbiAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBoYXZlIGJlZW4gc3BlY2lmaWVkIHRvIGVudGVyIG9yIGxlYXZlIGEgcHJlc2VuY2UgY2hhbm5lbFwiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVhdmVDbGllbnQodm9pZCAwLCBkYXRhKTtcbiAgfVxuICBhc3luYyBsZWF2ZUNsaWVudChjbGllbnRJZCwgZGF0YSkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2UubGVhdmVDbGllbnQoKVwiLFxuICAgICAgXCJsZWF2aW5nOyBjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSArIFwiLCBjbGllbnQgPSBcIiArIGNsaWVudElkXG4gICAgKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21EYXRhKGRhdGEpO1xuICAgIHByZXNlbmNlLmFjdGlvbiA9IFwibGVhdmVcIjtcbiAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgIHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgfVxuICAgIGNvbnN0IHdpcmVQcmVzTXNnID0gYXdhaXQgcHJlc2VuY2UuZW5jb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMpO1xuICAgIHN3aXRjaCAoY2hhbm5lbC5zdGF0ZSkge1xuICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgIHJldHVybiBjaGFubmVsLnNlbmRQcmVzZW5jZShbd2lyZVByZXNNc2ddKTtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcbiAgICAgICAgICAgIHByZXNlbmNlOiB3aXJlUHJlc01zZyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgICAgY2FzZSBcImZhaWxlZFwiOiB7XG4gICAgICAgIHRocm93IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGxlYXZlIHByZXNlbmNlIGNoYW5uZWwgKGluY29tcGF0aWJsZSBzdGF0ZSlcIiwgOTAwMDEpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgY29uc3Qgd2FpdEZvclN5bmMgPSAhcGFyYW1zIHx8IChcIndhaXRGb3JTeW5jXCIgaW4gcGFyYW1zID8gcGFyYW1zLndhaXRGb3JTeW5jIDogdHJ1ZSk7XG4gICAgZnVuY3Rpb24gdG9NZXNzYWdlcyhtZW1iZXJzMikge1xuICAgICAgcmV0dXJuIHBhcmFtcyA/IG1lbWJlcnMyLmxpc3QocGFyYW1zKSA6IG1lbWJlcnMyLnZhbHVlcygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFubmVsLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICBpZiAod2FpdEZvclN5bmMpIHtcbiAgICAgICAgdGhyb3cgRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICBjb2RlOiA5MTAwNSxcbiAgICAgICAgICBtZXNzYWdlOiBcIlByZXNlbmNlIHN0YXRlIGlzIG91dCBvZiBzeW5jIGR1ZSB0byBjaGFubmVsIGJlaW5nIGluIHRoZSBTVVNQRU5ERUQgc3RhdGVcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b01lc3NhZ2VzKHRoaXMubWVtYmVycyk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuY2hhbm5lbC5lbnN1cmVBdHRhY2hlZCgpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLm1lbWJlcnM7XG4gICAgaWYgKHdhaXRGb3JTeW5jKSB7XG4gICAgICBhd2FpdCBtZW1iZXJzLndhaXRTeW5jKCk7XG4gICAgfVxuICAgIHJldHVybiB0b01lc3NhZ2VzKHRoaXMubWVtYmVycyk7XG4gIH1cbiAgYXN5bmMgaGlzdG9yeShwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZVByZXNlbmNlLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgY29uc3QgcmVzdE1peGluID0gdGhpcy5jaGFubmVsLmNsaWVudC5yZXN0LnByZXNlbmNlTWl4aW47XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcbiAgICAgIGlmICh0aGlzLmNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICBkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuICAgICAgICBwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLmNoYW5uZWwucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkLCB3YXM6IFwiICsgdGhpcy5jaGFubmVsLnN0YXRlLFxuICAgICAgICAgIDRlNCxcbiAgICAgICAgICA0MDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3RNaXhpbi5oaXN0b3J5KHRoaXMsIHBhcmFtcyk7XG4gIH1cbiAgc2V0UHJlc2VuY2UocHJlc2VuY2VTZXQsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5zZXRQcmVzZW5jZSgpXCIsXG4gICAgICBcInJlY2VpdmVkIHByZXNlbmNlIGZvciBcIiArIHByZXNlbmNlU2V0Lmxlbmd0aCArIFwiIHBhcnRpY2lwYW50czsgc3luY0NoYW5uZWxTZXJpYWwgPSBcIiArIHN5bmNDaGFubmVsU2VyaWFsXG4gICAgKTtcbiAgICBsZXQgc3luY0N1cnNvciwgbWF0Y2g7XG4gICAgY29uc3QgbWVtYmVycyA9IHRoaXMubWVtYmVycywgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzLCBicm9hZGNhc3RNZXNzYWdlcyA9IFtdLCBjb25uSWQgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkO1xuICAgIGlmIChpc1N5bmMpIHtcbiAgICAgIHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcbiAgICAgIGlmIChzeW5jQ2hhbm5lbFNlcmlhbCAmJiAobWF0Y2ggPSBzeW5jQ2hhbm5lbFNlcmlhbC5tYXRjaCgvXltcXHctXSs6KC4qKSQvKSkpIHtcbiAgICAgICAgc3luY0N1cnNvciA9IG1hdGNoWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcmVzZW5jZSBvZiBwcmVzZW5jZVNldCkge1xuICAgICAgc3dpdGNoIChwcmVzZW5jZS5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBcImxlYXZlXCI6XG4gICAgICAgICAgaWYgKG1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCAmJiAhcHJlc2VuY2UuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgICAgICAgICBteU1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbnRlclwiOlxuICAgICAgICBjYXNlIFwicHJlc2VudFwiOlxuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgaWYgKG1lbWJlcnMucHV0KHByZXNlbmNlKSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCkge1xuICAgICAgICAgICAgbXlNZW1iZXJzLnB1dChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTeW5jICYmICFzeW5jQ3Vyc29yKSB7XG4gICAgICBtZW1iZXJzLmVuZFN5bmMoKTtcbiAgICAgIHRoaXMuY2hhbm5lbC5zeW5jQ2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnJvYWRjYXN0TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByZXNlbmNlID0gYnJvYWRjYXN0TWVzc2FnZXNbaV07XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZW1pdChwcmVzZW5jZS5hY3Rpb24sIHByZXNlbmNlKTtcbiAgICB9XG4gIH1cbiAgb25BdHRhY2hlZChoYXNQcmVzZW5jZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSArIFwiLCBoYXNQcmVzZW5jZSA9IFwiICsgaGFzUHJlc2VuY2VcbiAgICApO1xuICAgIGlmIChoYXNQcmVzZW5jZSkge1xuICAgICAgdGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zeW50aGVzaXplTGVhdmVzKHRoaXMubWVtYmVycy52YWx1ZXMoKSk7XG4gICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpO1xuICAgIGNvbnN0IHBlbmRpbmdQcmVzZW5jZSA9IHRoaXMucGVuZGluZ1ByZXNlbmNlLCBwZW5kaW5nUHJlc0NvdW50ID0gcGVuZGluZ1ByZXNlbmNlLmxlbmd0aDtcbiAgICBpZiAocGVuZGluZ1ByZXNDb3VudCkge1xuICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICAgIGNvbnN0IHByZXNlbmNlQXJyYXkgPSBbXTtcbiAgICAgIGNvbnN0IG11bHRpY2FzdGVyID0gbXVsdGljYXN0ZXJfZGVmYXVsdC5jcmVhdGUodGhpcy5sb2dnZXIpO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlJlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZFwiLFxuICAgICAgICBcInNlbmRpbmcgXCIgKyBwZW5kaW5nUHJlc0NvdW50ICsgXCIgcXVldWVkIHByZXNlbmNlIG1lc3NhZ2VzXCJcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmdQcmVzQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBldmVudCA9IHBlbmRpbmdQcmVzZW5jZVtpXTtcbiAgICAgICAgcHJlc2VuY2VBcnJheS5wdXNoKGV2ZW50LnByZXNlbmNlKTtcbiAgICAgICAgbXVsdGljYXN0ZXIucHVzaChldmVudC5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlQXJyYXkpLnRoZW4oKCkgPT4gbXVsdGljYXN0ZXIoKSkuY2F0Y2goKGVycikgPT4gbXVsdGljYXN0ZXIoZXJyKSk7XG4gICAgfVxuICB9XG4gIGFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgZXJyKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgIHRoaXMub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgIHRoaXMuX2NsZWFyTXlNZW1iZXJzKCk7XG4gICAgICAgIHRoaXMubWVtYmVycy5jbGVhcigpO1xuICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICB0aGlzLmZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5mYWlsUGVuZGluZ1ByZXNlbmNlXCIsXG4gICAgICAgIFwiY2hhbm5lbDsgbmFtZSA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUgKyBcIiwgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoOyBpKyspXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2VbaV0uY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICAgIH1cbiAgfVxuICBfY2xlYXJNeU1lbWJlcnMoKSB7XG4gICAgdGhpcy5fbXlNZW1iZXJzLmNsZWFyKCk7XG4gIH1cbiAgX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKSB7XG4gICAgY29uc3QgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzO1xuICAgIGNvbnN0IGNvbm5JZCA9IHRoaXMuY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQ7XG4gICAgZm9yIChjb25zdCBtZW1iZXJLZXkgaW4gbXlNZW1iZXJzLm1hcCkge1xuICAgICAgY29uc3QgZW50cnkgPSBteU1lbWJlcnMubWFwW21lbWJlcktleV07XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpXCIsXG4gICAgICAgICdBdXRvLXJlZW50ZXJpbmcgY2xpZW50SWQgXCInICsgZW50cnkuY2xpZW50SWQgKyAnXCIgaW50byB0aGUgcHJlc2VuY2Ugc2V0J1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGlkID0gZW50cnkuY29ubmVjdGlvbklkID09PSBjb25uSWQgPyBlbnRyeS5pZCA6IHZvaWQgMDtcbiAgICAgIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoaWQsIGVudHJ5LmNsaWVudElkLCBlbnRyeS5kYXRhLCBcImVudGVyXCIpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEVyciA9IG5ldyBFcnJvckluZm8oXCJQcmVzZW5jZSBhdXRvIHJlLWVudGVyIGZhaWxlZFwiLCA5MTAwNCwgNDAwLCBlcnIpO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpXCIsXG4gICAgICAgICAgXCJQcmVzZW5jZSBhdXRvIHJlLWVudGVyIGZhaWxlZDsgcmVhc29uID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlX2RlZmF1bHQodGhpcy5jaGFubmVsLnN0YXRlLCB0aGlzLmNoYW5uZWwuc3RhdGUsIHRydWUsIGZhbHNlLCB3cmFwcGVkRXJyKTtcbiAgICAgICAgdGhpcy5jaGFubmVsLmVtaXQoXCJ1cGRhdGVcIiwgY2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc3ludGhlc2l6ZUxlYXZlcyhpdGVtcykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBjb25zdCBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICBhY3Rpb246IFwibGVhdmVcIixcbiAgICAgICAgY29ubmVjdGlvbklkOiBpdGVtLmNvbm5lY3Rpb25JZCxcbiAgICAgICAgY2xpZW50SWQ6IGl0ZW0uY2xpZW50SWQsXG4gICAgICAgIGRhdGE6IGl0ZW0uZGF0YSxcbiAgICAgICAgZW5jb2Rpbmc6IGl0ZW0uZW5jb2RpbmcsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfSk7XG4gICAgICBzdWJzY3JpcHRpb25zLmVtaXQoXCJsZWF2ZVwiLCBwcmVzZW5jZSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc3Vic2NyaWJlKC4uLl9hcmdzKSB7XG4gICAgY29uc3QgYXJncyA9IHJlYWx0aW1lY2hhbm5lbF9kZWZhdWx0LnByb2Nlc3NMaXN0ZW5lckFyZ3MoX2FyZ3MpO1xuICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgdGhyb3cgRXJyb3JJbmZvLmZyb21WYWx1ZXMoY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgaWYgKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMuYXR0YWNoT25TdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBjaGFubmVsLmF0dGFjaCgpO1xuICAgIH1cbiAgfVxuICB1bnN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxufTtcbnZhciByZWFsdGltZXByZXNlbmNlX2RlZmF1bHQgPSBSZWFsdGltZVByZXNlbmNlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvd2Vic29ja2V0dHJhbnNwb3J0LnRzXG52YXIgc2hvcnROYW1lID0gVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0O1xuZnVuY3Rpb24gaXNOb2RlV2ViU29ja2V0KHdzKSB7XG4gIHJldHVybiAhIXdzLm9uO1xufVxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgdHJhbnNwb3J0X2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSBQbGF0Zm9ybS5Db25maWcudXNlUHJvdG9jb2xIZWFydGJlYXRzO1xuICAgIHRoaXMud3NIb3N0ID0gcGFyYW1zLmhvc3Q7XG4gIH1cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgIHJldHVybiAhIVBsYXRmb3JtLkNvbmZpZy5XZWJTb2NrZXQ7XG4gIH1cbiAgY3JlYXRlV2ViU29ja2V0KHVyaSwgY29ubmVjdFBhcmFtcykge1xuICAgIHRoaXMudXJpID0gdXJpICsgdG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFBsYXRmb3JtLkNvbmZpZy5XZWJTb2NrZXQodGhpcy51cmkpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIldlYlNvY2tldFRyYW5zcG9ydDsgdXJpPVwiICsgdGhpcy51cmk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwic3RhcnRpbmdcIik7XG4gICAgdHJhbnNwb3J0X2RlZmF1bHQucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcbiAgICBjb25zdCBzZWxmMiA9IHRoaXMsIHBhcmFtcyA9IHRoaXMucGFyYW1zLCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG4gICAgY29uc3Qgd3NTY2hlbWUgPSBvcHRpb25zLnRscyA/IFwid3NzOi8vXCIgOiBcIndzOi8vXCI7XG4gICAgY29uc3Qgd3NVcmkgPSB3c1NjaGVtZSArIHRoaXMud3NIb3N0ICsgXCI6XCIgKyBkZWZhdWx0c19kZWZhdWx0LmdldFBvcnQob3B0aW9ucykgKyBcIi9cIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwidXJpOiBcIiArIHdzVXJpKTtcbiAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICB0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcygpLFxuICAgICAgZnVuY3Rpb24oZXJyLCBhdXRoUGFyYW1zKSB7XG4gICAgICAgIGlmIChzZWxmMi5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbVN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW0gaW4gYXV0aFBhcmFtcylcbiAgICAgICAgICBwYXJhbVN0ciArPSBcIiBcIiArIHBhcmFtICsgXCI6IFwiICsgYXV0aFBhcmFtc1twYXJhbV0gKyBcIjtcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHNlbGYyLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgICAgXCJhdXRoUGFyYW1zOlwiICsgcGFyYW1TdHIgKyBcIiBlcnI6IFwiICsgZXJyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBzZWxmMi5kaXNjb25uZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSBwYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSBzZWxmMi53c0Nvbm5lY3Rpb24gPSBzZWxmMi5jcmVhdGVXZWJTb2NrZXQod3NVcmksIGNvbm5lY3RQYXJhbXMpO1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5iaW5hcnlUeXBlID0gUGxhdGZvcm0uQ29uZmlnLmJpbmFyeVR5cGU7XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZjIub25Xc09wZW4oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbmNsb3NlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NDbG9zZShldik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NEYXRhKGV2LmRhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgc2VsZjIub25Xc0Vycm9yKGV2KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpc05vZGVXZWJTb2NrZXQod3NDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9uKFwicGluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZjIub25BY3Rpdml0eSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgc2VsZjIubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIGNyZWF0aW5nIHdlYnNvY2tldDogZXJyID0gXCIgKyAoZS5zdGFjayB8fCBlLm1lc3NhZ2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmMi5kaXNjb25uZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBzZW5kKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICBpZiAoIXdzQ29ubmVjdGlvbikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKVwiLCBcIk5vIHNvY2tldCBjb25uZWN0aW9uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgd3NDb25uZWN0aW9uLnNlbmQoXG4gICAgICAgIHNlcmlhbGl6ZTIobWVzc2FnZSwgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fTXNnUGFjaywgdGhpcy5wYXJhbXMuZm9ybWF0KVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBtc2cgPSBcIkV4Y2VwdGlvbiBmcm9tIHdzIGNvbm5lY3Rpb24gd2hlbiB0cnlpbmcgdG8gc2VuZDogXCIgKyBpbnNwZWN0RXJyb3IoZSk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpXCIsIG1zZyk7XG4gICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBuZXcgRXJyb3JJbmZvKG1zZywgNWU0LCA1MDApKTtcbiAgICB9XG4gIH1cbiAgb25Xc0RhdGEoZGF0YSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKVwiLFxuICAgICAgXCJkYXRhIHJlY2VpdmVkOyBsZW5ndGggPSBcIiArIGRhdGEubGVuZ3RoICsgXCI7IHR5cGUgPSBcIiArIHR5cGVvZiBkYXRhXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5vblByb3RvY29sTWVzc2FnZShcbiAgICAgICAgZGVzZXJpYWxpemUoXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Nc2dQYWNrLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fQW5ub3RhdGlvbnMsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fbGl2ZU9iamVjdHNQbHVnaW4sXG4gICAgICAgICAgdGhpcy5mb3JtYXRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgbWVzc2FnZTogXCIgKyBlLnN0YWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBvbldzT3BlbigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc09wZW4oKVwiLCBcIm9wZW5lZCBXZWJTb2NrZXRcIik7XG4gICAgdGhpcy5lbWl0KFwicHJlY29ubmVjdFwiKTtcbiAgfVxuICBvbldzQ2xvc2UoZXYpIHtcbiAgICBsZXQgd2FzQ2xlYW4sIGNvZGU7XG4gICAgaWYgKHR5cGVvZiBldiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb2RlID0gZXYuY29kZTtcbiAgICAgIHdhc0NsZWFuID0gZXYud2FzQ2xlYW4gfHwgY29kZSA9PT0gMWUzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gZXY7XG4gICAgICB3YXNDbGVhbiA9IGNvZGUgPT0gMWUzO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgaWYgKHdhc0NsZWFuKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKClcIiwgXCJDbGVhbmx5IGNsb3NlZCBXZWJTb2NrZXRcIik7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiV2Vic29ja2V0IGNsb3NlZFwiLCA4MDAwMywgNDAwKTtcbiAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiVW5jbGVhbiBkaXNjb25uZWN0aW9uIG9mIFdlYlNvY2tldCA7IGNvZGUgPSBcIiArIGNvZGUsIGVyciA9IG5ldyBFcnJvckluZm8obXNnLCA4MDAwMywgNDAwKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiZGlzcG9zZWRcIik7XG4gIH1cbiAgb25Xc0Vycm9yKGVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25FcnJvcigpXCIsXG4gICAgICBcIkVycm9yIGZyb20gV2ViU29ja2V0OiBcIiArIGVyci5tZXNzYWdlXG4gICAgKTtcbiAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KEVycm9yKGVyci5tZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiXCIpO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgY29uc3Qgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgaWYgKHdzQ29ubmVjdGlvbikge1xuICAgICAgd3NDb25uZWN0aW9uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIldlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJjbG9zaW5nIHdlYnNvY2tldFwiKTtcbiAgICAgICAgaWYgKCF3c0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpOiB3c0Nvbm5lY3Rpb24gaXMgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgd3NDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG52YXIgd2Vic29ja2V0dHJhbnNwb3J0X2RlZmF1bHQgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9maWx0ZXJlZHN1YnNjcmlwdGlvbnMudHNcbnZhciBGaWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSBjbGFzcyB7XG4gIHN0YXRpYyBzdWJzY3JpYmVGaWx0ZXIoY2hhbm5lbCwgZmlsdGVyLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGZpbHRlcmVkTGlzdGVuZXIgPSAobSkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgY29uc3QgbWFwcGluZyA9IHtcbiAgICAgICAgbmFtZTogbS5uYW1lLFxuICAgICAgICByZWZUaW1lc2VyaWFsOiAoX2IgPSAoX2EyID0gbS5leHRyYXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2IudGltZXNlcmlhbCxcbiAgICAgICAgcmVmVHlwZTogKF9kID0gKF9jID0gbS5leHRyYXMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfZC50eXBlLFxuICAgICAgICBpc1JlZjogISEoKF9mID0gKF9lID0gbS5leHRyYXMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfZi50aW1lc2VyaWFsKSxcbiAgICAgICAgY2xpZW50SWQ6IG0uY2xpZW50SWRcbiAgICAgIH07XG4gICAgICBpZiAoT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5maW5kKFxuICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gbWFwcGluZ1trZXldICE9PSB2YWx1ZSA6IGZhbHNlXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKG0pO1xuICAgIH07XG4gICAgdGhpcy5hZGRGaWx0ZXJlZFN1YnNjcmlwdGlvbihjaGFubmVsLCBmaWx0ZXIsIGxpc3RlbmVyLCBmaWx0ZXJlZExpc3RlbmVyKTtcbiAgICBjaGFubmVsLnN1YnNjcmlwdGlvbnMub24oZmlsdGVyZWRMaXN0ZW5lcik7XG4gIH1cbiAgLy8gQWRkcyBhIG5ldyBmaWx0ZXJlZCBzdWJzY3JpcHRpb25cbiAgc3RhdGljIGFkZEZpbHRlcmVkU3Vic2NyaXB0aW9uKGNoYW5uZWwsIGZpbHRlciwgcmVhbExpc3RlbmVyLCBmaWx0ZXJlZExpc3RlbmVyKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoIWNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGlmIChjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5oYXMocmVhbExpc3RlbmVyKSkge1xuICAgICAgY29uc3QgcmVhbExpc3RlbmVyTWFwID0gY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0KHJlYWxMaXN0ZW5lcik7XG4gICAgICByZWFsTGlzdGVuZXJNYXAuc2V0KGZpbHRlciwgKChfYTIgPSByZWFsTGlzdGVuZXJNYXAgPT0gbnVsbCA/IHZvaWQgMCA6IHJlYWxMaXN0ZW5lck1hcC5nZXQoZmlsdGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb25jYXQoZmlsdGVyZWRMaXN0ZW5lcikpIHx8IFtmaWx0ZXJlZExpc3RlbmVyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLnNldChcbiAgICAgICAgcmVhbExpc3RlbmVyLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW2ZpbHRlciwgW2ZpbHRlcmVkTGlzdGVuZXJdXV0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zKGNoYW5uZWwsIGZpbHRlciwgcmVhbExpc3RlbmVyKSB7XG4gICAgaWYgKCFjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIXJlYWxMaXN0ZW5lciAmJiBmaWx0ZXIpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmVudHJpZXMoKSkubWFwKChba2V5LCBmaWx0ZXJNYXBzXSkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBsZXQgbGlzdGVuZXJNYXBzID0gZmlsdGVyTWFwcy5nZXQoZmlsdGVyKTtcbiAgICAgICAgZmlsdGVyTWFwcy5kZWxldGUoZmlsdGVyKTtcbiAgICAgICAgaWYgKGZpbHRlck1hcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIChfYTIgPSBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJNYXBzO1xuICAgICAgfSkucmVkdWNlKFxuICAgICAgICAocHJldiwgY3VyKSA9PiBjdXIgPyBwcmV2LmNvbmNhdCguLi5jdXIpIDogcHJldixcbiAgICAgICAgW11cbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVhbExpc3RlbmVyIHx8ICFjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5oYXMocmVhbExpc3RlbmVyKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZWFsTGlzdGVuZXJNYXAgPSBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5nZXQocmVhbExpc3RlbmVyKTtcbiAgICBpZiAoIWZpbHRlcikge1xuICAgICAgY29uc3QgbGlzdGVuZXJzMiA9IEFycmF5LmZyb20ocmVhbExpc3RlbmVyTWFwLnZhbHVlcygpKS5yZWR1Y2UoKHByZXYsIGN1cikgPT4gcHJldi5jb25jYXQoLi4uY3VyKSwgW10pO1xuICAgICAgY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZGVsZXRlKHJlYWxMaXN0ZW5lcik7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzMjtcbiAgICB9XG4gICAgbGV0IGxpc3RlbmVycyA9IHJlYWxMaXN0ZW5lck1hcC5nZXQoZmlsdGVyKTtcbiAgICByZWFsTGlzdGVuZXJNYXAuZGVsZXRlKGZpbHRlcik7XG4gICAgcmV0dXJuIGxpc3RlbmVycyB8fCBbXTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2RlZmF1bHRyZWFsdGltZS50c1xudmFyIF9EZWZhdWx0UmVhbHRpbWUgPSBjbGFzcyBfRGVmYXVsdFJlYWx0aW1lIGV4dGVuZHMgYmFzZXJlYWx0aW1lX2RlZmF1bHQge1xuICAvLyBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgcmVxdWlyZXMgYW4gYXJndW1lbnQgdG8gYmUgcGFzc2VkLCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG5vdCBwYXNzIGFuIGFyZ3VtZW50LCB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoaXMgaXMgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIGl0LlxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBNc2dQYWNrID0gX0RlZmF1bHRSZWFsdGltZS5fTXNnUGFjaztcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIERlZmF1bHRSZWFsdGltZS5fTXNnUGFjayB0byBoYXZlIGJlZW4gc2V0XCIpO1xuICAgIH1cbiAgICBzdXBlcihcbiAgICAgIGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCB0cnVlLCBcIlJlYWx0aW1lXCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGFsbENvbW1vbk1vZHVsYXJQbHVnaW5zKSwge1xuICAgICAgICBDcnlwdG86IChfYTIgPSBfRGVmYXVsdFJlYWx0aW1lLkNyeXB0bykgIT0gbnVsbCA/IF9hMiA6IHZvaWQgMCxcbiAgICAgICAgTXNnUGFjayxcbiAgICAgICAgUmVhbHRpbWVQcmVzZW5jZToge1xuICAgICAgICAgIFJlYWx0aW1lUHJlc2VuY2U6IHJlYWx0aW1lcHJlc2VuY2VfZGVmYXVsdCxcbiAgICAgICAgICBQcmVzZW5jZU1lc3NhZ2U6IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LFxuICAgICAgICAgIFdpcmVQcmVzZW5jZU1lc3NhZ2VcbiAgICAgICAgfSxcbiAgICAgICAgQW5ub3RhdGlvbnM6IHtcbiAgICAgICAgICBBbm5vdGF0aW9uOiBhbm5vdGF0aW9uX2RlZmF1bHQsXG4gICAgICAgICAgV2lyZUFubm90YXRpb24sXG4gICAgICAgICAgUmVhbHRpbWVBbm5vdGF0aW9uczogcmVhbHRpbWVhbm5vdGF0aW9uc19kZWZhdWx0LFxuICAgICAgICAgIFJlc3RBbm5vdGF0aW9uczogcmVzdGFubm90YXRpb25zX2RlZmF1bHRcbiAgICAgICAgfSxcbiAgICAgICAgV2ViU29ja2V0VHJhbnNwb3J0OiB3ZWJzb2NrZXR0cmFuc3BvcnRfZGVmYXVsdCxcbiAgICAgICAgTWVzc2FnZUludGVyYWN0aW9uczogRmlsdGVyZWRTdWJzY3JpcHRpb25zXG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIHN0YXRpYyBnZXQgQ3J5cHRvKCkge1xuICAgIGlmICh0aGlzLl9DcnlwdG8gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX0NyeXB0bztcbiAgfVxuICBzdGF0aWMgc2V0IENyeXB0byhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX0NyeXB0byA9IG5ld1ZhbHVlO1xuICB9XG59O1xuX0RlZmF1bHRSZWFsdGltZS5VdGlscyA9IHV0aWxzX2V4cG9ydHM7XG5fRGVmYXVsdFJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbm1hbmFnZXJfZGVmYXVsdDtcbl9EZWZhdWx0UmVhbHRpbWUuUHJvdG9jb2xNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlX2RlZmF1bHQ7XG5fRGVmYXVsdFJlYWx0aW1lLl9DcnlwdG8gPSBudWxsO1xuX0RlZmF1bHRSZWFsdGltZS5NZXNzYWdlID0gRGVmYXVsdE1lc3NhZ2U7XG5fRGVmYXVsdFJlYWx0aW1lLlByZXNlbmNlTWVzc2FnZSA9IERlZmF1bHRQcmVzZW5jZU1lc3NhZ2U7XG5fRGVmYXVsdFJlYWx0aW1lLkFubm90YXRpb24gPSBEZWZhdWx0QW5ub3RhdGlvbjtcbl9EZWZhdWx0UmVhbHRpbWUuX01zZ1BhY2sgPSBudWxsO1xuLy8gVXNlZCBieSB0ZXN0c1xuX0RlZmF1bHRSZWFsdGltZS5fSHR0cCA9IEh0dHA7XG5fRGVmYXVsdFJlYWx0aW1lLl9QcmVzZW5jZU1hcCA9IFByZXNlbmNlTWFwO1xuX0RlZmF1bHRSZWFsdGltZS5fTWVzc2FnZUVuY29kaW5nID0gTWVzc2FnZUVuY29kaW5nO1xudmFyIERlZmF1bHRSZWFsdGltZSA9IF9EZWZhdWx0UmVhbHRpbWU7XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvbGliL3V0aWwvYnVmZmVydXRpbHMudHNcbnZhciBpbXBvcnRfY3J5cHRvID0gX190b0VTTShyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbnZhciBCdWZmZXJVdGlscyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5iYXNlNjRDaGFyU2V0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gICAgdGhpcy5oZXhDaGFyU2V0ID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIH1cbiAgYmFzZTY0RGVjb2RlKHN0cmluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmcsIFwiYmFzZTY0XCIpO1xuICB9XG4gIGJhc2U2NEVuY29kZShidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICB9XG4gIGJhc2U2NFVybEVuY29kZShidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIpLnRvU3RyaW5nKFwiYmFzZTY0dXJsXCIpO1xuICB9XG4gIGFyZUJ1ZmZlcnNFcXVhbChidWZmZXIxLCBidWZmZXIyKSB7XG4gICAgaWYgKCFidWZmZXIxIHx8ICFidWZmZXIyKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKGJ1ZmZlcjEpLmNvbXBhcmUodGhpcy50b0J1ZmZlcihidWZmZXIyKSkgPT0gMDtcbiAgfVxuICBieXRlTGVuZ3RoKGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgfVxuICBoZXhEZWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cmluZywgXCJoZXhcIik7XG4gIH1cbiAgaGV4RW5jb2RlKGJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKGJ1ZmZlcikudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cbiAgLyogSW4gbm9kZSwgQnVmZmVyVXRpbHMgbWV0aG9kcyB0aGF0IHJldHVybiBiaW5hcnkgb2JqZWN0cyByZXR1cm4gYSBCdWZmZXJcbiAgICogZm9yIGhpc3RvcmljYWwgcmVhc29uczsgdGhlIGJyb3dzZXIgZXF1aXZhbGVudHMgcmV0dXJuIEFycmF5QnVmZmVycyAqL1xuICBpc0J1ZmZlcihidWZmZXIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikgfHwgYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcik7XG4gIH1cbiAgdG9BcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgICBjb25zdCBub2RlQnVmZmVyID0gdGhpcy50b0J1ZmZlcihidWZmZXIpO1xuICAgIHJldHVybiBub2RlQnVmZmVyLmJ1ZmZlci5zbGljZShub2RlQnVmZmVyLmJ5dGVPZmZzZXQsIG5vZGVCdWZmZXIuYnl0ZU9mZnNldCArIG5vZGVCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgdG9CdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgfVxuICBhcnJheUJ1ZmZlclZpZXdUb0J1ZmZlcihhcnJheUJ1ZmZlclZpZXcpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihhcnJheUJ1ZmZlclZpZXcpO1xuICB9XG4gIHV0ZjhEZWNvZGUoYnVmZmVyKSB7XG4gICAgaWYgKCF0aGlzLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIHV0ZjhEZWNvZGUgdG8gYmUgYSBidWZmZXIsIGFycmF5YnVmZmVyLCBvciB2aWV3XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgfVxuICB1dGY4RW5jb2RlKHN0cmluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmcsIFwidXRmOFwiKTtcbiAgfVxuICBjb25jYXQoYnVmZmVycykge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMubWFwKCh4KSA9PiB0aGlzLnRvQnVmZmVyKHgpKSk7XG4gIH1cbiAgc2hhMjU2KG1lc3NhZ2UpIHtcbiAgICBjb25zdCBtZXNzYWdlQnVmZmVyID0gdGhpcy50b0J1ZmZlcihtZXNzYWdlKTtcbiAgICByZXR1cm4gaW1wb3J0X2NyeXB0by5kZWZhdWx0LmNyZWF0ZUhhc2goXCJTSEEyNTZcIikudXBkYXRlKG1lc3NhZ2VCdWZmZXIpLmRpZ2VzdCgpO1xuICB9XG4gIGhtYWNTaGEyNTYobWVzc2FnZSwga2V5KSB7XG4gICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IHRoaXMudG9CdWZmZXIobWVzc2FnZSk7XG4gICAgY29uc3Qga2V5QnVmZmVyID0gdGhpcy50b0J1ZmZlcihrZXkpO1xuICAgIHJldHVybiBpbXBvcnRfY3J5cHRvLmRlZmF1bHQuY3JlYXRlSG1hYyhcIlNIQTI1NlwiLCBrZXlCdWZmZXIpLnVwZGF0ZShtZXNzYWdlQnVmZmVyKS5kaWdlc3QoKTtcbiAgfVxufTtcbnZhciBidWZmZXJ1dGlsc19kZWZhdWx0ID0gbmV3IEJ1ZmZlclV0aWxzKCk7XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvbGliL3V0aWwvY3J5cHRvLnRzXG52YXIgaW1wb3J0X2NyeXB0bzIgPSBfX3RvRVNNKHJlcXVpcmUoXCJjcnlwdG9cIikpO1xudmFyIGltcG9ydF91dGlsID0gX190b0VTTShyZXF1aXJlKFwidXRpbFwiKSk7XG52YXIgY3JlYXRlQ3J5cHRvQ2xhc3MgPSBmdW5jdGlvbihidWZmZXJVdGlscykge1xuICB2YXIgREVGQVVMVF9BTEdPUklUSE0gPSBcImFlc1wiO1xuICB2YXIgREVGQVVMVF9LRVlMRU5HVEggPSAyNTY7XG4gIHZhciBERUZBVUxUX01PREUgPSBcImNiY1wiO1xuICB2YXIgREVGQVVMVF9CTE9DS0xFTkdUSCA9IDE2O1xuICBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbShieXRlcykge1xuICAgIHJldHVybiBpbXBvcnRfdXRpbC5kZWZhdWx0LnByb21pc2lmeShpbXBvcnRfY3J5cHRvMi5kZWZhdWx0LnJhbmRvbUJ5dGVzKShieXRlcyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCkge1xuICAgIHJldHVybiBwbGFpbnRleHRMZW5ndGggKyBERUZBVUxUX0JMT0NLTEVOR1RIICYgLURFRkFVTFRfQkxPQ0tMRU5HVEg7XG4gIH1cbiAgZnVuY3Rpb24gdmFsaWRhdGVDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5hbGdvcml0aG0gPT09IFwiYWVzXCIgJiYgcGFyYW1zLm1vZGUgPT09IFwiY2JjXCIpIHtcbiAgICAgIGlmIChwYXJhbXMua2V5TGVuZ3RoID09PSAxMjggfHwgcGFyYW1zLmtleUxlbmd0aCA9PT0gMjU2KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJVbnN1cHBvcnRlZCBrZXkgbGVuZ3RoIFwiICsgcGFyYW1zLmtleUxlbmd0aCArIFwiIGZvciBhZXMtY2JjIGVuY3J5cHRpb24uIEVuY3J5cHRpb24ga2V5IG11c3QgYmUgMTI4IG9yIDI1NiBiaXRzICgxNiBvciAzMiBBU0NJSSBjaGFyYWN0ZXJzKVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpc2VCYXNlNjQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKFwiX1wiLCBcIi9cIikucmVwbGFjZShcIi1cIiwgXCIrXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbGxlZEJ1ZmZlcihsZW5ndGgsIHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgIHJlc3VsdC5maWxsKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBwa2NzNVBhZGRpbmcgPSBbZmlsbGVkQnVmZmVyKDE2LCAxNildO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSAxNjsgaSsrKVxuICAgIHBrY3M1UGFkZGluZy5wdXNoKGZpbGxlZEJ1ZmZlcihpLCBpKSk7XG4gIGNsYXNzIENpcGhlclBhcmFtcyB7XG4gICAgY29uc3RydWN0b3IoYWxnb3JpdGhtLCBrZXlMZW5ndGgsIG1vZGUsIGtleSkge1xuICAgICAgdGhpcy5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICB0aGlzLmtleUxlbmd0aCA9IGtleUxlbmd0aDtcbiAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuaXYgPSBudWxsO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0luc3RDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG4gICAgcmV0dXJuICEhKHBhcmFtcy5hbGdvcml0aG0gJiYgcGFyYW1zLmtleSAmJiBwYXJhbXMua2V5TGVuZ3RoICYmIHBhcmFtcy5tb2RlKTtcbiAgfVxuICBjbGFzcyBDcnlwdG8yIHtcbiAgICAvKipcbiAgICAgKiBPYnRhaW4gYSBjb21wbGV0ZSBDaXBoZXJQYXJhbXMgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQgcGFyYW1zLCBmaWxsaW5nXG4gICAgICogaW4gYW55IG5vdCBwcm92aWRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzLCBjYWxjdWxhdGluZyBhIGtleUxlbmd0aCBmcm9tXG4gICAgICogdGhlIHN1cHBsaWVkIGtleSwgYW5kIHZhbGlkYXRpbmcgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIGFuIG9iamVjdCBjb250YWluaW5nIGF0IGEgbWluaW11bSBhIGBrZXlgIGtleSB3aXRoIHZhbHVlIHRoZVxuICAgICAqIGtleSwgYXMgZWl0aGVyIGEgYmluYXJ5IG9yIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqIE1heSBvcHRpb25hbGx5IGFsc28gY29udGFpbjogYWxnb3JpdGhtIChkZWZhdWx0cyB0byBBRVMpLFxuICAgICAqIG1vZGUgKGRlZmF1bHRzIHRvICdjYmMnKVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREZWZhdWx0UGFyYW1zKHBhcmFtcykge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGlmICghcGFyYW1zLmtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXkgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5rZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAga2V5ID0gYnVmZmVyVXRpbHMuYmFzZTY0RGVjb2RlKG5vcm1hbGlzZUJhc2U2NChwYXJhbXMua2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5rZXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBrZXkgPSBCdWZmZXIuZnJvbShwYXJhbXMua2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IHBhcmFtcy5rZXk7XG4gICAgICB9XG4gICAgICB2YXIgYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSB8fCBERUZBVUxUX0FMR09SSVRITTtcbiAgICAgIHZhciBrZXlMZW5ndGggPSBrZXkubGVuZ3RoICogODtcbiAgICAgIHZhciBtb2RlID0gcGFyYW1zLm1vZGUgfHwgREVGQVVMVF9NT0RFO1xuICAgICAgdmFyIGNpcGhlclBhcmFtcyA9IG5ldyBDaXBoZXJQYXJhbXMoYWxnb3JpdGhtLCBrZXlMZW5ndGgsIG1vZGUsIGtleSk7XG4gICAgICBpZiAocGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMua2V5TGVuZ3RoICE9PSBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleUxlbmd0aCBvZiBcIiArIHBhcmFtcy5rZXlMZW5ndGggKyBcIiB3YXMgc3BlY2lmaWVkLCBidXQgdGhlIGtleSBhY3R1YWxseSBoYXMgbGVuZ3RoIFwiICsgY2lwaGVyUGFyYW1zLmtleUxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVDaXBoZXJQYXJhbXMoY2lwaGVyUGFyYW1zKTtcbiAgICAgIHJldHVybiBjaXBoZXJQYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgcmFuZG9tIGVuY3J5cHRpb24ga2V5IGZyb20gdGhlIHN1cHBsaWVkIGtleWxlbmd0aCAob3IgdGhlXG4gICAgICogZGVmYXVsdCBrZXlMZW5ndGggaWYgbm9uZSBzdXBwbGllZCkgYXMgYSBCdWZmZXJcbiAgICAgKiBAcGFyYW0ga2V5TGVuZ3RoIChvcHRpb25hbCkgdGhlIHJlcXVpcmVkIGtleUxlbmd0aCBpbiBiaXRzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlUmFuZG9tS2V5KGtleUxlbmd0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlUmFuZG9tKChrZXlMZW5ndGggfHwgREVGQVVMVF9LRVlMRU5HVEgpIC8gOCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIkZhaWxlZCB0byBnZW5lcmF0ZSByYW5kb20ga2V5OiBcIiArIGVyci5tZXNzYWdlLCA1MDAsIDVlNCwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWw7IGdldCBhIENoYW5uZWxDaXBoZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGdpdmVuIGNpcGhlclBhcmFtc1xuICAgICAqIEBwYXJhbSBwYXJhbXMgZWl0aGVyIGEgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIG9yIHNvbWUgc3Vic2V0IG9mIGl0c1xuICAgICAqIGZpZWxkcyB0aGF0IGluY2x1ZGVzIGEga2V5XG4gICAgICovXG4gICAgc3RhdGljIGdldENpcGhlcihwYXJhbXMsIGxvZ2dlcikge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHZhciBjaXBoZXJQYXJhbXMgPSBpc0luc3RDaXBoZXJQYXJhbXMocGFyYW1zKSA/IHBhcmFtcyA6IHRoaXMuZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2lwaGVyUGFyYW1zLFxuICAgICAgICBjaXBoZXI6IG5ldyBDQkNDaXBoZXIoY2lwaGVyUGFyYW1zLCAoX2EyID0gcGFyYW1zLml2KSAhPSBudWxsID8gX2EyIDogbnVsbCwgbG9nZ2VyKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgQ3J5cHRvMi5DaXBoZXJQYXJhbXMgPSBDaXBoZXJQYXJhbXM7XG4gIENyeXB0bzI7XG4gIGNsYXNzIENCQ0NpcGhlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCBpdiwgbG9nZ2VyKSB7XG4gICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgIHRoaXMuZW5jcnlwdENpcGhlciA9IG51bGw7XG4gICAgICB0aGlzLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gKyBcIi1cIiArIFN0cmluZyhwYXJhbXMua2V5TGVuZ3RoKSArIFwiLVwiICsgcGFyYW1zLm1vZGU7XG4gICAgICB0aGlzLmtleSA9IHBhcmFtcy5rZXk7XG4gICAgICB0aGlzLml2ID0gaXY7XG4gICAgfVxuICAgIGFzeW5jIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDQkNDaXBoZXIuZW5jcnlwdCgpXCIsIFwiXCIpO1xuICAgICAgY29uc3QgaXYgPSBhd2FpdCB0aGlzLmdldEl2KCk7XG4gICAgICBpZiAoIXRoaXMuZW5jcnlwdENpcGhlcikge1xuICAgICAgICB0aGlzLmVuY3J5cHRDaXBoZXIgPSBpbXBvcnRfY3J5cHRvMi5kZWZhdWx0LmNyZWF0ZUNpcGhlcml2KHRoaXMuYWxnb3JpdGhtLCB0aGlzLmtleSwgaXYpO1xuICAgICAgfVxuICAgICAgdmFyIHBsYWludGV4dEJ1ZmZlciA9IGJ1ZmZlclV0aWxzLnRvQnVmZmVyKHBsYWludGV4dCk7XG4gICAgICB2YXIgcGxhaW50ZXh0TGVuZ3RoID0gcGxhaW50ZXh0QnVmZmVyLmxlbmd0aCwgcGFkZGVkTGVuZ3RoID0gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCk7XG4gICAgICB2YXIgY2lwaGVyT3V0ID0gdGhpcy5lbmNyeXB0Q2lwaGVyLnVwZGF0ZShcbiAgICAgICAgQnVmZmVyLmNvbmNhdChbcGxhaW50ZXh0QnVmZmVyLCBwa2NzNVBhZGRpbmdbcGFkZGVkTGVuZ3RoIC0gcGxhaW50ZXh0TGVuZ3RoXV0pXG4gICAgICApO1xuICAgICAgdmFyIGNpcGhlcnRleHQgPSBCdWZmZXIuY29uY2F0KFtpdiwgY2lwaGVyT3V0XSk7XG4gICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG4gICAgYXN5bmMgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICB2YXIgZGVjcnlwdENpcGhlciA9IGltcG9ydF9jcnlwdG8yLmRlZmF1bHQuY3JlYXRlRGVjaXBoZXJpdih0aGlzLmFsZ29yaXRobSwgdGhpcy5rZXksIGNpcGhlcnRleHQuc2xpY2UoMCwgREVGQVVMVF9CTE9DS0xFTkdUSCkpLCBwbGFpbnRleHQgPSBkZWNyeXB0Q2lwaGVyLnVwZGF0ZShjaXBoZXJ0ZXh0LnNsaWNlKERFRkFVTFRfQkxPQ0tMRU5HVEgpKSwgZmluYWwgPSBkZWNyeXB0Q2lwaGVyLmZpbmFsKCk7XG4gICAgICBpZiAoZmluYWwgJiYgZmluYWwubGVuZ3RoKVxuICAgICAgICBwbGFpbnRleHQgPSBCdWZmZXIuY29uY2F0KFtwbGFpbnRleHQsIGZpbmFsXSk7XG4gICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbiAgICBhc3luYyBnZXRJdigpIHtcbiAgICAgIGlmICh0aGlzLml2KSB7XG4gICAgICAgIHZhciBpdiA9IHRoaXMuaXY7XG4gICAgICAgIHRoaXMuaXYgPSBudWxsO1xuICAgICAgICByZXR1cm4gaXY7XG4gICAgICB9XG4gICAgICB2YXIgcmFuZG9tQmxvY2sgPSBhd2FpdCBnZW5lcmF0ZVJhbmRvbShERUZBVUxUX0JMT0NLTEVOR1RIKTtcbiAgICAgIGlmICghdGhpcy5lbmNyeXB0Q2lwaGVyKSB7XG4gICAgICAgIHJldHVybiByYW5kb21CbG9jaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRDaXBoZXIudXBkYXRlKHJhbmRvbUJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIENyeXB0bzI7XG59O1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi91dGlsL2h0dHAudHNcbnZhciBpbXBvcnRfZ290ID0gX190b0VTTShyZXF1aXJlKFwiZ290XCIpKTtcbnZhciBpbXBvcnRfaHR0cDUgPSBfX3RvRVNNKHJlcXVpcmUoXCJodHRwXCIpKTtcbnZhciBpbXBvcnRfaHR0cHMgPSBfX3RvRVNNKHJlcXVpcmUoXCJodHRwc1wiKSk7XG52YXIgZ2xvYmFsQWdlbnRQb29sID0gW107XG52YXIgX2E7XG52YXIgSHR0cDIgPSAoX2EgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuYWdlbnQgPSBudWxsO1xuICAgIHRoaXMuc3VwcG9ydHNBdXRoSGVhZGVycyA9IHRydWU7XG4gICAgdGhpcy5zdXBwb3J0c0xpbmtIZWFkZXJzID0gdHJ1ZTtcbiAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICBpZiAoKF9hMiA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm9wdGlvbnMuZGlzYWJsZUNvbm5lY3Rpdml0eUNoZWNrKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSAoKF9iID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsKSB8fCBkZWZhdWx0c19kZWZhdWx0LmNvbm5lY3Rpdml0eUNoZWNrVXJsO1xuICAgICAgY29uc3QgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSAoX2QgPSAoX2MgPSB0aGlzLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMpICE9IG51bGwgPyBfZCA6IG51bGw7XG4gICAgICBjb25zdCBjb25uZWN0aXZpdHlVcmxJc0RlZmF1bHQgPSAhKChfZSA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Uub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybCk7XG4gICAgICBjb25zdCB7IGVycm9yLCBzdGF0dXNDb2RlLCBib2R5IH0gPSBhd2FpdCB0aGlzLmRvVXJpKFxuICAgICAgICBIdHRwTWV0aG9kc19kZWZhdWx0LkdldCxcbiAgICAgICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zXG4gICAgICApO1xuICAgICAgaWYgKCFlcnJvciAmJiAhY29ubmVjdGl2aXR5VXJsSXNEZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBpc1N1Y2Nlc3NDb2RlKHN0YXR1c0NvZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFlcnJvciAmJiAoYm9keSA9PSBudWxsID8gdm9pZCAwIDogYm9keS50b1N0cmluZygpLnRyaW0oKSkgPT09IFwieWVzXCI7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudCAhPSBudWxsID8gY2xpZW50IDogbnVsbDtcbiAgfVxuICBhc3luYyBkb1VyaShtZXRob2QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB0aGlzLmNsaWVudCAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnJlc3RBZ2VudE9wdGlvbnMgfHwgZGVmYXVsdHNfZGVmYXVsdC5yZXN0QWdlbnRPcHRpb25zO1xuICAgIGNvbnN0IGRvT3B0aW9ucyA9IHsgaGVhZGVyczogaGVhZGVycyB8fCB2b2lkIDAsIHJlc3BvbnNlVHlwZTogXCJidWZmZXJcIiB9O1xuICAgIGlmICghdGhpcy5hZ2VudCkge1xuICAgICAgY29uc3QgcGVyc2lzdGVkQWdlbnQgPSAoX2EyID0gZ2xvYmFsQWdlbnRQb29sLmZpbmQoKHgpID0+IHNoYWxsb3dFcXVhbHMoYWdlbnRPcHRpb25zLCB4Lm9wdGlvbnMpKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5hZ2VudHM7XG4gICAgICBpZiAocGVyc2lzdGVkQWdlbnQpIHtcbiAgICAgICAgdGhpcy5hZ2VudCA9IHBlcnNpc3RlZEFnZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZ2VudCA9IHtcbiAgICAgICAgICBodHRwOiBuZXcgaW1wb3J0X2h0dHA1LmRlZmF1bHQuQWdlbnQoYWdlbnRPcHRpb25zKSxcbiAgICAgICAgICBodHRwczogbmV3IGltcG9ydF9odHRwcy5kZWZhdWx0LkFnZW50KGFnZW50T3B0aW9ucylcbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmFsQWdlbnRQb29sLnB1c2goe1xuICAgICAgICAgIG9wdGlvbnM6IGFnZW50T3B0aW9ucyxcbiAgICAgICAgICBhZ2VudHM6IHRoaXMuYWdlbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICBkb09wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMpXG4gICAgICBkb09wdGlvbnMuc2VhcmNoUGFyYW1zID0gcGFyYW1zO1xuICAgIGRvT3B0aW9ucy5hZ2VudCA9IHRoaXMuYWdlbnQ7XG4gICAgZG9PcHRpb25zLnVybCA9IHVyaTtcbiAgICBkb09wdGlvbnMudGltZW91dCA9IHtcbiAgICAgIHJlcXVlc3Q6ICh0aGlzLmNsaWVudCAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuVElNRU9VVFMpLmh0dHBSZXF1ZXN0VGltZW91dFxuICAgIH07XG4gICAgZG9PcHRpb25zLnJldHJ5ID0geyBsaW1pdDogMCB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBpbXBvcnRfZ290LmRlZmF1bHRbbWV0aG9kXShkb09wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXIobnVsbCwgcmVzLCByZXMuYm9keSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgaW1wb3J0X2dvdC5kZWZhdWx0LkhUVFBFcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlcihudWxsLCBlcnIucmVzcG9uc2UsIGVyci5yZXNwb25zZS5ib2R5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyKGVycik7XG4gICAgfVxuICB9XG4gIHNob3VsZEZhbGxiYWNrKGVycikge1xuICAgIGNvbnN0IHsgY29kZSwgc3RhdHVzQ29kZSB9ID0gZXJyO1xuICAgIHJldHVybiBjb2RlID09PSBcIkVORVRVTlJFQUNIXCIgfHwgY29kZSA9PT0gXCJFSE9TVFVOUkVBQ0hcIiB8fCBjb2RlID09PSBcIkVIT1NURE9XTlwiIHx8IGNvZGUgPT09IFwiRVRJTUVET1VUXCIgfHwgY29kZSA9PT0gXCJFU09DS0VUVElNRURPVVRcIiB8fCBjb2RlID09PSBcIkVOT1RGT1VORFwiIHx8IGNvZGUgPT09IFwiRUNPTk5SRVNFVFwiIHx8IGNvZGUgPT09IFwiRUNPTk5SRUZVU0VEXCIgfHwgc3RhdHVzQ29kZSA+PSA1MDAgJiYgc3RhdHVzQ29kZSA8PSA1MDQ7XG4gIH1cbiAgX2hhbmRsZXIoZXJyLCByZXNwb25zZSwgYm9keSkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IGVyciB9O1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZSwgaGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgaWYgKHN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICBzd2l0Y2ggKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pIHtcbiAgICAgICAgY2FzZSBcImFwcGxpY2F0aW9uL2pzb25cIjpcbiAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFwcGxpY2F0aW9uL3gtbXNncGFja1wiOlxuICAgICAgICAgIGlmICghKChfYTIgPSB0aGlzLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5fTXNnUGFjaykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkgPSB0aGlzLmNsaWVudC5fTXNnUGFjay5kZWNvZGUoYm9keSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IGJvZHkuZXJyb3IgPyBFcnJvckluZm8uZnJvbVZhbHVlcyhib2R5LmVycm9yKSA6IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGhlYWRlcnNbXCJ4LWFibHktZXJyb3JtZXNzYWdlXCJdIHx8IFwiRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6IFwiICsgc3RhdHVzQ29kZSArIFwiIGJvZHkgd2FzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGJvZHkpLFxuICAgICAgICBOdW1iZXIoaGVhZGVyc1tcIngtYWJseS1lcnJvcmNvZGVcIl0pLFxuICAgICAgICBzdGF0dXNDb2RlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgZXJyb3IsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkOiB0cnVlLCBzdGF0dXNDb2RlIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVycm9yOiBudWxsLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZDogZmFsc2UsIHN0YXR1c0NvZGUgfTtcbiAgfVxufSwgX2EubWV0aG9kcyA9IFtIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5EZWxldGUsIEh0dHBNZXRob2RzX2RlZmF1bHQuUG9zdCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5QdXQsIEh0dHBNZXRob2RzX2RlZmF1bHQuUGF0Y2hdLCBfYS5tZXRob2RzV2l0aG91dEJvZHkgPSBbSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsIEh0dHBNZXRob2RzX2RlZmF1bHQuRGVsZXRlXSwgX2EubWV0aG9kc1dpdGhCb2R5ID0gW0h0dHBNZXRob2RzX2RlZmF1bHQuUG9zdCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5QdXQsIEh0dHBNZXRob2RzX2RlZmF1bHQuUGF0Y2hdLCBfYSk7XG52YXIgaHR0cF9kZWZhdWx0ID0gSHR0cDI7XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvY29uZmlnLnRzXG52YXIgaW1wb3J0X2NyeXB0bzMgPSBfX3RvRVNNKHJlcXVpcmUoXCJjcnlwdG9cIikpO1xudmFyIGltcG9ydF93cyA9IF9fdG9FU00ocmVxdWlyZShcIndzXCIpKTtcbnZhciBpbXBvcnRfdXRpbDIgPSBfX3RvRVNNKHJlcXVpcmUoXCJ1dGlsXCIpKTtcbnZhciBDb25maWcgPSB7XG4gIGFnZW50OiBcIm5vZGVqcy9cIiArIHByb2Nlc3MudmVyc2lvbnMubm9kZSxcbiAgbG9nVGltZXN0YW1wczogdHJ1ZSxcbiAgdXNlckFnZW50OiBudWxsLFxuICBiaW5hcnlUeXBlOiBcIm5vZGVidWZmZXJcIixcbiAgV2ViU29ja2V0OiBpbXBvcnRfd3MuZGVmYXVsdCxcbiAgdXNlUHJvdG9jb2xIZWFydGJlYXRzOiBmYWxzZSxcbiAgc3VwcG9ydHNCaW5hcnk6IHRydWUsXG4gIHByZWZlckJpbmFyeTogdHJ1ZSxcbiAgbmV4dFRpY2s6IHByb2Nlc3MubmV4dFRpY2ssXG4gIGluc3BlY3Q6IGltcG9ydF91dGlsMi5kZWZhdWx0Lmluc3BlY3QsXG4gIHN0cmluZ0J5dGVTaXplOiBCdWZmZXIuYnl0ZUxlbmd0aCxcbiAgaW5oZXJpdHM6IGltcG9ydF91dGlsMi5kZWZhdWx0LmluaGVyaXRzLFxuICBhZGRFdmVudExpc3RlbmVyOiBudWxsLFxuICBnZXRSYW5kb21BcnJheUJ1ZmZlcjogYXN5bmMgZnVuY3Rpb24oYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBpbXBvcnRfdXRpbDIuZGVmYXVsdC5wcm9taXNpZnkoaW1wb3J0X2NyeXB0bzMuZGVmYXVsdC5yYW5kb21CeXRlcykoYnl0ZUxlbmd0aCk7XG4gIH1cbn07XG52YXIgY29uZmlnX2RlZmF1bHQgPSBDb25maWc7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL1hIUlN0YXRlcy50c1xudmFyIFhIUlN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFhIUlN0YXRlczIpID0+IHtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1NFTkRcIl0gPSAwXSA9IFwiUkVRX1NFTkRcIjtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1JFQ1ZcIl0gPSAxXSA9IFwiUkVRX1JFQ1ZcIjtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1JFQ1ZfUE9MTFwiXSA9IDJdID0gXCJSRVFfUkVDVl9QT0xMXCI7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9SRUNWX1NUUkVBTVwiXSA9IDNdID0gXCJSRVFfUkVDVl9TVFJFQU1cIjtcbiAgcmV0dXJuIFhIUlN0YXRlczI7XG59KShYSFJTdGF0ZXMgfHwge30pO1xudmFyIFhIUlN0YXRlc19kZWZhdWx0ID0gWEhSU3RhdGVzO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29tZXR0cmFuc3BvcnQudHNcbmZ1bmN0aW9uIHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSB7XG4gIGNvbnN0IFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUyA9IFs4MDAxNSwgODAwMTcsIDgwMDMwXTtcbiAgaWYgKGVyci5jb2RlKSB7XG4gICAgaWYgKGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKGVycikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUy5pbmNsdWRlcyhlcnIuY29kZSkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZXJyLmNvZGUgPj0gNGU0ICYmIGVyci5jb2RlIDwgNWU0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikge1xuICBpZiAoc2hvdWxkQmVFcnJvckFjdGlvbihlcnIpKSB7XG4gICAgcmV0dXJuIFtmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkVSUk9SLCBlcnJvcjogZXJyIH0pXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2Zyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuRElTQ09OTkVDVEVELCBlcnJvcjogZXJyIH0pXTtcbiAgfVxufVxudmFyIENvbWV0VHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyB0cmFuc3BvcnRfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICBzdXBlcihcbiAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLFxuICAgICAgYXV0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIC8qIGJpbmFyeSBub3Qgc3VwcG9ydGVkIGZvciBjb21ldCBzbyBmb3JjZSBKU09OIHByb3RvY29sICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICAvKiBIaXN0b3JpY2FsIGNvbW1lbnQsIGJhY2sgZnJvbSB3aGVuIHdlIHN1cHBvcnRlZCBKU09OUDpcbiAgICAgKlxuICAgICAqID4gRm9yIGNvbWV0LCB3ZSBjb3VsZCBkbyB0aGUgYXV0aCB1cGRhdGUgYnkgYWJvcnRpbmcgdGhlIGN1cnJlbnQgcmVjdiBhbmRcbiAgICAgKiA+IHN0YXJ0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRoYXQnZCBiZSBzdWZmaWNpZW50IGZvciByZWFsdGltZS5cbiAgICAgKiA+IFByb2JsZW0gaXMgSlNPTlAgLSB5b3UgY2FuJ3QgY2FuY2VsIHRydWx5IGFib3J0IGEgcmVjdiBvbmNlIHN0YXJ0ZWQuIFNvXG4gICAgICogPiB3ZSBuZWVkIHRvIHNlbmQgYW4gQVVUSCBmb3IganNvbnAuIEluIHdoaWNoIGNhc2UgaXQncyBzaW1wbGVyIHRvIGtlZXAgYWxsXG4gICAgICogPiBjb21ldCB0cmFuc3BvcnRzIHRoZSBzYW1lIGFuZCBkbyBpdCBmb3IgYWxsIG9mIHRoZW0uIFNvIHdlIHNlbmQgdGhlIEFVVEhcbiAgICAgKiA+IGluc3RlYWQsIGFuZCBkb24ndCBuZWVkIHRvIGFib3J0IHRoZSByZWN2XG4gICAgICpcbiAgICAgKiBOb3cgdGhhdCB3ZeKAmXZlIGRyb3BwZWQgSlNPTlAgc3VwcG9ydCwgd2UgbWF5IGJlIGFibGUgdG8gcmV2aXNpdCB0aGUgYWJvdmU7XG4gICAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzEyMTQuXG4gICAgICovXG4gICAgdGhpcy5vbkF1dGhVcGRhdGVkID0gKHRva2VuRGV0YWlscykgPT4ge1xuICAgICAgdGhpcy5hdXRoUGFyYW1zID0geyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9O1xuICAgIH07XG4gICAgdGhpcy5zdHJlYW0gPSBcInN0cmVhbVwiIGluIHBhcmFtcyA/IHBhcmFtcy5zdHJlYW0gOiB0cnVlO1xuICAgIHRoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJzdGFydGluZ1wiKTtcbiAgICB0cmFuc3BvcnRfZGVmYXVsdC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcbiAgICBjb25zdCBob3N0ID0gcGFyYW1zLmhvc3QgfHwgb3B0aW9ucy5wcmltYXJ5RG9tYWluO1xuICAgIGNvbnN0IHBvcnQgPSBkZWZhdWx0c19kZWZhdWx0LmdldFBvcnQob3B0aW9ucyk7XG4gICAgY29uc3QgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/IFwiaHR0cHM6Ly9cIiA6IFwiaHR0cDovL1wiO1xuICAgIHRoaXMuYmFzZVVyaSA9IGNvbWV0U2NoZW1lICsgaG9zdCArIFwiOlwiICsgcG9ydCArIFwiL2NvbWV0L1wiO1xuICAgIGNvbnN0IGNvbm5lY3RVcmkgPSB0aGlzLmJhc2VVcmkgKyBcImNvbm5lY3RcIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJ1cmk6IFwiICsgY29ubmVjdFVyaSk7XG4gICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKCksIChlcnIsIGF1dGhQYXJhbXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRoUGFyYW1zID0gYXV0aFBhcmFtcztcbiAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSB0aGlzLnBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuICAgICAgaWYgKFwic3RyZWFtXCIgaW4gY29ubmVjdFBhcmFtcylcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBjb25uZWN0UGFyYW1zLnN0cmVhbTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIixcbiAgICAgICAgXCJjb25uZWN0UGFyYW1zOlwiICsgdG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKVxuICAgICAgKTtcbiAgICAgIGxldCBwcmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbm5lY3RSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgICAgY29ubmVjdFVyaSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY29ubmVjdFBhcmFtcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVlxuICAgICAgKTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmVjb25uZWN0ZWQpIHtcbiAgICAgICAgICBwcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZW1pdChcInByZWNvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycjIpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgZXJyMiA9IGVycjIgfHwgbmV3IEVycm9ySW5mbyhcIlJlcXVlc3QgY2FuY2VsbGVkXCIsIDgwMDAzLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgICBpZiAoIXByZWNvbm5lY3RlZCAmJiAhZXJyMikge1xuICAgICAgICAgIHByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicHJlY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICBpZiAoZXJyMi5jb2RlKSB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyMikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVjdigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29ubmVjdFJlcXVlc3QuZXhlYygpO1xuICAgIH0pO1xuICB9XG4gIHJlcXVlc3RDbG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKVwiKTtcbiAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QodHJ1ZSk7XG4gIH1cbiAgcmVxdWVzdERpc2Nvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKVwiKTtcbiAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoZmFsc2UpO1xuICB9XG4gIF9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoY2xvc2luZykge1xuICAgIGNvbnN0IGNsb3NlT3JEaXNjb25uZWN0VXJpID0gY2xvc2luZyA/IHRoaXMuY2xvc2VVcmkgOiB0aGlzLmRpc2Nvbm5lY3RVcmk7XG4gICAgaWYgKGNsb3NlT3JEaXNjb25uZWN0VXJpKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KGNsb3NlT3JEaXNjb25uZWN0VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5EKTtcbiAgICAgIHJlcXVlc3Qub24oXCJjb21wbGV0ZVwiLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdFwiICsgKGNsb3NpbmcgPyBcIkNsb3NlKClcIiA6IFwiRGlzY29ubmVjdCgpXCIpLFxuICAgICAgICAgICAgXCJyZXF1ZXN0IHJldHVybmVkIGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVxdWVzdC5leGVjKCk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiXCIpO1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiYWJvcnRpbmcgcmVjdiByZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcImRpc3Bvc2VkXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uQ29ubmVjdChtZXNzYWdlKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25TdHIgPSAoX2EyID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb25uZWN0aW9uS2V5O1xuICAgIHRyYW5zcG9ydF9kZWZhdWx0LnByb3RvdHlwZS5vbkNvbm5lY3QuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBjb25zdCBiYXNlQ29ubmVjdGlvblVyaSA9IHRoaXMuYmFzZVVyaSArIGNvbm5lY3Rpb25TdHI7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29tZXRUcmFuc3BvcnQub25Db25uZWN0KClcIiwgXCJiYXNlVXJpID0gXCIgKyBiYXNlQ29ubmVjdGlvblVyaSk7XG4gICAgdGhpcy5zZW5kVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9zZW5kXCI7XG4gICAgdGhpcy5yZWN2VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9yZWN2XCI7XG4gICAgdGhpcy5jbG9zZVVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgXCIvY2xvc2VcIjtcbiAgICB0aGlzLmRpc2Nvbm5lY3RVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArIFwiL2Rpc2Nvbm5lY3RcIjtcbiAgfVxuICBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcbiAgICAgIHRoaXMucGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuICAgIHBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICB9XG4gIHNlbmRBbnlQZW5kaW5nKCkge1xuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zO1xuICAgIGlmICghcGVuZGluZ0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICB9XG4gIHNlbmRJdGVtcyhpdGVtcykge1xuICAgIGNvbnN0IHNlbmRSZXF1ZXN0ID0gdGhpcy5zZW5kUmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHRoaXMuc2VuZFVyaSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmF1dGhQYXJhbXMsXG4gICAgICB0aGlzLmVuY29kZVJlcXVlc3QoaXRlbXMpLFxuICAgICAgWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1NFTkRcbiAgICApO1xuICAgIHNlbmRSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycilcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkNvbWV0VHJhbnNwb3J0LnNlbmRJdGVtcygpXCIsXG4gICAgICAgICAgXCJvbiBjb21wbGV0ZTogZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICApO1xuICAgICAgdGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgIHRoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdJdGVtcykge1xuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kQW55UGVuZGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VuZFJlcXVlc3QuZXhlYygpO1xuICB9XG4gIHJlY3YoKSB7XG4gICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJlY3ZSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHRoaXMucmVjdlVyaSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmF1dGhQYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9QT0xMXG4gICAgKTtcbiAgICByZWN2UmVxdWVzdC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgIH0pO1xuICAgIHJlY3ZSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycikgPT4ge1xuICAgICAgdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMucmVjdigpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmVjdlJlcXVlc3QuZXhlYygpO1xuICB9XG4gIG9uRGF0YShyZXNwb25zZURhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmRlY29kZVJlc3BvbnNlKHJlc3BvbnNlRGF0YSk7XG4gICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoXG4gICAgICAgICAgICBmcm9tRGVzZXJpYWxpemVkKFxuICAgICAgICAgICAgICBpdGVtc1tpXSxcbiAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fQW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX2xpdmVPYmplY3RzUGx1Z2luXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29tZXRUcmFuc3BvcnQub25EYXRhKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgZXZlbnQ6IFwiICsgZS5zdGFja1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlUmVxdWVzdChyZXF1ZXN0SXRlbXMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVxdWVzdEl0ZW1zKTtcbiAgfVxuICBkZWNvZGVSZXNwb25zZShyZXNwb25zZURhdGEpIHtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlRGF0YSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2VEYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2VEYXRhO1xuICB9XG59O1xudmFyIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQgPSBDb21ldFRyYW5zcG9ydDtcblxuLy8gc3JjL3BsYXRmb3JtL25vZGVqcy9saWIvdHJhbnNwb3J0L25vZGVjb21ldHRyYW5zcG9ydC5qc1xudmFyIGltcG9ydF9odHRwNiA9IF9fdG9FU00ocmVxdWlyZShcImh0dHBcIikpO1xudmFyIGltcG9ydF9odHRwczIgPSBfX3RvRVNNKHJlcXVpcmUoXCJodHRwc1wiKSk7XG52YXIgaW1wb3J0X3VybCA9IF9fdG9FU00ocmVxdWlyZShcInVybFwiKSk7XG52YXIgaW1wb3J0X3V0aWwzID0gX190b0VTTShyZXF1aXJlKFwidXRpbFwiKSk7XG52YXIgbm9vcDMgPSBmdW5jdGlvbigpIHtcbn07XG52YXIgc2hvcnROYW1lMiA9IFRyYW5zcG9ydE5hbWVzLkNvbWV0O1xudmFyIE5vZGVDb21ldFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgY29tZXR0cmFuc3BvcnRfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICBzdXBlcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcbiAgICB0aGlzLmh0dHBBZ2VudCA9IG51bGw7XG4gICAgdGhpcy5odHRwc0FnZW50ID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IDA7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWUyO1xuICB9XG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJOb2RlQ29tZXRUcmFuc3BvcnQ7IHVyaT1cIiArIHRoaXMuYmFzZVVyaSArIFwiOyBpc0Nvbm5lY3RlZD1cIiArIHRoaXMuaXNDb25uZWN0ZWQgKyBcIjsgZm9ybWF0PVwiICsgdGhpcy5mb3JtYXQgKyBcIjsgc3RyZWFtPVwiICsgdGhpcy5zdHJlYW07XG4gIH1cbiAgZ2V0QWdlbnQodGxzKSB7XG4gICAgdmFyIHByb3AgPSB0bHMgPyBcImh0dHBzQWdlbnRcIiA6IFwiaHR0cEFnZW50XCIsIGFnZW50MiA9IHRoaXNbcHJvcF07XG4gICAgaWYgKCFhZ2VudDIpXG4gICAgICBhZ2VudDIgPSB0aGlzW3Byb3BdID0gbmV3ICh0bHMgPyBpbXBvcnRfaHR0cHMyLmRlZmF1bHQgOiBpbXBvcnRfaHR0cDYuZGVmYXVsdCkuQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUgfSk7XG4gICAgcmV0dXJuIGFnZW50MjtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHZhciBzZWxmMiA9IHRoaXM7XG4gICAgdGhpcy5vbmNlTm9QZW5kaW5nKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYyLmh0dHBBZ2VudClcbiAgICAgICAgc2VsZjIuaHR0cEFnZW50LmRlc3Ryb3koKTtcbiAgICAgIGlmIChzZWxmMi5odHRwc0FnZW50KVxuICAgICAgICBzZWxmMi5odHRwc0FnZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICBjb21ldHRyYW5zcG9ydF9kZWZhdWx0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH1cbiAgLyogdmFsaWQgaW4gbm9uLXN0cmVhbWluZyBtb2RlIG9ubHksIG9yIGRhdGEgb25seSBjb250YWlucyBsYXN0IHVwZGF0ZSAqL1xuICByZXF1ZXN0KHVyaSwgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVxID0gdGhpcy5jcmVhdGVSZXF1ZXN0KHVyaSwgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSk7XG4gICAgcmVxLm9uY2UoXCJjb21wbGV0ZVwiLCBjYWxsYmFjayk7XG4gICAgcmVxLmV4ZWMoKTtcbiAgICByZXR1cm4gcmVxO1xuICB9XG4gIGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGhpcy5mb3JtYXQsIHRoaXMudGltZW91dHMsIHRoaXMpO1xuICB9XG4gIGFkZFBlbmRpbmcoKSB7XG4gICAgKyt0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuICByZW1vdmVQZW5kaW5nKCkge1xuICAgIGlmICgtLXRoaXMucGVuZGluZ1JlcXVlc3RzIDw9IDApIHtcbiAgICAgIHRoaXMuZW1pdChcIm5vcGVuZGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgb25jZU5vUGVuZGluZyhsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9PSAwKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9uY2UoXCJub3BlbmRpbmdcIiwgbGlzdGVuZXIpO1xuICB9XG59O1xudmFyIFJlcXVlc3QgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCBmb3JtYXQsIHRpbWVvdXRzLCB0cmFuc3BvcnQpIHtcbiAgICBzdXBlcih0cmFuc3BvcnQubG9nZ2VyKTtcbiAgICBpZiAodHlwZW9mIHVyaSA9PSBcInN0cmluZ1wiKVxuICAgICAgdXJpID0gaW1wb3J0X3VybC5kZWZhdWx0LnBhcnNlKHVyaSk7XG4gICAgdmFyIHRscyA9IHVyaS5wcm90b2NvbCA9PSBcImh0dHBzOlwiO1xuICAgIHRoaXMuY2xpZW50ID0gdGxzID8gaW1wb3J0X2h0dHBzMi5kZWZhdWx0IDogaW1wb3J0X2h0dHA2LmRlZmF1bHQ7XG4gICAgdGhpcy5yZXF1ZXN0TW9kZSA9IHJlcXVlc3RNb2RlO1xuICAgIHRoaXMudGltZW91dHMgPSB0aW1lb3V0cztcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXMgPSBudWxsO1xuICAgIHZhciBtZXRob2QgPSBcIkdFVFwiLCBjb250ZW50VHlwZSA9IGZvcm1hdCA9PSBcIm1zZ3BhY2tcIiA/IFwiYXBwbGljYXRpb24veC1tc2dwYWNrXCIgOiBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICBoZWFkZXJzID0gaGVhZGVycyA/IG1peGluKHt9LCBoZWFkZXJzKSA6IHt9O1xuICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gPSBjb250ZW50VHlwZTtcbiAgICBpZiAoYm9keSkge1xuICAgICAgbWV0aG9kID0gXCJQT1NUXCI7XG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIGJvZHkgPSBCdWZmZXIuZnJvbShib2R5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSBib2R5Lmxlbmd0aDtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBjb250ZW50VHlwZTtcbiAgICB9XG4gICAgdmFyIHJlcXVlc3RPcHRpb25zID0gdGhpcy5yZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgIGhvc3RuYW1lOiB1cmkuaG9zdG5hbWUsXG4gICAgICBwb3J0OiB1cmkucG9ydCxcbiAgICAgIHBhdGg6IHVyaS5wYXRoICsgdG9RdWVyeVN0cmluZyhwYXJhbXMpLFxuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVyc1xuICAgIH07XG4gICAgaWYgKHRyYW5zcG9ydClcbiAgICAgIHJlcXVlc3RPcHRpb25zLmFnZW50ID0gdHJhbnNwb3J0LmdldEFnZW50KHRscyk7XG4gIH1cbiAgZXhlYygpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMucmVxdWVzdE1vZGUgPT0gWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1NFTkQgPyB0aGlzLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IHRoaXMudGltZW91dHMucmVjdlRpbWVvdXQsIHNlbGYyID0gdGhpcztcbiAgICB2YXIgdGltZXIgPSB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYyLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCksIHJlcSA9IHRoaXMucmVxID0gdGhpcy5jbGllbnQucmVxdWVzdCh0aGlzLnJlcXVlc3RPcHRpb25zKTtcbiAgICByZXEub24oXG4gICAgICBcImVycm9yXCIsXG4gICAgICB0aGlzLm9uUmVxRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXCJSZXF1ZXN0IGVycm9yOiBcIiArIGVyci5tZXNzYWdlLCBudWxsLCA0MDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBzZWxmMi50aW1lciA9IG51bGw7XG4gICAgICAgIHNlbGYyLmNvbXBsZXRlKGVycik7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXEub24oXCJyZXNwb25zZVwiLCBmdW5jdGlvbihyZXMpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICBzZWxmMi50aW1lciA9IG51bGw7XG4gICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuTm9Db250ZW50KSB7XG4gICAgICAgIHJlcy5yZXN1bWUoKTtcbiAgICAgICAgc2VsZjIuY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzLm9uKFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIHNlbGYyLm9uUmVzRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgUGFydGlhbEVycm9ySW5mbyhcIlJlc3BvbnNlIGVycm9yOiBcIiArIGVyci5tZXNzYWdlLCBudWxsLCA0MDApO1xuICAgICAgICAgIHNlbGYyLmNvbXBsZXRlKGVycik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBzZWxmMi5yZXMgPSByZXM7XG4gICAgICBpZiAoc2VsZjIucmVxdWVzdE1vZGUgPT0gWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNICYmIHN0YXR1c0NvZGUgPCA0MDApIHtcbiAgICAgICAgc2VsZjIucmVhZFN0cmVhbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZjIucmVhZEZ1bGx5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMudHJhbnNwb3J0KVxuICAgICAgdGhpcy50cmFuc3BvcnQuYWRkUGVuZGluZygpO1xuICAgIHJlcS5lbmQodGhpcy5ib2R5KTtcbiAgfVxuICByZWFkU3RyZWFtKCkge1xuICAgIHZhciByZXMgPSB0aGlzLnJlcywgc2VsZjIgPSB0aGlzO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5zdHJlYW1Db21wbGV0ZSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIG9uQ2h1bmsoY2h1bmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNodW5rID0gSlNPTi5wYXJzZShjaHVuayk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIk1hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHNlbGYyLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIk5vZGVDb21ldFRyYW5zcG9ydC5SZXF1ZXN0LnJlYWRTdHJlYW0oKVwiLCBtc2cpO1xuICAgICAgICBzZWxmMi5jb21wbGV0ZShuZXcgUGFydGlhbEVycm9ySW5mbyhtc2csIG51bGwsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxmMi5lbWl0KFwiZGF0YVwiLCBjaHVuayk7XG4gICAgfVxuICAgIHJlcy5vbihcbiAgICAgIFwiZGF0YVwiLFxuICAgICAgdGhpcy5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBuZXdDaHVua3MgPSBTdHJpbmcoZGF0YSkuc3BsaXQoXCJcXG5cIiksIGNodW5rcyA9IHNlbGYyLmNodW5rcztcbiAgICAgICAgaWYgKG5ld0NodW5rcy5sZW5ndGggPiAxICYmIGNodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2gobmV3Q2h1bmtzLnNoaWZ0KCkpO1xuICAgICAgICAgIHNlbGYyLmNodW5rcyA9IFtdO1xuICAgICAgICAgIG9uQ2h1bmsoY2h1bmtzLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFpbGluZ05ld0NodW5rID0gbmV3Q2h1bmtzLnBvcCgpO1xuICAgICAgICBpZiAodHJhaWxpbmdOZXdDaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmMi5jaHVua3MucHVzaCh0cmFpbGluZ05ld0NodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdDaHVua3MubWFwKG9uQ2h1bmspO1xuICAgICAgfVxuICAgICk7XG4gICAgcmVzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZjIuc3RyZWFtQ29tcGxldGUgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZjIuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlYWRGdWxseSgpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5yZXMsIGNodW5rcyA9IFtdLCBzZWxmMiA9IHRoaXM7XG4gICAgcmVzLm9uKFwiZGF0YVwiLCBmdW5jdGlvbihjaHVuaykge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH0pO1xuICAgIHJlcy5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib2R5ID0gQnVmZmVyLmNvbmNhdChjaHVua3MpLCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoU3RyaW5nKGJvZHkpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHZhciBtc2cgPSBcIk1hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oc2VsZjIubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiTm9kZUNvbWV0VHJhbnNwb3J0LlJlcXVlc3QucmVhZEZ1bGx5KClcIiwgbXNnKTtcbiAgICAgICAgICBzZWxmMi5jb21wbGV0ZShuZXcgUGFydGlhbEVycm9ySW5mbyhtc2csIG51bGwsIDQwMCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDQwMCB8fCBBcnJheS5pc0FycmF5KGJvZHkpKSB7XG4gICAgICAgICAgc2VsZjIuY29tcGxldGUobnVsbCwgYm9keSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnIgPSBib2R5LmVycm9yICYmIEVycm9ySW5mby5mcm9tVmFsdWVzKGJvZHkuZXJyb3IpO1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIGVyciA9IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFxuICAgICAgICAgICAgXCJFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogXCIgKyBzdGF0dXNDb2RlICsgXCIsIGJvZHkgd2FzOiBcIiArIGltcG9ydF91dGlsMy5kZWZhdWx0Lmluc3BlY3QoYm9keSksXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3RhdHVzQ29kZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZjIuY29tcGxldGUoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbXBsZXRlKGVyciwgYm9keSkge1xuICAgIGlmICghdGhpcy5yZXF1ZXN0Q29tcGxldGUpIHtcbiAgICAgIHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIGlmIChib2R5KVxuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGJvZHkpO1xuICAgICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgZXJyLCBib2R5KTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMub25kYXRhICYmICF0aGlzLnN0cmVhbUNvbXBsZXRlKSB7XG4gICAgICAgICAgaWYgKHRoaXMub25kYXRhICYmIHRoaXMucmVzKVxuICAgICAgICAgICAgdGhpcy5yZXMucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIHRoaXMub25kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZVBlbmRpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiTm9kZUNvbWV0VHJhbnNwb3J0LlJlcXVlc3QuYWJvcnQoKVwiLCBcIlwiKTtcbiAgICB2YXIgdGltZXIgPSB0aGlzLnRpbWVyO1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gICAgaWYgKHJlcSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiTm9kZUNvbWV0VHJhbnNwb3J0LlJlcXVlc3QuYWJvcnQoKVwiLCBcImFib3J0aW5nIHJlcXVlc3RcIik7XG4gICAgICByZXEucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLm9uUmVxRXJyb3IpO1xuICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgbm9vcDMpO1xuICAgICAgcmVxLmFib3J0KCk7XG4gICAgICB0aGlzLnJlcSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY29tcGxldGUoeyBzdGF0dXNDb2RlOiA0MDAsIGNvZGU6IDgwMDAzLCBtZXNzYWdlOiBcIkNhbmNlbGxlZFwiIH0pO1xuICB9XG59O1xudmFyIG5vZGVjb21ldHRyYW5zcG9ydF9kZWZhdWx0ID0gTm9kZUNvbWV0VHJhbnNwb3J0O1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi90cmFuc3BvcnQvaW5kZXgudHNcbnZhciB0cmFuc3BvcnRfZGVmYXVsdDIgPSB7XG4gIG9yZGVyOiBbVHJhbnNwb3J0TmFtZXMuQ29tZXRdLFxuICBidW5kbGVkSW1wbGVtZW50YXRpb25zOiB7XG4gICAgW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldF06IHdlYnNvY2tldHRyYW5zcG9ydF9kZWZhdWx0LFxuICAgIFtUcmFuc3BvcnROYW1lcy5Db21ldF06IG5vZGVjb21ldHRyYW5zcG9ydF9kZWZhdWx0XG4gIH1cbn07XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvbGliL3V0aWwvZGVmYXVsdHMudHNcbnZhciBEZWZhdWx0czIgPSB7XG4gIGNvbm5lY3Rpdml0eUNoZWNrVXJsOiBcImh0dHBzOi8vaW50ZXJuZXQtdXAuYWJseS1yZWFsdGltZS5jb20vaXMtdGhlLWludGVybmV0LXVwLnR4dFwiLFxuICB3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsOiBcIndzczovL3dzLXVwLmFibHktcmVhbHRpbWUuY29tXCIsXG4gIC8qIE5vdGU6IG9yZGVyIG1hdHRlcnMgaGVyZTogdGhlIGJhc2UgdHJhbnNwb3J0IGlzIHRoZSBsZWZ0bW9zdCBvbmUgaW4gdGhlXG4gICAqIGludGVyc2VjdGlvbiBvZiBiYXNlVHJhbnNwb3J0T3JkZXIgYW5kIHRoZSB0cmFuc3BvcnRzIGNsaWVudE9wdGlvbiB0aGF0J3Mgc3VwcG9ydGVkLiAqL1xuICBkZWZhdWx0VHJhbnNwb3J0czogW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldF0sXG4gIHJlc3RBZ2VudE9wdGlvbnM6IHsgbWF4U29ja2V0czogNDAsIGtlZXBBbGl2ZTogdHJ1ZSB9XG59O1xudmFyIGRlZmF1bHRzX2RlZmF1bHQyID0gRGVmYXVsdHMyO1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2luZGV4LnRzXG52YXIgbXNncGFjayA9IHJlcXVpcmVfbXNncGFjaygpO1xudmFyIENyeXB0byA9IGNyZWF0ZUNyeXB0b0NsYXNzKGJ1ZmZlcnV0aWxzX2RlZmF1bHQpO1xuUGxhdGZvcm0uQ3J5cHRvID0gQ3J5cHRvO1xuUGxhdGZvcm0uQnVmZmVyVXRpbHMgPSBidWZmZXJ1dGlsc19kZWZhdWx0O1xuUGxhdGZvcm0uSHR0cCA9IGh0dHBfZGVmYXVsdDtcblBsYXRmb3JtLkNvbmZpZyA9IGNvbmZpZ19kZWZhdWx0O1xuUGxhdGZvcm0uVHJhbnNwb3J0cyA9IHRyYW5zcG9ydF9kZWZhdWx0MjtcblBsYXRmb3JtLldlYlN0b3JhZ2UgPSBudWxsO1xuZm9yIChjb25zdCBjbGllbnRDbGFzcyBvZiBbRGVmYXVsdFJlc3QsIERlZmF1bHRSZWFsdGltZV0pIHtcbiAgY2xpZW50Q2xhc3MuQ3J5cHRvID0gQ3J5cHRvO1xuICBjbGllbnRDbGFzcy5fTXNnUGFjayA9IG1zZ3BhY2s7XG59XG5sb2dnZXJfZGVmYXVsdC5pbml0TG9nSGFuZGxlcnMoKTtcblBsYXRmb3JtLkRlZmF1bHRzID0gZ2V0RGVmYXVsdHMoZGVmYXVsdHNfZGVmYXVsdDIpO1xuaWYgKFBsYXRmb3JtLkNvbmZpZy5hZ2VudCkge1xuICBQbGF0Zm9ybS5EZWZhdWx0cy5hZ2VudCArPSBcIiBcIiArIFBsYXRmb3JtLkNvbmZpZy5hZ2VudDtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFcnJvckluZm8sXG4gIFJlc3Q6IERlZmF1bHRSZXN0LFxuICBSZWFsdGltZTogRGVmYXVsdFJlYWx0aW1lLFxuICBtc2dwYWNrOiBudWxsLFxuICBtYWtlUHJvdG9jb2xNZXNzYWdlRnJvbURlc2VyaWFsaXplZDogbWFrZUZyb21EZXNlcmlhbGl6ZWRXaXRoRGVwZW5kZW5jaWVzXG59O1xuaWYgKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIpIHtcbiAgdmFyIF9fY3AgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICAgIGlmICgoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIikgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGZyb20pKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIGtleSwge1xuICAgICAgICAgIGdldDogKCkgPT4gZnJvbVtrZXldLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEoZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fY3AobW9kdWxlLmV4cG9ydHMsIGV4cG9ydHMpO1xufVxucmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufSkpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmx5LW5vZGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably-node.js\n");

/***/ })

};
;