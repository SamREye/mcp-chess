/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/games/[id]/page",{

/***/ "(app-pages-browser)/./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably.js ***!
  \********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)\n\nAbly JavaScript Library v2.17.1\nhttps://github.com/ably/ably-js\n\nReleased under the Apache Licence v2.0*/(function (g, f) {\n    if (true) {\n      module.exports = f();\n    } else {}\n  }(this, () => {\nvar exports = {};\nvar module = { exports };\n\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __await = function(promise, isYieldStar) {\n  this[0] = promise;\n  this[1] = isYieldStar;\n};\nvar __asyncGenerator = (__this, __arguments, generator) => {\n  var resume = (k, v, yes, no) => {\n    try {\n      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;\n      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === \"return\" ? k : \"next\", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume(\"throw\", e, yes, no));\n    } catch (e) {\n      no(e);\n    }\n  };\n  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));\n  var it = {};\n  return generator = generator.apply(__this, __arguments), it[Symbol.asyncIterator] = () => it, method(\"next\"), method(\"throw\"), method(\"return\"), it;\n};\n\n// src/platform/web/index.ts\nvar web_exports = {};\n__export(web_exports, {\n  ErrorInfo: () => ErrorInfo,\n  Realtime: () => DefaultRealtime,\n  Rest: () => DefaultRest,\n  default: () => web_default,\n  makeProtocolMessageFromDeserialized: () => makeFromDeserializedWithDependencies,\n  msgpack: () => msgpack_default\n});\nmodule.exports = __toCommonJS(web_exports);\n\n// src/common/platform.ts\nvar Platform = class {\n};\n\n// src/common/lib/util/logger.ts\nvar globalObject = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : self;\nfunction pad(timeSegment, three) {\n  return `${timeSegment}`.padStart(three ? 3 : 2, \"0\");\n}\nfunction getHandler(logger) {\n  return Platform.Config.logTimestamps ? function(msg) {\n    const time = /* @__PURE__ */ new Date();\n    logger(\n      pad(time.getHours()) + \":\" + pad(time.getMinutes()) + \":\" + pad(time.getSeconds()) + \".\" + pad(time.getMilliseconds(), 1) + \" \" + msg\n    );\n  } : function(msg) {\n    logger(msg);\n  };\n}\nvar getDefaultLoggers = () => {\n  var _a2;\n  let consoleLogger;\n  let errorLogger;\n  if (typeof ((_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) === \"function\") {\n    consoleLogger = function(...args) {\n      console.log.apply(console, args);\n    };\n    errorLogger = console.warn ? function(...args) {\n      console.warn.apply(console, args);\n    } : consoleLogger;\n  } else {\n    consoleLogger = errorLogger = function() {\n    };\n  }\n  return [consoleLogger, errorLogger].map(getHandler);\n};\nvar _Logger = class _Logger {\n  constructor() {\n    this.deprecated = (description, msg) => {\n      this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\n    };\n    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n      the object being serialised if the log level will not output the message */\n    this.shouldLog = (level) => {\n      return level <= this.logLevel;\n    };\n    this.setLog = (level, handler) => {\n      if (level !== void 0)\n        this.logLevel = level;\n      if (handler !== void 0)\n        this.logHandler = this.logErrorHandler = handler;\n    };\n    this.logLevel = _Logger.defaultLogLevel;\n    this.logHandler = _Logger.defaultLogHandler;\n    this.logErrorHandler = _Logger.defaultLogErrorHandler;\n  }\n  static initLogHandlers() {\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\n    this.defaultLogHandler = logHandler;\n    this.defaultLogErrorHandler = logErrorHandler;\n    this.defaultLogger = new _Logger();\n  }\n  /**\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\n   */\n  static logActionNoStrip(logger, level, action, message) {\n    logger.logAction(level, action, message);\n  }\n  logAction(level, action, message) {\n    if (this.shouldLog(level)) {\n      (level === 1 /* Error */ ? this.logErrorHandler : this.logHandler)(\"Ably: \" + action + \": \" + message, level);\n    }\n  }\n  renamedClientOption(oldName, newName) {\n    this.deprecationWarning(\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  renamedMethod(className, oldName, newName) {\n    this.deprecationWarning(\n      `\\`${className}\\`\\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  deprecationWarning(message) {\n    if (this.shouldLog(1 /* Error */)) {\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, 1 /* Error */);\n    }\n  }\n};\n_Logger.defaultLogLevel = 1 /* Error */;\n// public constants\n_Logger.LOG_NONE = 0 /* None */;\n_Logger.LOG_ERROR = 1 /* Error */;\n_Logger.LOG_MAJOR = 2 /* Major */;\n_Logger.LOG_MINOR = 3 /* Minor */;\n_Logger.LOG_MICRO = 4 /* Micro */;\n/* public static functions */\n/**\n * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\n *\n * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you canâ€™t dynamically specify the log level.\n */\n_Logger.logAction = (logger, level, action, message) => {\n  _Logger.logActionNoStrip(logger, level, action, message);\n};\nvar Logger = _Logger;\nvar logger_default = Logger;\n\n// src/common/lib/util/utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Format: () => Format,\n  allSame: () => allSame,\n  allToLowerCase: () => allToLowerCase,\n  allToUpperCase: () => allToUpperCase,\n  arrChooseN: () => arrChooseN,\n  arrDeleteValue: () => arrDeleteValue,\n  arrEquals: () => arrEquals,\n  arrIntersect: () => arrIntersect,\n  arrIntersectOb: () => arrIntersectOb,\n  arrPopRandomElement: () => arrPopRandomElement,\n  arrWithoutValue: () => arrWithoutValue,\n  cheapRandStr: () => cheapRandStr,\n  containsValue: () => containsValue,\n  copy: () => copy,\n  createMissingPluginError: () => createMissingPluginError,\n  dataSizeBytes: () => dataSizeBytes,\n  decodeBody: () => decodeBody,\n  encodeBody: () => encodeBody,\n  ensureArray: () => ensureArray,\n  forInOwnNonNullProperties: () => forInOwnNonNullProperties,\n  getBackoffCoefficient: () => getBackoffCoefficient,\n  getGlobalObject: () => getGlobalObject,\n  getJitterCoefficient: () => getJitterCoefficient,\n  getRetryTime: () => getRetryTime,\n  inherits: () => inherits,\n  inspectBody: () => inspectBody,\n  inspectError: () => inspectError,\n  intersect: () => intersect,\n  isEmpty: () => isEmpty,\n  isErrorInfoOrPartialErrorInfo: () => isErrorInfoOrPartialErrorInfo,\n  isNil: () => isNil,\n  isObject: () => isObject,\n  keysArray: () => keysArray,\n  listenerToAsyncIterator: () => listenerToAsyncIterator,\n  matchDerivedChannel: () => matchDerivedChannel,\n  mixin: () => mixin,\n  parseQueryString: () => parseQueryString,\n  prototypicalClone: () => prototypicalClone,\n  randomString: () => randomString,\n  shallowClone: () => shallowClone,\n  shallowEquals: () => shallowEquals,\n  stringifyValues: () => stringifyValues,\n  throwMissingPluginError: () => throwMissingPluginError,\n  toBase64: () => toBase64,\n  toQueryString: () => toQueryString,\n  valuesArray: () => valuesArray,\n  whenPromiseSettles: () => whenPromiseSettles,\n  withTimeoutAsync: () => withTimeoutAsync\n});\n\n// src/common/lib/types/errorinfo.ts\nfunction toString(err) {\n  let result = \"[\" + err.constructor.name;\n  if (err.message)\n    result += \": \" + err.message;\n  if (err.statusCode)\n    result += \"; statusCode=\" + err.statusCode;\n  if (err.code)\n    result += \"; code=\" + err.code;\n  if (err.cause)\n    result += \"; cause=\" + inspectError(err.cause);\n  if (err.href && !(err.message && err.message.indexOf(\"help.ably.io\") > -1))\n    result += \"; see \" + err.href + \" \";\n  result += \"]\";\n  return result;\n}\nvar ErrorInfo = class _ErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _ErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || typeof code !== \"number\" || typeof statusCode !== \"number\") {\n      throw new Error(\"ErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\nvar PartialErrorInfo = class _PartialErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _PartialErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || !isNil(code) && typeof code !== \"number\" || !isNil(statusCode) && typeof statusCode !== \"number\") {\n      throw new Error(\"PartialErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _PartialErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\n\n// src/common/lib/util/utils.ts\nfunction randomPosn(arrOrStr) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\nfunction mixin(target, ...args) {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\nfunction copy(src) {\n  return mixin({}, src);\n}\nfunction ensureArray(obj) {\n  if (isNil(obj)) {\n    return [];\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\nfunction isObject(ob) {\n  return Object.prototype.toString.call(ob) == \"[object Object]\";\n}\nfunction isEmpty(ob) {\n  for (const prop in ob)\n    return false;\n  return true;\n}\nfunction isNil(arg) {\n  return arg == null;\n}\nfunction shallowClone(ob) {\n  const result = new Object();\n  for (const prop in ob)\n    result[prop] = ob[prop];\n  return result;\n}\nfunction prototypicalClone(ob, ownProperties) {\n  class F {\n  }\n  F.prototype = ob;\n  const result = new F();\n  if (ownProperties)\n    mixin(result, ownProperties);\n  return result;\n}\nvar inherits = function(ctor, superCtor) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\nfunction containsValue(ob, val) {\n  for (const i in ob) {\n    if (ob[i] == val)\n      return true;\n  }\n  return false;\n}\nfunction intersect(arr, ob) {\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\nfunction arrIntersect(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arr2.indexOf(member) != -1)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrIntersectOb(arr, ob) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrDeleteValue(arr, val) {\n  const idx = arr.indexOf(val);\n  const res = idx != -1;\n  if (res)\n    arr.splice(idx, 1);\n  return res;\n}\nfunction arrWithoutValue(arr, val) {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\nfunction keysArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(prop);\n  }\n  return result;\n}\nfunction valuesArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\nfunction forInOwnNonNullProperties(ob, fn) {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\nfunction allSame(arr, prop) {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arr.every(function(item) {\n    return item[prop] === first;\n  });\n}\nvar Format = /* @__PURE__ */ ((Format2) => {\n  Format2[\"msgpack\"] = \"msgpack\";\n  Format2[\"json\"] = \"json\";\n  return Format2;\n})(Format || {});\nfunction arrPopRandomElement(arr) {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\nfunction toQueryString(params) {\n  const parts = [];\n  if (params) {\n    for (const key in params)\n      parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n  return parts.length ? \"?\" + parts.join(\"&\") : \"\";\n}\nfunction stringifyValues(params) {\n  return Object.fromEntries(Object.entries(params).map(([k, v]) => [k, String(v)]));\n}\nfunction parseQueryString(query) {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result = {};\n  while (match = search.exec(query))\n    result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n  return result;\n}\nfunction isErrorInfoOrPartialErrorInfo(err) {\n  return typeof err == \"object\" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\nfunction inspectError(err) {\n  var _a2, _b;\n  if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === \"ErrorInfo\" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === \"PartialErrorInfo\")\n    return err.toString();\n  return Platform.Config.inspect(err);\n}\nfunction inspectBody(body) {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return body.toString();\n  } else if (typeof body === \"string\") {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\nfunction dataSizeBytes(data) {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === \"string\") {\n    return Platform.Config.stringByteSize(data);\n  }\n  if (typeof data === \"number\") {\n    return 8;\n  }\n  if (typeof data === \"boolean\") {\n    return 1;\n  }\n  throw new Error(\n    `Expected input of Utils.dataSizeBytes to be a string, a number, a boolean or a buffer, but was: ${typeof data}`\n  );\n}\nfunction cheapRandStr() {\n  return String(Math.random()).substr(2);\n}\nvar randomString = async (numBytes) => {\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n  return Platform.BufferUtils.base64Encode(buffer);\n};\nfunction arrChooseN(arr, n2) {\n  const numItems = Math.min(n2, arr.length), mutableArr = arr.slice(), result = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\nfunction whenPromiseSettles(promise, callback) {\n  promise.then((result) => {\n    callback == null ? void 0 : callback(null, result);\n  }).catch((err) => {\n    callback == null ? void 0 : callback(err);\n  });\n}\nfunction decodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.decode(body);\n  }\n  return JSON.parse(String(body));\n}\nfunction encodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.encode(body, true);\n  }\n  return JSON.stringify(body);\n}\nfunction allToLowerCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toLowerCase();\n  });\n}\nfunction allToUpperCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toUpperCase();\n  });\n}\nfunction getBackoffCoefficient(count) {\n  return Math.min((count + 2) / 3, 2);\n}\nfunction getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\nfunction getRetryTime(initialTimeout, retryAttempt) {\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\nfunction getGlobalObject() {\n  if (typeof __webpack_require__.g !== \"undefined\") {\n    return __webpack_require__.g;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return self;\n}\nfunction shallowEquals(source, target) {\n  return Object.keys(source).every((key) => source[key] === target[key]) && Object.keys(target).every((key) => target[key] === source[key]);\n}\nfunction matchDerivedChannel(name) {\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/;\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo(\"regex match failed\", 400, 40010);\n  }\n  if (match[2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  return {\n    qualifierParam: match[3] || \"\",\n    channelName: match[4]\n  };\n}\nfunction toBase64(str) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\nfunction arrEquals(a, b) {\n  return a.length === b.length && a.every(function(val, i) {\n    return val === b[i];\n  });\n}\nfunction createMissingPluginError(pluginName) {\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n}\nfunction throwMissingPluginError(pluginName) {\n  throw createMissingPluginError(pluginName);\n}\nasync function withTimeoutAsync(promise, timeout = 5e3, err = \"Timeout expired\") {\n  const e = new ErrorInfo(err, 5e4, 500);\n  return Promise.race([promise, new Promise((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\n}\nfunction listenerToAsyncIterator(registerListener) {\n  return __asyncGenerator(this, null, function* () {\n    const eventQueue = [];\n    let resolveNext = null;\n    const removeListener2 = registerListener((event) => {\n      if (resolveNext) {\n        const resolve = resolveNext;\n        resolveNext = null;\n        resolve(event);\n      } else {\n        eventQueue.push(event);\n      }\n    });\n    try {\n      while (true) {\n        if (eventQueue.length > 0) {\n          yield eventQueue.shift();\n        } else {\n          if (resolveNext) {\n            throw new ErrorInfo(\"Concurrent next() calls are not supported\", 4e4, 400);\n          }\n          const event = yield new __await(new Promise((resolve) => {\n            resolveNext = resolve;\n          }));\n          yield event;\n        }\n      }\n    } finally {\n      removeListener2();\n    }\n  });\n}\n\n// package.json\nvar version = \"2.17.1\";\n\n// src/common/lib/util/defaults.ts\nvar agent = \"ably-js/\" + version;\nvar Defaults = {\n  ENDPOINT: \"main\",\n  ENVIRONMENT: \"\",\n  REST_HOST: \"rest.ably.io\",\n  REALTIME_HOST: \"realtime.ably.io\",\n  FALLBACK_HOSTS: [\n    \"main.a.fallback.ably-realtime.com\",\n    \"main.b.fallback.ably-realtime.com\",\n    \"main.c.fallback.ably-realtime.com\",\n    \"main.d.fallback.ably-realtime.com\",\n    \"main.e.fallback.ably-realtime.com\"\n  ],\n  PORT: 80,\n  TLS_PORT: 443,\n  TIMEOUTS: {\n    /* Documented as options params: */\n    disconnectedRetryTimeout: 15e3,\n    suspendedRetryTimeout: 3e4,\n    /* Undocumented, but part of the api and can be used by customers: */\n    httpRequestTimeout: 1e4,\n    httpMaxRetryDuration: 15e3,\n    channelRetryTimeout: 15e3,\n    fallbackRetryTimeout: 6e5,\n    /* For internal / test use only: */\n    connectionStateTtl: 12e4,\n    realtimeRequestTimeout: 1e4,\n    recvTimeout: 9e4,\n    webSocketConnectTimeout: 1e4,\n    webSocketSlowTimeout: 4e3\n  },\n  httpMaxRetryCount: 3,\n  maxMessageSize: 65536,\n  version,\n  protocolVersion: 5,\n  agent,\n  getPort,\n  getHttpScheme,\n  getPrimaryDomainFromEndpoint,\n  getEndpointFallbackHosts,\n  getFallbackHosts,\n  getHosts,\n  checkHost,\n  objectifyOptions,\n  normaliseOptions,\n  defaultGetHeaders,\n  defaultPostHeaders\n};\nfunction getPort(options, tls) {\n  return tls || options.tls ? options.tlsPort : options.port;\n}\nfunction getHttpScheme(options) {\n  return options.tls ? \"https://\" : \"http://\";\n}\nfunction isFqdnIpOrLocalhost(endpoint) {\n  return endpoint.includes(\".\") || endpoint.includes(\"::\") || endpoint === \"localhost\";\n}\nfunction getPrimaryDomainFromEndpoint(endpoint) {\n  if (isFqdnIpOrLocalhost(endpoint))\n    return endpoint;\n  if (endpoint.startsWith(\"nonprod:\")) {\n    const routingPolicyId = endpoint.replace(\"nonprod:\", \"\");\n    return `${routingPolicyId}.realtime.ably-nonprod.net`;\n  }\n  return `${endpoint}.realtime.ably.net`;\n}\nfunction getEndpointFallbackHosts(endpoint) {\n  if (isFqdnIpOrLocalhost(endpoint))\n    return [];\n  if (endpoint.startsWith(\"nonprod:\")) {\n    const routingPolicyId = endpoint.replace(\"nonprod:\", \"\");\n    return endpointFallbacks(routingPolicyId, \"ably-realtime-nonprod.com\");\n  }\n  return endpointFallbacks(endpoint, \"ably-realtime.com\");\n}\nfunction endpointFallbacks(routingPolicyId, domain) {\n  return [\"a\", \"b\", \"c\", \"d\", \"e\"].map((id) => `${routingPolicyId}.${id}.fallback.${domain}`);\n}\nfunction getFallbackHosts(options) {\n  const fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== \"undefined\" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n  return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\nfunction getHosts(options) {\n  return [options.primaryDomain].concat(getFallbackHosts(options));\n}\nfunction checkHost(host) {\n  if (typeof host !== \"string\") {\n    throw new ErrorInfo(\"host must be a string; was a \" + typeof host, 4e4, 400);\n  }\n  if (!host.length) {\n    throw new ErrorInfo(\"host must not be zero-length\", 4e4, 400);\n  }\n}\nfunction getTimeouts(options) {\n  const timeouts = {};\n  for (const prop in Defaults.TIMEOUTS) {\n    timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];\n  }\n  return timeouts;\n}\nfunction getAgentString(options) {\n  let agentStr = Defaults.agent;\n  if (options.agents) {\n    for (var agent2 in options.agents) {\n      agentStr += \" \" + agent2 + \"/\" + options.agents[agent2];\n    }\n  }\n  return agentStr;\n}\nfunction objectifyOptions(options, allowKeyOrToken, sourceForErrorMessage, logger, modularPluginsToInclude) {\n  if (options === void 0) {\n    const msg = allowKeyOrToken ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token` : `${sourceForErrorMessage} must be initialized with a client options object`;\n    logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n    throw new Error(msg);\n  }\n  let optionsObj;\n  if (typeof options === \"string\") {\n    if (options.indexOf(\":\") == -1) {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\\u2019s \\`token\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { token: options };\n    } else {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\\u2019s \\`key\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { key: options };\n    }\n  } else {\n    optionsObj = options;\n  }\n  if (modularPluginsToInclude) {\n    optionsObj = __spreadProps(__spreadValues({}, optionsObj), { plugins: __spreadValues(__spreadValues({}, modularPluginsToInclude), optionsObj.plugins) });\n  }\n  return optionsObj;\n}\nfunction checkIfClientOptionsAreValid(options) {\n  if (options.endpoint && (options.environment || options.restHost || options.realtimeHost)) {\n    throw new ErrorInfo(\n      \"The `endpoint` option cannot be used in conjunction with the `environment`, `restHost`, or `realtimeHost` options.\",\n      40106,\n      400\n    );\n  }\n  if (options.environment && (options.restHost || options.realtimeHost)) {\n    throw new ErrorInfo(\n      \"The `environment` option cannot be used in conjunction with the `restHost`, or `realtimeHost` options.\",\n      40106,\n      400\n    );\n  }\n}\nfunction normaliseOptions(options, MsgPack, logger) {\n  const loggerToUse = logger != null ? logger : logger_default.defaultLogger;\n  if (options.environment) {\n    loggerToUse.deprecated(\"The `environment` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  if (options.restHost) {\n    loggerToUse.deprecated(\"The `restHost` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  if (options.realtimeHost) {\n    loggerToUse.deprecated(\"The `realtimeHost` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  checkIfClientOptionsAreValid(options);\n  if (typeof options.recover === \"function\" && options.closeOnUnload === true) {\n    logger_default.logAction(\n      loggerToUse,\n      logger_default.LOG_ERROR,\n      \"Defaults.normaliseOptions\",\n      \"closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter\"\n    );\n    options.recover = void 0;\n  }\n  if (!(\"closeOnUnload\" in options)) {\n    options.closeOnUnload = !options.recover;\n  }\n  if (!(\"queueMessages\" in options))\n    options.queueMessages = true;\n  const endpoint = options.endpoint || Defaults.ENDPOINT;\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n    options.fallbackHosts = getEndpointFallbackHosts(options.environment || endpoint);\n  }\n  const primaryDomainFromEnvironment = options.environment && `${options.environment}.realtime.ably.net`;\n  const primaryDomainFromLegacyOptions = options.restHost || options.realtimeHost || primaryDomainFromEnvironment;\n  const primaryDomain = primaryDomainFromLegacyOptions || getPrimaryDomainFromEndpoint(endpoint);\n  (options.fallbackHosts || []).concat(primaryDomain).forEach(checkHost);\n  options.port = options.port || Defaults.PORT;\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n  if (!(\"tls\" in options))\n    options.tls = true;\n  const timeouts = getTimeouts(options);\n  if (MsgPack) {\n    if (\"useBinaryProtocol\" in options) {\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n    } else {\n      options.useBinaryProtocol = Platform.Config.preferBinary;\n    }\n  } else {\n    options.useBinaryProtocol = false;\n  }\n  const headers = {};\n  if (options.clientId) {\n    headers[\"X-Ably-ClientId\"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n  }\n  if (!(\"idempotentRestPublishing\" in options)) {\n    options.idempotentRestPublishing = true;\n  }\n  let connectivityCheckParams = null;\n  let connectivityCheckUrl = options.connectivityCheckUrl;\n  if (options.connectivityCheckUrl) {\n    let [uri, qs] = options.connectivityCheckUrl.split(\"?\");\n    connectivityCheckParams = qs ? parseQueryString(qs) : {};\n    if (uri.indexOf(\"://\") === -1) {\n      uri = \"https://\" + uri;\n    }\n    connectivityCheckUrl = uri;\n  }\n  let wsConnectivityCheckUrl = options.wsConnectivityCheckUrl;\n  if (wsConnectivityCheckUrl && wsConnectivityCheckUrl.indexOf(\"://\") === -1) {\n    wsConnectivityCheckUrl = \"wss://\" + wsConnectivityCheckUrl;\n  }\n  return __spreadProps(__spreadValues({}, options), {\n    primaryDomain,\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\n    timeouts,\n    connectivityCheckParams,\n    connectivityCheckUrl,\n    wsConnectivityCheckUrl,\n    headers\n  });\n}\nfunction normaliseChannelOptions(Crypto2, logger, options) {\n  const channelOptions = options || {};\n  if (channelOptions.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(channelOptions.cipher, logger);\n    channelOptions.cipher = cipher.cipherParams;\n    channelOptions.channelCipher = cipher.cipher;\n  } else if (\"cipher\" in channelOptions) {\n    channelOptions.cipher = void 0;\n    channelOptions.channelCipher = null;\n  }\n  return channelOptions;\n}\nvar contentTypes = {\n  json: \"application/json\",\n  xml: \"application/xml\",\n  html: \"text/html\",\n  msgpack: \"application/x-msgpack\",\n  text: \"text/plain\"\n};\nvar defaultHeadersOptions = {\n  format: \"json\" /* json */,\n  protocolVersion: Defaults.protocolVersion\n};\nfunction defaultGetHeaders(options, { format, protocolVersion = defaultHeadersOptions.protocolVersion } = {}) {\n  const accept = contentTypes[format != null ? format : options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */];\n  return {\n    accept,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nfunction defaultPostHeaders(options, { format, protocolVersion = defaultHeadersOptions.protocolVersion } = {}) {\n  const accept = contentTypes[format != null ? format : options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */];\n  const contentType = accept;\n  return {\n    accept,\n    \"content-type\": contentType,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nvar defaults_default = Defaults;\nfunction getDefaults(platformDefaults) {\n  return Object.assign(Defaults, platformDefaults);\n}\n\n// src/common/lib/util/multicaster.ts\nvar Multicaster = class _Multicaster {\n  // Private constructor; use static Multicaster.create instead\n  constructor(logger, members) {\n    this.logger = logger;\n    this.members = members || [];\n  }\n  call(err, result) {\n    for (const member of this.members) {\n      if (member) {\n        try {\n          member(err, result);\n        } catch (e) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Multicaster multiple callback handler\",\n            \"Unexpected exception: \" + e + \"; stack = \" + e.stack\n          );\n        }\n      }\n    }\n  }\n  push(...args) {\n    this.members.push(...args);\n  }\n  createPromise() {\n    return new Promise((resolve, reject) => {\n      this.push((err, result) => {\n        err ? reject(err) : resolve(result);\n      });\n    });\n  }\n  resolveAll(result) {\n    this.call(null, result);\n  }\n  rejectAll(err) {\n    this.call(err);\n  }\n  static create(logger, members) {\n    const instance = new _Multicaster(logger, members);\n    return Object.assign((err, result) => instance.call(err, result), {\n      push: (fn) => instance.push(fn),\n      createPromise: () => instance.createPromise(),\n      resolveAll: (result) => instance.resolveAll(result),\n      rejectAll: (err) => instance.rejectAll(err)\n    });\n  }\n};\nvar multicaster_default = Multicaster;\n\n// src/common/constants/HttpMethods.ts\nvar HttpMethods = /* @__PURE__ */ ((HttpMethods2) => {\n  HttpMethods2[\"Get\"] = \"get\";\n  HttpMethods2[\"Delete\"] = \"delete\";\n  HttpMethods2[\"Post\"] = \"post\";\n  HttpMethods2[\"Put\"] = \"put\";\n  HttpMethods2[\"Patch\"] = \"patch\";\n  return HttpMethods2;\n})(HttpMethods || {});\nvar HttpMethods_default = HttpMethods;\n\n// src/common/constants/HttpStatusCodes.ts\nvar HttpStatusCodes = /* @__PURE__ */ ((HttpStatusCodes2) => {\n  HttpStatusCodes2[HttpStatusCodes2[\"Success\"] = 200] = \"Success\";\n  HttpStatusCodes2[HttpStatusCodes2[\"NoContent\"] = 204] = \"NoContent\";\n  HttpStatusCodes2[HttpStatusCodes2[\"BadRequest\"] = 400] = \"BadRequest\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Unauthorized\"] = 401] = \"Unauthorized\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Forbidden\"] = 403] = \"Forbidden\";\n  HttpStatusCodes2[HttpStatusCodes2[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n  HttpStatusCodes2[HttpStatusCodes2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  return HttpStatusCodes2;\n})(HttpStatusCodes || {});\nfunction isSuccessCode(statusCode) {\n  return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;\n}\nvar HttpStatusCodes_default = HttpStatusCodes;\n\n// src/common/lib/client/auth.ts\nvar MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction random() {\n  return (\"000000\" + Math.floor(Math.random() * 1e16)).slice(-16);\n}\nfunction isRealtime(client) {\n  return !!client.connection;\n}\nfunction normaliseAuthcallbackError(err) {\n  if (!isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\nvar hmac = (text, key) => {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n  return bufferUtils.base64Encode(digest);\n};\nfunction c14n(capability) {\n  if (!capability)\n    return \"\";\n  if (typeof capability == \"string\")\n    capability = JSON.parse(capability);\n  const c14nCapability = /* @__PURE__ */ Object.create(null);\n  const keys = keysArray(capability, true);\n  if (!keys)\n    return \"\";\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = capability[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\nfunction logAndValidateTokenAuthMethod(authOptions, logger) {\n  if (authOptions.authCallback) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authCallback\");\n  } else if (authOptions.authUrl) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authUrl\");\n  } else if (authOptions.key) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with client-side signing\");\n  } else if (authOptions.tokenDetails) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with supplied token only\");\n  } else {\n    const msg = \"authOptions must include valid authentication parameters\";\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n    throw new Error(msg);\n  }\n}\nfunction basicAuthForced(options) {\n  return \"useTokenAuth\" in options && !options.useTokenAuth;\n}\nfunction useTokenAuth(options) {\n  return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);\n}\nfunction noWayToRenew(options) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\nvar trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\nvar Auth = class {\n  constructor(client, options) {\n    // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n    this.authOptions = {};\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n    if (useTokenAuth(options)) {\n      if (noWayToRenew(options)) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"Auth()\",\n          \"Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams, options);\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    } else {\n      if (!options.key) {\n        const msg = \"No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth()\", \"anonymous, using basic auth\");\n      this._saveBasicOptions(options);\n    }\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async authorize(tokenParams, authOptions) {\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n      throw new ErrorInfo(\"Unable to update auth options with incompatible key\", 40102, 401);\n    }\n    try {\n      let tokenDetails = await this._forceNewToken(tokenParams != null ? tokenParams : null, authOptions != null ? authOptions : null);\n      if (isRealtime(this.client)) {\n        return new Promise((resolve, reject) => {\n          this.client.connection.connectionManager.onAuthUpdated(\n            tokenDetails,\n            (err, tokenDetails2) => err ? reject(err) : resolve(tokenDetails2)\n          );\n        });\n      } else {\n        return tokenDetails;\n      }\n    } catch (err) {\n      if (this.client.connection && err.statusCode === HttpStatusCodes_default.Forbidden) {\n        this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n      }\n      throw err;\n    }\n  }\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  async _forceNewToken(tokenParams, authOptions) {\n    this.tokenDetails = null;\n    this._saveTokenOptions(tokenParams, authOptions);\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    try {\n      return this._ensureValidAuthCredentials(true);\n    } finally {\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n    }\n  }\n  async requestToken(tokenParams, authOptions) {\n    const resolvedAuthOptions = authOptions || this.authOptions;\n    const resolvedTokenParams = tokenParams || copy(this.tokenParams);\n    let tokenRequestCallback, client = this.client;\n    if (resolvedAuthOptions.authCallback) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authCallback\");\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\n    } else if (resolvedAuthOptions.authUrl) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authUrl\");\n      tokenRequestCallback = (params, cb) => {\n        const authHeaders = mixin(\n          { accept: \"application/json, text/plain\" },\n          resolvedAuthOptions.authHeaders\n        );\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === \"post\";\n        let providedQsParams;\n        const queryIdx = resolvedAuthOptions.authUrl.indexOf(\"?\");\n        if (queryIdx > -1) {\n          providedQsParams = parseQueryString(resolvedAuthOptions.authUrl.slice(queryIdx));\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl.slice(0, queryIdx);\n          if (!usePost) {\n            resolvedAuthOptions.authParams = mixin(\n              providedQsParams,\n              resolvedAuthOptions.authParams\n            );\n          }\n        }\n        const authParams = mixin({}, resolvedAuthOptions.authParams || {}, params);\n        const authUrlRequestCallback = (result) => {\n          var _a2, _b;\n          let body = (_a2 = result.body) != null ? _a2 : null;\n          let contentType = null;\n          if (result.error) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received Error: \" + inspectError(result.error)\n            );\n          } else {\n            const contentTypeHeaderOrHeaders = (_b = result.headers[\"content-type\"]) != null ? _b : null;\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\n              contentType = contentTypeHeaderOrHeaders.join(\", \");\n            } else {\n              contentType = contentTypeHeaderOrHeaders;\n            }\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received; content-type: \" + contentType + \"; body: \" + inspectBody(body)\n            );\n          }\n          if (result.error) {\n            cb(result.error, null);\n            return;\n          }\n          if (result.unpacked) {\n            cb(null, body);\n            return;\n          }\n          if (Platform.BufferUtils.isBuffer(body))\n            body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo(\"authUrl response is missing a content-type header\", 40170, 401), null);\n            return;\n          }\n          const json = contentType.indexOf(\"application/json\") > -1, text = contentType.indexOf(\"text/plain\") > -1 || contentType.indexOf(\"application/jwt\") > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                \"authUrl responded with unacceptable content-type \" + contentType + \", should be either text/plain, application/jwt or application/json\",\n                40170,\n                401\n              ),\n              null\n            );\n            return;\n          }\n          if (json) {\n            if (body.length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo(\"authUrl response exceeded max permitted length\", 40170, 401), null);\n              return;\n            }\n            try {\n              body = JSON.parse(body);\n            } catch (e) {\n              cb(\n                new ErrorInfo(\n                  \"Unexpected error processing authURL response; err = \" + e.message,\n                  40170,\n                  401\n                ),\n                null\n              );\n              return;\n            }\n          }\n          cb(null, body, contentType);\n        };\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Auth.requestToken().tokenRequestCallback\",\n          \"Requesting token from \" + resolvedAuthOptions.authUrl + \"; Params: \" + JSON.stringify(authParams) + \"; method: \" + (usePost ? \"POST\" : \"GET\")\n        );\n        if (usePost) {\n          const headers = authHeaders || {};\n          headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n          const body = toQueryString(authParams).slice(1);\n          whenPromiseSettles(\n            this.client.http.doUri(\n              HttpMethods_default.Post,\n              resolvedAuthOptions.authUrl,\n              headers,\n              body,\n              providedQsParams\n            ),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        } else {\n          whenPromiseSettles(\n            this.client.http.doUri(HttpMethods_default.Get, resolvedAuthOptions.authUrl, authHeaders || {}, null, authParams),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        }\n      };\n    } else if (resolvedAuthOptions.key) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth.requestToken()\",\n        \"using token auth with client-side signing\"\n      );\n      tokenRequestCallback = (params, cb) => {\n        whenPromiseSettles(\n          this.createTokenRequest(params, resolvedAuthOptions),\n          (err, result) => cb(err, result != null ? result : null)\n        );\n      };\n    } else {\n      const msg = \"Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)\";\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Auth()\",\n        \"library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n      );\n      throw new ErrorInfo(msg, 40171, 403);\n    }\n    if (\"capability\" in resolvedTokenParams)\n      resolvedTokenParams.capability = c14n(\n        resolvedTokenParams.capability\n      );\n    const tokenRequest = (signedTokenParams, tokenCb) => {\n      const keyName = signedTokenParams.keyName, path = \"/keys/\" + keyName + \"/requestToken\", tokenUri = function(host) {\n        return client.baseUri(host) + path;\n      };\n      const requestHeaders = defaults_default.defaultPostHeaders(this.client.options, { format: \"json\" /* json */ });\n      if (resolvedAuthOptions.requestHeaders)\n        mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Auth.requestToken().requestToken\",\n        \"Sending POST to \" + path + \"; Token params: \" + JSON.stringify(signedTokenParams)\n      );\n      whenPromiseSettles(\n        this.client.http.do(HttpMethods_default.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\n        (err, result) => err ? tokenCb(err) : tokenCb(result.error, result.body, result.unpacked)\n      );\n    };\n    return new Promise((resolve, reject) => {\n      let tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(() => {\n        tokenRequestCallbackTimeoutExpired = true;\n        const msg = \"Token request callback timed out after \" + timeoutLength / 1e3 + \" seconds\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n        reject(new ErrorInfo(msg, 40170, 401));\n      }, timeoutLength);\n      tokenRequestCallback(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\n        if (tokenRequestCallbackTimeoutExpired)\n          return;\n        clearTimeout(tokenRequestCallbackTimeout);\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Auth.requestToken()\",\n            \"token request signing call returned error; err = \" + inspectError(err)\n          );\n          reject(normaliseAuthcallbackError(err));\n          return;\n        }\n        if (typeof tokenRequestOrDetails === \"string\") {\n          if (tokenRequestOrDetails.length === 0) {\n            reject(new ErrorInfo(\"Token string is empty\", 40170, 401));\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n            reject(\n              new ErrorInfo(\n                \"Token string exceeded max permitted length (was \" + tokenRequestOrDetails.length + \" bytes)\",\n                40170,\n                401\n              )\n            );\n          } else if (tokenRequestOrDetails === \"undefined\" || tokenRequestOrDetails === \"null\") {\n            reject(new ErrorInfo(\"Token string was literal null/undefined\", 40170, 401));\n          } else if (tokenRequestOrDetails[0] === \"{\" && !(contentType && contentType.indexOf(\"application/jwt\") > -1)) {\n            reject(\n              new ErrorInfo(\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n                40170,\n                401\n              )\n            );\n          } else {\n            resolve({ token: tokenRequestOrDetails });\n          }\n          return;\n        }\n        if (typeof tokenRequestOrDetails !== \"object\" || tokenRequestOrDetails === null) {\n          const msg = \"Expected token request callback to call back with a token string or token request/details object, but got a \" + typeof tokenRequestOrDetails;\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n          reject(\n            new ErrorInfo(\n              \"Token request/details object exceeded max permitted stringified size (was \" + objectSize + \" bytes)\",\n              40170,\n              401\n            )\n          );\n          return;\n        }\n        if (\"issued\" in tokenRequestOrDetails) {\n          resolve(tokenRequestOrDetails);\n          return;\n        }\n        if (!(\"keyName\" in tokenRequestOrDetails)) {\n          const msg = \"Expected token request callback to call back with a token string, token request object, or token details object\";\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        tokenRequest(tokenRequestOrDetails, (err2, tokenResponse, unpacked) => {\n          if (err2) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Auth.requestToken()\",\n              \"token request API call returned error; err = \" + inspectError(err2)\n            );\n            reject(normaliseAuthcallbackError(err2));\n            return;\n          }\n          if (!unpacked)\n            tokenResponse = JSON.parse(tokenResponse);\n          logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"token received\");\n          resolve(tokenResponse);\n        });\n      });\n    });\n  }\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async createTokenRequest(tokenParams, authOptions) {\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || copy(this.tokenParams);\n    const key = authOptions.key;\n    if (!key) {\n      throw new ErrorInfo(\"No key specified\", 40101, 403);\n    }\n    const keyParts = key.split(\":\"), keyName = keyParts[0], keySecret = keyParts[1];\n    if (!keySecret) {\n      throw new ErrorInfo(\"Invalid key specified\", 40101, 403);\n    }\n    if (tokenParams.clientId === \"\") {\n      throw new ErrorInfo(\"clientId can\\u2019t be an empty string\", 40012, 400);\n    }\n    if (\"capability\" in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n    const request = mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || \"\", ttl = tokenParams.ttl || \"\", capability = tokenParams.capability || \"\";\n    if (!request.timestamp) {\n      request.timestamp = await this._getTimestamp(authOptions && authOptions.queryTime);\n    }\n    const nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;\n    const signText = request.keyName + \"\\n\" + ttl + \"\\n\" + capability + \"\\n\" + clientId + \"\\n\" + timestamp + \"\\n\" + nonce + \"\\n\";\n    request.mac = request.mac || hmac(signText, keySecret);\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getTokenRequest()\", \"generated signed request\");\n    return request;\n  }\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  async getAuthParams() {\n    if (this.method == \"basic\")\n      return { key: this.key };\n    else {\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { access_token: tokenDetails.token };\n    }\n  }\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  async getAuthHeaders() {\n    if (this.method == \"basic\") {\n      return { authorization: \"Basic \" + this.basicKey };\n    } else {\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { authorization: \"Bearer \" + toBase64(tokenDetails.token) };\n    }\n  }\n  _saveBasicOptions(authOptions) {\n    this.method = \"basic\";\n    this.key = authOptions.key;\n    this.basicKey = toBase64(authOptions.key);\n    this.authOptions = authOptions || {};\n    if (\"clientId\" in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n  _saveTokenOptions(tokenParams, authOptions) {\n    this.method = \"token\";\n    if (tokenParams) {\n      this.tokenParams = tokenParams;\n    }\n    if (authOptions) {\n      if (authOptions.token) {\n        authOptions.tokenDetails = typeof authOptions.token === \"string\" ? { token: authOptions.token } : authOptions.token;\n      }\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n      if (\"clientId\" in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n      this.authOptions = authOptions;\n    }\n  }\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  async _ensureValidAuthCredentials(forceSupersede) {\n    const token = this.tokenDetails;\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        throw new ErrorInfo(\n          \"Mismatch between clientId in token (\" + token.clientId + \") and current clientId (\" + this.clientId + \")\",\n          40102,\n          403\n        );\n      }\n      if (!this.client.isTimeOffsetSet() || !token.expires || token.expires >= this.client.getTimestampUsingOffset()) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Auth.getToken()\",\n          \"using cached token; expires = \" + token.expires\n        );\n        return token;\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"deleting expired token\");\n      this.tokenDetails = null;\n    }\n    const promise = (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create(this.logger))).createPromise();\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return promise;\n    }\n    const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();\n    let tokenResponse, caughtError = null;\n    try {\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n    } catch (err) {\n      caughtError = err;\n    }\n    if (this.currentTokenRequestId > tokenRequestId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth._ensureValidAuthCredentials()\",\n        \"Discarding token request response; overtaken by newer one\"\n      );\n      return promise;\n    }\n    this.currentTokenRequestId = null;\n    const multicaster = this.waitingForTokenRequest;\n    this.waitingForTokenRequest = null;\n    if (caughtError) {\n      multicaster == null ? void 0 : multicaster.rejectAll(caughtError);\n      return promise;\n    }\n    multicaster == null ? void 0 : multicaster.resolveAll(this.tokenDetails = tokenResponse);\n    return promise;\n  }\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId) {\n    if (!(typeof clientId === \"string\" || clientId === null)) {\n      throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n    } else if (clientId === \"*\") {\n      throw new ErrorInfo(\n        'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err)\n        throw err;\n    }\n  }\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      const msg = \"Unexpected clientId mismatch: client has \" + this.clientId + \", requested \" + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth._uncheckedSetClientId()\", msg);\n      return err;\n    } else {\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n  _tokenClientIdMismatch(tokenClientId) {\n    return !!(this.clientId && this.clientId !== \"*\" && tokenClientId && tokenClientId !== \"*\" && this.clientId !== tokenClientId);\n  }\n  static isTokenErr(error) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n  revokeTokens(specifiers, options) {\n    return this.client.rest.revokeTokens(specifiers, options);\n  }\n  /**\n   * Same as {@link BaseClient.getTimestamp} but also takes into account {@link Auth.authOptions}\n   */\n  async _getTimestamp(queryTime) {\n    return this.client.getTimestamp(queryTime || !!this.authOptions.queryTime);\n  }\n};\nvar auth_default = Auth;\n\n// src/common/types/http.ts\nfunction paramString(params) {\n  const paramPairs = [];\n  if (params) {\n    for (const needle in params) {\n      paramPairs.push(needle + \"=\" + params[needle]);\n    }\n  }\n  return paramPairs.join(\"&\");\n}\nfunction appendingParams(uri, params) {\n  return uri + (params ? \"?\" : \"\") + paramString(params);\n}\nfunction logResult(result, method, uri, params, logger) {\n  if (result.error) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(uri, params) + \"; Error: \" + inspectError(result.error)\n    );\n  } else {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received; \" + appendingParams(uri, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body\" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + result.body)\n    );\n  }\n}\nfunction logRequest(method, uri, body, params, logger) {\n  if (logger.shouldLog(logger_default.LOG_MICRO)) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Sending; \" + appendingParams(uri, params) + \"; Body\" + (Platform.BufferUtils.isBuffer(body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(body) : \": \" + body)\n    );\n  }\n}\nvar Http = class {\n  constructor(client) {\n    this.client = client;\n    this.platformHttp = new Platform.Http(client);\n    this.checkConnectivity = this.platformHttp.checkConnectivity ? () => this.platformHttp.checkConnectivity() : void 0;\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  get supportsAuthHeaders() {\n    return this.platformHttp.supportsAuthHeaders;\n  }\n  get supportsLinkHeaders() {\n    return this.platformHttp.supportsLinkHeaders;\n  }\n  _getHosts(client) {\n    const connection = client.connection, connectionHost = connection && connection.connectionManager.host;\n    if (connectionHost) {\n      return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));\n    }\n    return defaults_default.getHosts(client.options);\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async do(method, path, headers, body, params) {\n    try {\n      const client = this.client;\n      if (!client) {\n        return { error: new ErrorInfo(\"http.do called without client\", 5e4, 500) };\n      }\n      const uriFromHost = typeof path === \"function\" ? path : function(host) {\n        return client.baseUri(host) + path;\n      };\n      const currentFallback = client._currentFallback;\n      if (currentFallback) {\n        if (currentFallback.validUntil > Date.now()) {\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\n          if (result.error && this.platformHttp.shouldFallback(result.error)) {\n            client._currentFallback = null;\n            return this.do(method, path, headers, body, params);\n          }\n          return result;\n        } else {\n          client._currentFallback = null;\n        }\n      }\n      const hosts = this._getHosts(client);\n      if (hosts.length === 1) {\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\n      }\n      let tryAHostStartedAt = null;\n      const tryAHost = async (candidateHosts, persistOnSuccess) => {\n        const host = candidateHosts.shift();\n        tryAHostStartedAt = tryAHostStartedAt != null ? tryAHostStartedAt : /* @__PURE__ */ new Date();\n        const result = await this.doUri(method, uriFromHost(host), headers, body, params);\n        if (result.error && this.platformHttp.shouldFallback(result.error) && candidateHosts.length) {\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\n            return {\n              error: new ErrorInfo(\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\n                50003,\n                500\n              )\n            };\n          }\n          return tryAHost(candidateHosts, true);\n        }\n        if (persistOnSuccess) {\n          client._currentFallback = {\n            host,\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout\n          };\n        }\n        return result;\n      };\n      return tryAHost(hosts);\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async doUri(method, uri, headers, body, params) {\n    try {\n      logRequest(method, uri, body, params, this.logger);\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\n      if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n        logResult(result, method, uri, params, this.logger);\n      }\n      return result;\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n};\n\n// src/common/lib/util/eventemitter.ts\nfunction callListener(logger, eventThis, listener, args) {\n  try {\n    listener.apply(eventThis, args);\n  } catch (e) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_ERROR,\n      \"EventEmitter.emit()\",\n      \"Unexpected listener exception: \" + e + \"; stack = \" + (e && e.stack)\n    );\n  }\n}\nfunction removeListener(targetListeners, listener, eventFilter) {\n  let listeners;\n  let index;\n  let eventName;\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n    listeners = targetListeners[targetListenersIndex];\n    if (eventFilter) {\n      listeners = listeners[eventFilter];\n    }\n    if (Array.isArray(listeners)) {\n      while ((index = listeners.indexOf(listener)) !== -1) {\n        listeners.splice(index, 1);\n      }\n      if (eventFilter && listeners.length === 0) {\n        delete targetListeners[targetListenersIndex][eventFilter];\n      }\n    } else if (isObject(listeners)) {\n      for (eventName in listeners) {\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\n          removeListener([listeners], listener, eventName);\n        }\n      }\n    }\n  }\n}\nvar EventEmitter = class {\n  constructor(logger) {\n    this.logger = logger;\n    this.any = [];\n    this.events = /* @__PURE__ */ Object.create(null);\n    this.anyOnce = [];\n    this.eventsOnce = /* @__PURE__ */ Object.create(null);\n  }\n  on(...args) {\n    if (args.length === 1) {\n      const listener = args[0];\n      if (typeof listener === \"function\") {\n        this.any.push(listener);\n      } else {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n    }\n    if (args.length === 2) {\n      const [event, listener] = args;\n      if (typeof listener !== \"function\") {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n      if (isNil(event)) {\n        this.any.push(listener);\n      } else if (Array.isArray(event)) {\n        event.forEach((eventName) => {\n          this.on(eventName, listener);\n        });\n      } else {\n        if (typeof event !== \"string\") {\n          throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n        }\n        const listeners = this.events[event] || (this.events[event] = []);\n        listeners.push(listener);\n      }\n    }\n  }\n  off(...args) {\n    if (args.length == 0 || isNil(args[0]) && isNil(args[1])) {\n      this.any = [];\n      this.events = /* @__PURE__ */ Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = /* @__PURE__ */ Object.create(null);\n      return;\n    }\n    const [firstArg, secondArg] = args;\n    let listener = null;\n    let event = null;\n    if (args.length === 1 || !secondArg) {\n      if (typeof firstArg === \"function\") {\n        listener = firstArg;\n      } else {\n        event = firstArg;\n      }\n    } else {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      [event, listener] = [firstArg, secondArg];\n    }\n    if (listener && isNil(event)) {\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n      return;\n    }\n    if (Array.isArray(event)) {\n      event.forEach((eventName) => {\n        this.off(eventName, listener);\n      });\n      return;\n    }\n    if (typeof event !== \"string\") {\n      throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n    }\n    if (listener) {\n      removeListener([this.events, this.eventsOnce], listener, event);\n    } else {\n      delete this.events[event];\n      delete this.eventsOnce[event];\n    }\n  }\n  /**\n   * Get the array of listeners for a given event; excludes once events\n   * @param event (optional) the name of the event, or none for 'any'\n   * @return array of events, or null if none\n   */\n  listeners(event) {\n    if (event) {\n      const listeners = this.events[event] || [];\n      if (this.eventsOnce[event])\n        Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n      return listeners.length ? listeners : null;\n    }\n    return this.any.length ? this.any : null;\n  }\n  /**\n   * Emit an event\n   * @param event the event name\n   * @param args the arguments to pass to the listener\n   */\n  emit(event, ...args) {\n    const eventThis = { event };\n    const listeners = [];\n    if (this.anyOnce.length) {\n      Array.prototype.push.apply(listeners, this.anyOnce);\n      this.anyOnce = [];\n    }\n    if (this.any.length) {\n      Array.prototype.push.apply(listeners, this.any);\n    }\n    const eventsOnceListeners = this.eventsOnce[event];\n    if (eventsOnceListeners) {\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\n      delete this.eventsOnce[event];\n    }\n    const eventsListeners = this.events[event];\n    if (eventsListeners) {\n      Array.prototype.push.apply(listeners, eventsListeners);\n    }\n    listeners.forEach((listener) => {\n      callListener(this.logger, eventThis, listener, args);\n    });\n  }\n  once(...args) {\n    const argCount = args.length;\n    if (argCount === 0 || argCount === 1 && typeof args[0] !== \"function\") {\n      const event = args[0];\n      return new Promise((resolve) => {\n        this.once(event, resolve);\n      });\n    }\n    const [firstArg, secondArg] = args;\n    if (args.length === 1 && typeof firstArg === \"function\") {\n      this.anyOnce.push(firstArg);\n    } else if (isNil(firstArg)) {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      this.anyOnce.push(secondArg);\n    } else if (Array.isArray(firstArg)) {\n      const self2 = this;\n      const listenerWrapper = function() {\n        const innerArgs = Array.prototype.slice.call(arguments);\n        firstArg.forEach(function(eventName) {\n          self2.off(eventName, listenerWrapper);\n        });\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        secondArg.apply(this, innerArgs);\n      };\n      firstArg.forEach(function(eventName) {\n        self2.on(eventName, listenerWrapper);\n      });\n    } else {\n      if (typeof firstArg !== \"string\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n      if (secondArg) {\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        listeners.push(secondArg);\n      }\n    }\n  }\n  /**\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n   * @param targetState the name of the state event to listen to\n   * @param currentState the name of the current state of this object\n   */\n  async whenState(targetState, currentState) {\n    if (typeof targetState !== \"string\" || typeof currentState !== \"string\") {\n      throw new Error(\"whenState requires a valid state String argument\");\n    }\n    if (targetState === currentState) {\n      return null;\n    } else {\n      return this.once(targetState);\n    }\n  }\n};\nvar eventemitter_default = EventEmitter;\n\n// src/common/lib/types/protocolmessagecommon.ts\nvar actions = {\n  HEARTBEAT: 0,\n  ACK: 1,\n  NACK: 2,\n  CONNECT: 3,\n  CONNECTED: 4,\n  DISCONNECT: 5,\n  DISCONNECTED: 6,\n  CLOSE: 7,\n  CLOSED: 8,\n  ERROR: 9,\n  ATTACH: 10,\n  ATTACHED: 11,\n  DETACH: 12,\n  DETACHED: 13,\n  PRESENCE: 14,\n  MESSAGE: 15,\n  SYNC: 16,\n  AUTH: 17,\n  ACTIVATE: 18,\n  OBJECT: 19,\n  OBJECT_SYNC: 20,\n  ANNOTATION: 21\n};\nvar ActionName = [];\nObject.keys(actions).forEach(function(name) {\n  ActionName[actions[name]] = name;\n});\nvar flags = {\n  /* Channel attach state flags */\n  HAS_PRESENCE: 1 << 0,\n  HAS_BACKLOG: 1 << 1,\n  RESUMED: 1 << 2,\n  TRANSIENT: 1 << 4,\n  ATTACH_RESUME: 1 << 5,\n  HAS_OBJECTS: 1 << 7,\n  /* Channel mode flags */\n  PRESENCE: 1 << 16,\n  PUBLISH: 1 << 17,\n  SUBSCRIBE: 1 << 18,\n  PRESENCE_SUBSCRIBE: 1 << 19,\n  ANNOTATION_PUBLISH: 1 << 21,\n  ANNOTATION_SUBSCRIBE: 1 << 22,\n  OBJECT_SUBSCRIBE: 1 << 24,\n  OBJECT_PUBLISH: 1 << 25\n};\nvar flagNames = Object.keys(flags);\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE | flags.ANNOTATION_PUBLISH | flags.ANNOTATION_SUBSCRIBE | flags.OBJECT_SUBSCRIBE | flags.OBJECT_PUBLISH;\nvar channelModes = [\n  \"PRESENCE\",\n  \"PUBLISH\",\n  \"SUBSCRIBE\",\n  \"PRESENCE_SUBSCRIBE\",\n  \"ANNOTATION_PUBLISH\",\n  \"ANNOTATION_SUBSCRIBE\",\n  \"OBJECT_SUBSCRIBE\",\n  \"OBJECT_PUBLISH\"\n];\n\n// src/common/lib/types/basemessage.ts\nfunction normaliseContext(context) {\n  if (!context || !context.channelOptions) {\n    return {\n      channelOptions: context,\n      plugins: {},\n      baseEncodedPreviousPayload: void 0\n    };\n  }\n  return context;\n}\nfunction normalizeCipherOptions(Crypto2, logger, options) {\n  if (options && options.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(options.cipher, logger);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher\n    };\n  }\n  return options != null ? options : {};\n}\nasync function encrypt(msg, cipherOptions) {\n  const { data, encoding } = await encryptData(msg.data, msg.encoding, cipherOptions);\n  msg.data = data;\n  msg.encoding = encoding;\n  return msg;\n}\nasync function encryptData(data, encoding, cipherOptions) {\n  let cipher = cipherOptions.channelCipher;\n  let dataToEncrypt = data;\n  let finalEncoding = encoding ? encoding + \"/\" : \"\";\n  if (!Platform.BufferUtils.isBuffer(dataToEncrypt)) {\n    dataToEncrypt = Platform.BufferUtils.utf8Encode(String(dataToEncrypt));\n    finalEncoding = finalEncoding + \"utf-8/\";\n  }\n  const ciphertext = await cipher.encrypt(dataToEncrypt);\n  finalEncoding = finalEncoding + \"cipher+\" + cipher.algorithm;\n  return {\n    data: ciphertext,\n    encoding: finalEncoding\n  };\n}\nasync function encode(msg, options) {\n  const { data, encoding } = encodeData(msg.data, msg.encoding);\n  msg.data = data;\n  msg.encoding = encoding;\n  if (options != null && options.cipher) {\n    return encrypt(msg, options);\n  } else {\n    return msg;\n  }\n}\nfunction encodeData(data, encoding) {\n  const nativeDataType = typeof data == \"string\" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;\n  if (nativeDataType) {\n    return {\n      data,\n      encoding\n    };\n  }\n  if (isObject(data) || Array.isArray(data)) {\n    return {\n      data: JSON.stringify(data),\n      encoding: encoding ? encoding + \"/json\" : \"json\"\n    };\n  }\n  throw new ErrorInfo(\"Data type is unsupported\", 40013, 400);\n}\nasync function decode(message, inputContext) {\n  const { data, encoding, error } = await decodeData(message.data, message.encoding, inputContext);\n  message.data = data;\n  message.encoding = encoding;\n  if (error) {\n    throw error;\n  }\n}\nasync function decodeData(data, encoding, inputContext) {\n  const context = normaliseContext(inputContext);\n  let lastPayload = data;\n  let decodedData = data;\n  let finalEncoding = encoding;\n  let decodingError;\n  if (encoding) {\n    const xforms = encoding.split(\"/\");\n    let lastProcessedEncodingIndex;\n    let encodingsToProcess = xforms.length;\n    let xform = \"\";\n    try {\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n        if (!match)\n          break;\n        xform = match[1];\n        switch (xform) {\n          case \"base64\":\n            decodedData = Platform.BufferUtils.base64Decode(String(decodedData));\n            if (lastProcessedEncodingIndex == xforms.length) {\n              lastPayload = decodedData;\n            }\n            continue;\n          case \"utf-8\":\n            decodedData = Platform.BufferUtils.utf8Decode(decodedData);\n            continue;\n          case \"json\":\n            decodedData = JSON.parse(decodedData);\n            continue;\n          case \"cipher\":\n            if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {\n              const xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;\n              if (xformAlgorithm != cipher.algorithm) {\n                throw new Error(\"Unable to decrypt message with given cipher; incompatible cipher params\");\n              }\n              decodedData = await cipher.decrypt(decodedData);\n              continue;\n            } else {\n              throw new Error(\"Unable to decrypt message; not an encrypted channel\");\n            }\n          case \"vcdiff\":\n            if (!context.plugins || !context.plugins.vcdiff) {\n              throw new ErrorInfo(\"Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)\", 40019, 400);\n            }\n            if (typeof Uint8Array === \"undefined\") {\n              throw new ErrorInfo(\n                \"Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)\",\n                40020,\n                400\n              );\n            }\n            try {\n              let deltaBase = context.baseEncodedPreviousPayload;\n              if (typeof deltaBase === \"string\") {\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n              }\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase);\n              decodedData = Platform.BufferUtils.toBuffer(decodedData);\n              decodedData = Platform.BufferUtils.arrayBufferViewToBuffer(\n                context.plugins.vcdiff.decode(decodedData, deltaBaseBuffer)\n              );\n              lastPayload = decodedData;\n            } catch (e) {\n              throw new ErrorInfo(\"Vcdiff delta decode failed with \" + e, 40018, 400);\n            }\n            continue;\n          default:\n            throw new Error(\"Unknown encoding\");\n        }\n      }\n    } catch (e) {\n      const err = e;\n      decodingError = new ErrorInfo(\n        `Error processing the ${xform} encoding, decoder returned \\u2018${err.message}\\u2019`,\n        err.code || 40013,\n        400\n      );\n    } finally {\n      finalEncoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join(\"/\");\n    }\n  }\n  if (decodingError) {\n    return {\n      error: decodingError,\n      data: decodedData,\n      encoding: finalEncoding\n    };\n  }\n  context.baseEncodedPreviousPayload = lastPayload;\n  return {\n    data: decodedData,\n    encoding: finalEncoding\n  };\n}\nfunction wireToJSON(...args) {\n  const format = args.length > 0 ? \"json\" /* json */ : \"msgpack\" /* msgpack */;\n  const { data, encoding } = encodeDataForWire(this.data, this.encoding, format);\n  return Object.assign({}, this, { encoding, data });\n}\nfunction encodeDataForWire(data, encoding, format) {\n  if (!data || !Platform.BufferUtils.isBuffer(data)) {\n    return {\n      data,\n      encoding\n    };\n  }\n  if (format === \"msgpack\" /* msgpack */) {\n    return {\n      data: Platform.BufferUtils.toBuffer(data),\n      encoding\n    };\n  }\n  return {\n    data: Platform.BufferUtils.base64Encode(data),\n    encoding: encoding ? encoding + \"/base64\" : \"base64\"\n  };\n}\nvar MessageEncoding = {\n  encryptData,\n  encodeData,\n  encodeDataForWire,\n  decodeData\n};\nfunction populateFieldsFromParent(parent) {\n  const { id, connectionId, timestamp } = parent;\n  let msgs;\n  switch (parent.action) {\n    case actions.MESSAGE: {\n      msgs = parent.messages;\n      break;\n    }\n    case actions.PRESENCE:\n    case actions.SYNC:\n      msgs = parent.presence;\n      break;\n    case actions.ANNOTATION:\n      msgs = parent.annotations;\n      break;\n    case actions.OBJECT:\n    case actions.OBJECT_SYNC:\n      msgs = parent.state;\n      break;\n    default:\n      throw new ErrorInfo(\"Unexpected action \" + parent.action, 4e4, 400);\n  }\n  for (let i = 0; i < msgs.length; i++) {\n    const msg = msgs[i];\n    if (!msg.connectionId) {\n      msg.connectionId = connectionId;\n    }\n    if (!msg.timestamp) {\n      msg.timestamp = timestamp;\n    }\n    if (id && !msg.id) {\n      msg.id = id + \":\" + i;\n    }\n  }\n}\nfunction strMsg(m, cls) {\n  let result = \"[\" + cls;\n  for (const attr in m) {\n    if (attr === \"data\") {\n      if (typeof m.data == \"string\") {\n        result += \"; data=\" + m.data;\n      } else if (Platform.BufferUtils.isBuffer(m.data)) {\n        result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(m.data);\n      } else if (typeof m.data !== \"undefined\") {\n        result += \"; data (json)=\" + JSON.stringify(m.data);\n      }\n    } else if (attr && (attr === \"extras\" || attr === \"operation\")) {\n      result += \"; \" + attr + \"=\" + JSON.stringify(m[attr]);\n    } else if (attr === \"version\") {\n      result += \"; version=\" + JSON.stringify(m[attr]);\n    } else if (attr === \"annotations\") {\n      result += \"; annotations=\" + JSON.stringify(m[attr]);\n    } else if (m[attr] !== void 0) {\n      result += \"; \" + attr + \"=\" + m[attr];\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar BaseMessage = class {\n};\n\n// src/common/lib/client/baseclient.ts\nvar BaseClient = class {\n  constructor(options) {\n    /**\n     * These exports are for use by UMD plugins; reason being so that constructors and static methods can be accessed by these plugins without needing to import the classes directly and result in the class existing in both the plugin and the core library.\n     */\n    this.Platform = Platform;\n    this.ErrorInfo = ErrorInfo;\n    this.Logger = logger_default;\n    this.Defaults = defaults_default;\n    this.Utils = utils_exports;\n    this.EventEmitter = eventemitter_default;\n    this.MessageEncoding = MessageEncoding;\n    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    this._additionalHTTPRequestImplementations = (_a2 = options.plugins) != null ? _a2 : null;\n    this.logger = new logger_default();\n    this.logger.setLog(options.logLevel, options.logHandler);\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"BaseClient()\",\n      \"initialized with clientOptions \" + Platform.Config.inspect(options)\n    );\n    this._MsgPack = (_c = (_b = options.plugins) == null ? void 0 : _b.MsgPack) != null ? _c : null;\n    const normalOptions = this.options = defaults_default.normaliseOptions(options, this._MsgPack, this.logger);\n    if (normalOptions.key) {\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n      if (!keyMatch) {\n        const msg = \"invalid key parameter\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"BaseClient()\", msg);\n        throw new ErrorInfo(msg, 40400, 404);\n      }\n      normalOptions.keyName = keyMatch[1];\n      normalOptions.keySecret = keyMatch[2];\n    }\n    if (\"clientId\" in normalOptions) {\n      if (!(typeof normalOptions.clientId === \"string\" || normalOptions.clientId === null))\n        throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n      else if (normalOptions.clientId === \"*\")\n        throw new ErrorInfo(\n          'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\n          40012,\n          400\n        );\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"BaseClient()\", \"started; version = \" + defaults_default.version);\n    this._currentFallback = null;\n    this.serverTimeOffset = null;\n    this.http = new Http(this);\n    this.auth = new auth_default(this, normalOptions);\n    this._rest = ((_d = options.plugins) == null ? void 0 : _d.Rest) ? new options.plugins.Rest(this) : null;\n    this._Crypto = (_f = (_e = options.plugins) == null ? void 0 : _e.Crypto) != null ? _f : null;\n    this.__FilteredSubscriptions = (_h = (_g = options.plugins) == null ? void 0 : _g.MessageInteractions) != null ? _h : null;\n    this._Annotations = (_j = (_i = options.plugins) == null ? void 0 : _i.Annotations) != null ? _j : null;\n  }\n  get rest() {\n    if (!this._rest) {\n      throwMissingPluginError(\"Rest\");\n    }\n    return this._rest;\n  }\n  get _FilteredSubscriptions() {\n    if (!this.__FilteredSubscriptions) {\n      throwMissingPluginError(\"MessageInteractions\");\n    }\n    return this.__FilteredSubscriptions;\n  }\n  get channels() {\n    return this.rest.channels;\n  }\n  get push() {\n    return this.rest.push;\n  }\n  /** RSH8 */\n  device() {\n    var _a2;\n    if (!((_a2 = this.options.plugins) == null ? void 0 : _a2.Push) || !this.push.LocalDevice) {\n      throwMissingPluginError(\"Push\");\n    }\n    if (!this._device) {\n      this._device = this.push.LocalDevice.load(this);\n    }\n    return this._device;\n  }\n  baseUri(host) {\n    return defaults_default.getHttpScheme(this.options) + host + \":\" + defaults_default.getPort(this.options, false);\n  }\n  async stats(params) {\n    return this.rest.stats(params);\n  }\n  async time(params) {\n    return this.rest.time(params);\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    return this.rest.request(method, path, version2, params, body, customHeaders);\n  }\n  batchPublish(specOrSpecs) {\n    return this.rest.batchPublish(specOrSpecs);\n  }\n  batchPresence(channels) {\n    return this.rest.batchPresence(channels);\n  }\n  setLog(logOptions) {\n    this.logger.setLog(logOptions.level, logOptions.handler);\n  }\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  async getTimestamp(queryTime) {\n    if (!this.isTimeOffsetSet() && queryTime) {\n      return this.time();\n    }\n    return this.getTimestampUsingOffset();\n  }\n  getTimestampUsingOffset() {\n    return Date.now() + (this.serverTimeOffset || 0);\n  }\n  isTimeOffsetSet() {\n    return this.serverTimeOffset !== null;\n  }\n};\nBaseClient.Platform = Platform;\nvar baseclient_default = BaseClient;\n\n// src/common/lib/types/devicedetails.ts\nvar DeviceDetails = class _DeviceDetails {\n  toJSON() {\n    var _a2, _b, _c;\n    return {\n      id: this.id,\n      deviceSecret: this.deviceSecret,\n      platform: this.platform,\n      formFactor: this.formFactor,\n      clientId: this.clientId,\n      metadata: this.metadata,\n      deviceIdentityToken: this.deviceIdentityToken,\n      push: {\n        recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,\n        state: (_b = this.push) == null ? void 0 : _b.state,\n        error: (_c = this.push) == null ? void 0 : _c.error\n      }\n    };\n  }\n  toString() {\n    var _a2, _b, _c, _d;\n    let result = \"[DeviceDetails\";\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.platform)\n      result += \"; platform=\" + this.platform;\n    if (this.formFactor)\n      result += \"; formFactor=\" + this.formFactor;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.metadata)\n      result += \"; metadata=\" + this.metadata;\n    if (this.deviceIdentityToken)\n      result += \"; deviceIdentityToken=\" + JSON.stringify(this.deviceIdentityToken);\n    if ((_a2 = this.push) == null ? void 0 : _a2.recipient)\n      result += \"; push.recipient=\" + JSON.stringify(this.push.recipient);\n    if ((_b = this.push) == null ? void 0 : _b.state)\n      result += \"; push.state=\" + this.push.state;\n    if ((_c = this.push) == null ? void 0 : _c.error)\n      result += \"; push.error=\" + JSON.stringify(this.push.error);\n    if ((_d = this.push) == null ? void 0 : _d.metadata)\n      result += \"; push.metadata=\" + this.push.metadata;\n    result += \"]\";\n    return result;\n  }\n  static toRequestBody(body, MsgPack, format) {\n    return encodeBody(body, MsgPack, format);\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _DeviceDetails.fromValuesArray(body);\n    } else {\n      return _DeviceDetails.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    values.error = values.error && ErrorInfo.fromValues(values.error);\n    return Object.assign(new _DeviceDetails(), values);\n  }\n  static fromLocalDevice(device) {\n    return Object.assign(new _DeviceDetails(), device);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _DeviceDetails.fromValues(values[i]);\n    return result;\n  }\n};\nvar devicedetails_default = DeviceDetails;\n\n// src/common/lib/client/resource.ts\nasync function withAuthDetails(client, headers, params, opCallback) {\n  if (client.http.supportsAuthHeaders) {\n    const authHeaders = await client.auth.getAuthHeaders();\n    return opCallback(mixin(authHeaders, headers), params);\n  } else {\n    const authParams = await client.auth.getAuthParams();\n    return opCallback(headers, mixin(authParams, params));\n  }\n}\nfunction unenvelope(result, MsgPack, format) {\n  if (result.err && !result.body) {\n    return { err: result.err };\n  }\n  if (result.statusCode === HttpStatusCodes_default.NoContent) {\n    return __spreadProps(__spreadValues({}, result), { body: [], unpacked: true });\n  }\n  let body = result.body;\n  if (!result.unpacked) {\n    try {\n      body = decodeBody(body, MsgPack, format);\n    } catch (e) {\n      if (isErrorInfoOrPartialErrorInfo(e)) {\n        return { err: e };\n      } else {\n        return { err: new PartialErrorInfo(inspectError(e), null) };\n      }\n    }\n  }\n  if (!body) {\n    return { err: new PartialErrorInfo(\"unenvelope(): Response body is missing\", null) };\n  }\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body;\n  if (wrappedStatusCode === void 0) {\n    return __spreadProps(__spreadValues({}, result), { body, unpacked: true });\n  }\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n    let wrappedErr = response && response.error || result.err;\n    if (!wrappedErr) {\n      wrappedErr = new Error(\"Error in unenveloping \" + body);\n      wrappedErr.statusCode = wrappedStatusCode;\n    }\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n  }\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n}\nfunction logResult2(result, method, path, params, logger) {\n  if (result.err) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(path, params) + \"; Error: \" + inspectError(result.err)\n    );\n  } else {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received; \" + appendingParams(path, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body: \" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + Platform.Config.inspect(result.body))\n    );\n  }\n}\nvar Resource = class _Resource {\n  static async get(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, throwError != null ? throwError : false);\n  }\n  static async delete(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, throwError);\n  }\n  static async post(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, throwError);\n  }\n  static async patch(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, throwError);\n  }\n  static async put(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, throwError);\n  }\n  static async do(method, client, path, body, headers, params, envelope, throwError) {\n    if (envelope) {\n      (params = params || {})[\"envelope\"] = envelope;\n    }\n    const logger = client.logger;\n    async function doRequest(headers2, params2) {\n      var _a2;\n      if (logger.shouldLog(logger_default.LOG_MICRO)) {\n        let decodedBody = body;\n        if (((_a2 = headers2[\"content-type\"]) == null ? void 0 : _a2.indexOf(\"msgpack\")) > 0) {\n          try {\n            if (!client._MsgPack) {\n              throwMissingPluginError(\"MsgPack\");\n            }\n            decodedBody = client._MsgPack.decode(body);\n          } catch (decodeErr) {\n            logger_default.logAction(\n              logger,\n              logger_default.LOG_MICRO,\n              \"Resource.\" + method + \"()\",\n              \"Sending MsgPack Decoding Error: \" + inspectError(decodeErr)\n            );\n          }\n        }\n        logger_default.logAction(\n          logger,\n          logger_default.LOG_MICRO,\n          \"Resource.\" + method + \"()\",\n          \"Sending; \" + appendingParams(path, params2) + \"; Body: \" + decodedBody\n        );\n      }\n      const httpResult = await client.http.do(method, path, headers2, body, params2);\n      if (httpResult.error && auth_default.isTokenErr(httpResult.error)) {\n        await client.auth.authorize(null, null);\n        return withAuthDetails(client, headers2, params2, doRequest);\n      }\n      return {\n        err: httpResult.error,\n        body: httpResult.body,\n        headers: httpResult.headers,\n        unpacked: httpResult.unpacked,\n        statusCode: httpResult.statusCode\n      };\n    }\n    let result = await withAuthDetails(client, headers, params, doRequest);\n    if (envelope) {\n      result = unenvelope(result, client._MsgPack, envelope);\n    }\n    if (logger.shouldLog(logger_default.LOG_MICRO)) {\n      logResult2(result, method, path, params, logger);\n    }\n    if (throwError) {\n      if (result.err) {\n        throw result.err;\n      } else {\n        const response = __spreadValues({}, result);\n        delete response.err;\n        return response;\n      }\n    }\n    return result;\n  }\n};\nvar resource_default = Resource;\n\n// src/common/lib/client/paginatedresource.ts\nfunction getRelParams(linkUrl) {\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n  return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);\n}\nfunction parseRelLinks(linkHeader) {\n  if (typeof linkHeader == \"string\")\n    linkHeader = linkHeader.split(\",\");\n  const relParams = {};\n  for (let i = 0; i < linkHeader.length; i++) {\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n    if (linkMatch) {\n      const params = getRelParams(linkMatch[1]);\n      if (params)\n        relParams[linkMatch[2]] = params;\n    }\n  }\n  return relParams;\n}\nfunction returnErrOnly(err, body, useHPR) {\n  return !(useHPR && (body || typeof err.code === \"number\"));\n}\nvar PaginatedResource = class {\n  constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {\n    this.client = client;\n    this.path = path;\n    this.headers = headers;\n    this.envelope = envelope != null ? envelope : null;\n    this.bodyHandler = bodyHandler;\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async get(params) {\n    const result = await resource_default.get(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async delete(params) {\n    const result = await resource_default.delete(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async post(params, body) {\n    const result = await resource_default.post(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async put(params, body) {\n    const result = await resource_default.put(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async patch(params, body) {\n    const result = await resource_default.patch(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async handlePage(result) {\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"PaginatedResource.handlePage()\",\n        \"Unexpected error getting resource: err = \" + inspectError(result.err)\n      );\n      throw result.err;\n    }\n    let items, linkHeader, relParams;\n    try {\n      items = result.statusCode == HttpStatusCodes_default.NoContent ? [] : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\n    } catch (e) {\n      throw result.err || e;\n    }\n    if (result.headers && (linkHeader = result.headers[\"Link\"] || result.headers[\"link\"])) {\n      relParams = parseRelLinks(linkHeader);\n    }\n    if (this.useHttpPaginatedResponse) {\n      return new HttpPaginatedResponse(\n        this,\n        items,\n        result.headers || {},\n        result.statusCode,\n        relParams,\n        result.err\n      );\n    } else {\n      return new PaginatedResult(this, items, relParams);\n    }\n  }\n};\nvar PaginatedResult = class {\n  constructor(resource, items, relParams) {\n    this.resource = resource;\n    this.items = items;\n    this._relParams = relParams;\n  }\n  async first() {\n    if (this.hasFirst()) {\n      return this.get(this._relParams.first);\n    }\n    throw new ErrorInfo(\"No link to the first page of results\", 40400, 404);\n  }\n  async current() {\n    if (this.hasCurrent()) {\n      return this.get(this._relParams.current);\n    }\n    throw new ErrorInfo(\"No link to the current page of results\", 40400, 404);\n  }\n  async next() {\n    if (this.hasNext()) {\n      return this.get(this._relParams.next);\n    }\n    return null;\n  }\n  hasFirst() {\n    return this._relParams != null && \"first\" in this._relParams;\n  }\n  hasCurrent() {\n    return this._relParams != null && \"current\" in this._relParams;\n  }\n  hasNext() {\n    return this._relParams != null && \"next\" in this._relParams;\n  }\n  isLast() {\n    return !this.hasNext();\n  }\n  /* We assume that only the initial request can be a POST, and that accessing\n   * the rest of a multipage set of results can always be done with GET */\n  async get(params) {\n    const res = this.resource;\n    const result = await resource_default.get(res.client, res.path, res.headers, params, res.envelope, false);\n    return res.handlePage(result);\n  }\n};\nvar HttpPaginatedResponse = class extends PaginatedResult {\n  constructor(resource, items, headers, statusCode, relParams, err) {\n    super(resource, items, relParams);\n    this.statusCode = statusCode;\n    this.success = statusCode < 300 && statusCode >= 200;\n    this.headers = headers;\n    this.errorCode = err && err.code;\n    this.errorMessage = err && err.message;\n  }\n  toJSON() {\n    return {\n      items: this.items,\n      statusCode: this.statusCode,\n      success: this.success,\n      headers: this.headers,\n      errorCode: this.errorCode,\n      errorMessage: this.errorMessage\n    };\n  }\n};\nvar paginatedresource_default = PaginatedResource;\n\n// src/common/lib/types/pushchannelsubscription.ts\nvar _PushChannelSubscription = class _PushChannelSubscription {\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    return {\n      channel: this.channel,\n      deviceId: this.deviceId,\n      clientId: this.clientId\n    };\n  }\n  toString() {\n    let result = \"[PushChannelSubscription\";\n    if (this.channel)\n      result += \"; channel=\" + this.channel;\n    if (this.deviceId)\n      result += \"; deviceId=\" + this.deviceId;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    result += \"]\";\n    return result;\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _PushChannelSubscription.fromValuesArray(body);\n    } else {\n      return _PushChannelSubscription.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    return Object.assign(new _PushChannelSubscription(), values);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _PushChannelSubscription.fromValues(values[i]);\n    return result;\n  }\n};\n_PushChannelSubscription.toRequestBody = encodeBody;\nvar PushChannelSubscription = _PushChannelSubscription;\nvar pushchannelsubscription_default = PushChannelSubscription;\n\n// src/common/lib/client/push.ts\nvar Push = class {\n  constructor(client) {\n    var _a2;\n    this.client = client;\n    this.admin = new Admin(client);\n    if (Platform.Config.push && ((_a2 = client.options.plugins) == null ? void 0 : _a2.Push)) {\n      this.stateMachine = new client.options.plugins.Push.ActivationStateMachine(client);\n      this.LocalDevice = client.options.plugins.Push.localDeviceFactory(devicedetails_default);\n    }\n  }\n  async activate(registerCallback, updateFailedCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.activatedCallback) {\n        reject(new ErrorInfo(\"Activation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.activatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.updateFailedCallback = updateFailedCallback;\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledActivate(this.stateMachine, registerCallback)\n      );\n    });\n  }\n  async deactivate(deregisterCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.deactivatedCallback) {\n        reject(new ErrorInfo(\"Deactivation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.deactivatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledDeactivate(this.stateMachine, deregisterCallback)\n      );\n    });\n  }\n};\nvar Admin = class {\n  constructor(client) {\n    this.client = client;\n    this.deviceRegistrations = new DeviceRegistrations(client);\n    this.channelSubscriptions = new ChannelSubscriptions(client);\n  }\n  async publish(recipient, payload) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    const body = mixin({ recipient }, payload);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    await resource_default.post(client, \"/push/publish\", requestBody, headers, params, null, true);\n  }\n};\nvar DeviceRegistrations = class {\n  constructor(client) {\n    this.client = client;\n  }\n  async save(device) {\n    const client = this.client;\n    const body = devicedetails_default.fromValues(device);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.put(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(device.id),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async get(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    const response = await resource_default.get(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      {},\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/deviceRegistrations\", headers, envelope, async function(body, headers2, unpacked) {\n      return devicedetails_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async remove(deviceIdOrDetails) {\n    const client = this.client, headers = defaults_default.defaultGetHeaders(client.options), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/deviceRegistrations\", headers, params, null, true);\n  }\n};\nvar ChannelSubscriptions = class _ChannelSubscriptions {\n  constructor(client) {\n    /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n    this.remove = _ChannelSubscriptions.prototype.removeWhere;\n    this.client = client;\n  }\n  async save(subscription) {\n    const client = this.client;\n    const body = pushchannelsubscription_default.fromValues(subscription);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.post(\n      client,\n      \"/push/channelSubscriptions\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return pushchannelsubscription_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/channelSubscriptions\", headers, envelope, async function(body, headers2, unpacked) {\n      return pushchannelsubscription_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/channelSubscriptions\", headers, params, null, true);\n  }\n  async listChannels(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    return new paginatedresource_default(client, \"/push/channels\", headers, envelope, async function(body, headers2, unpacked) {\n      const parsedBody = !unpacked && format ? decodeBody(body, client._MsgPack, format) : body;\n      for (let i = 0; i < parsedBody.length; i++) {\n        parsedBody[i] = String(parsedBody[i]);\n      }\n      return parsedBody;\n    }).get(params);\n  }\n};\nvar push_default = Push;\n\n// src/common/lib/types/presencemessage.ts\nvar actions2 = [\"absent\", \"present\", \"enter\", \"leave\", \"update\"];\nasync function fromEncoded(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wpm = WirePresenceMessage.fromValues(encoded);\n  return wpm.decode(options, logger);\n}\nasync function fromEncodedArray(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded(encoded, channel) {\n  return WirePresenceMessage.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded(encoded, channel);\n    })\n  );\n}\nvar PresenceMessage = class _PresenceMessage extends BaseMessage {\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n   * sent by the connection (usually means a leave event sent 15s after a\n   * disconnection). This is useful because synthesized messages cannot be\n   * compared for newness by id lexicographically - RTP2b1\n   */\n  isSynthesized() {\n    if (!this.id || !this.connectionId) {\n      return true;\n    }\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n  }\n  /* RTP2b2 */\n  parseId() {\n    if (!this.id)\n      throw new Error(\"parseId(): Presence message does not contain an id\");\n    const parts = this.id.split(\":\");\n    return {\n      connectionId: parts[0],\n      msgSerial: parseInt(parts[1], 10),\n      index: parseInt(parts[2], 10)\n    };\n  }\n  async encode(options) {\n    const res = Object.assign(new WirePresenceMessage(), this, {\n      action: actions2.indexOf(this.action || \"present\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _PresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _PresenceMessage.fromValues(v));\n  }\n  static fromData(data) {\n    if (data instanceof _PresenceMessage) {\n      return data;\n    }\n    return _PresenceMessage.fromValues({\n      data\n    });\n  }\n  toString() {\n    return strMsg(this, \"PresenceMessage\");\n  }\n};\nvar WirePresenceMessage = class _WirePresenceMessage extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WirePresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WirePresenceMessage.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new PresenceMessage(), __spreadProps(__spreadValues({}, this), {\n      action: actions2[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WirePresenceMessage.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WirePresenceMessage\");\n  }\n};\nvar presencemessage_default = PresenceMessage;\n\n// src/common/lib/client/restpresence.ts\nvar RestPresence = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  get logger() {\n    return this.channel.logger;\n  }\n  async get(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.get()\", \"channel = \" + this.channel.name);\n    const client = this.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.channel.client.rest.presenceMixin.basePath(this),\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, this.channel);\n      }\n    ).get(params);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.history()\", \"channel = \" + this.channel.name);\n    return this.channel.client.rest.presenceMixin.history(this, params);\n  }\n};\nvar restpresence_default = RestPresence;\n\n// src/common/lib/types/message.ts\nvar actions3 = [\n  \"message.create\",\n  \"message.update\",\n  \"message.delete\",\n  \"meta\",\n  \"message.summary\",\n  \"message.append\"\n];\nfunction stringifyAction(action) {\n  return actions3[action || 0] || \"unknown\";\n}\nfunction getMessageSize(msg) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += dataSizeBytes(msg.data);\n  }\n  return size;\n}\nasync function fromEncoded2(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(options, logger);\n}\nasync function fromEncodedArray2(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded2(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded2(encoded, channel) {\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray2(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded2(encoded, channel);\n    })\n  );\n}\nasync function encodeArray(messages, options) {\n  return Promise.all(messages.map((message) => message.encode(options)));\n}\nvar serialize = encodeBody;\nfunction getMessagesSize(messages) {\n  let msg, total = 0;\n  for (let i = 0; i < messages.length; i++) {\n    msg = messages[i];\n    total += msg.size || (msg.size = getMessageSize(msg));\n  }\n  return total;\n}\nvar Message = class _Message extends BaseMessage {\n  expandFields() {\n    if (!this.version) {\n      this.version = {};\n    }\n    if (!this.version.serial && this.serial) {\n      this.version.serial = this.serial;\n    }\n    if (!this.version.timestamp && this.timestamp) {\n      this.version.timestamp = this.timestamp;\n    }\n    if (!this.annotations) {\n      this.annotations = {\n        summary: {}\n      };\n    } else if (!this.annotations.summary) {\n      this.annotations.summary = {};\n    }\n    if (this.annotations && this.annotations.summary) {\n      for (const [type, summaryEntry] of Object.entries(this.annotations.summary)) {\n        if (type.endsWith(\":distinct.v1\") || type.endsWith(\":unique.v1\") || type.endsWith(\":multiple.v1\")) {\n          for (const [, entry] of Object.entries(summaryEntry)) {\n            if (!entry.clipped) {\n              entry.clipped = false;\n            }\n          }\n        } else if (type.endsWith(\":flag.v1\")) {\n          if (!summaryEntry.clipped) {\n            summaryEntry.clipped = false;\n          }\n        }\n      }\n    }\n  }\n  async encode(options) {\n    const res = Object.assign(new WireMessage(), this, {\n      action: actions3.indexOf(this.action || \"message.create\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _Message(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Message.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Message\");\n  }\n};\nvar WireMessage = class _WireMessage extends BaseMessage {\n  // Overload toJSON() to intercept JSON.stringify()\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireMessage.fromValues(v));\n  }\n  // for contexts where some decoding errors need to be handled specially by the caller\n  async decodeWithErr(inputContext, logger) {\n    const res = Object.assign(new Message(), __spreadProps(__spreadValues({}, this), {\n      action: stringifyAction(this.action)\n    }));\n    let err;\n    try {\n      await decode(res, inputContext);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireMessage.decode()\", inspectError(e));\n      err = e;\n    }\n    res.expandFields();\n    return { decoded: res, err };\n  }\n  async decode(inputContext, logger) {\n    const { decoded } = await this.decodeWithErr(inputContext, logger);\n    return decoded;\n  }\n  toString() {\n    return strMsg(this, \"WireMessage\");\n  }\n};\nvar message_default = Message;\n\n// src/common/lib/client/restchannel.ts\nvar MSG_ID_ENTROPY_BYTES = 9;\nfunction allEmptyIds(messages) {\n  return messages.every(function(message) {\n    return !message.id;\n  });\n}\nvar RestChannel = class {\n  constructor(client, name, channelOptions) {\n    this._annotations = null;\n    var _a2, _b;\n    logger_default.logAction(client.logger, logger_default.LOG_MINOR, \"RestChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.client = client;\n    this.presence = new restpresence_default(this);\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, channelOptions);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RestAnnotations(this);\n    }\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  setOptions(options) {\n    var _a2;\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.history()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.history(this, params);\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null) {\n      messages = [message_default.fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [message_default.fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = message_default.fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    if (!params) {\n      params = {};\n    }\n    const client = this.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, idempotentRestPublishing = client.options.idempotentRestPublishing, headers = defaults_default.defaultPostHeaders(client.options);\n    mixin(headers, options.headers);\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\n      const msgIdBase = await randomString(MSG_ID_ENTROPY_BYTES);\n      messages.forEach(function(message, index) {\n        message.id = msgIdBase + \":\" + index.toString();\n      });\n    }\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages), maxMessageSize = options.maxMessageSize;\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        `Maximum size of messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400\n      );\n    }\n    return this._publish(serialize(wireMessages, client._MsgPack, format), headers, params);\n  }\n  async _publish(requestBody, headers, params) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const { body, unpacked } = await resource_default.post(\n      client,\n      client.rest.channelMixin.basePath(this) + \"/messages\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    const decoded = (unpacked ? body : decodeBody(body, client._MsgPack, format)) || {};\n    delete decoded[\"channel\"];\n    delete decoded[\"messageId\"];\n    return decoded;\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n  async getMessage(serialOrMessage) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.getMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.getMessage(this, serialOrMessage);\n  }\n  async updateMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.updateMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.updateDeleteMessage(this, \"message.update\", message, operation, params);\n  }\n  async deleteMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.deleteMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.updateDeleteMessage(this, \"message.delete\", message, operation, params);\n  }\n  async appendMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.appendMessage()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.updateDeleteMessage(this, \"message.append\", message, operation, params);\n  }\n  async getMessageVersions(serialOrMessage, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.getMessageVersions()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.getMessageVersions(this, serialOrMessage, params);\n  }\n};\nvar restchannel_default = RestChannel;\n\n// src/common/lib/types/stats.ts\nvar Stats = class _Stats {\n  constructor(values) {\n    this.entries = values && values.entries || void 0;\n    this.schema = values && values.schema || void 0;\n    this.appId = values && values.appId || void 0;\n    this.inProgress = values && values.inProgress || void 0;\n    this.unit = values && values.unit || void 0;\n    this.intervalId = values && values.intervalId || void 0;\n  }\n  static fromValues(values) {\n    return new _Stats(values);\n  }\n};\nvar stats_default = Stats;\n\n// src/common/lib/client/restchannelmixin.ts\nvar RestChannelMixin = class {\n  static basePath(channel) {\n    return \"/channels/\" + encodeURIComponent(channel.name);\n  }\n  static history(channel, params) {\n    const client = channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, this.basePath(channel) + \"/messages\", headers, envelope, async function(body, headers2, unpacked) {\n      const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n      return _fromEncodedArray2(decoded, channel);\n    }).get(params);\n  }\n  static async status(channel) {\n    const format = channel.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(channel.client.options);\n    const response = await resource_default.get(\n      channel.client,\n      this.basePath(channel),\n      headers,\n      {},\n      format,\n      true\n    );\n    return response.body;\n  }\n  static async getMessage(channel, serialOrMessage) {\n    const serial = typeof serialOrMessage === \"string\" ? serialOrMessage : serialOrMessage.serial;\n    if (!serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    const client = channel.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    const { body, unpacked } = await resource_default.get(\n      client,\n      this.basePath(channel) + \"/messages/\" + encodeURIComponent(serial),\n      headers,\n      {},\n      null,\n      true\n    );\n    const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n    return _fromEncoded2(decoded, channel);\n  }\n  static async updateDeleteMessage(channel, action, message, operation, params) {\n    if (!message.serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial and cannot be updated. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    const client = channel.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(client.options);\n    mixin(headers, client.options.headers);\n    const requestMessage = message_default.fromValues(message);\n    requestMessage.action = action;\n    requestMessage.version = operation;\n    const encoded = await requestMessage.encode(channel.channelOptions);\n    const requestBody = serialize(encoded, client._MsgPack, format);\n    let method = resource_default.patch;\n    const { body, unpacked } = await method(\n      client,\n      this.basePath(channel) + \"/messages/\" + encodeURIComponent(message.serial),\n      requestBody,\n      headers,\n      params || {},\n      null,\n      true\n    );\n    const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n    return decoded || { versionSerial: null };\n  }\n  static getMessageVersions(channel, serialOrMessage, params) {\n    const serial = typeof serialOrMessage === \"string\" ? serialOrMessage : serialOrMessage.serial;\n    if (!serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    const client = channel.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const envelope = channel.client.http.supportsLinkHeaders ? void 0 : format;\n    const headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.basePath(channel) + \"/messages/\" + encodeURIComponent(serial) + \"/versions\",\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray2(decoded, channel);\n      }\n    ).get(params || {});\n  }\n};\n\n// src/common/lib/client/restpresencemixin.ts\nvar RestPresenceMixin = class {\n  static basePath(presence) {\n    return RestChannelMixin.basePath(presence.channel) + \"/presence\";\n  }\n  static async history(presence, params) {\n    const client = presence.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = presence.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.basePath(presence) + \"/history\",\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, presence.channel);\n      }\n    ).get(params);\n  }\n};\n\n// src/common/lib/client/rest.ts\nvar Rest = class {\n  constructor(client) {\n    this.channelMixin = RestChannelMixin;\n    this.presenceMixin = RestPresenceMixin;\n    // exposed for plugins but shouldn't be bundled with minimal realtime\n    this.Resource = resource_default;\n    this.PaginatedResource = paginatedresource_default;\n    this.DeviceDetails = devicedetails_default;\n    this.PushChannelSubscription = pushchannelsubscription_default;\n    this.client = client;\n    this.channels = new Channels(this.client);\n    this.push = new push_default(this.client);\n  }\n  async stats(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options), format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    mixin(headers, this.client.options.headers);\n    return new paginatedresource_default(this.client, \"/stats\", headers, envelope, async (body, _, unpacked) => {\n      const statsValues = unpacked ? body : decodeBody(body, this.client._MsgPack, format);\n      for (let i = 0; i < statsValues.length; i++)\n        statsValues[i] = stats_default.fromValues(statsValues[i]);\n      return statsValues;\n    }).get(params);\n  }\n  async time(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options, { format: \"json\" /* json */ });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const timeUri = (host) => {\n      return this.client.baseUri(host) + \"/time\";\n    };\n    let { error, body, unpacked } = await this.client.http.do(\n      HttpMethods_default.Get,\n      timeUri,\n      headers,\n      null,\n      params\n    );\n    if (error) {\n      throw error;\n    }\n    if (!unpacked)\n      body = JSON.parse(body);\n    const time = body[0];\n    if (!time) {\n      throw new ErrorInfo(\"Internal error (unexpected result type from GET /time)\", 5e4, 500);\n    }\n    this.client.serverTimeOffset = time - Date.now();\n    return time;\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    var _a2;\n    const [encoder, decoder, format] = (() => {\n      if (this.client.options.useBinaryProtocol) {\n        if (!this.client._MsgPack) {\n          throwMissingPluginError(\"MsgPack\");\n        }\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, \"msgpack\" /* msgpack */];\n      } else {\n        return [JSON.stringify, JSON.parse, \"json\" /* json */];\n      }\n    })();\n    const envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    params = params || {};\n    const _method = method.toLowerCase();\n    const headers = _method == \"get\" ? defaults_default.defaultGetHeaders(this.client.options, { format, protocolVersion: version2 }) : defaults_default.defaultPostHeaders(this.client.options, { format, protocolVersion: version2 });\n    if (typeof body !== \"string\") {\n      body = (_a2 = encoder(body)) != null ? _a2 : null;\n    }\n    mixin(headers, this.client.options.headers);\n    if (customHeaders) {\n      mixin(headers, customHeaders);\n    }\n    const paginatedResource = new paginatedresource_default(\n      this.client,\n      path,\n      headers,\n      envelope,\n      async function(resbody, headers2, unpacked) {\n        return ensureArray(unpacked ? resbody : decoder(resbody));\n      },\n      /* useHttpPaginatedResponse: */\n      true\n    );\n    if (!Platform.Http.methods.includes(_method)) {\n      throw new ErrorInfo(\"Unsupported method \" + _method, 40500, 405);\n    }\n    if (Platform.Http.methodsWithBody.includes(_method)) {\n      return paginatedResource[_method](params, body);\n    } else {\n      return paginatedResource[_method](params);\n    }\n  }\n  async batchPublish(specOrSpecs) {\n    let requestBodyDTO;\n    let singleSpecMode;\n    if (Array.isArray(specOrSpecs)) {\n      requestBodyDTO = specOrSpecs;\n      singleSpecMode = false;\n    } else {\n      requestBodyDTO = [specOrSpecs];\n      singleSpecMode = true;\n    }\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(this.client, \"/messages\", requestBody, headers, {}, null, true);\n    const batchResults = response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n    if (singleSpecMode) {\n      return batchResults[0];\n    } else {\n      return batchResults;\n    }\n  }\n  async batchPresence(channels) {\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const channelsParam = channels.join(\",\");\n    const response = await resource_default.get(this.client, \"/presence\", headers, { channels: channelsParam }, null, true);\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n  async revokeTokens(specifiers, options) {\n    if (useTokenAuth(this.client.options)) {\n      throw new ErrorInfo(\"Cannot revoke tokens when using token auth\", 40162, 401);\n    }\n    const keyName = this.client.options.keyName;\n    let resolvedOptions = options != null ? options : {};\n    const requestBodyDTO = __spreadValues({\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`)\n    }, resolvedOptions);\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(\n      this.client,\n      `/keys/${keyName}/revokeTokens`,\n      requestBody,\n      headers,\n      {},\n      null,\n      true\n    );\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n};\nvar Channels = class {\n  constructor(client) {\n    this.client = client;\n    this.all = /* @__PURE__ */ Object.create(null);\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      this.all[name] = channel = new restchannel_default(this.client, name, channelOptions);\n    } else if (channelOptions) {\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    delete this.all[String(name)];\n  }\n};\n\n// src/common/lib/client/baserest.ts\nvar BaseRest = class extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    super(defaults_default.objectifyOptions(options, false, \"BaseRest\", logger_default.defaultLogger, { Rest }));\n  }\n};\n\n// src/common/lib/client/modularplugins.ts\nvar allCommonModularPlugins = { Rest };\n\n// src/common/lib/types/defaultmessage.ts\nvar DefaultMessage = class extends message_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded2(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray2(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return message_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/defaultpresencemessage.ts\nvar DefaultPresenceMessage = class extends presencemessage_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return presencemessage_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/annotation.ts\nvar actions4 = [\"annotation.create\", \"annotation.delete\"];\nasync function fromEncoded3(logger, encoded, options) {\n  const wa = WireAnnotation.fromValues(encoded);\n  return wa.decode(options || {}, logger);\n}\nasync function fromEncodedArray3(logger, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded3(logger, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded3(encoded, channel) {\n  return WireAnnotation.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray3(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded3(encoded, channel);\n    })\n  );\n}\nvar Annotation = class _Annotation extends BaseMessage {\n  async encode() {\n    const res = Object.assign(new WireAnnotation(), this, {\n      action: actions4.indexOf(this.action || \"annotation.create\")\n    });\n    return encode(res, {});\n  }\n  static fromValues(values) {\n    return Object.assign(new _Annotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Annotation.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Annotation\");\n  }\n};\nvar WireAnnotation = class _WireAnnotation extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireAnnotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireAnnotation.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new Annotation(), __spreadProps(__spreadValues({}, this), {\n      action: actions4[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireAnnotation.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WireAnnotation\");\n  }\n};\nvar annotation_default = Annotation;\n\n// src/common/lib/types/defaultannotation.ts\nvar DefaultAnnotation = class extends annotation_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded3(logger_default.defaultLogger, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray3(logger_default.defaultLogger, encodedArray, options);\n  }\n  static fromValues(values) {\n    return annotation_default.fromValues(values);\n  }\n};\n\n// src/common/lib/client/restannotations.ts\nfunction serialFromMsgOrSerial(msgOrSerial) {\n  let messageSerial;\n  switch (typeof msgOrSerial) {\n    case \"string\":\n      messageSerial = msgOrSerial;\n      break;\n    case \"object\":\n      messageSerial = msgOrSerial.serial;\n      break;\n  }\n  if (!messageSerial || typeof messageSerial !== \"string\") {\n    throw new ErrorInfo(\n      \"First argument of annotations.publish() must be either a Message (or at least an object with a string `serial` property) or a message serial (string)\",\n      40003,\n      400\n    );\n  }\n  return messageSerial;\n}\nfunction constructValidateAnnotation(msgOrSerial, annotationValues) {\n  const messageSerial = serialFromMsgOrSerial(msgOrSerial);\n  if (!annotationValues || typeof annotationValues !== \"object\") {\n    throw new ErrorInfo(\n      \"Second argument of annotations.publish() must be an object (the intended annotation to publish)\",\n      40003,\n      400\n    );\n  }\n  const annotation = annotation_default.fromValues(annotationValues);\n  annotation.messageSerial = messageSerial;\n  if (!annotation.action) {\n    annotation.action = \"annotation.create\";\n  }\n  return annotation;\n}\nfunction basePathForSerial(channel, serial) {\n  return channel.client.rest.channelMixin.basePath(channel) + \"/messages/\" + encodeURIComponent(serial) + \"/annotations\";\n}\nvar RestAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    const client = this.channel.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options), params = {};\n    mixin(headers, client.options.headers);\n    const requestBody = encodeBody([wireAnnotation], client._MsgPack, format);\n    await resource_default.post(\n      client,\n      basePathForSerial(this.channel, annotation.messageSerial),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    return this.publish(msgOrSerial, annotationValues);\n  }\n  async get(msgOrSerial, params) {\n    const client = this.channel.client, messageSerial = serialFromMsgOrSerial(msgOrSerial), format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options);\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      basePathForSerial(this.channel, messageSerial),\n      headers,\n      envelope,\n      async (body, _, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray3(decoded, this.channel);\n      }\n    ).get(params);\n  }\n};\nvar restannotations_default = RestAnnotations;\n\n// src/common/lib/types/protocolmessage.ts\nvar serialize2 = encodeBody;\nfunction toStringArray(array) {\n  const result = [];\n  if (array) {\n    for (let i = 0; i < array.length; i++) {\n      result.push(array[i].toString());\n    }\n  }\n  return \"[ \" + result.join(\", \") + \" ]\";\n}\nfunction deserialize(serialized, MsgPack, presenceMessagePlugin, annotationsPlugin, objectsPlugin, format) {\n  const deserialized = decodeBody(serialized, MsgPack, format);\n  return fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin, objectsPlugin);\n}\nfunction fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin, objectsPlugin) {\n  let error;\n  if (deserialized.error) {\n    error = ErrorInfo.fromValues(deserialized.error);\n  }\n  let messages;\n  if (deserialized.messages) {\n    messages = WireMessage.fromValuesArray(deserialized.messages);\n  }\n  let presence;\n  if (presenceMessagePlugin && deserialized.presence) {\n    presence = presenceMessagePlugin.WirePresenceMessage.fromValuesArray(\n      deserialized.presence\n    );\n  }\n  let annotations;\n  if (annotationsPlugin && deserialized.annotations) {\n    annotations = annotationsPlugin.WireAnnotation.fromValuesArray(\n      deserialized.annotations\n    );\n  }\n  let state;\n  if (objectsPlugin && deserialized.state) {\n    state = objectsPlugin.WireObjectMessage.fromValuesArray(\n      deserialized.state,\n      utils_exports,\n      MessageEncoding\n    );\n  }\n  return Object.assign(new ProtocolMessage(), __spreadProps(__spreadValues({}, deserialized), { presence, messages, annotations, state, error }));\n}\nfunction makeFromDeserializedWithDependencies(dependencies) {\n  return (deserialized) => {\n    var _a2;\n    return fromDeserialized(\n      deserialized,\n      {\n        PresenceMessage: presencemessage_default,\n        WirePresenceMessage\n      },\n      { Annotation: annotation_default, WireAnnotation, RealtimeAnnotations: realtimeannotations_default, RestAnnotations: restannotations_default },\n      (_a2 = dependencies == null ? void 0 : dependencies.LiveObjectsPlugin) != null ? _a2 : null\n    );\n  };\n}\nfunction fromValues(values) {\n  return Object.assign(new ProtocolMessage(), values);\n}\nfunction stringify(msg, presenceMessagePlugin, annotationsPlugin, objectsPlugin) {\n  let result = \"[ProtocolMessage\";\n  if (msg.action !== void 0)\n    result += \"; action=\" + ActionName[msg.action] || 0;\n  const simpleAttributes = [\"id\", \"channel\", \"channelSerial\", \"connectionId\", \"count\", \"msgSerial\", \"timestamp\"];\n  let attribute;\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n    attribute = simpleAttributes[attribIndex];\n    if (msg[attribute] !== void 0)\n      result += \"; \" + attribute + \"=\" + msg[attribute];\n  }\n  if (msg.messages)\n    result += \"; messages=\" + toStringArray(WireMessage.fromValuesArray(msg.messages));\n  if (msg.presence && presenceMessagePlugin)\n    result += \"; presence=\" + toStringArray(presenceMessagePlugin.WirePresenceMessage.fromValuesArray(msg.presence));\n  if (msg.annotations && annotationsPlugin) {\n    result += \"; annotations=\" + toStringArray(annotationsPlugin.WireAnnotation.fromValuesArray(msg.annotations));\n  }\n  if (msg.state && objectsPlugin) {\n    result += \"; state=\" + toStringArray(objectsPlugin.WireObjectMessage.fromValuesArray(msg.state, utils_exports, MessageEncoding));\n  }\n  if (msg.error)\n    result += \"; error=\" + ErrorInfo.fromValues(msg.error).toString();\n  if (msg.auth && msg.auth.accessToken)\n    result += \"; token=\" + msg.auth.accessToken;\n  if (msg.flags)\n    result += \"; flags=\" + flagNames.filter(msg.hasFlag).join(\",\");\n  if (msg.params) {\n    let stringifiedParams = \"\";\n    forInOwnNonNullProperties(msg.params, function(prop) {\n      if (stringifiedParams.length > 0) {\n        stringifiedParams += \"; \";\n      }\n      stringifiedParams += prop + \"=\" + msg.params[prop];\n    });\n    if (stringifiedParams.length > 0) {\n      result += \"; params=[\" + stringifiedParams + \"]\";\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar ProtocolMessage = class {\n  constructor() {\n    this.hasFlag = (flag) => {\n      return (this.flags & flags[flag]) > 0;\n    };\n  }\n  setFlag(flag) {\n    return this.flags = this.flags | flags[flag];\n  }\n  getMode() {\n    return (this.flags || 0) & flags.MODE_ALL;\n  }\n  encodeModesToFlags(modes) {\n    modes.forEach((mode) => this.setFlag(mode));\n  }\n  decodeModesFromFlags() {\n    const modes = [];\n    channelModes.forEach((mode) => {\n      if (this.hasFlag(mode)) {\n        modes.push(mode);\n      }\n    });\n    return modes.length > 0 ? modes : void 0;\n  }\n};\nvar protocolmessage_default = ProtocolMessage;\n\n// src/common/lib/client/channelstatechange.ts\nvar ChannelStateChange = class {\n  constructor(previous, current, resumed, hasBacklog, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (current === \"attached\") {\n      this.resumed = resumed;\n      this.hasBacklog = hasBacklog;\n    }\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar channelstatechange_default = ChannelStateChange;\n\n// src/common/lib/client/realtimechannel.ts\nvar noop = function() {\n};\nfunction validateChannelOptions(options) {\n  if (options && \"params\" in options && !isObject(options.params)) {\n    return new ErrorInfo(\"options.params must be an object\", 4e4, 400);\n  }\n  if (options && \"modes\" in options) {\n    if (!Array.isArray(options.modes)) {\n      return new ErrorInfo(\"options.modes must be an array\", 4e4, 400);\n    }\n    for (let i = 0; i < options.modes.length; i++) {\n      const currentMode = options.modes[i];\n      if (!currentMode || typeof currentMode !== \"string\" || !channelModes.includes(String.prototype.toUpperCase.call(currentMode))) {\n        return new ErrorInfo(\"Invalid channel mode: \" + currentMode, 4e4, 400);\n      }\n    }\n  }\n}\nvar RealtimeChannel = class _RealtimeChannel extends eventemitter_default {\n  constructor(client, name, options) {\n    var _a2, _b, _c;\n    super(client.logger);\n    this._annotations = null;\n    this._mode = 0;\n    this.retryCount = 0;\n    this.history = async function(params) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.history()\", \"channel = \" + this.name);\n      const restMixin = this.client.rest.channelMixin;\n      if (params && params.untilAttach) {\n        if (this.state !== \"attached\") {\n          throw new ErrorInfo(\"option untilAttach requires the channel to be attached\", 4e4, 400);\n        }\n        if (!this.properties.attachSerial) {\n          throw new ErrorInfo(\n            \"untilAttach was specified and channel is attached, but attachSerial is not defined\",\n            4e4,\n            400\n          );\n        }\n        delete params.untilAttach;\n        params.from_serial = this.properties.attachSerial;\n      }\n      return restMixin.history(this, params);\n    };\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, options);\n    this.client = client;\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RealtimeAnnotations(this);\n    }\n    this.connectionManager = client.connection.connectionManager;\n    this.state = \"initialized\";\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.syncChannelSerial = void 0;\n    this.properties = {\n      attachSerial: void 0,\n      channelSerial: void 0\n    };\n    this.setOptions(options);\n    this.errorReason = null;\n    this._attachResume = false;\n    this._decodingContext = {\n      channelOptions: this.channelOptions,\n      plugins: client.options.plugins || {},\n      baseEncodedPreviousPayload: void 0\n    };\n    this._lastPayload = {\n      messageId: null,\n      protocolMessageChannelSerial: null,\n      decodeFailureRecoveryInProgress: null\n    };\n    this._allChannelChanges = new eventemitter_default(this.logger);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n    if ((_c = client.options.plugins) == null ? void 0 : _c.LiveObjects) {\n      this._object = new client.options.plugins.LiveObjects.RealtimeObject(this);\n    }\n  }\n  get presence() {\n    if (!this._presence) {\n      throwMissingPluginError(\"RealtimePresence\");\n    }\n    return this._presence;\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  /** @spec RTL27 */\n  get object() {\n    if (!this._object) {\n      throwMissingPluginError(\"LiveObjects\");\n    }\n    return this._object;\n  }\n  invalidStateError() {\n    return new ErrorInfo(\n      \"Channel operation failed as channel state is \" + this.state,\n      90001,\n      400,\n      this.errorReason || void 0\n    );\n  }\n  static processListenerArgs(args) {\n    args = Array.prototype.slice.call(args);\n    if (typeof args[0] === \"function\") {\n      args.unshift(null);\n    }\n    return args;\n  }\n  async setOptions(options) {\n    var _a2;\n    const previousChannelOptions = this.channelOptions;\n    const err = validateChannelOptions(options);\n    if (err) {\n      throw err;\n    }\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n    if (this._decodingContext)\n      this._decodingContext.channelOptions = this.channelOptions;\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n      this.attachImpl();\n      return new Promise((resolve, reject) => {\n        this._allChannelChanges.once(\n          [\"attached\", \"update\", \"detached\", \"failed\"],\n          function(stateChange) {\n            switch (this.event) {\n              case \"update\":\n              case \"attached\":\n                resolve();\n                break;\n              default:\n                reject(stateChange.reason);\n            }\n          }\n        );\n      });\n    }\n  }\n  _shouldReattachToSetOptions(options, prevOptions) {\n    if (!(this.state === \"attached\" || this.state === \"attaching\")) {\n      return false;\n    }\n    if (options == null ? void 0 : options.params) {\n      const requestedParams = omitAgent(options.params);\n      const existingParams = omitAgent(prevOptions.params);\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n        return true;\n      }\n      if (!shallowEquals(existingParams, requestedParams)) {\n        return true;\n      }\n    }\n    if (options == null ? void 0 : options.modes) {\n      if (!prevOptions.modes || !arrEquals(options.modes, prevOptions.modes)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null || first === void 0) {\n      messages = [message_default.fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [message_default.fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = message_default.fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    const maxMessageSize = this.client.options.maxMessageSize;\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages);\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        `Maximum size of messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400\n      );\n    }\n    this.throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.publish()\",\n      \"sending message; channel state is \" + this.state + \", message count = \" + wireMessages.length\n    );\n    const pm = fromValues({\n      action: actions.MESSAGE,\n      channel: this.name,\n      messages: wireMessages,\n      params: params ? stringifyValues(params) : void 0\n    });\n    const res = await this.sendMessage(pm);\n    return res || { serials: [] };\n  }\n  throwIfUnpublishableState() {\n    if (!this.connectionManager.activeState()) {\n      throw this.connectionManager.getError();\n    }\n    if (this.state === \"failed\" || this.state === \"suspended\") {\n      throw this.invalidStateError();\n    }\n  }\n  onEvent(messages) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.onEvent()\", \"received message\");\n    const subscriptions = this.subscriptions;\n    for (let i = 0; i < messages.length; i++) {\n      const message = messages[i];\n      subscriptions.emit(message.name, message);\n    }\n  }\n  async attach() {\n    if (this.state === \"attached\") {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      this._attach(false, null, (err, result) => err ? reject(err) : resolve(result));\n    });\n  }\n  _attach(forceReattach, attachReason, callback) {\n    if (!callback) {\n      callback = (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"RealtimeChannel._attach()\",\n            \"Channel attach failed: \" + err.toString()\n          );\n        }\n      };\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      callback(connectionManager.getError());\n      return;\n    }\n    if (this.state !== \"attaching\" || forceReattach) {\n      this.requestState(\"attaching\", attachReason);\n    }\n    this.once(function(stateChange) {\n      switch (this.event) {\n        case \"attached\":\n          callback == null ? void 0 : callback(null, stateChange);\n          break;\n        case \"detached\":\n        case \"suspended\":\n        case \"failed\":\n          callback == null ? void 0 : callback(\n            stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to attach; reason unknown; state = \" + this.event, 9e4, 500)\n          );\n          break;\n        case \"detaching\":\n          callback == null ? void 0 : callback(new ErrorInfo(\"Attach request superseded by a subsequent detach request\", 9e4, 409));\n          break;\n      }\n    });\n  }\n  attachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.attachImpl()\", \"sending ATTACH message\");\n    const attachMsg = fromValues({\n      action: actions.ATTACH,\n      channel: this.name,\n      params: this.channelOptions.params,\n      // RTL4c1: Includes the channel serial to resume from a previous message\n      // or attachment.\n      channelSerial: this.properties.channelSerial\n    });\n    if (this.channelOptions.modes) {\n      attachMsg.encodeModesToFlags(allToUpperCase(this.channelOptions.modes));\n    }\n    if (this._attachResume) {\n      attachMsg.setFlag(\"ATTACH_RESUME\");\n    }\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n    }\n    this.sendMessage(attachMsg).catch(noop);\n  }\n  async detach() {\n    const connectionManager = this.connectionManager;\n    switch (this.state) {\n      case \"suspended\":\n        this.notifyState(\"detached\");\n        return;\n      case \"detached\":\n        return;\n      case \"failed\":\n        throw new ErrorInfo(\"Unable to detach; channel state = failed\", 90001, 400);\n      default:\n        if (connectionManager.state.state !== \"connected\") {\n          this.notifyState(\"detached\");\n          return;\n        }\n        this.requestState(\"detaching\");\n      case \"detaching\":\n        return new Promise((resolve, reject) => {\n          this.once(function(stateChange) {\n            switch (this.event) {\n              case \"detached\":\n                resolve();\n                break;\n              case \"attached\":\n              case \"suspended\":\n              case \"failed\":\n                reject(\n                  stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to detach; reason unknown; state = \" + this.event, 9e4, 500)\n                );\n                break;\n              case \"attaching\":\n                reject(new ErrorInfo(\"Detach request superseded by a subsequent attach request\", 9e4, 409));\n                break;\n            }\n          });\n        });\n    }\n  }\n  detachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.detach()\", \"sending DETACH message\");\n    const msg = fromValues({ action: actions.DETACH, channel: this.name });\n    this.sendMessage(msg).catch(noop);\n  }\n  async subscribe(...args) {\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (this.state === \"failed\") {\n      throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n    if (event && typeof event === \"object\" && !Array.isArray(event)) {\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\n    } else {\n      this.subscriptions.on(event, listener);\n    }\n    if (this.channelOptions.attachOnSubscribe !== false) {\n      return this.attach();\n    } else {\n      return null;\n    }\n  }\n  unsubscribe(...args) {\n    var _a2;\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (typeof event === \"object\" && !listener || ((_a2 = this.filteredSubscriptions) == null ? void 0 : _a2.has(listener))) {\n      this.client._FilteredSubscriptions.getAndDeleteFilteredSubscriptions(this, event, listener).forEach((l) => this.subscriptions.off(l));\n      return;\n    }\n    this.subscriptions.off(event, listener);\n  }\n  sync() {\n    switch (this.state) {\n      case \"initialized\":\n      case \"detaching\":\n      case \"detached\":\n        throw new PartialErrorInfo(\"Unable to sync to channel; not attached\", 4e4);\n      default:\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    const syncMessage = fromValues({ action: actions.SYNC, channel: this.name });\n    if (this.syncChannelSerial) {\n      syncMessage.channelSerial = this.syncChannelSerial;\n    }\n    connectionManager.send(syncMessage);\n  }\n  async sendMessage(msg) {\n    return new Promise((resolve, reject) => {\n      this.connectionManager.send(msg, this.client.options.queueMessages, (err, publishResponse) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(publishResponse);\n        }\n      });\n    });\n  }\n  async sendPresence(presence) {\n    const msg = fromValues({\n      action: actions.PRESENCE,\n      channel: this.name,\n      presence\n    });\n    await this.sendMessage(msg);\n  }\n  async sendState(objectMessages) {\n    const msg = fromValues({\n      action: actions.OBJECT,\n      channel: this.name,\n      state: objectMessages\n    });\n    await this.sendMessage(msg);\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\n  async processMessage(message) {\n    if (message.action === actions.ATTACHED || message.action === actions.MESSAGE || message.action === actions.PRESENCE || message.action === actions.OBJECT || message.action === actions.ANNOTATION) {\n      this.setChannelSerial(message.channelSerial);\n    }\n    let syncChannelSerial, isSync = false;\n    switch (message.action) {\n      case actions.ATTACHED: {\n        this.properties.attachSerial = message.channelSerial;\n        this._mode = message.getMode();\n        this.params = message.params || {};\n        const modesFromFlags = message.decodeModesFromFlags();\n        this.modes = modesFromFlags && allToLowerCase(modesFromFlags) || void 0;\n        const resumed = message.hasFlag(\"RESUMED\");\n        const hasPresence = message.hasFlag(\"HAS_PRESENCE\");\n        const hasBacklog = message.hasFlag(\"HAS_BACKLOG\");\n        const hasObjects = message.hasFlag(\"HAS_OBJECTS\");\n        if (this.state === \"attached\") {\n          if (!resumed) {\n            if (this._presence) {\n              this._presence.onAttached(hasPresence);\n            }\n            if (this._object) {\n              this._object.onAttached(hasObjects);\n            }\n          }\n          const change = new channelstatechange_default(this.state, this.state, resumed, hasBacklog, message.error);\n          this._allChannelChanges.emit(\"update\", change);\n          if (!resumed || this.channelOptions.updateOnAttached) {\n            this.emit(\"update\", change);\n          }\n        } else if (this.state === \"detaching\") {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"attached\", message.error, resumed, hasPresence, hasBacklog, hasObjects);\n        }\n        break;\n      }\n      case actions.DETACHED: {\n        const detachErr = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo(\"Channel detached\", 90001, 404);\n        if (this.state === \"detaching\") {\n          this.notifyState(\"detached\", detachErr);\n        } else if (this.state === \"attaching\") {\n          this.notifyState(\"suspended\", detachErr);\n        } else if (this.state === \"attached\" || this.state === \"suspended\") {\n          this.requestState(\"attaching\", detachErr);\n        }\n        break;\n      }\n      case actions.SYNC:\n        isSync = true;\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n        if (!message.presence)\n          break;\n      case actions.PRESENCE: {\n        if (!message.presence) {\n          break;\n        }\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._presence) {\n          const presenceMessages = await Promise.all(\n            message.presence.map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._presence.setPresence(presenceMessages, isSync, syncChannelSerial);\n        }\n        break;\n      }\n      case actions.OBJECT:\n      case actions.OBJECT_SYNC: {\n        if (!this._object || !message.state) {\n          return;\n        }\n        populateFieldsFromParent(message);\n        const format = this.client.connection.connectionManager.getActiveTransportFormat();\n        const objectMessages = message.state.map((om) => om.decode(this.client, format));\n        if (message.action === actions.OBJECT) {\n          this._object.handleObjectMessages(objectMessages);\n        } else {\n          this._object.handleObjectSyncMessages(objectMessages, message.channelSerial);\n        }\n        break;\n      }\n      case actions.MESSAGE: {\n        if (this.state !== \"attached\") {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"RealtimeChannel.processMessage()\",\n            'Message \"' + message.id + '\" skipped as this channel \"' + this.name + '\" state is not \"attached\" (state is \"' + this.state + '\").'\n          );\n          return;\n        }\n        populateFieldsFromParent(message);\n        const encoded = message.messages, firstMessage = encoded[0], lastMessage = encoded[encoded.length - 1];\n        if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {\n          const msg = 'Delta message decode failure - previous message not available for message \"' + message.id + '\" on this channel \"' + this.name + '\".';\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", msg);\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\n          break;\n        }\n        let messages = [];\n        for (let i = 0; i < encoded.length; i++) {\n          const { decoded, err } = await encoded[i].decodeWithErr(this._decodingContext, this.logger);\n          messages[i] = decoded;\n          if (err) {\n            switch (err.code) {\n              case 40018:\n                this._startDecodeFailureRecovery(err);\n                return;\n              case 40019:\n              case 40021:\n                this.notifyState(\"failed\", err);\n                return;\n              default:\n            }\n          }\n        }\n        this._lastPayload.messageId = lastMessage.id;\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n        this.onEvent(messages);\n        break;\n      }\n      case actions.ANNOTATION: {\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._annotations) {\n          const annotations = await Promise.all(\n            (message.annotations || []).map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._annotations._processIncoming(annotations);\n        }\n        break;\n      }\n      case actions.ERROR: {\n        const err = message.error;\n        if (err && err.code == 80016) {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"failed\", ErrorInfo.fromValues(err));\n        }\n        break;\n      }\n      default:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"RealtimeChannel.processMessage()\",\n          \"Protocol error: unrecognised message action (\" + message.action + \")\"\n        );\n    }\n  }\n  _startDecodeFailureRecovery(reason) {\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MAJOR,\n        \"RealtimeChannel.processMessage()\",\n        \"Starting decode failure recovery process.\"\n      );\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\n      this._attach(true, reason, () => {\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\n      });\n    }\n  }\n  onAttached() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.onAttached\",\n      \"activating channel; name = \" + this.name\n    );\n  }\n  notifyState(state, reason, resumed, hasPresence, hasBacklog, hasObjects) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.notifyState\",\n      \"name = \" + this.name + \", current state = \" + this.state + \", notifying state \" + state\n    );\n    this.clearStateTimer();\n    if ([\"detached\", \"suspended\", \"failed\"].includes(state)) {\n      this.properties.channelSerial = null;\n    }\n    if (state === this.state) {\n      return;\n    }\n    if (this._presence) {\n      this._presence.actOnChannelState(state, hasPresence, reason);\n    }\n    if (this._object) {\n      this._object.actOnChannelState(state, hasObjects);\n    }\n    if (state === \"suspended\" && this.connectionManager.state.sendEvents) {\n      this.startRetryTimer();\n    } else {\n      this.cancelRetryTimer();\n    }\n    if (reason) {\n      this.errorReason = reason;\n    }\n    const change = new channelstatechange_default(this.state, state, resumed, hasBacklog, reason);\n    const action = 'Channel state for channel \"' + this.name + '\"';\n    const message = state + (reason ? \"; reason: \" + reason : \"\");\n    if (state === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    if (state !== \"attaching\" && state !== \"suspended\") {\n      this.retryCount = 0;\n    }\n    if (state === \"attached\") {\n      this.onAttached();\n    }\n    if (state === \"attached\") {\n      this._attachResume = true;\n    } else if (state === \"detaching\" || state === \"failed\") {\n      this._attachResume = false;\n    }\n    this.state = state;\n    this._allChannelChanges.emit(state, change);\n    this.emit(state, change);\n  }\n  requestState(state, reason) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.requestState\",\n      \"name = \" + this.name + \", state = \" + state\n    );\n    this.notifyState(state, reason);\n    this.checkPendingState();\n  }\n  checkPendingState() {\n    const cmState = this.connectionManager.state;\n    if (!cmState.sendEvents) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.checkPendingState\",\n        \"sendEvents is false; state is \" + this.connectionManager.state.state\n      );\n      return;\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.checkPendingState\",\n      \"name = \" + this.name + \", state = \" + this.state\n    );\n    switch (this.state) {\n      case \"attaching\":\n        this.startStateTimerIfNotRunning();\n        this.attachImpl();\n        break;\n      case \"detaching\":\n        this.startStateTimerIfNotRunning();\n        this.detachImpl();\n        break;\n      case \"attached\":\n        this.sync();\n        break;\n      default:\n        break;\n    }\n  }\n  timeoutPendingState() {\n    switch (this.state) {\n      case \"attaching\": {\n        const err = new ErrorInfo(\"Channel attach timed out\", 90007, 408);\n        this.notifyState(\"suspended\", err);\n        break;\n      }\n      case \"detaching\": {\n        const err = new ErrorInfo(\"Channel detach timed out\", 90007, 408);\n        this.notifyState(\"attached\", err);\n        break;\n      }\n      default:\n        this.checkPendingState();\n        break;\n    }\n  }\n  startStateTimerIfNotRunning() {\n    if (!this.stateTimer) {\n      this.stateTimer = setTimeout(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel.startStateTimerIfNotRunning\", \"timer expired\");\n        this.stateTimer = null;\n        this.timeoutPendingState();\n      }, this.client.options.timeouts.realtimeRequestTimeout);\n    }\n  }\n  clearStateTimer() {\n    const stateTimer = this.stateTimer;\n    if (stateTimer) {\n      clearTimeout(stateTimer);\n      this.stateTimer = null;\n    }\n  }\n  startRetryTimer() {\n    if (this.retryTimer)\n      return;\n    this.retryCount++;\n    const retryDelay = getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\n    this.retryTimer = setTimeout(() => {\n      if (this.state === \"suspended\" && this.connectionManager.state.sendEvents) {\n        this.retryTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"RealtimeChannel retry timer expired\",\n          \"attempting a new attach\"\n        );\n        this.requestState(\"attaching\");\n      }\n    }, retryDelay);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n  getReleaseErr() {\n    const s = this.state;\n    if (s === \"initialized\" || s === \"detached\" || s === \"failed\") {\n      return null;\n    }\n    return new ErrorInfo(\n      \"Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was \" + s,\n      90001,\n      400\n    );\n  }\n  setChannelSerial(channelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.setChannelSerial()\",\n      \"Updating channel serial; serial = \" + channelSerial + \"; previous = \" + this.properties.channelSerial\n    );\n    if (channelSerial) {\n      this.properties.channelSerial = channelSerial;\n    }\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n  async getMessage(serialOrMessage) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.getMessage()\", \"channel = \" + this.name);\n    const restMixin = this.client.rest.channelMixin;\n    return restMixin.getMessage(this, serialOrMessage);\n  }\n  async updateMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.updateMessage()\", \"channel = \" + this.name);\n    return this.sendUpdate(message, \"message.update\", operation, params);\n  }\n  async deleteMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.deleteMessage()\", \"channel = \" + this.name);\n    return this.sendUpdate(message, \"message.delete\", operation, params);\n  }\n  async appendMessage(message, operation, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.appendMessage()\", \"channel = \" + this.name);\n    return this.sendUpdate(message, \"message.append\", operation, params);\n  }\n  async sendUpdate(message, action, operation, params) {\n    var _a2, _b;\n    if (!message.serial) {\n      throw new ErrorInfo(\n        'This message lacks a serial and cannot be updated. Make sure you have enabled \"Message annotations, updates, and deletes\" in channel settings on your dashboard.',\n        40003,\n        400\n      );\n    }\n    this.throwIfUnpublishableState();\n    const updateDeleteMsg = message_default.fromValues(__spreadProps(__spreadValues({}, message), {\n      action,\n      version: operation\n    }));\n    const wireMessage = await updateDeleteMsg.encode(this.channelOptions);\n    const pm = fromValues({\n      action: actions.MESSAGE,\n      channel: this.name,\n      messages: [wireMessage],\n      params: params ? stringifyValues(params) : void 0\n    });\n    const publishResponse = await this.sendMessage(pm);\n    return { versionSerial: (_b = (_a2 = publishResponse == null ? void 0 : publishResponse.serials) == null ? void 0 : _a2[0]) != null ? _b : null };\n  }\n  async getMessageVersions(serialOrMessage, params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.getMessageVersions()\", \"channel = \" + this.name);\n    const restMixin = this.client.rest.channelMixin;\n    return restMixin.getMessageVersions(this, serialOrMessage, params);\n  }\n  /**\n   * Ensures the channel is attached, attaching if necessary.\n   *\n   * This method is intended for use by features like Presence or Objects that need to\n   * implicitly attach the channel when an operation is called (e.g., `presence.get()` per RTP11b,\n   * or `objects.get()`). This guarantees that the corresponding sync sequence will start and\n   * that the operation will resolve for callers even if they did not explicitly attach beforehand.\n   */\n  async ensureAttached() {\n    switch (this.state) {\n      case \"attached\":\n      case \"suspended\":\n        break;\n      case \"initialized\":\n      case \"detached\":\n      case \"detaching\":\n      case \"attaching\":\n        await this.attach();\n        break;\n      case \"failed\":\n      default:\n        throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n  }\n};\nfunction omitAgent(channelParams) {\n  const _a2 = channelParams || {}, { agent: _ } = _a2, paramsWithoutAgent = __objRest(_a2, [\"agent\"]);\n  return paramsWithoutAgent;\n}\nvar realtimechannel_default = RealtimeChannel;\n\n// src/common/lib/client/realtimeannotations.ts\nvar RealtimeAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n    this.logger = channel.logger;\n    this.subscriptions = new eventemitter_default(this.logger);\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const channelName = this.channel.name;\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    this.channel.throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeAnnotations.publish()\",\n      \"channelName = \" + channelName + \", sending annotation with messageSerial = \" + annotation.messageSerial + \", type = \" + annotation.type\n    );\n    const pm = fromValues({\n      action: actions.ANNOTATION,\n      channel: channelName,\n      annotations: [wireAnnotation]\n    });\n    await this.channel.sendMessage(pm);\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    await this.publish(msgOrSerial, annotationValues);\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (this.channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n    if ((this.channel.state === \"attached\" && this.channel._mode & flags.ANNOTATION_SUBSCRIBE) === 0) {\n      throw new ErrorInfo(\n        \"You are trying to add an annotation listener, but you haven't requested the annotation_subscribe channel mode in ChannelOptions, so this won't do anything (we only deliver annotations to clients who have explicitly requested them)\",\n        93001,\n        400\n      );\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n  _processIncoming(annotations) {\n    for (const annotation of annotations) {\n      this.subscriptions.emit(annotation.type || \"\", annotation);\n    }\n  }\n  async get(msgOrSerial, params) {\n    return restannotations_default.prototype.get.call(this, msgOrSerial, params);\n  }\n};\nvar realtimeannotations_default = RealtimeAnnotations;\n\n// src/common/lib/client/defaultrest.ts\nvar _DefaultRest = class _DefaultRest extends BaseRest {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2, _b;\n    const MsgPack = _DefaultRest._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRest._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Rest\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRest.Crypto) != null ? _a2 : void 0,\n        MsgPack: (_b = _DefaultRest._MsgPack) != null ? _b : void 0,\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        }\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRest._Crypto = null;\n_DefaultRest.Message = DefaultMessage;\n_DefaultRest.PresenceMessage = DefaultPresenceMessage;\n_DefaultRest.Annotation = DefaultAnnotation;\n_DefaultRest._MsgPack = null;\n// Used by tests\n_DefaultRest._Http = Http;\nvar DefaultRest = _DefaultRest;\n\n// src/common/lib/transport/messagequeue.ts\nvar MessageQueue = class extends eventemitter_default {\n  constructor(logger) {\n    super(logger);\n    this.messages = [];\n  }\n  count() {\n    return this.messages.length;\n  }\n  push(message) {\n    this.messages.push(message);\n  }\n  shift() {\n    return this.messages.shift();\n  }\n  last() {\n    return this.messages[this.messages.length - 1];\n  }\n  copyAll() {\n    return this.messages.slice();\n  }\n  append(messages) {\n    this.messages.push.apply(this.messages, messages);\n  }\n  prepend(messages) {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n  /**\n   * For all messages targeted by the selector, calls their callback and removes them from the queue.\n   *\n   * @param selector - Describes which messages to target. 'all' means all messages in the queue (regardless of whether they have had a `msgSerial` assigned); `serial` / `count` targets a range of messages described by an `ACK` or `NACK` received from Ably (this assumes that all the messages in the queue have had a `msgSerial` assigned).\n   */\n  completeMessages(selector, err, res) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.completeMessages()\",\n      selector == \"all\" ? \"(all)\" : \"serial = \" + selector.serial + \"; count = \" + selector.count\n    );\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error(\"MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue\");\n    }\n    let completeMessages = [];\n    if (selector === \"all\") {\n      completeMessages = messages.splice(0);\n    } else {\n      const first = messages[0];\n      if (first) {\n        const startSerial = first.message.msgSerial;\n        const endSerial = selector.serial + selector.count;\n        if (endSerial > startSerial) {\n          completeMessages = messages.splice(0, endSerial - startSerial);\n        }\n      }\n    }\n    for (let i = 0; i < completeMessages.length; i++) {\n      const message = completeMessages[i];\n      const publishResponse = res == null ? void 0 : res[i];\n      message.callback(err, publishResponse);\n    }\n    if (messages.length == 0)\n      this.emit(\"idle\");\n  }\n  completeAllMessages(err) {\n    this.completeMessages(\"all\", err);\n  }\n  resetSendAttempted() {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n  clear() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.clear()\",\n      \"clearing \" + this.messages.length + \" messages\"\n    );\n    this.messages = [];\n    this.emit(\"idle\");\n  }\n};\nvar messagequeue_default = MessageQueue;\n\n// src/common/lib/transport/protocol.ts\nvar PendingMessage = class {\n  constructor(message, callback) {\n    this.message = message;\n    this.callback = callback;\n    this.merged = false;\n    const action = message.action;\n    this.sendAttempted = false;\n    this.ackRequired = typeof action === \"number\" && [actions.MESSAGE, actions.PRESENCE, actions.ANNOTATION, actions.OBJECT].includes(action);\n  }\n};\nvar Protocol = class extends eventemitter_default {\n  constructor(transport) {\n    super(transport.logger);\n    this.transport = transport;\n    this.messageQueue = new messagequeue_default(this.logger);\n    transport.on(\"ack\", (serial, count, res) => {\n      this.onAck(serial, count, res);\n    });\n    transport.on(\"nack\", (serial, count, err) => {\n      this.onNack(serial, count, err);\n    });\n  }\n  onAck(serial, count, res) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"Protocol.onAck()\", \"serial = \" + serial + \"; count = \" + count);\n    this.messageQueue.completeMessages({ serial, count }, null, res);\n  }\n  onNack(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_ERROR,\n      \"Protocol.onNack()\",\n      \"serial = \" + serial + \"; count = \" + count + \"; err = \" + inspectError(err)\n    );\n    if (!err) {\n      err = new ErrorInfo(\"Unable to send message; channel not responding\", 50001, 500);\n    }\n    this.messageQueue.completeMessages({ serial, count }, err);\n  }\n  onceIdle(listener) {\n    const messageQueue = this.messageQueue;\n    if (messageQueue.count() === 0) {\n      listener();\n      return;\n    }\n    messageQueue.once(\"idle\", listener);\n  }\n  send(pendingMessage) {\n    if (pendingMessage.ackRequired) {\n      this.messageQueue.push(pendingMessage);\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Protocol.send()\",\n        \"sending msg; \" + stringify(\n          pendingMessage.message,\n          this.transport.connectionManager.realtime._RealtimePresence,\n          this.transport.connectionManager.realtime._Annotations,\n          this.transport.connectionManager.realtime._liveObjectsPlugin\n        )\n      );\n    }\n    pendingMessage.sendAttempted = true;\n    this.transport.send(pendingMessage.message);\n  }\n  getTransport() {\n    return this.transport;\n  }\n  getPendingMessages() {\n    return this.messageQueue.copyAll();\n  }\n  clearPendingMessages() {\n    return this.messageQueue.clear();\n  }\n  finish() {\n    const transport = this.transport;\n    this.onceIdle(function() {\n      transport.disconnect();\n    });\n  }\n};\nvar protocol_default = Protocol;\n\n// src/common/lib/client/connectionstatechange.ts\nvar ConnectionStateChange = class {\n  constructor(previous, current, retryIn, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn)\n      this.retryIn = retryIn;\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar connectionstatechange_default = ConnectionStateChange;\n\n// src/common/lib/transport/connectionerrors.ts\nvar ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 8e4,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001\n};\nvar ConnectionErrors = {\n  disconnected: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.DISCONNECTED,\n    message: \"Connection to server temporarily unavailable\"\n  }),\n  suspended: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.SUSPENDED,\n    message: \"Connection to server unavailable\"\n  }),\n  failed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.FAILED,\n    message: \"Connection failed or disconnected by server\"\n  }),\n  closing: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSING,\n    message: \"Connection closing\"\n  }),\n  closed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSED,\n    message: \"Connection closed\"\n  }),\n  unknownConnectionErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal connection error\"\n  }),\n  unknownChannelErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal channel error\"\n  })\n};\nfunction isRetriable(err) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\nvar connectionerrors_default = ConnectionErrors;\n\n// src/common/lib/transport/transport.ts\nvar closeMessage = fromValues({ action: actions.CLOSE });\nvar disconnectMessage = fromValues({ action: actions.DISCONNECT });\nvar Transport = class extends eventemitter_default {\n  constructor(connectionManager, auth, params, forceJsonProtocol) {\n    super(connectionManager.logger);\n    if (forceJsonProtocol) {\n      params.format = void 0;\n      params.heartbeats = true;\n    }\n    this.connectionManager = connectionManager;\n    this.auth = auth;\n    this.params = params;\n    this.timeouts = params.options.timeouts;\n    this.format = params.format;\n    this.isConnected = false;\n    this.isFinished = false;\n    this.isDisposed = false;\n    this.maxIdleInterval = null;\n    this.idleTimer = null;\n    this.lastActivity = null;\n  }\n  connect() {\n  }\n  close() {\n    if (this.isConnected) {\n      this.requestClose();\n    }\n    this.finish(\"closed\", connectionerrors_default.closed());\n  }\n  disconnect(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"disconnected\", err || connectionerrors_default.disconnected());\n  }\n  fail(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"failed\", err || connectionerrors_default.failed());\n  }\n  finish(event, err) {\n    var _a2;\n    if (this.isFinished) {\n      return;\n    }\n    this.isFinished = true;\n    this.isConnected = false;\n    this.maxIdleInterval = null;\n    clearTimeout((_a2 = this.idleTimer) != null ? _a2 : void 0);\n    this.idleTimer = null;\n    this.emit(event, err);\n    this.dispose();\n  }\n  onProtocolMessage(message) {\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Transport.onProtocolMessage()\",\n        \"received on \" + this.shortName + \": \" + stringify(\n          message,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations,\n          this.connectionManager.realtime._liveObjectsPlugin\n        ) + \"; connectionId = \" + this.connectionManager.connectionId\n      );\n    }\n    this.onActivity();\n    switch (message.action) {\n      case actions.HEARTBEAT:\n        logger_default.logActionNoStrip(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Transport.onProtocolMessage()\",\n          this.shortName + \" heartbeat; connectionId = \" + this.connectionManager.connectionId\n        );\n        this.emit(\"heartbeat\", message.id);\n        break;\n      case actions.CONNECTED:\n        this.onConnect(message);\n        this.emit(\"connected\", message.error, message.connectionId, message.connectionDetails, message);\n        break;\n      case actions.CLOSED:\n        this.onClose(message);\n        break;\n      case actions.DISCONNECTED:\n        this.onDisconnect(message);\n        break;\n      case actions.ACK:\n        this.emit(\"ack\", message.msgSerial, message.count, message.res);\n        break;\n      case actions.NACK:\n        this.emit(\"nack\", message.msgSerial, message.count, message.error);\n        break;\n      case actions.SYNC:\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      case actions.ACTIVATE:\n        break;\n      case actions.AUTH:\n        whenPromiseSettles(this.auth.authorize(), (err) => {\n          if (err) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Transport.onProtocolMessage()\",\n              \"Ably requested re-authentication, but unable to obtain a new token: \" + inspectError(err)\n            );\n          }\n        });\n        break;\n      case actions.ERROR:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Transport.onProtocolMessage()\",\n          \"received error action; connectionId = \" + this.connectionManager.connectionId + \"; err = \" + Platform.Config.inspect(message.error) + (message.channel ? \", channel: \" + message.channel : \"\")\n        );\n        if (message.channel === void 0) {\n          this.onFatalError(message);\n          break;\n        }\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      default:\n        this.connectionManager.onChannelMessage(message, this);\n    }\n  }\n  onConnect(message) {\n    this.isConnected = true;\n    if (!message.connectionDetails) {\n      throw new Error(\"Transport.onConnect(): Connect message recieved without connectionDetails\");\n    }\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval;\n    if (maxPromisedIdle) {\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n      this.onActivity();\n    }\n  }\n  onDisconnect(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onDisconnect()\", \"err = \" + inspectError(err));\n    this.finish(\"disconnected\", err);\n  }\n  onFatalError(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onFatalError()\", \"err = \" + inspectError(err));\n    this.finish(\"failed\", err);\n  }\n  onClose(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onClose()\", \"err = \" + inspectError(err));\n    this.finish(\"closed\", err);\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestClose()\", \"\");\n    this.send(closeMessage);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestDisconnect()\", \"\");\n    this.send(disconnectMessage);\n  }\n  ping(id) {\n    const msg = { action: actions.HEARTBEAT };\n    if (id)\n      msg.id = id;\n    this.send(fromValues(msg));\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.dispose()\", \"\");\n    this.isDisposed = true;\n    this.off();\n  }\n  onActivity() {\n    if (!this.maxIdleInterval) {\n      return;\n    }\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\n    this.setIdleTimer(this.maxIdleInterval + 100);\n  }\n  setIdleTimer(timeout) {\n    if (!this.idleTimer) {\n      this.idleTimer = setTimeout(() => {\n        this.onIdleTimerExpire();\n      }, timeout);\n    }\n  }\n  onIdleTimerExpire() {\n    if (!this.lastActivity || !this.maxIdleInterval) {\n      throw new Error(\"Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set\");\n    }\n    this.idleTimer = null;\n    const sinceLast = Date.now() - this.lastActivity;\n    const timeRemaining = this.maxIdleInterval - sinceLast;\n    if (timeRemaining <= 0) {\n      const msg = \"No activity seen from realtime in \" + sinceLast + \"ms; assuming connection has dropped\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Transport.onIdleTimerExpire()\", msg);\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\n    } else {\n      this.setIdleTimer(timeRemaining + 100);\n    }\n  }\n  static tryConnect(transportCtor, connectionManager, auth, transportParams, callback) {\n    const transport = new transportCtor(connectionManager, auth, transportParams);\n    let transportAttemptTimer;\n    const errorCb = function(err) {\n      clearTimeout(transportAttemptTimer);\n      callback({ event: this.event, error: err });\n    };\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n    transportAttemptTimer = setTimeout(() => {\n      transport.off([\"preconnect\", \"disconnected\", \"failed\"]);\n      transport.dispose();\n      errorCb.call(\n        { event: \"disconnected\" },\n        new ErrorInfo(\"Timeout waiting for transport to indicate itself viable\", 5e4, 500)\n      );\n    }, realtimeRequestTimeout);\n    transport.on([\"failed\", \"disconnected\"], errorCb);\n    transport.on(\"preconnect\", function() {\n      logger_default.logAction(\n        connectionManager.logger,\n        logger_default.LOG_MINOR,\n        \"Transport.tryConnect()\",\n        \"viable transport \" + transport\n      );\n      clearTimeout(transportAttemptTimer);\n      transport.off([\"failed\", \"disconnected\"], errorCb);\n      callback(null, transport);\n    });\n    transport.connect();\n    return transport;\n  }\n  static isAvailable() {\n    throw new ErrorInfo(\"isAvailable not implemented for transport\", 5e4, 500);\n  }\n};\nvar transport_default = Transport;\n\n// src/common/constants/TransportName.ts\nvar TransportNames;\n((TransportNames2) => {\n  TransportNames2.WebSocket = \"web_socket\";\n  TransportNames2.Comet = \"comet\";\n  TransportNames2.XhrPolling = \"xhr_polling\";\n})(TransportNames || (TransportNames = {}));\n\n// src/common/lib/transport/connectionmanager.ts\nvar globalObject2 = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : self;\nvar haveWebStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.localSupported);\n};\nvar haveSessionStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.sessionSupported);\n};\nvar noop2 = function() {\n};\nvar transportPreferenceName = \"ably-transport-preference\";\nfunction decodeRecoveryKey(recoveryKey) {\n  try {\n    return JSON.parse(recoveryKey);\n  } catch (e) {\n    return null;\n  }\n}\nvar TransportParams = class {\n  constructor(options, host, mode, connectionKey) {\n    this.options = options;\n    this.host = host;\n    this.mode = mode;\n    this.connectionKey = connectionKey;\n    this.format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n  }\n  getConnectParams(authParams) {\n    const params = authParams ? copy(authParams) : {};\n    const options = this.options;\n    switch (this.mode) {\n      case \"resume\":\n        params.resume = this.connectionKey;\n        break;\n      case \"recover\": {\n        const recoveryContext = decodeRecoveryKey(options.recover);\n        if (recoveryContext) {\n          params.recover = recoveryContext.connectionKey;\n        }\n        break;\n      }\n      default:\n    }\n    if (options.clientId !== void 0) {\n      params.clientId = options.clientId;\n    }\n    if (options.echoMessages === false) {\n      params.echo = \"false\";\n    }\n    if (this.format !== void 0) {\n      params.format = this.format;\n    }\n    if (this.stream !== void 0) {\n      params.stream = this.stream;\n    }\n    if (this.heartbeats !== void 0) {\n      params.heartbeats = this.heartbeats;\n    }\n    params.v = defaults_default.protocolVersion;\n    params.agent = getAgentString(this.options);\n    if (options.transportParams !== void 0) {\n      mixin(params, options.transportParams);\n    }\n    return params;\n  }\n  toString() {\n    let result = \"[mode=\" + this.mode;\n    if (this.host) {\n      result += \",host=\" + this.host;\n    }\n    if (this.connectionKey) {\n      result += \",connectionKey=\" + this.connectionKey;\n    }\n    if (this.format) {\n      result += \",format=\" + this.format;\n    }\n    result += \"]\";\n    return result;\n  }\n};\nvar ConnectionManager = class _ConnectionManager extends eventemitter_default {\n  constructor(realtime, options) {\n    super(realtime.logger);\n    this.supportedTransports = {};\n    this.disconnectedRetryCount = 0;\n    this.pendingChannelMessagesState = { isProcessing: false, queue: [] };\n    this.realtime = realtime;\n    this.initTransports();\n    this.options = options;\n    const timeouts = options.timeouts;\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\n    this.states = {\n      initialized: {\n        state: \"initialized\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        failState: \"disconnected\"\n      },\n      connecting: {\n        state: \"connecting\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: connectingTimeout,\n        failState: \"disconnected\"\n      },\n      connected: {\n        state: \"connected\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: true,\n        failState: \"disconnected\"\n      },\n      disconnected: {\n        state: \"disconnected\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: timeouts.disconnectedRetryTimeout,\n        failState: \"disconnected\"\n      },\n      suspended: {\n        state: \"suspended\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.suspendedRetryTimeout,\n        failState: \"suspended\"\n      },\n      closing: {\n        state: \"closing\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.realtimeRequestTimeout,\n        failState: \"closed\"\n      },\n      closed: { state: \"closed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"closed\" },\n      failed: { state: \"failed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"failed\" }\n    };\n    this.state = this.states.initialized;\n    this.errorReason = null;\n    this.queuedMessages = new messagequeue_default(this.logger);\n    this.msgSerial = 0;\n    this.connectionDetails = void 0;\n    this.connectionId = void 0;\n    this.connectionKey = void 0;\n    this.connectionStateTtl = timeouts.connectionStateTtl;\n    this.maxIdleInterval = null;\n    this.transports = intersect(options.transports || defaults_default.defaultTransports, this.supportedTransports);\n    this.transportPreference = null;\n    if (this.transports.includes(TransportNames.WebSocket)) {\n      this.webSocketTransportAvailable = true;\n    }\n    if (this.transports.includes(TransportNames.XhrPolling)) {\n      this.baseTransport = TransportNames.XhrPolling;\n    } else if (this.transports.includes(TransportNames.Comet)) {\n      this.baseTransport = TransportNames.Comet;\n    }\n    this.domains = defaults_default.getHosts(options);\n    this.activeProtocol = null;\n    this.host = null;\n    this.lastAutoReconnectAttempt = null;\n    this.lastActivity = null;\n    this.forceFallbackHost = false;\n    this.connectCounter = 0;\n    this.wsCheckResult = null;\n    this.webSocketSlowTimer = null;\n    this.webSocketGiveUpTimer = null;\n    this.abandonedWebSocket = false;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.ConnectionManager()\", \"started\");\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"requested transports = [\" + (options.transports || defaults_default.defaultTransports) + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"available transports = [\" + this.transports + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"http domains = [\" + this.domains + \"]\"\n    );\n    if (!this.transports.length) {\n      const msg = \"no requested transports available\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"realtime.ConnectionManager()\", msg);\n      throw new Error(msg);\n    }\n    const addEventListener = Platform.Config.addEventListener;\n    if (addEventListener) {\n      if (haveSessionStorage() && typeof options.recover === \"function\") {\n        addEventListener(\"beforeunload\", this.persistConnection.bind(this));\n      }\n      if (options.closeOnUnload === true) {\n        addEventListener(\"beforeunload\", () => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"Realtime.ConnectionManager()\",\n            \"beforeunload event has triggered the connection to close as closeOnUnload is true\"\n          );\n          this.requestState({ state: \"closing\" });\n        });\n      }\n      addEventListener(\"online\", () => {\n        var _a2;\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018online\\u2019 event\",\n            \"reattempting connection\"\n          );\n          this.requestState({ state: \"connecting\" });\n        } else if (this.state == this.states.connecting) {\n          (_a2 = this.pendingTransport) == null ? void 0 : _a2.off();\n          this.disconnectAllTransports();\n          this.startConnect();\n        }\n      });\n      addEventListener(\"offline\", () => {\n        if (this.state == this.states.connected) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018offline\\u2019 event\",\n            \"disconnecting active transport\"\n          );\n          this.disconnectAllTransports();\n        }\n      });\n    }\n  }\n  /*********************\n   * transport management\n   *********************/\n  // Used by tests\n  static supportedTransports(additionalImplementations) {\n    const storage = { supportedTransports: {} };\n    this.initTransports(additionalImplementations, storage);\n    return storage.supportedTransports;\n  }\n  static initTransports(additionalImplementations, storage) {\n    const implementations = __spreadValues(__spreadValues({}, Platform.Transports.bundledImplementations), additionalImplementations);\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\n      const transport = implementations[transportName];\n      if (transport && transport.isAvailable()) {\n        storage.supportedTransports[transportName] = transport;\n      }\n    });\n  }\n  initTransports() {\n    _ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\n  }\n  createTransportParams(host, mode) {\n    return new TransportParams(this.options, host, mode, this.connectionKey);\n  }\n  getTransportParams(callback) {\n    const decideMode = (modeCb) => {\n      if (this.connectionKey) {\n        modeCb(\"resume\");\n        return;\n      }\n      if (typeof this.options.recover === \"string\") {\n        modeCb(\"recover\");\n        return;\n      }\n      const recoverFn = this.options.recover, lastSessionData = this.getSessionRecoverData(), sessionRecoveryName = this.sessionRecoveryName();\n      if (lastSessionData && typeof recoverFn === \"function\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Calling clientOptions-provided recover function with last session data (recovery scope: \" + sessionRecoveryName + \")\"\n        );\n        recoverFn(lastSessionData, (shouldRecover) => {\n          if (shouldRecover) {\n            this.options.recover = lastSessionData.recoveryKey;\n            modeCb(\"recover\");\n          } else {\n            modeCb(\"clean\");\n          }\n        });\n        return;\n      }\n      modeCb(\"clean\");\n    };\n    decideMode((mode) => {\n      const transportParams = this.createTransportParams(null, mode);\n      if (mode === \"recover\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport recovery mode = recover; recoveryKey = \" + this.options.recover\n        );\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\n        if (recoveryContext) {\n          this.msgSerial = recoveryContext.msgSerial;\n        }\n      } else {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport params = \" + transportParams.toString()\n        );\n      }\n      callback(transportParams);\n    });\n  }\n  /**\n   * Attempt to connect using a given transport\n   * @param transportParams\n   * @param candidate, the transport to try\n   * @param callback\n   */\n  tryATransport(transportParams, candidate, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.tryATransport()\", \"trying \" + candidate);\n    this.proposedTransport = transport_default.tryConnect(\n      this.supportedTransports[candidate],\n      this,\n      this.realtime.auth,\n      transportParams,\n      (wrappedErr, transport) => {\n        const state = this.state;\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\n          if (transport) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager.tryATransport()\",\n              \"connection \" + state.state + \" while we were attempting the transport; closing \" + transport\n            );\n            transport.close();\n          }\n          callback(true);\n          return;\n        }\n        if (wrappedErr) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.tryATransport()\",\n            \"transport \" + candidate + \" \" + wrappedErr.event + \", err: \" + wrappedErr.error.toString()\n          );\n          if (auth_default.isTokenErr(wrappedErr.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason))) {\n            this.errorReason = wrappedErr.error;\n            whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err) => {\n              if (err) {\n                this.actOnErrorFromAuthorize(err);\n                return;\n              }\n              this.tryATransport(transportParams, candidate, callback);\n            });\n          } else if (wrappedErr.event === \"failed\") {\n            this.notifyState({ state: \"failed\", error: wrappedErr.error });\n            callback(true);\n          } else if (wrappedErr.event === \"disconnected\") {\n            if (!isRetriable(wrappedErr.error)) {\n              this.notifyState({ state: this.states.connecting.failState, error: wrappedErr.error });\n              callback(true);\n            } else {\n              callback(false);\n            }\n          }\n          return;\n        }\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.tryATransport()\",\n          \"viable transport \" + candidate + \"; setting pending\"\n        );\n        this.setTransportPending(transport, transportParams);\n        callback(null, transport);\n      }\n    );\n  }\n  /**\n   * Called when a transport is indicated to be viable, and the ConnectionManager\n   * expects to activate this transport as soon as it is connected.\n   * @param transport\n   * @param transportParams\n   */\n  setTransportPending(transport, transportParams) {\n    const mode = transportParams.mode;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.setTransportPending()\",\n      \"transport = \" + transport + \"; mode = \" + mode\n    );\n    this.pendingTransport = transport;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    transport.once(\"connected\", (error, connectionId, connectionDetails) => {\n      this.activateTransport(error, transport, connectionId, connectionDetails);\n      if (mode === \"recover\" && this.options.recover) {\n        delete this.options.recover;\n        this.unpersistConnection();\n      }\n    });\n    const self2 = this;\n    transport.on([\"disconnected\", \"closed\", \"failed\"], function(error) {\n      self2.deactivateTransport(transport, this.event, error);\n    });\n    this.emit(\"transport.pending\", transport);\n  }\n  /**\n   * Called when a transport is connected, and the connectionmanager decides that\n   * it will now be the active transport. Returns whether or not it activated\n   * the transport (if the connection is closing/closed it will choose not to).\n   * @param transport the transport instance\n   * @param connectionId the id of the new active connection\n   * @param connectionDetails the details of the new active connection\n   */\n  activateTransport(error, transport, connectionId, connectionDetails) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"transport = \" + transport\n    );\n    if (error) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", \"error = \" + error);\n    }\n    if (connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionId =  \" + connectionId\n      );\n    }\n    if (connectionDetails) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionDetails =  \" + JSON.stringify(connectionDetails)\n      );\n    }\n    this.persistTransportPreference(transport);\n    const existingState = this.state, connectedState = this.states.connected.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"current state = \" + existingState.state\n    );\n    if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Disconnecting transport and abandoning\"\n      );\n      transport.disconnect();\n      return false;\n    }\n    delete this.pendingTransport;\n    if (!transport.isConnected) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Declining to activate transport \" + transport + \" since it appears to no longer be connected\"\n      );\n      return false;\n    }\n    const existingActiveProtocol = this.activeProtocol;\n    this.activeProtocol = new protocol_default(transport);\n    this.host = transport.params.host;\n    const connectionKey = connectionDetails.connectionKey;\n    if (connectionKey && this.connectionKey != connectionKey) {\n      this.setConnection(connectionId, connectionDetails, !!error);\n    }\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\n    Platform.Config.nextTick(() => {\n      transport.on(\n        \"connected\",\n        (connectedErr, _connectionId, connectionDetails2) => {\n          this.onConnectionDetailsUpdate(connectionDetails2, transport);\n          this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, connectedErr));\n        }\n      );\n    });\n    if (existingState.state === this.states.connected.state) {\n      if (error) {\n        this.errorReason = this.realtime.connection.errorReason = error;\n        this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, error));\n      }\n    } else {\n      this.notifyState({ state: \"connected\", error });\n      this.errorReason = this.realtime.connection.errorReason = error || null;\n    }\n    this.emit(\"transport.active\", transport);\n    if (existingActiveProtocol) {\n      if (existingActiveProtocol.messageQueue.count() > 0) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.activateTransport()\",\n          \"Previous active protocol (for transport \" + existingActiveProtocol.transport.shortName + \", new one is \" + transport.shortName + \") finishing with \" + existingActiveProtocol.messageQueue.count() + \" messages still pending\"\n        );\n      }\n      if (existingActiveProtocol.transport === transport) {\n        const msg = \"Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = \" + transport.shortName + \"; stack = \" + new Error().stack;\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", msg);\n      } else {\n        existingActiveProtocol.finish();\n      }\n    }\n    return true;\n  }\n  /**\n   * Called when a transport is no longer the active transport. This can occur\n   * in any transport connection state.\n   * @param transport\n   */\n  deactivateTransport(transport, state, error) {\n    const currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = transport === this.pendingTransport, noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"transport = \" + transport\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"state = \" + state + (wasActive ? \"; was active\" : wasPending ? \"; was pending\" : \"\") + (noTransportsScheduledForActivation ? \"\" : \"; another transport is scheduled for activation\")\n    );\n    if (error && error.message)\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"reason =  \" + error.message\n      );\n    if (wasActive) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"Getting, clearing, and requeuing \" + this.activeProtocol.messageQueue.count() + \" pending messages\"\n      );\n      this.queuePendingMessages(currentProtocol.getPendingMessages());\n      currentProtocol.clearPendingMessages();\n      this.activeProtocol = this.host = null;\n    }\n    this.emit(\"transport.inactive\", transport);\n    if (wasActive && noTransportsScheduledForActivation || wasActive && state === \"failed\" || state === \"closed\" || currentProtocol === null && wasPending) {\n      if (state === \"disconnected\" && error && error.statusCode > 500 && this.domains.length > 1) {\n        this.unpersistTransportPreference();\n        this.forceFallbackHost = true;\n        this.notifyState({ state, error, retryImmediately: true });\n        return;\n      }\n      const newConnectionState = state === \"failed\" && auth_default.isTokenErr(error) ? \"disconnected\" : state;\n      this.notifyState({ state: newConnectionState, error });\n      return;\n    }\n  }\n  /* Helper that returns true if there are no transports which are pending,\n   * have been connected, and are just waiting for onceNoPending to fire before\n   * being activated */\n  noTransportsScheduledForActivation() {\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\n  }\n  setConnection(connectionId, connectionDetails, hasConnectionError) {\n    const prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;\n    if (connIdChanged || recoverFailure) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.setConnection()\", \"Resetting msgSerial\");\n      this.msgSerial = 0;\n      this.queuedMessages.resetSendAttempted();\n    }\n    if (this.connectionId !== connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.setConnection()\",\n        \"New connectionId; reattaching any attached channels\"\n      );\n    }\n    this.realtime.connection.id = this.connectionId = connectionId;\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n  }\n  clearConnection() {\n    this.realtime.connection.id = this.connectionId = void 0;\n    this.realtime.connection.key = this.connectionKey = void 0;\n    this.msgSerial = 0;\n    this.queuedMessages.resetSendAttempted();\n    this.unpersistConnection();\n  }\n  createRecoveryKey() {\n    if (!this.connectionKey) {\n      return null;\n    }\n    return JSON.stringify({\n      connectionKey: this.connectionKey,\n      msgSerial: this.msgSerial,\n      channelSerials: this.realtime.channels.channelSerials()\n    });\n  }\n  checkConnectionStateFreshness() {\n    if (!this.lastActivity || !this.connectionId) {\n      return;\n    }\n    const sinceLast = Date.now() - this.lastActivity;\n    if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.checkConnectionStateFreshness()\",\n        \"Last known activity from realtime was \" + sinceLast + \"ms ago; discarding connection state\"\n      );\n      this.clearConnection();\n      this.states.connecting.failState = \"suspended\";\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  persistConnection() {\n    if (haveSessionStorage()) {\n      const recoveryKey = this.createRecoveryKey();\n      if (recoveryKey) {\n        this.setSessionRecoverData({\n          recoveryKey,\n          disconnectedAt: Date.now(),\n          location: globalObject2.location,\n          clientId: this.realtime.auth.clientId\n        });\n      }\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  unpersistConnection() {\n    this.clearSessionRecoverData();\n  }\n  getActiveTransportFormat() {\n    var _a2;\n    return (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport().format;\n  }\n  /*********************\n   * state management\n   *********************/\n  getError() {\n    if (this.errorReason) {\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\n      newError.cause = this.errorReason;\n      return newError;\n    }\n    return this.getStateError();\n  }\n  getStateError() {\n    var _a2, _b;\n    return (_b = (_a2 = connectionerrors_default)[this.state.state]) == null ? void 0 : _b.call(_a2);\n  }\n  activeState() {\n    return this.state.queueEvents || this.state.sendEvents;\n  }\n  enactStateChange(stateChange) {\n    const action = \"Connection state\";\n    const message = stateChange.current + (stateChange.reason ? \"; reason: \" + stateChange.reason : \"\");\n    if (stateChange.current === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.enactStateChange\",\n      \"setting new state: \" + stateChange.current + \"; reason = \" + (stateChange.reason && stateChange.reason.message)\n    );\n    const newState = this.state = this.states[stateChange.current];\n    if (stateChange.reason) {\n      this.errorReason = stateChange.reason;\n      this.realtime.connection.errorReason = stateChange.reason;\n    }\n    if (newState.terminal || newState.state === \"suspended\") {\n      this.clearConnection();\n    }\n    this.emit(\"connectionstate\", stateChange);\n  }\n  /****************************************\n   * ConnectionManager connection lifecycle\n   ****************************************/\n  startTransitionTimer(transitionState) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.startTransitionTimer()\",\n      \"transitionState: \" + transitionState.state\n    );\n    if (this.transitionTimer) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startTransitionTimer()\",\n        \"clearing already-running timer\"\n      );\n      clearTimeout(this.transitionTimer);\n    }\n    this.transitionTimer = setTimeout(() => {\n      if (this.transitionTimer) {\n        this.transitionTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager \" + transitionState.state + \" timer expired\",\n          \"requesting new state: \" + transitionState.failState\n        );\n        this.notifyState({ state: transitionState.failState });\n      }\n    }, transitionState.retryDelay);\n  }\n  cancelTransitionTimer() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.cancelTransitionTimer()\", \"\");\n    if (this.transitionTimer) {\n      clearTimeout(this.transitionTimer);\n      this.transitionTimer = null;\n    }\n  }\n  startSuspendTimer() {\n    if (this.suspendTimer)\n      return;\n    this.suspendTimer = setTimeout(() => {\n      if (this.suspendTimer) {\n        this.suspendTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager suspend timer expired\",\n          \"requesting new state: suspended\"\n        );\n        this.states.connecting.failState = \"suspended\";\n        this.notifyState({ state: \"suspended\" });\n      }\n    }, this.connectionStateTtl);\n  }\n  checkSuspendTimer(state) {\n    if (state !== \"disconnected\" && state !== \"suspended\" && state !== \"connecting\")\n      this.cancelSuspendTimer();\n  }\n  cancelSuspendTimer() {\n    this.states.connecting.failState = \"disconnected\";\n    if (this.suspendTimer) {\n      clearTimeout(this.suspendTimer);\n      this.suspendTimer = null;\n    }\n  }\n  startRetryTimer(interval) {\n    this.retryTimer = setTimeout(() => {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager retry timer expired\", \"retrying\");\n      this.retryTimer = null;\n      this.requestState({ state: \"connecting\" });\n    }, interval);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  startWebSocketSlowTimer() {\n    this.webSocketSlowTimer = setTimeout(() => {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager WebSocket slow timer\",\n        \"checking connectivity\"\n      );\n      this.checkWsConnectivity().then(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check succeeded\"\n        );\n        this.wsCheckResult = true;\n      }).catch(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check failed\"\n        );\n        this.wsCheckResult = false;\n      });\n      if (this.realtime.http.checkConnectivity) {\n        whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n          if (err || !connectivity) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MAJOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check failed\"\n            );\n            this.cancelWebSocketGiveUpTimer();\n            this.notifyState({\n              state: \"disconnected\",\n              error: new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404)\n            });\n          } else {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check succeeded\"\n            );\n          }\n        });\n      }\n    }, this.options.timeouts.webSocketSlowTimeout);\n  }\n  cancelWebSocketSlowTimer() {\n    if (this.webSocketSlowTimer) {\n      clearTimeout(this.webSocketSlowTimer);\n      this.webSocketSlowTimer = null;\n    }\n  }\n  startWebSocketGiveUpTimer(transportParams) {\n    this.webSocketGiveUpTimer = setTimeout(() => {\n      var _a2, _b;\n      if (!this.wsCheckResult) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket give up timer\",\n          \"websocket connection took more than 10s; \" + (this.baseTransport ? \"trying base transport\" : \"\")\n        );\n        if (this.baseTransport) {\n          this.abandonedWebSocket = true;\n          (_a2 = this.proposedTransport) == null ? void 0 : _a2.dispose();\n          (_b = this.pendingTransport) == null ? void 0 : _b.dispose();\n          this.connectBase(transportParams, ++this.connectCounter);\n        } else {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"ConnectionManager WebSocket give up timer\",\n            \"websocket connectivity appears to be unavailable but no other transports to try\"\n          );\n        }\n      }\n    }, this.options.timeouts.webSocketConnectTimeout);\n  }\n  cancelWebSocketGiveUpTimer() {\n    if (this.webSocketGiveUpTimer) {\n      clearTimeout(this.webSocketGiveUpTimer);\n      this.webSocketGiveUpTimer = null;\n    }\n  }\n  notifyState(indicated) {\n    var _a2, _b;\n    const state = indicated.state;\n    const retryImmediately = state === \"disconnected\" && (this.state === this.states.connected || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && auth_default.isTokenErr(indicated.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason)));\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.notifyState()\",\n      \"new state: \" + state + (retryImmediately ? \"; will retry connection immediately\" : \"\")\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.checkSuspendTimer(indicated.state);\n    if (state === \"suspended\" || state === \"connected\") {\n      this.disconnectedRetryCount = 0;\n    }\n    if (this.state.terminal)\n      return;\n    const newState = this.states[indicated.state];\n    let retryDelay = newState.retryDelay;\n    if (newState.state === \"disconnected\") {\n      this.disconnectedRetryCount++;\n      retryDelay = getRetryTime(newState.retryDelay, this.disconnectedRetryCount);\n    }\n    const change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      retryDelay,\n      indicated.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    if (retryImmediately) {\n      const autoReconnect = () => {\n        if (this.state === this.states.disconnected) {\n          this.lastAutoReconnectAttempt = Date.now();\n          this.requestState({ state: \"connecting\" });\n        }\n      };\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\n      if (sinceLast && sinceLast < 1e3) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.notifyState()\",\n          \"Last reconnect attempt was only \" + sinceLast + \"ms ago, waiting another \" + (1e3 - sinceLast) + \"ms before trying again\"\n        );\n        setTimeout(autoReconnect, 1e3 - sinceLast);\n      } else {\n        Platform.Config.nextTick(autoReconnect);\n      }\n    } else if (state === \"disconnected\" || state === \"suspended\") {\n      this.startRetryTimer(retryDelay);\n    }\n    if (state === \"disconnected\" && !retryImmediately || state === \"suspended\" || newState.terminal) {\n      Platform.Config.nextTick(() => {\n        this.disconnectAllTransports();\n      });\n    }\n    if (state == \"connected\" && !this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.notifyState()\",\n        \"Broken invariant: attempted to go into connected state, but there is no active protocol\"\n      );\n    }\n    this.enactStateChange(change);\n    if (this.state.sendEvents) {\n      this.sendQueuedMessages();\n    } else if (!this.state.queueEvents) {\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n      this.failQueuedMessages(change.reason);\n    }\n  }\n  requestState(request) {\n    var _a2, _b;\n    const state = request.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.requestState()\",\n      \"requested state: \" + state + \"; current state: \" + this.state.state\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.checkSuspendTimer(state);\n    if (state == \"connecting\" && this.state.state == \"connected\")\n      return;\n    if (state == \"closing\" && this.state.state == \"closed\")\n      return;\n    const newState = this.states[state], change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      null,\n      request.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    this.enactStateChange(change);\n    if (state == \"connecting\") {\n      Platform.Config.nextTick(() => {\n        this.startConnect();\n      });\n    }\n    if (state == \"closing\") {\n      this.closeImpl();\n    }\n  }\n  startConnect() {\n    if (this.state !== this.states.connecting) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startConnect()\",\n        \"Must be in connecting state to connect, but was \" + this.state.state\n      );\n      return;\n    }\n    const auth = this.realtime.auth;\n    const connectCount = ++this.connectCounter;\n    const connect = () => {\n      this.checkConnectionStateFreshness();\n      this.getTransportParams((transportParams) => {\n        if (transportParams.mode === \"recover\" && transportParams.options.recover) {\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n          if (recoveryContext) {\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n          }\n        }\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        this.connectImpl(transportParams, connectCount);\n      });\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.startConnect()\", \"starting connection\");\n    this.startSuspendTimer();\n    this.startTransitionTimer(this.states.connecting);\n    if (auth.method === \"basic\") {\n      connect();\n    } else {\n      const authCb = (err) => {\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        if (err) {\n          this.actOnErrorFromAuthorize(err);\n        } else {\n          connect();\n        }\n      };\n      if (this.errorReason && auth_default.isTokenErr(this.errorReason)) {\n        whenPromiseSettles(auth._forceNewToken(null, null), authCb);\n      } else {\n        whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\n      }\n    }\n  }\n  /*\n   * there are, at most, two transports available with which a connection may\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\n   * comet in nodejs). web_socket is always preferred, and the base transport is\n   * only used in case web_socket connectivity appears to be unavailable.\n   *\n   * connectImpl begins the transport selection process by checking which transports\n   * are available, and if there is a cached preference. It then defers to the\n   * transport-specific connect methods: connectWs and connectBase.\n   *\n   * It is also responsible for invalidating the cache in the case that a base\n   * transport preference is stored but web socket connectivity is now available.\n   *\n   * handling of the case where we need to failover from web_socket to the base\n   * transport is implemented in the connectWs method.\n   */\n  connectImpl(transportParams, connectCount) {\n    const state = this.state.state;\n    if (state !== this.states.connecting.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.connectImpl()\",\n        \"Must be in connecting state to connect, but was \" + state\n      );\n      return;\n    }\n    const transportPreference = this.getTransportPreference();\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\n      this.checkWsConnectivity().then(() => {\n        this.unpersistTransportPreference();\n        if (this.state === this.states.connecting) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.connectImpl():\",\n            \"web socket connectivity available, cancelling connection attempt with \" + this.baseTransport\n          );\n          this.disconnectAllTransports();\n          this.connectWs(transportParams, ++this.connectCounter);\n        }\n      }).catch(noop2);\n    }\n    if (transportPreference && transportPreference === this.baseTransport || this.baseTransport && !this.webSocketTransportAvailable) {\n      this.connectBase(transportParams, connectCount);\n    } else {\n      this.connectWs(transportParams, connectCount);\n    }\n  }\n  /*\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\n   *   connectivity check fails, we give up the connection sequence entirely and\n   *   transition to disconnected. if the websocket connectivity check fails then\n   *   we assume no ws connectivity and failover to base transport. in the case that\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\n   *   and, if unsuccessful, ultimately transition to disconnected.\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\n   *   connectivity check is still pending then we assume that there is an issue\n   *   with the transport and fallback to base transport.\n   */\n  connectWs(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectWs()\");\n    this.wsCheckResult = null;\n    this.abandonedWebSocket = false;\n    this.startWebSocketSlowTimer();\n    this.startWebSocketGiveUpTimer(transportParams);\n    this.tryTransportWithFallbacks(\"web_socket\", transportParams, true, connectCount, () => {\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\n    });\n  }\n  connectBase(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectBase()\");\n    if (this.baseTransport) {\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\n    } else {\n      this.notifyState({\n        state: \"disconnected\",\n        error: new ErrorInfo(\"No transports left to try\", 8e4, 404)\n      });\n    }\n  }\n  tryTransportWithFallbacks(transportName, transportParams, ws, connectCount, shouldContinue) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.tryTransportWithFallbacks()\",\n      transportName\n    );\n    const giveUp = (err) => {\n      this.notifyState({ state: this.states.connecting.failState, error: err });\n    };\n    const candidateHosts = this.domains.slice();\n    const hostAttemptCb = (fatal, transport) => {\n      if (connectCount !== this.connectCounter) {\n        return;\n      }\n      if (!shouldContinue()) {\n        if (transport) {\n          transport.dispose();\n        }\n        return;\n      }\n      if (!transport && !fatal) {\n        tryFallbackHosts();\n      }\n    };\n    const host = candidateHosts.shift();\n    if (!host) {\n      giveUp(new ErrorInfo(\"Unable to connect (no available host)\", 80003, 404));\n      return;\n    }\n    transportParams.host = host;\n    const tryFallbackHosts = () => {\n      if (!candidateHosts.length) {\n        giveUp(new ErrorInfo(\"Unable to connect (and no more fallback hosts to try)\", 80003, 404));\n        return;\n      }\n      if (!this.realtime.http.checkConnectivity) {\n        giveUp(new PartialErrorInfo(\"Internal error: Http.checkConnectivity not set\", null, 500));\n        return;\n      }\n      whenPromiseSettles(\n        this.realtime.http.checkConnectivity(),\n        (err, connectivity) => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (!shouldContinue()) {\n            return;\n          }\n          if (err) {\n            giveUp(err);\n            return;\n          }\n          if (!connectivity) {\n            giveUp(new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404));\n            return;\n          }\n          transportParams.host = arrPopRandomElement(candidateHosts);\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\n        }\n      );\n    };\n    if (this.forceFallbackHost && candidateHosts.length) {\n      this.forceFallbackHost = false;\n      tryFallbackHosts();\n      return;\n    }\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\n  }\n  closeImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.closeImpl()\", \"closing connection\");\n    this.cancelSuspendTimer();\n    this.startTransitionTimer(this.states.closing);\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.close();\n    }\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().close();\n    }\n    this.notifyState({ state: \"closed\" });\n  }\n  onAuthUpdated(tokenDetails, callback) {\n    var _a2;\n    switch (this.state.state) {\n      case \"connected\": {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Sending AUTH message on active transport\"\n        );\n        const activeTransport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n        if (activeTransport && activeTransport.onAuthUpdated) {\n          activeTransport.onAuthUpdated(tokenDetails);\n        }\n        const authMsg = fromValues({\n          action: actions.AUTH,\n          auth: {\n            accessToken: tokenDetails.token\n          }\n        });\n        this.send(authMsg);\n        const successListener = () => {\n          this.off(failureListener);\n          callback(null, tokenDetails);\n        };\n        const failureListener = (stateChange) => {\n          if (stateChange.current === \"failed\") {\n            this.off(successListener);\n            this.off(failureListener);\n            callback(stateChange.reason || this.getStateError());\n          }\n        };\n        this.once(\"connectiondetails\", successListener);\n        this.on(\"connectionstate\", failureListener);\n        break;\n      }\n      case \"connecting\":\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Aborting current connection attempts in order to start again with the new auth details\"\n        );\n        this.disconnectAllTransports();\n      default: {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Connection state is \" + this.state.state + \"; waiting until either connected or failed\"\n        );\n        const listener = (stateChange) => {\n          switch (stateChange.current) {\n            case \"connected\":\n              this.off(listener);\n              callback(null, tokenDetails);\n              break;\n            case \"failed\":\n            case \"closed\":\n            case \"suspended\":\n              this.off(listener);\n              callback(stateChange.reason || this.getStateError());\n              break;\n            default:\n              break;\n          }\n        };\n        this.on(\"connectionstate\", listener);\n        if (this.state.state === \"connecting\") {\n          this.startConnect();\n        } else {\n          this.requestState({ state: \"connecting\" });\n        }\n      }\n    }\n  }\n  disconnectAllTransports() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.disconnectAllTransports()\",\n      \"Disconnecting all transports\"\n    );\n    this.connectCounter++;\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.proposedTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting proposed transport: \" + this.pendingTransport\n      );\n      this.proposedTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().disconnect();\n    }\n  }\n  /******************\n   * event queueing\n   ******************/\n  send(msg, queueEvent, callback) {\n    callback = callback || noop2;\n    const state = this.state;\n    if (state.sendEvents) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", \"sending event\");\n      this.sendImpl(new PendingMessage(msg, callback));\n      return;\n    }\n    const shouldQueue = queueEvent && state.queueEvents;\n    if (!shouldQueue) {\n      const err = \"rejecting event, queueEvent was \" + queueEvent + \", state was \" + state.state;\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", err);\n      callback(this.errorReason || new ErrorInfo(err, 9e4, 400));\n      return;\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.send()\",\n        \"queueing msg; \" + stringify(\n          msg,\n          this.realtime._RealtimePresence,\n          this.realtime._Annotations,\n          this.realtime._liveObjectsPlugin\n        )\n      );\n    }\n    this.queue(msg, callback);\n  }\n  sendImpl(pendingMessage) {\n    const msg = pendingMessage.message;\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n      msg.msgSerial = this.msgSerial++;\n    }\n    try {\n      this.activeProtocol.send(pendingMessage);\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.sendImpl()\",\n        \"Unexpected exception in transport.send(): \" + e.stack\n      );\n    }\n  }\n  queue(msg, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.queue()\", \"queueing event\");\n    this.queuedMessages.push(new PendingMessage(msg, callback));\n  }\n  sendQueuedMessages() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.sendQueuedMessages()\",\n      \"sending \" + this.queuedMessages.count() + \" queued messages\"\n    );\n    let pendingMessage;\n    while (pendingMessage = this.queuedMessages.shift())\n      this.sendImpl(pendingMessage);\n  }\n  queuePendingMessages(pendingMessages) {\n    if (pendingMessages && pendingMessages.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.queuePendingMessages()\",\n        \"queueing \" + pendingMessages.length + \" pending messages\"\n      );\n      this.queuedMessages.prepend(pendingMessages);\n    }\n  }\n  failQueuedMessages(err) {\n    const numQueued = this.queuedMessages.count();\n    if (numQueued > 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.failQueuedMessages()\",\n        \"failing \" + numQueued + \" queued messages, err = \" + inspectError(err)\n      );\n      this.queuedMessages.completeAllMessages(err);\n    }\n  }\n  onChannelMessage(message, transport) {\n    this.pendingChannelMessagesState.queue.push({ message, transport });\n    if (!this.pendingChannelMessagesState.isProcessing) {\n      this.processNextPendingChannelMessage();\n    }\n  }\n  processNextPendingChannelMessage() {\n    if (this.pendingChannelMessagesState.queue.length > 0) {\n      this.pendingChannelMessagesState.isProcessing = true;\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift();\n      this.processChannelMessage(pendingChannelMessage.message).catch((err) => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.processNextPendingChannelMessage() received error \",\n          err\n        );\n      }).finally(() => {\n        this.pendingChannelMessagesState.isProcessing = false;\n        this.processNextPendingChannelMessage();\n      });\n    }\n  }\n  async processChannelMessage(message) {\n    await this.realtime.channels.processChannelMessage(message);\n  }\n  async ping() {\n    var _a2;\n    if (this.state.state !== \"connected\") {\n      throw new ErrorInfo(\"Unable to ping service; not connected\", 4e4, 400);\n    }\n    const transport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n    if (!transport) {\n      throw this.getStateError();\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.ping()\", \"transport = \" + transport);\n    const pingStart = Date.now();\n    const id = cheapRandStr();\n    return withTimeoutAsync(\n      new Promise((resolve) => {\n        const onHeartbeat = (responseId) => {\n          if (responseId === id) {\n            transport.off(\"heartbeat\", onHeartbeat);\n            resolve(Date.now() - pingStart);\n          }\n        };\n        transport.on(\"heartbeat\", onHeartbeat);\n        transport.ping(id);\n      }),\n      this.options.timeouts.realtimeRequestTimeout,\n      \"Timeout waiting for heartbeat response\"\n    );\n  }\n  abort(error) {\n    this.activeProtocol.getTransport().fail(error);\n  }\n  getTransportPreference() {\n    var _a2, _b;\n    return this.transportPreference || haveWebStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.get) == null ? void 0 : _b.call(_a2, transportPreferenceName));\n  }\n  persistTransportPreference(transport) {\n    var _a2, _b;\n    this.transportPreference = transport.shortName;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(_a2, transportPreferenceName, transport.shortName);\n    }\n  }\n  unpersistTransportPreference() {\n    var _a2, _b;\n    this.transportPreference = null;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, transportPreferenceName);\n    }\n  }\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n   * server returns 403. */\n  actOnErrorFromAuthorize(err) {\n    if (err.code === 40171) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.code === 40102) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.statusCode === HttpStatusCodes_default.Forbidden) {\n      const msg = \"Client configured authentication provider returned 403; failing the connection\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.actOnErrorFromAuthorize()\", msg);\n      this.notifyState({ state: \"failed\", error: new ErrorInfo(msg, 80019, 403, err) });\n    } else {\n      const msg = \"Client configured authentication provider request failed\";\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.actOnErrorFromAuthorize\", msg);\n      this.notifyState({ state: this.state.failState, error: new ErrorInfo(msg, 80019, 401, err) });\n    }\n  }\n  onConnectionDetailsUpdate(connectionDetails, transport) {\n    if (!connectionDetails) {\n      return;\n    }\n    this.connectionDetails = connectionDetails;\n    if (connectionDetails.maxMessageSize) {\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\n    }\n    const clientId = connectionDetails.clientId;\n    if (clientId) {\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\n      if (err) {\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.onConnectionDetailsUpdate()\", err.message);\n        transport.fail(err);\n        return;\n      }\n    }\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\n    if (connectionStateTtl) {\n      this.connectionStateTtl = connectionStateTtl;\n    }\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\n    this.emit(\"connectiondetails\", connectionDetails);\n  }\n  checkWsConnectivity() {\n    const wsConnectivityCheckUrl = this.options.wsConnectivityCheckUrl || defaults_default.wsConnectivityCheckUrl;\n    const ws = new Platform.Config.WebSocket(wsConnectivityCheckUrl);\n    return new Promise((resolve, reject) => {\n      let finished = false;\n      ws.onopen = () => {\n        if (!finished) {\n          finished = true;\n          resolve();\n          ws.close();\n        }\n      };\n      ws.onclose = ws.onerror = () => {\n        if (!finished) {\n          finished = true;\n          reject();\n        }\n      };\n    });\n  }\n  sessionRecoveryName() {\n    return this.options.recoveryKeyStorageName || \"ably-connection-recovery\";\n  }\n  getSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.getSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n  setSessionRecoverData(value) {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.setSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName(), value));\n  }\n  clearSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.removeSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n};\nvar connectionmanager_default = ConnectionManager;\n\n// src/common/lib/client/connection.ts\nvar Connection = class extends eventemitter_default {\n  constructor(ably, options) {\n    super(ably.logger);\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    this.ably = ably;\n    this.connectionManager = new connectionmanager_default(ably, options);\n    this.state = this.connectionManager.state.state;\n    this.key = void 0;\n    this.id = void 0;\n    this.errorReason = null;\n    this.connectionManager.on(\"connectionstate\", (stateChange) => {\n      const state = this.state = stateChange.current;\n      Platform.Config.nextTick(() => {\n        this.emit(state, stateChange);\n      });\n    });\n    this.connectionManager.on(\"update\", (stateChange) => {\n      Platform.Config.nextTick(() => {\n        this.emit(\"update\", stateChange);\n      });\n    });\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.connect()\", \"\");\n    this.connectionManager.requestState({ state: \"connecting\" });\n  }\n  async ping() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.ping()\", \"\");\n    return this.connectionManager.ping();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.close()\", \"connectionKey = \" + this.key);\n    this.connectionManager.requestState({ state: \"closing\" });\n  }\n  get recoveryKey() {\n    this.logger.deprecationWarning(\n      \"The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.\"\n    );\n    return this.createRecoveryKey();\n  }\n  createRecoveryKey() {\n    return this.connectionManager.createRecoveryKey();\n  }\n};\nvar connection_default = Connection;\n\n// src/common/lib/client/baserealtime.ts\nvar _BaseRealtime = class _BaseRealtime extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    var _a2, _b, _c, _d;\n    super(defaults_default.objectifyOptions(options, false, \"BaseRealtime\", logger_default.defaultLogger));\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime()\", \"\");\n    if (typeof EdgeRuntime === \"string\") {\n      throw new ErrorInfo(\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime. If you are running Vercel Edge functions, please replace your \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API instead of the Realtime API. If you are server-rendering your application in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\" to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\n        4e4,\n        400\n      );\n    }\n    this._additionalTransportImplementations = _BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\n    this._RealtimePresence = (_b = (_a2 = this.options.plugins) == null ? void 0 : _a2.RealtimePresence) != null ? _b : null;\n    this._liveObjectsPlugin = (_d = (_c = this.options.plugins) == null ? void 0 : _c.LiveObjects) != null ? _d : null;\n    this.connection = new connection_default(this, this.options);\n    this._channels = new Channels2(this);\n    if (this.options.autoConnect !== false)\n      this.connect();\n  }\n  static transportImplementationsFromPlugins(plugins) {\n    const transports = {};\n    if (plugins == null ? void 0 : plugins.WebSocketTransport) {\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\n    }\n    if (plugins == null ? void 0 : plugins.XHRPolling) {\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\n    }\n    return transports;\n  }\n  get channels() {\n    return this._channels;\n  }\n  get clientId() {\n    return this.auth.clientId;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.connect()\", \"\");\n    this.connection.connect();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.close()\", \"\");\n    this.connection.close();\n  }\n};\n// internal API to make EventEmitter usable in other SDKs\n_BaseRealtime.EventEmitter = eventemitter_default;\nvar BaseRealtime = _BaseRealtime;\nvar Channels2 = class extends eventemitter_default {\n  constructor(realtime) {\n    super(realtime.logger);\n    this.realtime = realtime;\n    this.all = /* @__PURE__ */ Object.create(null);\n    realtime.connection.connectionManager.on(\"transport.active\", () => {\n      this.onTransportActive();\n    });\n  }\n  channelSerials() {\n    let serials = {};\n    for (const name of keysArray(this.all, true)) {\n      const channel = this.all[name];\n      if (channel.properties.channelSerial) {\n        serials[name] = channel.properties.channelSerial;\n      }\n    }\n    return serials;\n  }\n  // recoverChannels gets the given channels and sets their channel serials.\n  recoverChannels(channelSerials) {\n    for (const name of keysArray(channelSerials, true)) {\n      const channel = this.get(name);\n      channel.properties.channelSerial = channelSerials[name];\n    }\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\n  async processChannelMessage(msg) {\n    const channelName = msg.channel;\n    if (channelName === void 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event unspecified channel, action = \" + msg.action\n      );\n      return;\n    }\n    const channel = this.all[channelName];\n    if (!channel) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event for non-existent channel: \" + channelName\n      );\n      return;\n    }\n    await channel.processMessage(msg);\n  }\n  /* called when a transport becomes connected; reattempt attach/detach\n   * for channels that are attaching or detaching. */\n  onTransportActive() {\n    for (const channelName in this.all) {\n      const channel = this.all[channelName];\n      if (channel.state === \"attaching\" || channel.state === \"detaching\") {\n        channel.checkPendingState();\n      } else if (channel.state === \"suspended\") {\n        channel._attach(false, null);\n      } else if (channel.state === \"attached\") {\n        channel.requestState(\"attaching\");\n      }\n    }\n  }\n  /* Connection interruptions (ie when the connection will no longer queue\n   * events) imply connection state changes for any channel which is either\n   * attached, pending, or will attempt to become attached in the future */\n  propogateConnectionInterruption(connectionState, reason) {\n    const connectionStateToChannelState = {\n      closing: \"detached\",\n      closed: \"detached\",\n      failed: \"failed\",\n      suspended: \"suspended\"\n    };\n    const fromChannelStates = [\"attaching\", \"attached\", \"detaching\", \"suspended\"];\n    const toChannelState = connectionStateToChannelState[connectionState];\n    for (const channelId in this.all) {\n      const channel = this.all[channelId];\n      if (fromChannelStates.includes(channel.state)) {\n        channel.notifyState(toChannelState, reason);\n      }\n    }\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      channel = this.all[name] = new realtimechannel_default(this.realtime, name, channelOptions);\n    } else if (channelOptions) {\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n        throw new ErrorInfo(\n          \"Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.\",\n          4e4,\n          400\n        );\n      }\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  getDerived(name, deriveOptions, channelOptions) {\n    if (deriveOptions.filter) {\n      const filter = toBase64(deriveOptions.filter);\n      const match = matchDerivedChannel(name);\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\n    }\n    return this.get(name, channelOptions);\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    name = String(name);\n    const channel = this.all[name];\n    if (!channel) {\n      return;\n    }\n    const releaseErr = channel.getReleaseErr();\n    if (releaseErr) {\n      throw releaseErr;\n    }\n    delete this.all[name];\n  }\n};\nvar baserealtime_default = BaseRealtime;\n\n// src/common/lib/client/presencemap.ts\nfunction newerThan(item, existing) {\n  if (item.isSynthesized() || existing.isSynthesized()) {\n    return item.timestamp >= existing.timestamp;\n  }\n  const itemOrderings = item.parseId(), existingOrderings = existing.parseId();\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n    return itemOrderings.index > existingOrderings.index;\n  } else {\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\n  }\n}\nvar PresenceMap = class extends eventemitter_default {\n  constructor(presence, memberKey, newer = newerThan) {\n    super(presence.logger);\n    this.presence = presence;\n    this.map = /* @__PURE__ */ Object.create(null);\n    this.syncInProgress = false;\n    this.residualMembers = null;\n    this.memberKey = memberKey;\n    this.newerThan = newer;\n  }\n  get(key) {\n    return this.map[key];\n  }\n  getClient(clientId) {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.clientId == clientId && item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  list(params) {\n    const map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action === \"absent\")\n        continue;\n      if (clientId && clientId != item.clientId)\n        continue;\n      if (connectionId && connectionId != item.connectionId)\n        continue;\n      result.push(item);\n    }\n    return result;\n  }\n  put(item) {\n    if (item.action === \"enter\" || item.action === \"update\") {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"present\";\n    }\n    const map = this.map, key = this.memberKey(item);\n    if (this.residualMembers)\n      delete this.residualMembers[key];\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    map[key] = item;\n    return true;\n  }\n  values() {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  remove(item) {\n    const map = this.map, key = this.memberKey(item);\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    if (this.syncInProgress) {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"absent\";\n      map[key] = item;\n    } else {\n      delete map[key];\n    }\n    return !!existingItem;\n  }\n  startSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.startSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!this.syncInProgress) {\n      this.residualMembers = copy(map);\n      this.setInProgress(true);\n    }\n  }\n  endSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.endSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (syncInProgress) {\n      for (const memberKey in map) {\n        const entry = map[memberKey];\n        if (entry.action === \"absent\") {\n          delete map[memberKey];\n        }\n      }\n      this.presence._synthesizeLeaves(valuesArray(this.residualMembers));\n      for (const memberKey in this.residualMembers) {\n        delete map[memberKey];\n      }\n      this.residualMembers = null;\n      this.setInProgress(false);\n    }\n    this.emit(\"sync\");\n  }\n  async waitSync() {\n    const syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.waitSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!syncInProgress) {\n      return;\n    }\n    await this.once(\"sync\");\n  }\n  clear() {\n    this.map = {};\n    this.setInProgress(false);\n    this.residualMembers = null;\n  }\n  setInProgress(inProgress) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"PresenceMap.setInProgress()\", \"inProgress = \" + inProgress);\n    this.syncInProgress = inProgress;\n    this.presence.syncComplete = !inProgress;\n  }\n};\n\n// src/common/lib/client/realtimepresence.ts\nfunction getClientId(realtimePresence) {\n  return realtimePresence.channel.client.auth.clientId;\n}\nfunction isAnonymousOrWildcard(realtimePresence) {\n  const realtime = realtimePresence.channel.client;\n  const clientId = realtime.auth.clientId;\n  return (!clientId || clientId === \"*\") && realtime.connection.state === \"connected\";\n}\nvar RealtimePresence = class extends eventemitter_default {\n  constructor(channel) {\n    super(channel.logger);\n    this.channel = channel;\n    this.syncComplete = false;\n    this.members = new PresenceMap(this, (item) => item.clientId + \":\" + item.connectionId);\n    this._myMembers = new PresenceMap(this, (item) => item.clientId);\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.pendingPresence = [];\n  }\n  async enter(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to enter a presence channel\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"enter\");\n  }\n  async update(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to update presence data\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"update\");\n  }\n  async enterClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"enter\");\n  }\n  async updateClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"update\");\n  }\n  async _enterOrUpdateClient(id, clientId, data, action) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.\" + action + \"Client()\",\n      \"channel = \" + channel.name + \", id = \" + id + \", client = \" + (clientId || \"(implicit) \" + getClientId(this))\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = action;\n    if (id) {\n      presence.id = id;\n    }\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"initialized\":\n      case \"detached\":\n        channel.attach();\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      default: {\n        const err = new PartialErrorInfo(\n          \"Unable to \" + action + \" presence channel while in \" + channel.state + \" state\",\n          90001\n        );\n        err.code = 90001;\n        throw err;\n      }\n    }\n  }\n  async leave(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must have been specified to enter or leave a presence channel\", 40012, 400);\n    }\n    return this.leaveClient(void 0, data);\n  }\n  async leaveClient(clientId, data) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.leaveClient()\",\n      \"leaving; channel = \" + this.channel.name + \", client = \" + clientId\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = \"leave\";\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      case \"initialized\":\n      case \"failed\": {\n        throw new PartialErrorInfo(\"Unable to leave presence channel (incompatible state)\", 90001);\n      }\n      default:\n        throw channel.invalidStateError();\n    }\n  }\n  async get(params) {\n    const waitForSync = !params || (\"waitForSync\" in params ? params.waitForSync : true);\n    function toMessages(members2) {\n      return params ? members2.list(params) : members2.values();\n    }\n    if (this.channel.state === \"suspended\") {\n      if (waitForSync) {\n        throw ErrorInfo.fromValues({\n          statusCode: 400,\n          code: 91005,\n          message: \"Presence state is out of sync due to channel being in the SUSPENDED state\"\n        });\n      }\n      return toMessages(this.members);\n    }\n    await this.channel.ensureAttached();\n    const members = this.members;\n    if (waitForSync) {\n      await members.waitSync();\n    }\n    return toMessages(this.members);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimePresence.history()\", \"channel = \" + this.name);\n    const restMixin = this.channel.client.rest.presenceMixin;\n    if (params && params.untilAttach) {\n      if (this.channel.state === \"attached\") {\n        delete params.untilAttach;\n        params.from_serial = this.channel.properties.attachSerial;\n      } else {\n        throw new ErrorInfo(\n          \"option untilAttach requires the channel to be attached, was: \" + this.channel.state,\n          4e4,\n          400\n        );\n      }\n    }\n    return restMixin.history(this, params);\n  }\n  setPresence(presenceSet, isSync, syncChannelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.setPresence()\",\n      \"received presence for \" + presenceSet.length + \" participants; syncChannelSerial = \" + syncChannelSerial\n    );\n    let syncCursor, match;\n    const members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;\n    if (isSync) {\n      this.members.startSync();\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n        syncCursor = match[1];\n      }\n    }\n    for (let presence of presenceSet) {\n      switch (presence.action) {\n        case \"leave\":\n          if (members.remove(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\n            myMembers.remove(presence);\n          }\n          break;\n        case \"enter\":\n        case \"present\":\n        case \"update\":\n          if (members.put(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId) {\n            myMembers.put(presence);\n          }\n          break;\n      }\n    }\n    if (isSync && !syncCursor) {\n      members.endSync();\n      this.channel.syncChannelSerial = null;\n    }\n    for (let i = 0; i < broadcastMessages.length; i++) {\n      const presence = broadcastMessages[i];\n      this.subscriptions.emit(presence.action, presence);\n    }\n  }\n  onAttached(hasPresence) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimePresence.onAttached()\",\n      \"channel = \" + this.channel.name + \", hasPresence = \" + hasPresence\n    );\n    if (hasPresence) {\n      this.members.startSync();\n    } else {\n      this._synthesizeLeaves(this.members.values());\n      this.members.clear();\n    }\n    this._ensureMyMembersPresent();\n    const pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;\n    if (pendingPresCount) {\n      this.pendingPresence = [];\n      const presenceArray = [];\n      const multicaster = multicaster_default.create(this.logger);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence.onAttached\",\n        \"sending \" + pendingPresCount + \" queued presence messages\"\n      );\n      for (let i = 0; i < pendingPresCount; i++) {\n        const event = pendingPresence[i];\n        presenceArray.push(event.presence);\n        multicaster.push(event.callback);\n      }\n      this.channel.sendPresence(presenceArray).then(() => multicaster()).catch((err) => multicaster(err));\n    }\n  }\n  actOnChannelState(state, hasPresence, err) {\n    switch (state) {\n      case \"attached\":\n        this.onAttached(hasPresence);\n        break;\n      case \"detached\":\n      case \"failed\":\n        this._clearMyMembers();\n        this.members.clear();\n      case \"suspended\":\n        this.failPendingPresence(err);\n        break;\n    }\n  }\n  failPendingPresence(err) {\n    if (this.pendingPresence.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.failPendingPresence\",\n        \"channel; name = \" + this.channel.name + \", err = \" + inspectError(err)\n      );\n      for (let i = 0; i < this.pendingPresence.length; i++)\n        try {\n          this.pendingPresence[i].callback(err);\n        } catch (e) {\n        }\n      this.pendingPresence = [];\n    }\n  }\n  _clearMyMembers() {\n    this._myMembers.clear();\n  }\n  _ensureMyMembersPresent() {\n    const myMembers = this._myMembers;\n    const connId = this.channel.connectionManager.connectionId;\n    for (const memberKey in myMembers.map) {\n      const entry = myMembers.map[memberKey];\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence._ensureMyMembersPresent()\",\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set'\n      );\n      const id = entry.connectionId === connId ? entry.id : void 0;\n      this._enterOrUpdateClient(id, entry.clientId, entry.data, \"enter\").catch((err) => {\n        const wrappedErr = new ErrorInfo(\"Presence auto re-enter failed\", 91004, 400, err);\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"RealtimePresence._ensureMyMembersPresent()\",\n          \"Presence auto re-enter failed; reason = \" + inspectError(err)\n        );\n        const change = new channelstatechange_default(this.channel.state, this.channel.state, true, false, wrappedErr);\n        this.channel.emit(\"update\", change);\n      });\n    }\n  }\n  _synthesizeLeaves(items) {\n    const subscriptions = this.subscriptions;\n    items.forEach(function(item) {\n      const presence = presencemessage_default.fromValues({\n        action: \"leave\",\n        connectionId: item.connectionId,\n        clientId: item.clientId,\n        data: item.data,\n        encoding: item.encoding,\n        timestamp: Date.now()\n      });\n      subscriptions.emit(\"leave\", presence);\n    });\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n};\nvar realtimepresence_default = RealtimePresence;\n\n// src/common/lib/transport/websockettransport.ts\nvar shortName = TransportNames.WebSocket;\nfunction isNodeWebSocket(ws) {\n  return !!ws.on;\n}\nvar WebSocketTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName;\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\n    this.wsHost = params.host;\n  }\n  static isAvailable() {\n    return !!Platform.Config.WebSocket;\n  }\n  createWebSocket(uri, connectParams) {\n    this.uri = uri + toQueryString(connectParams);\n    return new Platform.Config.WebSocket(this.uri);\n  }\n  toString() {\n    return \"WebSocketTransport; uri=\" + this.uri;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const self2 = this, params = this.params, options = params.options;\n    const wsScheme = options.tls ? \"wss://\" : \"ws://\";\n    const wsUri = wsScheme + this.wsHost + \":\" + defaults_default.getPort(options) + \"/\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"uri: \" + wsUri);\n    whenPromiseSettles(\n      this.auth.getAuthParams(),\n      function(err, authParams) {\n        if (self2.isDisposed) {\n          return;\n        }\n        let paramStr = \"\";\n        for (const param in authParams)\n          paramStr += \" \" + param + \": \" + authParams[param] + \";\";\n        logger_default.logAction(\n          self2.logger,\n          logger_default.LOG_MINOR,\n          \"WebSocketTransport.connect()\",\n          \"authParams:\" + paramStr + \" err: \" + err\n        );\n        if (err) {\n          self2.disconnect(err);\n          return;\n        }\n        const connectParams = params.getConnectParams(authParams);\n        try {\n          const wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);\n          wsConnection.binaryType = Platform.Config.binaryType;\n          wsConnection.onopen = function() {\n            self2.onWsOpen();\n          };\n          wsConnection.onclose = function(ev) {\n            self2.onWsClose(ev);\n          };\n          wsConnection.onmessage = function(ev) {\n            self2.onWsData(ev.data);\n          };\n          wsConnection.onerror = function(ev) {\n            self2.onWsError(ev);\n          };\n          if (isNodeWebSocket(wsConnection)) {\n            wsConnection.on(\"ping\", function() {\n              self2.onActivity();\n            });\n          }\n        } catch (e) {\n          logger_default.logAction(\n            self2.logger,\n            logger_default.LOG_ERROR,\n            \"WebSocketTransport.connect()\",\n            \"Unexpected exception creating websocket: err = \" + (e.stack || e.message)\n          );\n          self2.disconnect(e);\n        }\n      }\n    );\n  }\n  send(message) {\n    const wsConnection = this.wsConnection;\n    if (!wsConnection) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", \"No socket connection\");\n      return;\n    }\n    try {\n      wsConnection.send(\n        serialize2(message, this.connectionManager.realtime._MsgPack, this.params.format)\n      );\n    } catch (e) {\n      const msg = \"Exception from ws connection when trying to send: \" + inspectError(e);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", msg);\n      this.finish(\"disconnected\", new ErrorInfo(msg, 5e4, 500));\n    }\n  }\n  onWsData(data) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"WebSocketTransport.onWsData()\",\n      \"data received; length = \" + data.length + \"; type = \" + typeof data\n    );\n    try {\n      this.onProtocolMessage(\n        deserialize(\n          data,\n          this.connectionManager.realtime._MsgPack,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations,\n          this.connectionManager.realtime._liveObjectsPlugin,\n          this.format\n        )\n      );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"WebSocketTransport.onWsData()\",\n        \"Unexpected exception handing channel message: \" + e.stack\n      );\n    }\n  }\n  onWsOpen() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsOpen()\", \"opened WebSocket\");\n    this.emit(\"preconnect\");\n  }\n  onWsClose(ev) {\n    let wasClean, code;\n    if (typeof ev == \"object\") {\n      code = ev.code;\n      wasClean = ev.wasClean || code === 1e3;\n    } else {\n      code = ev;\n      wasClean = code == 1e3;\n    }\n    delete this.wsConnection;\n    if (wasClean) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", \"Cleanly closed WebSocket\");\n      const err = new ErrorInfo(\"Websocket closed\", 80003, 400);\n      this.finish(\"disconnected\", err);\n    } else {\n      const msg = \"Unclean disconnection of WebSocket ; code = \" + code, err = new ErrorInfo(msg, 80003, 400);\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", msg);\n      this.finish(\"disconnected\", err);\n    }\n    this.emit(\"disposed\");\n  }\n  onWsError(err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"WebSocketTransport.onError()\",\n      \"Error from WebSocket: \" + err.message\n    );\n    Platform.Config.nextTick(() => {\n      this.disconnect(Error(err.message));\n    });\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.dispose()\", \"\");\n    this.isDisposed = true;\n    const wsConnection = this.wsConnection;\n    if (wsConnection) {\n      wsConnection.onmessage = function() {\n      };\n      delete this.wsConnection;\n      Platform.Config.nextTick(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"WebSocketTransport.dispose()\", \"closing websocket\");\n        if (!wsConnection) {\n          throw new Error(\"WebSocketTransport.dispose(): wsConnection is not defined\");\n        }\n        wsConnection.close();\n      });\n    }\n  }\n};\nvar websockettransport_default = WebSocketTransport;\n\n// src/common/lib/client/filteredsubscriptions.ts\nvar FilteredSubscriptions = class {\n  static subscribeFilter(channel, filter, listener) {\n    const filteredListener = (m) => {\n      var _a2, _b, _c, _d, _e, _f;\n      const mapping = {\n        name: m.name,\n        refTimeserial: (_b = (_a2 = m.extras) == null ? void 0 : _a2.ref) == null ? void 0 : _b.timeserial,\n        refType: (_d = (_c = m.extras) == null ? void 0 : _c.ref) == null ? void 0 : _d.type,\n        isRef: !!((_f = (_e = m.extras) == null ? void 0 : _e.ref) == null ? void 0 : _f.timeserial),\n        clientId: m.clientId\n      };\n      if (Object.entries(filter).find(\n        ([key, value]) => value !== void 0 ? mapping[key] !== value : false\n      )) {\n        return;\n      }\n      listener(m);\n    };\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\n    channel.subscriptions.on(filteredListener);\n  }\n  // Adds a new filtered subscription\n  static addFilteredSubscription(channel, filter, realListener, filteredListener) {\n    var _a2;\n    if (!channel.filteredSubscriptions) {\n      channel.filteredSubscriptions = /* @__PURE__ */ new Map();\n    }\n    if (channel.filteredSubscriptions.has(realListener)) {\n      const realListenerMap = channel.filteredSubscriptions.get(realListener);\n      realListenerMap.set(filter, ((_a2 = realListenerMap == null ? void 0 : realListenerMap.get(filter)) == null ? void 0 : _a2.concat(filteredListener)) || [filteredListener]);\n    } else {\n      channel.filteredSubscriptions.set(\n        realListener,\n        /* @__PURE__ */ new Map([[filter, [filteredListener]]])\n      );\n    }\n  }\n  static getAndDeleteFilteredSubscriptions(channel, filter, realListener) {\n    if (!channel.filteredSubscriptions) {\n      return [];\n    }\n    if (!realListener && filter) {\n      return Array.from(channel.filteredSubscriptions.entries()).map(([key, filterMaps]) => {\n        var _a2;\n        let listenerMaps = filterMaps.get(filter);\n        filterMaps.delete(filter);\n        if (filterMaps.size === 0) {\n          (_a2 = channel.filteredSubscriptions) == null ? void 0 : _a2.delete(key);\n        }\n        return listenerMaps;\n      }).reduce(\n        (prev, cur) => cur ? prev.concat(...cur) : prev,\n        []\n      );\n    }\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\n      return [];\n    }\n    const realListenerMap = channel.filteredSubscriptions.get(realListener);\n    if (!filter) {\n      const listeners2 = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\n      channel.filteredSubscriptions.delete(realListener);\n      return listeners2;\n    }\n    let listeners = realListenerMap.get(filter);\n    realListenerMap.delete(filter);\n    return listeners || [];\n  }\n};\n\n// src/common/lib/client/defaultrealtime.ts\nvar _DefaultRealtime = class _DefaultRealtime extends baserealtime_default {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2;\n    const MsgPack = _DefaultRealtime._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRealtime._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Realtime\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRealtime.Crypto) != null ? _a2 : void 0,\n        MsgPack,\n        RealtimePresence: {\n          RealtimePresence: realtimepresence_default,\n          PresenceMessage: presencemessage_default,\n          WirePresenceMessage\n        },\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        },\n        WebSocketTransport: websockettransport_default,\n        MessageInteractions: FilteredSubscriptions\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRealtime.Utils = utils_exports;\n_DefaultRealtime.ConnectionManager = connectionmanager_default;\n_DefaultRealtime.ProtocolMessage = protocolmessage_default;\n_DefaultRealtime._Crypto = null;\n_DefaultRealtime.Message = DefaultMessage;\n_DefaultRealtime.PresenceMessage = DefaultPresenceMessage;\n_DefaultRealtime.Annotation = DefaultAnnotation;\n_DefaultRealtime._MsgPack = null;\n// Used by tests\n_DefaultRealtime._Http = Http;\n_DefaultRealtime._PresenceMap = PresenceMap;\n_DefaultRealtime._MessageEncoding = MessageEncoding;\nvar DefaultRealtime = _DefaultRealtime;\n\n// src/platform/web/lib/util/hmac-sha256.ts\nvar uint8Array = Uint8Array;\nvar uint32Array = Uint32Array;\nvar pow = Math.pow;\nvar DEFAULT_STATE = new uint32Array(8);\nvar ROUND_CONSTANTS = [];\nvar M = new uint32Array(64);\nfunction getFractionalBits(n2) {\n  return (n2 - (n2 | 0)) * pow(2, 32) | 0;\n}\nvar n = 2;\nvar nPrime = 0;\nwhile (nPrime < 64) {\n  isPrime = true;\n  for (factor = 2; factor <= n / 2; factor++) {\n    if (n % factor === 0) {\n      isPrime = false;\n    }\n  }\n  if (isPrime) {\n    if (nPrime < 8) {\n      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));\n    }\n    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));\n    nPrime++;\n  }\n  n++;\n}\nvar isPrime;\nvar factor;\nvar LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];\nfunction convertEndian(word) {\n  if (LittleEndian) {\n    return (\n      // byte 1 -> byte 4\n      word >>> 24 | // byte 2 -> byte 3\n      (word >>> 16 & 255) << 8 | // byte 3 -> byte 2\n      (word & 65280) << 8 | // byte 4 -> byte 1\n      word << 24\n    );\n  } else {\n    return word;\n  }\n}\nfunction rightRotate(word, bits) {\n  return word >>> bits | word << 32 - bits;\n}\nfunction sha256(data) {\n  var STATE = DEFAULT_STATE.slice();\n  var legth = data.length;\n  var bitLength = legth * 8;\n  var newBitLength = 512 - (bitLength + 64) % 512 - 1 + bitLength + 65;\n  var bytes = new uint8Array(newBitLength / 8);\n  var words = new uint32Array(bytes.buffer);\n  bytes.set(data, 0);\n  bytes[legth] = 128;\n  words[words.length - 1] = convertEndian(bitLength);\n  var round;\n  for (var block = 0; block < newBitLength / 32; block += 16) {\n    var workingState = STATE.slice();\n    for (round = 0; round < 64; round++) {\n      var MRound;\n      if (round < 16) {\n        MRound = convertEndian(words[block + round]);\n      } else {\n        var gamma0x = M[round - 15];\n        var gamma1x = M[round - 2];\n        MRound = M[round - 7] + M[round - 16] + (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ gamma0x >>> 3) + (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ gamma1x >>> 10);\n      }\n      M[round] = MRound |= 0;\n      var t1 = (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) + (workingState[4] & workingState[5] ^ ~workingState[4] & workingState[6]) + workingState[7] + MRound + ROUND_CONSTANTS[round];\n      var t2 = (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) + (workingState[0] & workingState[1] ^ workingState[2] & (workingState[0] ^ workingState[1]));\n      for (var i = 7; i > 0; i--) {\n        workingState[i] = workingState[i - 1];\n      }\n      workingState[0] = t1 + t2 | 0;\n      workingState[4] = workingState[4] + t1 | 0;\n    }\n    for (round = 0; round < 8; round++) {\n      STATE[round] = STATE[round] + workingState[round] | 0;\n    }\n  }\n  return new uint8Array(\n    new uint32Array(\n      STATE.map(function(val) {\n        return convertEndian(val);\n      })\n    ).buffer\n  );\n}\nfunction hmac2(key, data) {\n  if (key.length > 64)\n    key = sha256(key);\n  if (key.length < 64) {\n    const tmp = new Uint8Array(64);\n    tmp.set(key, 0);\n    key = tmp;\n  }\n  var innerKey = new Uint8Array(64);\n  var outerKey = new Uint8Array(64);\n  for (var i = 0; i < 64; i++) {\n    innerKey[i] = 54 ^ key[i];\n    outerKey[i] = 92 ^ key[i];\n  }\n  var msg = new Uint8Array(data.length + 64);\n  msg.set(innerKey, 0);\n  msg.set(data, 64);\n  var result = new Uint8Array(64 + 32);\n  result.set(outerKey, 0);\n  result.set(sha256(msg), 64);\n  return sha256(result);\n}\n\n// src/platform/web/lib/util/bufferutils.ts\nvar BufferUtils = class {\n  constructor() {\n    this.base64CharSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    this.hexCharSet = \"0123456789abcdef\";\n  }\n  // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\n  uint8ViewToBase64(bytes) {\n    let base64 = \"\";\n    const encodings = this.base64CharSet;\n    const byteLength = bytes.byteLength;\n    const byteRemainder = byteLength % 3;\n    const mainLength = byteLength - byteRemainder;\n    let a, b, c, d;\n    let chunk;\n    for (let i = 0; i < mainLength; i = i + 3) {\n      chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];\n      a = (chunk & 16515072) >> 18;\n      b = (chunk & 258048) >> 12;\n      c = (chunk & 4032) >> 6;\n      d = chunk & 63;\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n    }\n    if (byteRemainder == 1) {\n      chunk = bytes[mainLength];\n      a = (chunk & 252) >> 2;\n      b = (chunk & 3) << 4;\n      base64 += encodings[a] + encodings[b] + \"==\";\n    } else if (byteRemainder == 2) {\n      chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];\n      a = (chunk & 64512) >> 10;\n      b = (chunk & 1008) >> 4;\n      c = (chunk & 15) << 2;\n      base64 += encodings[a] + encodings[b] + encodings[c] + \"=\";\n    }\n    return base64;\n  }\n  base64ToArrayBuffer(base64) {\n    const binary_string = atob == null ? void 0 : atob(base64);\n    const len = binary_string.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      const ascii = binary_string.charCodeAt(i);\n      bytes[i] = ascii;\n    }\n    return this.toArrayBuffer(bytes);\n  }\n  isBuffer(buffer) {\n    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n  }\n  toBuffer(buffer) {\n    if (!ArrayBuffer) {\n      throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return new Uint8Array(buffer);\n    }\n    if (ArrayBuffer.isView(buffer)) {\n      return new Uint8Array(this.toArrayBuffer(buffer));\n    }\n    throw new Error(\"BufferUtils.toBuffer expected an ArrayBuffer or a view onto one\");\n  }\n  toArrayBuffer(buffer) {\n    if (!ArrayBuffer) {\n      throw new Error(\"Can't convert to ArrayBuffer: browser does not support the necessary types\");\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return buffer;\n    }\n    if (ArrayBuffer.isView(buffer)) {\n      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n    }\n    throw new Error(\"BufferUtils.toArrayBuffer expected an ArrayBuffer or a view onto one\");\n  }\n  base64Encode(buffer) {\n    return this.uint8ViewToBase64(this.toBuffer(buffer));\n  }\n  base64UrlEncode(buffer) {\n    return this.base64Encode(buffer).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n  }\n  base64Decode(str) {\n    if (ArrayBuffer && Platform.Config.atob) {\n      return this.base64ToArrayBuffer(str);\n    } else {\n      throw new Error(\"Expected ArrayBuffer to exist and Platform.Config.atob to be configured\");\n    }\n  }\n  hexEncode(buffer) {\n    const uint8Array2 = this.toBuffer(buffer);\n    return uint8Array2.reduce((accum, byte) => accum + byte.toString(16).padStart(2, \"0\"), \"\");\n  }\n  hexDecode(hexEncodedBytes) {\n    if (hexEncodedBytes.length % 2 !== 0) {\n      throw new Error(\"Can't create a byte array from a hex string of odd length\");\n    }\n    const uint8Array2 = new Uint8Array(hexEncodedBytes.length / 2);\n    for (let i = 0; i < uint8Array2.length; i++) {\n      uint8Array2[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);\n    }\n    return this.toArrayBuffer(uint8Array2);\n  }\n  utf8Encode(string) {\n    if (Platform.Config.TextEncoder) {\n      const encodedByteArray = new Platform.Config.TextEncoder().encode(string);\n      return this.toArrayBuffer(encodedByteArray);\n    } else {\n      throw new Error(\"Expected TextEncoder to be configured\");\n    }\n  }\n  /* For utf8 decoding we apply slightly stricter input validation than to\n   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\n   * can take (in particular allowing strings, which are just interpreted as\n   * binary); here we ensure that the input is actually a buffer since trying\n   * to utf8-decode a string to another string is almost certainly a mistake */\n  utf8Decode(buffer) {\n    if (!this.isBuffer(buffer)) {\n      throw new Error(\"Expected input of utf8decode to be an arraybuffer or typed array\");\n    }\n    if (TextDecoder) {\n      return new TextDecoder().decode(buffer);\n    } else {\n      throw new Error(\"Expected TextDecoder to be configured\");\n    }\n  }\n  areBuffersEqual(buffer1, buffer2) {\n    if (!buffer1 || !buffer2)\n      return false;\n    const arrayBuffer1 = this.toArrayBuffer(buffer1);\n    const arrayBuffer2 = this.toArrayBuffer(buffer2);\n    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength)\n      return false;\n    const bytes1 = new Uint8Array(arrayBuffer1);\n    const bytes2 = new Uint8Array(arrayBuffer2);\n    for (var i = 0; i < bytes1.length; i++) {\n      if (bytes1[i] != bytes2[i])\n        return false;\n    }\n    return true;\n  }\n  byteLength(buffer) {\n    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {\n      return buffer.byteLength;\n    }\n    return -1;\n  }\n  arrayBufferViewToBuffer(arrayBufferView) {\n    return this.toArrayBuffer(arrayBufferView);\n  }\n  concat(buffers) {\n    const sumLength = buffers.reduce((acc, v) => acc + v.byteLength, 0);\n    const result = new Uint8Array(sumLength);\n    let offset = 0;\n    for (const buffer of buffers) {\n      const uint8Array2 = this.toBuffer(buffer);\n      result.set(uint8Array2, offset);\n      offset += uint8Array2.byteLength;\n    }\n    return result.buffer;\n  }\n  sha256(message) {\n    const hash = sha256(this.toBuffer(message));\n    return this.toArrayBuffer(hash);\n  }\n  hmacSha256(message, key) {\n    const hash = hmac2(this.toBuffer(key), this.toBuffer(message));\n    return this.toArrayBuffer(hash);\n  }\n};\nvar bufferutils_default = new BufferUtils();\n\n// src/platform/web/lib/util/crypto.ts\nvar createCryptoClass = function(config, bufferUtils) {\n  var DEFAULT_ALGORITHM = \"aes\";\n  var DEFAULT_KEYLENGTH = 256;\n  var DEFAULT_MODE = \"cbc\";\n  var DEFAULT_BLOCKLENGTH = 16;\n  function validateCipherParams(params) {\n    if (params.algorithm === \"aes\" && params.mode === \"cbc\") {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        \"Unsupported key length \" + params.keyLength + \" for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)\"\n      );\n    }\n  }\n  function normaliseBase64(string) {\n    return string.replace(\"_\", \"/\").replace(\"-\", \"+\");\n  }\n  function isCipherParams(params) {\n    return params instanceof CipherParams;\n  }\n  class CipherParams {\n    constructor(algorithm, keyLength, mode, key) {\n      this.algorithm = algorithm;\n      this.keyLength = keyLength;\n      this.mode = mode;\n      this.key = key;\n    }\n  }\n  class Crypto2 {\n    /**\n     * Obtain a complete CipherParams instance from the provided params, filling\n     * in any not provided with default values, calculating a keyLength from\n     * the supplied key, and validating the result.\n     * @param params an object containing at a minimum a `key` key with value the\n     * key, as either a binary or a base64-encoded string.\n     * May optionally also contain: algorithm (defaults to AES),\n     * mode (defaults to 'cbc')\n     */\n    static getDefaultParams(params) {\n      var key;\n      if (!params.key) {\n        throw new Error(\"Crypto.getDefaultParams: a key is required\");\n      }\n      if (typeof params.key === \"string\") {\n        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));\n      } else if (params.key instanceof ArrayBuffer) {\n        key = params.key;\n      } else {\n        key = bufferUtils.toArrayBuffer(params.key);\n      }\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n      var keyLength = key.byteLength * 8;\n      var mode = params.mode || DEFAULT_MODE;\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n        throw new Error(\n          \"Crypto.getDefaultParams: a keyLength of \" + params.keyLength + \" was specified, but the key actually has length \" + cipherParams.keyLength\n        );\n      }\n      validateCipherParams(cipherParams);\n      return cipherParams;\n    }\n    /**\n     * Generate a random encryption key from the supplied keylength (or the\n     * default keyLength if none supplied) as an ArrayBuffer\n     * @param keyLength (optional) the required keyLength in bits\n     */\n    static async generateRandomKey(keyLength) {\n      try {\n        return config.getRandomArrayBuffer((keyLength || DEFAULT_KEYLENGTH) / 8);\n      } catch (err) {\n        throw new ErrorInfo(\"Failed to generate random key: \" + err.message, 400, 5e4, err);\n      }\n    }\n    /**\n     * Internal; get a ChannelCipher instance based on the given cipherParams\n     * @param params either a CipherParams instance or some subset of its\n     * fields that includes a key\n     */\n    static getCipher(params, logger) {\n      var _a2;\n      var cipherParams = isCipherParams(params) ? params : this.getDefaultParams(params);\n      return {\n        cipherParams,\n        cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null, logger)\n      };\n    }\n  }\n  Crypto2.CipherParams = CipherParams;\n  Crypto2;\n  class CBCCipher {\n    constructor(params, iv, logger) {\n      this.logger = logger;\n      if (!crypto.subtle) {\n        if (isSecureContext) {\n          throw new Error(\n            \"Crypto operations are not possible since the browser\\u2019s SubtleCrypto class is unavailable (reason unknown).\"\n          );\n        } else {\n          throw new Error(\n            \"Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\\u2019s SubtleCrypto class is not available.\"\n          );\n        }\n      }\n      this.algorithm = params.algorithm + \"-\" + String(params.keyLength) + \"-\" + params.mode;\n      this.webCryptoAlgorithm = params.algorithm + \"-\" + params.mode;\n      this.key = bufferUtils.toArrayBuffer(params.key);\n      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;\n    }\n    concat(buffer1, buffer2) {\n      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);\n      const outputView = new DataView(output);\n      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));\n      for (let i = 0; i < buffer1View.byteLength; i++) {\n        outputView.setInt8(i, buffer1View.getInt8(i));\n      }\n      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));\n      for (let i = 0; i < buffer2View.byteLength; i++) {\n        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));\n      }\n      return output;\n    }\n    async encrypt(plaintext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.encrypt()\", \"\");\n      const iv = await this.getIv();\n      const cryptoKey = await crypto.subtle.importKey(\"raw\", this.key, this.webCryptoAlgorithm, false, [\"encrypt\"]);\n      const ciphertext = await crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);\n      return this.concat(iv, ciphertext);\n    }\n    async decrypt(ciphertext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.decrypt()\", \"\");\n      const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);\n      const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);\n      const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);\n      const cryptoKey = await crypto.subtle.importKey(\"raw\", this.key, this.webCryptoAlgorithm, false, [\"decrypt\"]);\n      return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);\n    }\n    async getIv() {\n      if (this.iv) {\n        var iv = this.iv;\n        this.iv = null;\n        return iv;\n      }\n      const randomBlock = await config.getRandomArrayBuffer(DEFAULT_BLOCKLENGTH);\n      return bufferUtils.toArrayBuffer(randomBlock);\n    }\n  }\n  return Crypto2;\n};\n\n// src/common/constants/XHRStates.ts\nvar XHRStates = /* @__PURE__ */ ((XHRStates2) => {\n  XHRStates2[XHRStates2[\"REQ_SEND\"] = 0] = \"REQ_SEND\";\n  XHRStates2[XHRStates2[\"REQ_RECV\"] = 1] = \"REQ_RECV\";\n  XHRStates2[XHRStates2[\"REQ_RECV_POLL\"] = 2] = \"REQ_RECV_POLL\";\n  XHRStates2[XHRStates2[\"REQ_RECV_STREAM\"] = 3] = \"REQ_RECV_STREAM\";\n  return XHRStates2;\n})(XHRStates || {});\nvar XHRStates_default = XHRStates;\n\n// src/platform/web/lib/http/http.ts\nfunction createMissingImplementationError() {\n  return new ErrorInfo(\n    \"No HTTP request plugin provided. Provide at least one of the FetchRequest or XHRRequest plugins.\",\n    400,\n    4e4\n  );\n}\nvar _a;\nvar Http2 = (_a = class {\n  constructor(client) {\n    this.checksInProgress = null;\n    this.checkConnectivity = void 0;\n    this.supportsAuthHeaders = false;\n    this.supportsLinkHeaders = false;\n    var _a2;\n    this.client = client != null ? client : null;\n    const connectivityCheckUrl = (client == null ? void 0 : client.options.connectivityCheckUrl) || defaults_default.connectivityCheckUrl;\n    const connectivityCheckParams = (_a2 = client == null ? void 0 : client.options.connectivityCheckParams) != null ? _a2 : null;\n    const connectivityUrlIsDefault = !(client == null ? void 0 : client.options.connectivityCheckUrl);\n    const requestImplementations = __spreadValues(__spreadValues({}, Http2.bundledRequestImplementations), client == null ? void 0 : client._additionalHTTPRequestImplementations);\n    const xhrRequestImplementation = requestImplementations.XHRRequest;\n    const fetchRequestImplementation = requestImplementations.FetchRequest;\n    const hasImplementation = !!(xhrRequestImplementation || fetchRequestImplementation);\n    if (!hasImplementation) {\n      throw createMissingImplementationError();\n    }\n    if (Platform.Config.xhrSupported && xhrRequestImplementation) {\n      this.supportsAuthHeaders = true;\n      this.Request = async function(method, uri, headers, params, body) {\n        return new Promise((resolve) => {\n          var _a3;\n          const req = xhrRequestImplementation.createRequest(\n            uri,\n            headers,\n            params,\n            body,\n            XHRStates_default.REQ_SEND,\n            (_a3 = client && client.options.timeouts) != null ? _a3 : null,\n            this.logger,\n            method\n          );\n          req.once(\n            \"complete\",\n            (error, body2, headers2, unpacked, statusCode) => resolve({ error, body: body2, headers: headers2, unpacked, statusCode })\n          );\n          req.exec();\n        });\n      };\n      if (client == null ? void 0 : client.options.disableConnectivityCheck) {\n        this.checkConnectivity = async function() {\n          return true;\n        };\n      } else {\n        this.checkConnectivity = async function() {\n          var _a3;\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MICRO,\n            \"(XHRRequest)Http.checkConnectivity()\",\n            \"Sending; \" + connectivityCheckUrl\n          );\n          const requestResult = await this.doUri(\n            HttpMethods_default.Get,\n            connectivityCheckUrl,\n            null,\n            null,\n            connectivityCheckParams\n          );\n          let result = false;\n          if (!connectivityUrlIsDefault) {\n            result = !requestResult.error && isSuccessCode(requestResult.statusCode);\n          } else {\n            result = !requestResult.error && ((_a3 = requestResult.body) == null ? void 0 : _a3.replace(/\\n/, \"\")) == \"yes\";\n          }\n          logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"(XHRRequest)Http.checkConnectivity()\", \"Result: \" + result);\n          return result;\n        };\n      }\n    } else if (Platform.Config.fetchSupported && fetchRequestImplementation) {\n      this.supportsAuthHeaders = true;\n      this.Request = async (method, uri, headers, params, body) => {\n        return fetchRequestImplementation(method, client != null ? client : null, uri, headers, params, body);\n      };\n      if (client == null ? void 0 : client.options.disableConnectivityCheck) {\n        this.checkConnectivity = async function() {\n          return true;\n        };\n      } else {\n        this.checkConnectivity = async function() {\n          var _a3;\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MICRO,\n            \"(Fetch)Http.checkConnectivity()\",\n            \"Sending; \" + connectivityCheckUrl\n          );\n          const requestResult = await this.doUri(HttpMethods_default.Get, connectivityCheckUrl, null, null, null);\n          const result = !requestResult.error && ((_a3 = requestResult.body) == null ? void 0 : _a3.replace(/\\n/, \"\")) == \"yes\";\n          logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"(Fetch)Http.checkConnectivity()\", \"Result: \" + result);\n          return result;\n        };\n      }\n    } else {\n      this.Request = async () => {\n        const error = hasImplementation ? new PartialErrorInfo(\"no supported HTTP transports available\", null, 400) : createMissingImplementationError();\n        return { error };\n      };\n    }\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  async doUri(method, uri, headers, body, params) {\n    if (!this.Request) {\n      return { error: new PartialErrorInfo(\"Request invoked before assigned to\", null, 500) };\n    }\n    return this.Request(method, uri, headers, params, body);\n  }\n  shouldFallback(errorInfo) {\n    const statusCode = errorInfo.statusCode;\n    return statusCode === 408 && !errorInfo.code || statusCode === 400 && !errorInfo.code || statusCode >= 500 && statusCode <= 504;\n  }\n}, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);\nvar http_default = Http2;\n\n// src/platform/web/lib/util/webstorage.ts\nvar test = \"ablyjs-storage-test\";\nvar globalObject3 = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : self;\nvar Webstorage = class {\n  constructor() {\n    try {\n      globalObject3.sessionStorage.setItem(test, test);\n      globalObject3.sessionStorage.removeItem(test);\n      this.sessionSupported = true;\n    } catch (e) {\n      this.sessionSupported = false;\n    }\n    try {\n      globalObject3.localStorage.setItem(test, test);\n      globalObject3.localStorage.removeItem(test);\n      this.localSupported = true;\n    } catch (e) {\n      this.localSupported = false;\n    }\n  }\n  get(name) {\n    return this._get(name, false);\n  }\n  getSession(name) {\n    return this._get(name, true);\n  }\n  remove(name) {\n    return this._remove(name, false);\n  }\n  removeSession(name) {\n    return this._remove(name, true);\n  }\n  set(name, value, ttl) {\n    return this._set(name, value, ttl, false);\n  }\n  setSession(name, value, ttl) {\n    return this._set(name, value, ttl, true);\n  }\n  _set(name, value, ttl, session) {\n    const wrappedValue = { value };\n    if (ttl) {\n      wrappedValue.expires = Date.now() + ttl;\n    }\n    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\n  }\n  _get(name, session) {\n    if (session && !this.sessionSupported)\n      throw new Error(\"Session Storage not supported\");\n    if (!session && !this.localSupported)\n      throw new Error(\"Local Storage not supported\");\n    const rawItem = this.storageInterface(session).getItem(name);\n    if (!rawItem)\n      return null;\n    const wrappedValue = JSON.parse(rawItem);\n    if (wrappedValue.expires && wrappedValue.expires < Date.now()) {\n      this.storageInterface(session).removeItem(name);\n      return null;\n    }\n    return wrappedValue.value;\n  }\n  _remove(name, session) {\n    return this.storageInterface(session).removeItem(name);\n  }\n  storageInterface(session) {\n    return session ? globalObject3.sessionStorage : globalObject3.localStorage;\n  }\n};\nvar webstorage_default = new Webstorage();\n\n// src/platform/web/config.ts\nvar globalObject4 = getGlobalObject();\nvar isVercelEdgeRuntime = typeof EdgeRuntime === \"string\";\nif (typeof Window === \"undefined\" && typeof WorkerGlobalScope === \"undefined\" && !isVercelEdgeRuntime) {\n  console.log(\n    \"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\"\n  );\n}\nfunction allowComet() {\n  const loc = globalObject4.location;\n  return !globalObject4.WebSocket || !loc || !loc.origin || loc.origin.indexOf(\"http\") > -1;\n}\nfunction isWebWorkerContext() {\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n    return true;\n  } else {\n    return false;\n  }\n}\nvar userAgent = globalObject4.navigator && globalObject4.navigator.userAgent.toString();\nvar currentUrl = globalObject4.location && globalObject4.location.href;\nvar Config = {\n  agent: \"browser\",\n  logTimestamps: true,\n  userAgent,\n  currentUrl,\n  binaryType: \"arraybuffer\",\n  WebSocket: globalObject4.WebSocket,\n  fetchSupported: !!globalObject4.fetch,\n  xhrSupported: globalObject4.XMLHttpRequest && \"withCredentials\" in new XMLHttpRequest(),\n  allowComet: allowComet(),\n  useProtocolHeartbeats: true,\n  supportsBinary: !!globalObject4.TextDecoder,\n  /* Per Paddy (https://ably-real-time.slack.com/archives/CURL4U2FP/p1705674537763479) web intentionally prefers JSON to MessagePack:\n   *\n   * > browsers' support for binary types in general was historically poor, and JSON transport performance is significantly better in a browser than msgpack. In modern browsers then binary is supported consistently, but I'd still expect that JSON encode/decode performance is dramatically better than msgpack in a browser.\n   */\n  preferBinary: false,\n  ArrayBuffer: globalObject4.ArrayBuffer,\n  atob: globalObject4.atob,\n  nextTick: typeof globalObject4.queueMicrotask === \"function\" ? (f) => globalObject4.queueMicrotask(f) : (f) => Promise.resolve().then(f),\n  addEventListener: globalObject4.addEventListener,\n  inspect: JSON.stringify,\n  stringByteSize: function(str) {\n    return globalObject4.TextDecoder && new globalObject4.TextEncoder().encode(str).length || str.length;\n  },\n  TextEncoder: globalObject4.TextEncoder,\n  TextDecoder: globalObject4.TextDecoder,\n  getRandomArrayBuffer: async function(byteLength) {\n    const byteArray = new Uint8Array(byteLength);\n    globalObject4.crypto.getRandomValues(byteArray);\n    return byteArray.buffer;\n  },\n  isWebworker: isWebWorkerContext(),\n  push: {\n    platform: \"browser\" /* Browser */,\n    formFactor: \"desktop\" /* Desktop */,\n    storage: webstorage_default\n  }\n};\nvar config_default = Config;\n\n// src/common/lib/transport/comettransport.ts\nfunction shouldBeErrorAction(err) {\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n  if (err.code) {\n    if (auth_default.isTokenErr(err))\n      return false;\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code))\n      return true;\n    return err.code >= 4e4 && err.code < 5e4;\n  } else {\n    return false;\n  }\n}\nfunction protocolMessageFromRawError(err) {\n  if (shouldBeErrorAction(err)) {\n    return [fromValues({ action: actions.ERROR, error: err })];\n  } else {\n    return [fromValues({ action: actions.DISCONNECTED, error: err })];\n  }\n}\nvar CometTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(\n      connectionManager,\n      auth,\n      params,\n      /* binary not supported for comet so force JSON protocol */\n      true\n    );\n    /* Historical comment, back from when we supported JSONP:\n     *\n     * > For comet, we could do the auth update by aborting the current recv and\n     * > starting a new one with the new token, that'd be sufficient for realtime.\n     * > Problem is JSONP - you can't cancel truly abort a recv once started. So\n     * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\n     * > comet transports the same and do it for all of them. So we send the AUTH\n     * > instead, and don't need to abort the recv\n     *\n     * Now that weâ€™ve dropped JSONP support, we may be able to revisit the above;\n     * see https://github.com/ably/ably-js/issues/1214.\n     */\n    this.onAuthUpdated = (tokenDetails) => {\n      this.authParams = { access_token: tokenDetails.token };\n    };\n    this.stream = \"stream\" in params ? params.stream : true;\n    this.sendRequest = null;\n    this.recvRequest = null;\n    this.pendingCallback = null;\n    this.pendingItems = null;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const params = this.params;\n    const options = params.options;\n    const host = params.host || options.primaryDomain;\n    const port = defaults_default.getPort(options);\n    const cometScheme = options.tls ? \"https://\" : \"http://\";\n    this.baseUri = cometScheme + host + \":\" + port + \"/comet/\";\n    const connectUri = this.baseUri + \"connect\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"uri: \" + connectUri);\n    whenPromiseSettles(this.auth.getAuthParams(), (err, authParams) => {\n      if (err) {\n        this.disconnect(err);\n        return;\n      }\n      if (this.isDisposed) {\n        return;\n      }\n      this.authParams = authParams;\n      const connectParams = this.params.getConnectParams(authParams);\n      if (\"stream\" in connectParams)\n        this.stream = connectParams.stream;\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"CometTransport.connect()\",\n        \"connectParams:\" + toQueryString(connectParams)\n      );\n      let preconnected = false;\n      const connectRequest = this.recvRequest = this.createRequest(\n        connectUri,\n        null,\n        connectParams,\n        null,\n        this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV\n      );\n      connectRequest.on(\"data\", (data) => {\n        if (!this.recvRequest) {\n          return;\n        }\n        if (!preconnected) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onData(data);\n      });\n      connectRequest.on(\"complete\", (err2) => {\n        if (!this.recvRequest) {\n          err2 = err2 || new ErrorInfo(\"Request cancelled\", 80003, 400);\n        }\n        this.recvRequest = null;\n        if (!preconnected && !err2) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onActivity();\n        if (err2) {\n          if (err2.code) {\n            this.onData(protocolMessageFromRawError(err2));\n          } else {\n            this.disconnect(err2);\n          }\n          return;\n        }\n        Platform.Config.nextTick(() => {\n          this.recv();\n        });\n      });\n      connectRequest.exec();\n    });\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestClose()\");\n    this._requestCloseOrDisconnect(true);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestDisconnect()\");\n    this._requestCloseOrDisconnect(false);\n  }\n  _requestCloseOrDisconnect(closing) {\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n    if (closeOrDisconnectUri) {\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_default.REQ_SEND);\n      request.on(\"complete\", (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"CometTransport.request\" + (closing ? \"Close()\" : \"Disconnect()\"),\n            \"request returned err = \" + inspectError(err)\n          );\n          this.finish(\"disconnected\", err);\n        }\n      });\n      request.exec();\n    }\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"\");\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      if (this.recvRequest) {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"aborting recv request\");\n        this.recvRequest.abort();\n        this.recvRequest = null;\n      }\n      this.finish(\"disconnected\", connectionerrors_default.disconnected());\n      Platform.Config.nextTick(() => {\n        this.emit(\"disposed\");\n      });\n    }\n  }\n  onConnect(message) {\n    var _a2;\n    if (this.isDisposed) {\n      return;\n    }\n    const connectionStr = (_a2 = message.connectionDetails) == null ? void 0 : _a2.connectionKey;\n    transport_default.prototype.onConnect.call(this, message);\n    const baseConnectionUri = this.baseUri + connectionStr;\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CometTransport.onConnect()\", \"baseUri = \" + baseConnectionUri);\n    this.sendUri = baseConnectionUri + \"/send\";\n    this.recvUri = baseConnectionUri + \"/recv\";\n    this.closeUri = baseConnectionUri + \"/close\";\n    this.disconnectUri = baseConnectionUri + \"/disconnect\";\n  }\n  send(message) {\n    if (this.sendRequest) {\n      this.pendingItems = this.pendingItems || [];\n      this.pendingItems.push(message);\n      return;\n    }\n    const pendingItems = this.pendingItems || [];\n    pendingItems.push(message);\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendAnyPending() {\n    const pendingItems = this.pendingItems;\n    if (!pendingItems) {\n      return;\n    }\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendItems(items) {\n    const sendRequest = this.sendRequest = this.createRequest(\n      this.sendUri,\n      null,\n      this.authParams,\n      this.encodeRequest(items),\n      XHRStates_default.REQ_SEND\n    );\n    sendRequest.on(\"complete\", (err, data) => {\n      if (err)\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"CometTransport.sendItems()\",\n          \"on complete: err = \" + inspectError(err)\n        );\n      this.sendRequest = null;\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      if (data) {\n        this.onData(data);\n      }\n      if (this.pendingItems) {\n        Platform.Config.nextTick(() => {\n          if (!this.sendRequest) {\n            this.sendAnyPending();\n          }\n        });\n      }\n    });\n    sendRequest.exec();\n  }\n  recv() {\n    if (this.recvRequest)\n      return;\n    if (!this.isConnected)\n      return;\n    const recvRequest = this.recvRequest = this.createRequest(\n      this.recvUri,\n      null,\n      this.authParams,\n      null,\n      this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV_POLL\n    );\n    recvRequest.on(\"data\", (data) => {\n      this.onData(data);\n    });\n    recvRequest.on(\"complete\", (err) => {\n      this.recvRequest = null;\n      this.onActivity();\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      Platform.Config.nextTick(() => {\n        this.recv();\n      });\n    });\n    recvRequest.exec();\n  }\n  onData(responseData) {\n    try {\n      const items = this.decodeResponse(responseData);\n      if (items && items.length)\n        for (let i = 0; i < items.length; i++)\n          this.onProtocolMessage(\n            fromDeserialized(\n              items[i],\n              this.connectionManager.realtime._RealtimePresence,\n              this.connectionManager.realtime._Annotations,\n              this.connectionManager.realtime._liveObjectsPlugin\n            )\n          );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"CometTransport.onData()\",\n        \"Unexpected exception handing channel event: \" + e.stack\n      );\n    }\n  }\n  encodeRequest(requestItems) {\n    return JSON.stringify(requestItems);\n  }\n  decodeResponse(responseData) {\n    if (typeof responseData == \"string\")\n      return JSON.parse(responseData);\n    return responseData;\n  }\n};\nvar comettransport_default = CometTransport;\n\n// src/platform/web/lib/http/request/xhrrequest.ts\nfunction isAblyError(responseBody, headers) {\n  return allToLowerCase(keysArray(headers)).includes(\"x-ably-errorcode\");\n}\nfunction getAblyError(responseBody, headers) {\n  if (isAblyError(responseBody, headers)) {\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n  }\n}\nvar noop3 = function() {\n};\nvar idCounter = 0;\nvar pendingRequests = {};\nfunction getHeader(xhr, header) {\n  return xhr.getResponseHeader && xhr.getResponseHeader(header);\n}\nfunction isEncodingChunked(xhr) {\n  return xhr.getResponseHeader && (xhr.getResponseHeader(\"transfer-encoding\") || !xhr.getResponseHeader(\"content-length\"));\n}\nfunction getHeadersAsObject(xhr) {\n  const headerPairs = xhr.getAllResponseHeaders().trim().split(\"\\r\\n\");\n  const headers = {};\n  for (let i = 0; i < headerPairs.length; i++) {\n    const parts = headerPairs[i].split(\":\").map((x) => x.trim());\n    headers[parts[0].toLowerCase()] = parts[1];\n  }\n  return headers;\n}\nvar XHRRequest = class _XHRRequest extends eventemitter_default {\n  constructor(uri, headers, params, body, requestMode, timeouts, logger, method) {\n    super(logger);\n    params = params || {};\n    params.rnd = cheapRandStr();\n    this.uri = uri + toQueryString(params);\n    this.headers = headers || {};\n    this.body = body;\n    this.method = method ? method.toUpperCase() : isNil(body) ? \"GET\" : \"POST\";\n    this.requestMode = requestMode;\n    this.timeouts = timeouts;\n    this.timedOut = false;\n    this.requestComplete = false;\n    this.id = String(++idCounter);\n    pendingRequests[this.id] = this;\n  }\n  static createRequest(uri, headers, params, body, requestMode, timeouts, logger, method) {\n    const _timeouts = timeouts || defaults_default.TIMEOUTS;\n    return new _XHRRequest(\n      uri,\n      headers,\n      copy(params),\n      body,\n      requestMode,\n      _timeouts,\n      logger,\n      method\n    );\n  }\n  complete(err, body, headers, unpacked, statusCode) {\n    if (!this.requestComplete) {\n      this.requestComplete = true;\n      if (!err && body) {\n        this.emit(\"data\", body);\n      }\n      this.emit(\"complete\", err, body, headers, unpacked, statusCode);\n      this.dispose();\n    }\n  }\n  abort() {\n    this.dispose();\n  }\n  exec() {\n    let headers = this.headers;\n    const timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, timer = this.timer = setTimeout(() => {\n      this.timedOut = true;\n      xhr.abort();\n    }, timeout), method = this.method, xhr = this.xhr = new XMLHttpRequest(), accept = headers[\"accept\"];\n    let body = this.body;\n    let responseType = \"text\";\n    if (!accept) {\n      headers[\"accept\"] = \"application/json\";\n    } else if (accept.indexOf(\"application/x-msgpack\") === 0) {\n      responseType = \"arraybuffer\";\n    }\n    if (body) {\n      const contentType = headers[\"content-type\"] || (headers[\"content-type\"] = \"application/json\");\n      if (contentType.indexOf(\"application/json\") > -1 && typeof body != \"string\")\n        body = JSON.stringify(body);\n    }\n    xhr.open(method, this.uri, true);\n    xhr.responseType = responseType;\n    if (\"authorization\" in headers) {\n      xhr.withCredentials = true;\n    }\n    for (const h in headers)\n      xhr.setRequestHeader(h, headers[h]);\n    const errorHandler = (errorEvent, message, code, statusCode2) => {\n      var _a2;\n      let errorMessage = message + \" (event type: \" + errorEvent.type + \")\";\n      if ((_a2 = this == null ? void 0 : this.xhr) == null ? void 0 : _a2.statusText)\n        errorMessage += \", current statusText is \" + this.xhr.statusText;\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Request.on\" + errorEvent.type + \"()\", errorMessage);\n      this.complete(new PartialErrorInfo(errorMessage, code, statusCode2));\n    };\n    xhr.onerror = (errorEvent) => {\n      errorHandler(errorEvent, \"XHR error occurred\", null, 400);\n    };\n    xhr.onabort = (errorEvent) => {\n      if (this.timedOut) {\n        errorHandler(errorEvent, \"Request aborted due to request timeout expiring\", null, 408);\n      } else {\n        errorHandler(errorEvent, \"Request cancelled\", null, 400);\n      }\n    };\n    xhr.ontimeout = (errorEvent) => {\n      errorHandler(errorEvent, \"Request timed out\", null, 408);\n    };\n    let streaming;\n    let statusCode;\n    let successResponse;\n    let streamPos = 0;\n    let unpacked = false;\n    const onResponse = () => {\n      clearTimeout(timer);\n      successResponse = statusCode < 400;\n      if (statusCode == 204) {\n        this.complete(null, null, null, null, statusCode);\n        return;\n      }\n      streaming = this.requestMode == XHRStates_default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\n    };\n    const onEnd = () => {\n      let parsedResponse;\n      try {\n        const contentType = getHeader(xhr, \"content-type\");\n        const json = contentType ? contentType.indexOf(\"application/json\") >= 0 : xhr.responseType == \"text\";\n        if (json) {\n          const jsonResponseBody = xhr.responseType === \"arraybuffer\" ? Platform.BufferUtils.utf8Decode(xhr.response) : String(xhr.responseText);\n          if (jsonResponseBody.length) {\n            parsedResponse = JSON.parse(jsonResponseBody);\n          } else {\n            parsedResponse = jsonResponseBody;\n          }\n          unpacked = true;\n        } else {\n          parsedResponse = xhr.response;\n        }\n        if (parsedResponse.response !== void 0) {\n          statusCode = parsedResponse.statusCode;\n          successResponse = statusCode < 400;\n          headers = parsedResponse.headers;\n          parsedResponse = parsedResponse.response;\n        } else {\n          headers = getHeadersAsObject(xhr);\n        }\n      } catch (e) {\n        this.complete(new PartialErrorInfo(\"Malformed response body from server: \" + e.message, null, 400));\n        return;\n      }\n      if (successResponse || Array.isArray(parsedResponse)) {\n        this.complete(null, parsedResponse, headers, unpacked, statusCode);\n        return;\n      }\n      let err = getAblyError(parsedResponse, headers);\n      if (!err) {\n        err = new PartialErrorInfo(\n          \"Error response received from server: \" + statusCode + \" body was: \" + Platform.Config.inspect(parsedResponse),\n          null,\n          statusCode\n        );\n      }\n      this.complete(err, parsedResponse, headers, unpacked, statusCode);\n    };\n    function onProgress() {\n      const responseText = xhr.responseText;\n      const bodyEnd = responseText.length - 1;\n      let idx, chunk;\n      while (streamPos < bodyEnd && (idx = responseText.indexOf(\"\\n\", streamPos)) > -1) {\n        chunk = responseText.slice(streamPos, idx);\n        streamPos = idx + 1;\n        onChunk(chunk);\n      }\n    }\n    const onChunk = (chunk) => {\n      try {\n        chunk = JSON.parse(chunk);\n      } catch (e) {\n        this.complete(new PartialErrorInfo(\"Malformed response body from server: \" + e.message, null, 400));\n        return;\n      }\n      this.emit(\"data\", chunk);\n    };\n    const onStreamEnd = () => {\n      onProgress();\n      this.streamComplete = true;\n      Platform.Config.nextTick(() => {\n        this.complete();\n      });\n    };\n    xhr.onreadystatechange = () => {\n      const readyState = xhr.readyState;\n      if (readyState < 3)\n        return;\n      if (xhr.status !== 0) {\n        if (statusCode === void 0) {\n          statusCode = xhr.status;\n          onResponse();\n        }\n        if (readyState == 3 && streaming) {\n          onProgress();\n        } else if (readyState == 4) {\n          if (streaming)\n            onStreamEnd();\n          else\n            onEnd();\n        }\n      }\n    };\n    xhr.send(body);\n  }\n  dispose() {\n    const xhr = this.xhr;\n    if (xhr) {\n      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop3;\n      this.xhr = null;\n      const timer = this.timer;\n      if (timer) {\n        clearTimeout(timer);\n        this.timer = null;\n      }\n      if (!this.requestComplete)\n        xhr.abort();\n    }\n    delete pendingRequests[this.id];\n  }\n};\nvar xhrrequest_default = XHRRequest;\n\n// src/platform/web/lib/transport/xhrpollingtransport.ts\nvar shortName2 = TransportNames.XhrPolling;\nvar XHRPollingTransport = class extends comettransport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName2;\n    params.stream = false;\n    this.shortName = shortName2;\n  }\n  static isAvailable() {\n    return !!(Platform.Config.xhrSupported && Platform.Config.allowComet);\n  }\n  toString() {\n    return \"XHRPollingTransport; uri=\" + this.baseUri + \"; isConnected=\" + this.isConnected;\n  }\n  createRequest(uri, headers, params, body, requestMode) {\n    return xhrrequest_default.createRequest(uri, headers, params, body, requestMode, this.timeouts, this.logger);\n  }\n};\nvar xhrpollingtransport_default = XHRPollingTransport;\n\n// src/platform/web/lib/transport/index.ts\nvar order = [\"xhr_polling\"];\nvar defaultTransports = {\n  order,\n  bundledImplementations: {\n    web_socket: websockettransport_default,\n    xhr_polling: xhrpollingtransport_default\n  }\n};\nvar transport_default2 = defaultTransports;\n\n// src/platform/web/lib/util/defaults.ts\nvar Defaults2 = {\n  connectivityCheckUrl: \"https://internet-up.ably-realtime.com/is-the-internet-up.txt\",\n  wsConnectivityCheckUrl: \"wss://ws-up.ably-realtime.com\",\n  /* Order matters here: the base transport is the leftmost one in the\n   * intersection of baseTransportOrder and the transports clientOption that's\n   * supported. */\n  defaultTransports: [TransportNames.XhrPolling, TransportNames.WebSocket]\n};\nvar defaults_default2 = Defaults2;\n\n// src/platform/web/lib/util/msgpack.ts\nfunction inspect(buffer) {\n  if (buffer === void 0)\n    return \"undefined\";\n  let view;\n  let type;\n  if (buffer instanceof ArrayBuffer) {\n    type = \"ArrayBuffer\";\n    view = new DataView(buffer);\n  } else if (buffer instanceof DataView) {\n    type = \"DataView\";\n    view = buffer;\n  }\n  if (!view)\n    return JSON.stringify(buffer);\n  const bytes = [];\n  for (let i = 0; i < buffer.byteLength; i++) {\n    if (i > 20) {\n      bytes.push(\"...\");\n      break;\n    }\n    let byte_ = view.getUint8(i).toString(16);\n    if (byte_.length === 1)\n      byte_ = \"0\" + byte_;\n    bytes.push(byte_);\n  }\n  return \"<\" + type + \" \" + bytes.join(\" \") + \">\";\n}\nfunction utf8Write(view, offset, string) {\n  const encoder = new TextEncoder();\n  const encoded = encoder.encode(string);\n  for (let i = 0; i < encoded.length; i++) {\n    view.setUint8(offset + i, encoded[i]);\n  }\n}\nfunction utf8Read(view, offset, length) {\n  const decoder = new TextDecoder();\n  return decoder.decode(view.buffer.slice(offset, offset + length));\n}\nfunction utf8ByteCount(string) {\n  const encoder = new TextEncoder();\n  return encoder.encode(string).length;\n}\nfunction encode2(value, sparse) {\n  const size = sizeof(value, sparse);\n  if (size === 0)\n    return void 0;\n  const buffer = new ArrayBuffer(size);\n  const view = new DataView(buffer);\n  _encode(value, view, 0, sparse);\n  return buffer;\n}\nvar SH_L_32 = (1 << 16) * (1 << 16);\nvar SH_R_32 = 1 / SH_L_32;\nfunction getInt64(view, offset) {\n  offset = offset || 0;\n  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\nfunction getUint64(view, offset) {\n  offset = offset || 0;\n  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\nfunction setInt64(view, offset, val) {\n  if (val < 9223372036854776e3) {\n    view.setInt32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 2147483647);\n    view.setUint32(offset + 4, 2147483647);\n  }\n}\nfunction setUint64(view, offset, val) {\n  if (val < 18446744073709552e3) {\n    view.setUint32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 4294967295);\n    view.setUint32(offset + 4, 4294967295);\n  }\n}\nvar Decoder = class {\n  constructor(view, offset) {\n    this.map = (length) => {\n      const value = {};\n      for (let i = 0; i < length; i++) {\n        const key = this.parse();\n        value[key] = this.parse();\n      }\n      return value;\n    };\n    this.bin = (length) => {\n      const value = new ArrayBuffer(length);\n      new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\n      this.offset += length;\n      return value;\n    };\n    this.buf = this.bin;\n    this.str = (length) => {\n      const value = utf8Read(this.view, this.offset, length);\n      this.offset += length;\n      return value;\n    };\n    this.array = (length) => {\n      const value = new Array(length);\n      for (let i = 0; i < length; i++) {\n        value[i] = this.parse();\n      }\n      return value;\n    };\n    this.ext = (length) => {\n      this.offset += length;\n      return {\n        type: this.view.getInt8(this.offset),\n        data: this.buf(length)\n      };\n    };\n    this.parse = () => {\n      const type = this.view.getUint8(this.offset);\n      let value, length;\n      if ((type & 128) === 0) {\n        this.offset++;\n        return type;\n      }\n      if ((type & 240) === 128) {\n        length = type & 15;\n        this.offset++;\n        return this.map(length);\n      }\n      if ((type & 240) === 144) {\n        length = type & 15;\n        this.offset++;\n        return this.array(length);\n      }\n      if ((type & 224) === 160) {\n        length = type & 31;\n        this.offset++;\n        return this.str(length);\n      }\n      if ((type & 224) === 224) {\n        value = this.view.getInt8(this.offset);\n        this.offset++;\n        return value;\n      }\n      switch (type) {\n        case 192:\n          this.offset++;\n          return null;\n        case 193:\n          this.offset++;\n          return void 0;\n        case 194:\n          this.offset++;\n          return false;\n        case 195:\n          this.offset++;\n          return true;\n        case 196:\n          length = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return this.bin(length);\n        case 197:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.bin(length);\n        case 198:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.bin(length);\n        case 199:\n          length = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return this.ext(length);\n        case 200:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.ext(length);\n        case 201:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.ext(length);\n        case 202:\n          value = this.view.getFloat32(this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 203:\n          value = this.view.getFloat64(this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 204:\n          value = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 205:\n          value = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 206:\n          value = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 207:\n          value = getUint64(this.view, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 208:\n          value = this.view.getInt8(this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 209:\n          value = this.view.getInt16(this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 210:\n          value = this.view.getInt32(this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 211:\n          value = getInt64(this.view, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 212:\n          length = 1;\n          this.offset++;\n          return this.ext(length);\n        case 213:\n          length = 2;\n          this.offset++;\n          return this.ext(length);\n        case 214:\n          length = 4;\n          this.offset++;\n          return this.ext(length);\n        case 215:\n          length = 8;\n          this.offset++;\n          return this.ext(length);\n        case 216:\n          length = 16;\n          this.offset++;\n          return this.ext(length);\n        case 217:\n          length = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return this.str(length);\n        case 218:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.str(length);\n        case 219:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.str(length);\n        case 220:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.array(length);\n        case 221:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.array(length);\n        case 222:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.map(length);\n        case 223:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.map(length);\n      }\n      throw new Error(\"Unknown type 0x\" + type.toString(16));\n    };\n    this.offset = offset || 0;\n    this.view = view;\n  }\n};\nfunction decode2(buffer) {\n  const view = new DataView(buffer);\n  const decoder = new Decoder(view);\n  const value = decoder.parse();\n  if (decoder.offset !== buffer.byteLength)\n    throw new Error(buffer.byteLength - decoder.offset + \" trailing bytes\");\n  return value;\n}\nfunction encodeableKeys(value, sparse) {\n  return Object.keys(value).filter(function(e) {\n    const val = value[e], type = typeof val;\n    return (!sparse || val !== void 0 && val !== null) && (\"function\" !== type || !!val.toJSON);\n  });\n}\nfunction _encode(value, view, offset, sparse) {\n  const type = typeof value;\n  if (typeof value === \"string\") {\n    const length = utf8ByteCount(value);\n    if (length < 32) {\n      view.setUint8(offset, length | 160);\n      utf8Write(view, offset + 1, value);\n      return 1 + length;\n    }\n    if (length < 256) {\n      view.setUint8(offset, 217);\n      view.setUint8(offset + 1, length);\n      utf8Write(view, offset + 2, value);\n      return 2 + length;\n    }\n    if (length < 65536) {\n      view.setUint8(offset, 218);\n      view.setUint16(offset + 1, length);\n      utf8Write(view, offset + 3, value);\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      view.setUint8(offset, 219);\n      view.setUint32(offset + 1, length);\n      utf8Write(view, offset + 5, value);\n      return 5 + length;\n    }\n  }\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    value = value.buffer;\n  }\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n    if (length < 256) {\n      view.setUint8(offset, 196);\n      view.setUint8(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\n      return 2 + length;\n    }\n    if (length < 65536) {\n      view.setUint8(offset, 197);\n      view.setUint16(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      view.setUint8(offset, 198);\n      view.setUint32(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\n      return 5 + length;\n    }\n  }\n  if (typeof value === \"number\") {\n    if (Math.floor(value) !== value) {\n      view.setUint8(offset, 203);\n      view.setFloat64(offset + 1, value);\n      return 9;\n    }\n    if (value >= 0) {\n      if (value < 128) {\n        view.setUint8(offset, value);\n        return 1;\n      }\n      if (value < 256) {\n        view.setUint8(offset, 204);\n        view.setUint8(offset + 1, value);\n        return 2;\n      }\n      if (value < 65536) {\n        view.setUint8(offset, 205);\n        view.setUint16(offset + 1, value);\n        return 3;\n      }\n      if (value < 4294967296) {\n        view.setUint8(offset, 206);\n        view.setUint32(offset + 1, value);\n        return 5;\n      }\n      if (value < 18446744073709552e3) {\n        view.setUint8(offset, 207);\n        setUint64(view, offset + 1, value);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    if (value >= -32) {\n      view.setInt8(offset, value);\n      return 1;\n    }\n    if (value >= -128) {\n      view.setUint8(offset, 208);\n      view.setInt8(offset + 1, value);\n      return 2;\n    }\n    if (value >= -32768) {\n      view.setUint8(offset, 209);\n      view.setInt16(offset + 1, value);\n      return 3;\n    }\n    if (value >= -2147483648) {\n      view.setUint8(offset, 210);\n      view.setInt32(offset + 1, value);\n      return 5;\n    }\n    if (value >= -9223372036854776e3) {\n      view.setUint8(offset, 211);\n      setInt64(view, offset + 1, value);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + (-value).toString(16).substr(1));\n  }\n  if (type === \"undefined\") {\n    if (sparse)\n      return 0;\n    view.setUint8(offset, 212);\n    view.setUint8(offset + 1, 0);\n    view.setUint8(offset + 2, 0);\n    return 3;\n  }\n  if (value === null) {\n    if (sparse)\n      return 0;\n    view.setUint8(offset, 192);\n    return 1;\n  }\n  if (type === \"boolean\") {\n    view.setUint8(offset, value ? 195 : 194);\n    return 1;\n  }\n  if (\"function\" === typeof value.toJSON)\n    return _encode(value.toJSON(), view, offset, sparse);\n  if (type === \"object\") {\n    let length, size = 0;\n    let keys;\n    const isArray = Array.isArray(value);\n    if (isArray) {\n      length = value.length;\n    } else {\n      keys = encodeableKeys(value, sparse);\n      length = keys.length;\n    }\n    if (length < 16) {\n      view.setUint8(offset, length | (isArray ? 144 : 128));\n      size = 1;\n    } else if (length < 65536) {\n      view.setUint8(offset, isArray ? 220 : 222);\n      view.setUint16(offset + 1, length);\n      size = 3;\n    } else if (length < 4294967296) {\n      view.setUint8(offset, isArray ? 221 : 223);\n      view.setUint32(offset + 1, length);\n      size = 5;\n    }\n    if (isArray) {\n      for (let i = 0; i < length; i++) {\n        size += _encode(value[i], view, offset + size, sparse);\n      }\n    } else if (keys) {\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += _encode(key, view, offset + size);\n        size += _encode(value[key], view, offset + size, sparse);\n      }\n    }\n    return size;\n  }\n  if (type === \"function\")\n    return 0;\n  throw new Error(\"Unknown type \" + type);\n}\nfunction sizeof(value, sparse) {\n  const type = typeof value;\n  if (type === \"string\") {\n    const length = utf8ByteCount(value);\n    if (length < 32) {\n      return 1 + length;\n    }\n    if (length < 256) {\n      return 2 + length;\n    }\n    if (length < 65536) {\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      return 5 + length;\n    }\n  }\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    value = value.buffer;\n  }\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n    if (length < 256) {\n      return 2 + length;\n    }\n    if (length < 65536) {\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      return 5 + length;\n    }\n  }\n  if (typeof value === \"number\") {\n    if (Math.floor(value) !== value)\n      return 9;\n    if (value >= 0) {\n      if (value < 128)\n        return 1;\n      if (value < 256)\n        return 2;\n      if (value < 65536)\n        return 3;\n      if (value < 4294967296)\n        return 5;\n      if (value < 18446744073709552e3)\n        return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    if (value >= -32)\n      return 1;\n    if (value >= -128)\n      return 2;\n    if (value >= -32768)\n      return 3;\n    if (value >= -2147483648)\n      return 5;\n    if (value >= -9223372036854776e3)\n      return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n  if (type === \"boolean\")\n    return 1;\n  if (value === null)\n    return sparse ? 0 : 1;\n  if (value === void 0)\n    return sparse ? 0 : 3;\n  if (\"function\" === typeof value.toJSON)\n    return sizeof(value.toJSON(), sparse);\n  if (type === \"object\") {\n    let length, size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (let i = 0; i < length; i++) {\n        size += sizeof(value[i], sparse);\n      }\n    } else {\n      const keys = encodeableKeys(value, sparse);\n      length = keys.length;\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += sizeof(key) + sizeof(value[key], sparse);\n      }\n    }\n    if (length < 16) {\n      return 1 + size;\n    }\n    if (length < 65536) {\n      return 3 + size;\n    }\n    if (length < 4294967296) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  if (type === \"function\")\n    return 0;\n  throw new Error(\"Unknown type \" + type);\n}\nvar msgpack_default = {\n  encode: encode2,\n  decode: decode2,\n  inspect,\n  utf8Write,\n  utf8Read,\n  utf8ByteCount\n};\n\n// src/platform/web/lib/http/request/fetchrequest.ts\nfunction isAblyError2(responseBody, headers) {\n  return !!headers.get(\"x-ably-errorcode\");\n}\nfunction getAblyError2(responseBody, headers) {\n  if (isAblyError2(responseBody, headers)) {\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n  }\n}\nfunction convertHeaders(headers) {\n  const result = {};\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\nasync function fetchRequest(method, client, uri, headers, params, body) {\n  const fetchHeaders = new Headers(headers || {});\n  const _method = method ? method.toUpperCase() : isNil(body) ? \"GET\" : \"POST\";\n  const controller = new AbortController();\n  let timeout;\n  const timeoutPromise = new Promise((resolve) => {\n    timeout = setTimeout(\n      () => {\n        controller.abort();\n        resolve({ error: new PartialErrorInfo(\"Request timed out\", null, 408) });\n      },\n      client ? client.options.timeouts.httpRequestTimeout : defaults_default.TIMEOUTS.httpRequestTimeout\n    );\n  });\n  const requestInit = {\n    method: _method,\n    headers: fetchHeaders,\n    body,\n    signal: controller.signal\n  };\n  if (!Platform.Config.isWebworker) {\n    requestInit.credentials = fetchHeaders.has(\"authorization\") ? \"include\" : \"same-origin\";\n  }\n  const resultPromise = (async () => {\n    try {\n      const urlParams = new URLSearchParams(params || {});\n      urlParams.set(\"rnd\", cheapRandStr());\n      const preparedURI = uri + \"?\" + urlParams;\n      const res = await getGlobalObject().fetch(preparedURI, requestInit);\n      clearTimeout(timeout);\n      if (res.status == 204) {\n        return { error: null, statusCode: res.status };\n      }\n      const contentType = res.headers.get(\"Content-Type\");\n      let body2;\n      if (contentType && contentType.indexOf(\"application/x-msgpack\") > -1) {\n        body2 = await res.arrayBuffer();\n      } else if (contentType && contentType.indexOf(\"application/json\") > -1) {\n        body2 = await res.json();\n      } else {\n        body2 = await res.text();\n      }\n      const unpacked = !!contentType && contentType.indexOf(\"application/x-msgpack\") === -1;\n      const headers2 = convertHeaders(res.headers);\n      if (!res.ok) {\n        const error = getAblyError2(body2, res.headers) || new PartialErrorInfo(\n          \"Error response received from server: \" + res.status + \" body was: \" + Platform.Config.inspect(body2),\n          null,\n          res.status\n        );\n        return { error, body: body2, headers: headers2, unpacked, statusCode: res.status };\n      } else {\n        return { error: null, body: body2, headers: headers2, unpacked, statusCode: res.status };\n      }\n    } catch (error) {\n      clearTimeout(timeout);\n      return { error };\n    }\n  })();\n  return Promise.race([timeoutPromise, resultPromise]);\n}\n\n// src/platform/web/lib/http/request/index.ts\nvar defaultBundledRequestImplementations = {\n  XHRRequest: xhrrequest_default,\n  FetchRequest: fetchRequest\n};\n\n// src/platform/web/index.ts\nvar Crypto = createCryptoClass(config_default, bufferutils_default);\nPlatform.Crypto = Crypto;\nPlatform.BufferUtils = bufferutils_default;\nPlatform.Http = http_default;\nPlatform.Config = config_default;\nPlatform.Transports = transport_default2;\nPlatform.WebStorage = webstorage_default;\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\n  clientClass.Crypto = Crypto;\n  clientClass._MsgPack = msgpack_default;\n}\nhttp_default.bundledRequestImplementations = defaultBundledRequestImplementations;\nlogger_default.initLogHandlers();\nPlatform.Defaults = getDefaults(defaults_default2);\nif (Platform.Config.agent) {\n  Platform.Defaults.agent += \" \" + Platform.Config.agent;\n}\nvar web_default = {\n  ErrorInfo,\n  Rest: DefaultRest,\n  Realtime: DefaultRealtime,\n  msgpack: msgpack_default,\n  makeProtocolMessageFromDeserialized: makeFromDeserializedWithDependencies\n};\nif (typeof module.exports == \"object\" && typeof exports == \"object\") {\n  var __cp = (to, from, except, desc) => {\n    if ((from && typeof from === \"object\") || typeof from === \"function\") {\n      for (let key of Object.getOwnPropertyNames(from)) {\n        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)\n        Object.defineProperty(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,\n        });\n      }\n    }\n    return to;\n  };\n  module.exports = __cp(module.exports, exports);\n}\nreturn module.exports;\n}))\n//# sourceMappingURL=ably.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9hYmx5QDIuMTcuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9hYmx5L2J1aWxkL2FibHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBdUQ7QUFDL0Q7QUFDQSxNQUFNLEtBQUssRUFNTjtBQUNMLEdBQUc7QUFDSDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsK0JBQStCLHNCQUFzQixnQkFBZ0I7QUFDbEwsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIscUJBQU0sbUJBQW1CLHFCQUFNO0FBQ3pEO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEseURBQXlELElBQUk7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUSx5Q0FBeUMsUUFBUSx1Q0FBdUMsUUFBUSxnQkFBZ0IsUUFBUTtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVSxjQUFjLFFBQVEsa0NBQWtDLFFBQVEsdUNBQXVDLFFBQVEsZ0JBQWdCLFFBQVE7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvUUFBb1Esd0JBQXdCO0FBQzVSO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG1CQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxjQUFjO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxZQUFZO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBTTtBQUNu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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0VBQWtFLElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0VBQWtFLElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrQ0FBK0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JO0FBQ3BJLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxVQUFV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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsbUJBQW1CLCtDQUErQztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUSw0SUFBNEk7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUNBQXFDLENBQVU7QUFDaEU7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJLFdBQVc7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSkFBK0o7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xILHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZELHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQXFEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEIscUJBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQkFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3RELE1BQU07QUFDTix5QkFBeUIsNkJBQTZCO0FBQ3RELE1BQU07QUFDTiwyRUFBMkU7QUFDM0U7QUFDQSx5QkFBeUIsNkRBQTZEO0FBQ3RGLE1BQU07QUFDTjtBQUNBO0FBQ0EseUJBQXlCLHlFQUF5RTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLEVBQUUscUJBQXFCLEdBQUcsa0JBQWtCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQsSUFBSTtBQUNKLHlCQUF5QiwwQ0FBMEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQTZEO0FBQy9FLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQSxlQUFlO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vYWJseUAyLjE3LjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvYWJseS9idWlsZC9hYmx5LmpzP2YxZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypAbGljZW5zZSBDb3B5cmlnaHQgMjAxNS0yMDIyIEFibHkgUmVhbC10aW1lIEx0ZCAoYWJseS5jb20pXG5cbkFibHkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYyLjE3LjFcbmh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanNcblxuUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbmNlIHYyLjAqLyhmdW5jdGlvbiAoZywgZikge1xuICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSkge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XG4gICAgfSBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGYpO1xuICAgIH0gZWxzZSBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cykge1xuICAgICAgZXhwb3J0c1tcIkFibHlcIl0gPSBmKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdbXCJBYmx5XCJdID0gZigpO1xuICAgIH1cbiAgfSh0aGlzLCAoKSA9PiB7XG52YXIgZXhwb3J0cyA9IHt9O1xudmFyIG1vZHVsZSA9IHsgZXhwb3J0cyB9O1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX2F3YWl0ID0gZnVuY3Rpb24ocHJvbWlzZSwgaXNZaWVsZFN0YXIpIHtcbiAgdGhpc1swXSA9IHByb21pc2U7XG4gIHRoaXNbMV0gPSBpc1lpZWxkU3Rhcjtcbn07XG52YXIgX19hc3luY0dlbmVyYXRvciA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgdmFyIHJlc3VtZSA9IChrLCB2LCB5ZXMsIG5vKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB4ID0gZ2VuZXJhdG9yW2tdKHYpLCBpc0F3YWl0ID0gKHYgPSB4LnZhbHVlKSBpbnN0YW5jZW9mIF9fYXdhaXQsIGRvbmUgPSB4LmRvbmU7XG4gICAgICBQcm9taXNlLnJlc29sdmUoaXNBd2FpdCA/IHZbMF0gOiB2KS50aGVuKCh5KSA9PiBpc0F3YWl0ID8gcmVzdW1lKGsgPT09IFwicmV0dXJuXCIgPyBrIDogXCJuZXh0XCIsIHZbMV0gPyB7IGRvbmU6IHkuZG9uZSwgdmFsdWU6IHkudmFsdWUgfSA6IHksIHllcywgbm8pIDogeWVzKHsgdmFsdWU6IHksIGRvbmUgfSkpLmNhdGNoKChlKSA9PiByZXN1bWUoXCJ0aHJvd1wiLCBlLCB5ZXMsIG5vKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbm8oZSk7XG4gICAgfVxuICB9O1xuICB2YXIgbWV0aG9kID0gKGspID0+IGl0W2tdID0gKHgpID0+IG5ldyBQcm9taXNlKCh5ZXMsIG5vKSA9PiByZXN1bWUoaywgeCwgeWVzLCBubykpO1xuICB2YXIgaXQgPSB7fTtcbiAgcmV0dXJuIGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSwgaXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gKCkgPT4gaXQsIG1ldGhvZChcIm5leHRcIiksIG1ldGhvZChcInRocm93XCIpLCBtZXRob2QoXCJyZXR1cm5cIiksIGl0O1xufTtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9pbmRleC50c1xudmFyIHdlYl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh3ZWJfZXhwb3J0cywge1xuICBFcnJvckluZm86ICgpID0+IEVycm9ySW5mbyxcbiAgUmVhbHRpbWU6ICgpID0+IERlZmF1bHRSZWFsdGltZSxcbiAgUmVzdDogKCkgPT4gRGVmYXVsdFJlc3QsXG4gIGRlZmF1bHQ6ICgpID0+IHdlYl9kZWZhdWx0LFxuICBtYWtlUHJvdG9jb2xNZXNzYWdlRnJvbURlc2VyaWFsaXplZDogKCkgPT4gbWFrZUZyb21EZXNlcmlhbGl6ZWRXaXRoRGVwZW5kZW5jaWVzLFxuICBtc2dwYWNrOiAoKSA9PiBtc2dwYWNrX2RlZmF1bHRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMod2ViX2V4cG9ydHMpO1xuXG4vLyBzcmMvY29tbW9uL3BsYXRmb3JtLnRzXG52YXIgUGxhdGZvcm0gPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL2xvZ2dlci50c1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogc2VsZjtcbmZ1bmN0aW9uIHBhZCh0aW1lU2VnbWVudCwgdGhyZWUpIHtcbiAgcmV0dXJuIGAke3RpbWVTZWdtZW50fWAucGFkU3RhcnQodGhyZWUgPyAzIDogMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlcihsb2dnZXIpIHtcbiAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5sb2dUaW1lc3RhbXBzID8gZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc3QgdGltZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGxvZ2dlcihcbiAgICAgIHBhZCh0aW1lLmdldEhvdXJzKCkpICsgXCI6XCIgKyBwYWQodGltZS5nZXRNaW51dGVzKCkpICsgXCI6XCIgKyBwYWQodGltZS5nZXRTZWNvbmRzKCkpICsgXCIuXCIgKyBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgMSkgKyBcIiBcIiArIG1zZ1xuICAgICk7XG4gIH0gOiBmdW5jdGlvbihtc2cpIHtcbiAgICBsb2dnZXIobXNnKTtcbiAgfTtcbn1cbnZhciBnZXREZWZhdWx0TG9nZ2VycyA9ICgpID0+IHtcbiAgdmFyIF9hMjtcbiAgbGV0IGNvbnNvbGVMb2dnZXI7XG4gIGxldCBlcnJvckxvZ2dlcjtcbiAgaWYgKHR5cGVvZiAoKF9hMiA9IGdsb2JhbE9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsT2JqZWN0LmNvbnNvbGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9nKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZUxvZ2dlciA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH07XG4gICAgZXJyb3JMb2dnZXIgPSBjb25zb2xlLndhcm4gPyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfSA6IGNvbnNvbGVMb2dnZXI7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZUxvZ2dlciA9IGVycm9yTG9nZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gW2NvbnNvbGVMb2dnZXIsIGVycm9yTG9nZ2VyXS5tYXAoZ2V0SGFuZGxlcik7XG59O1xudmFyIF9Mb2dnZXIgPSBjbGFzcyBfTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZXByZWNhdGVkID0gKGRlc2NyaXB0aW9uLCBtc2cpID0+IHtcbiAgICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nKGAke2Rlc2NyaXB0aW9ufSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gJHttc2d9YCk7XG4gICAgfTtcbiAgICAvKiBXaGVyZSBhIGxvZ2dpbmcgb3BlcmF0aW9uIGlzIGV4cGVuc2l2ZSwgc3VjaCBhcyBzZXJpYWxpc2F0aW9uIG9mIGRhdGEsIHVzZSBzaG91bGRMb2cgd2lsbCBwcmV2ZW50XG4gICAgICB0aGUgb2JqZWN0IGJlaW5nIHNlcmlhbGlzZWQgaWYgdGhlIGxvZyBsZXZlbCB3aWxsIG5vdCBvdXRwdXQgdGhlIG1lc3NhZ2UgKi9cbiAgICB0aGlzLnNob3VsZExvZyA9IChsZXZlbCkgPT4ge1xuICAgICAgcmV0dXJuIGxldmVsIDw9IHRoaXMubG9nTGV2ZWw7XG4gICAgfTtcbiAgICB0aGlzLnNldExvZyA9IChsZXZlbCwgaGFuZGxlcikgPT4ge1xuICAgICAgaWYgKGxldmVsICE9PSB2b2lkIDApXG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsZXZlbDtcbiAgICAgIGlmIChoYW5kbGVyICE9PSB2b2lkIDApXG4gICAgICAgIHRoaXMubG9nSGFuZGxlciA9IHRoaXMubG9nRXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9O1xuICAgIHRoaXMubG9nTGV2ZWwgPSBfTG9nZ2VyLmRlZmF1bHRMb2dMZXZlbDtcbiAgICB0aGlzLmxvZ0hhbmRsZXIgPSBfTG9nZ2VyLmRlZmF1bHRMb2dIYW5kbGVyO1xuICAgIHRoaXMubG9nRXJyb3JIYW5kbGVyID0gX0xvZ2dlci5kZWZhdWx0TG9nRXJyb3JIYW5kbGVyO1xuICB9XG4gIHN0YXRpYyBpbml0TG9nSGFuZGxlcnMoKSB7XG4gICAgY29uc3QgW2xvZ0hhbmRsZXIsIGxvZ0Vycm9ySGFuZGxlcl0gPSBnZXREZWZhdWx0TG9nZ2VycygpO1xuICAgIHRoaXMuZGVmYXVsdExvZ0hhbmRsZXIgPSBsb2dIYW5kbGVyO1xuICAgIHRoaXMuZGVmYXVsdExvZ0Vycm9ySGFuZGxlciA9IGxvZ0Vycm9ySGFuZGxlcjtcbiAgICB0aGlzLmRlZmF1bHRMb2dnZXIgPSBuZXcgX0xvZ2dlcigpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyB0byB0aGlzIG1ldGhvZCBhcmUgbmV2ZXIgc3RyaXBwZWQgYnkgdGhlIGBzdHJpcExvZ3NgIGVzYnVpbGQgcGx1Z2luLiBVc2UgaXQgZm9yIGxvZyBzdGF0ZW1lbnRzIHRoYXQgeW91IHdpc2ggdG8gYWx3YXlzIGJlIGluY2x1ZGVkIGluIHRoZSBtb2R1bGFyIHZhcmlhbnQgb2YgdGhlIFNESy5cbiAgICovXG4gIHN0YXRpYyBsb2dBY3Rpb25Ob1N0cmlwKGxvZ2dlciwgbGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkge1xuICAgIGxvZ2dlci5sb2dBY3Rpb24obGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSk7XG4gIH1cbiAgbG9nQWN0aW9uKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2cobGV2ZWwpKSB7XG4gICAgICAobGV2ZWwgPT09IDEgLyogRXJyb3IgKi8gPyB0aGlzLmxvZ0Vycm9ySGFuZGxlciA6IHRoaXMubG9nSGFuZGxlcikoXCJBYmx5OiBcIiArIGFjdGlvbiArIFwiOiBcIiArIG1lc3NhZ2UsIGxldmVsKTtcbiAgICB9XG4gIH1cbiAgcmVuYW1lZENsaWVudE9wdGlvbihvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBgVGhlIFxcYCR7b2xkTmFtZX1cXGAgY2xpZW50IG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYCR7bmV3TmFtZX1cXGAuIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlIHRvIHVzZSBcXGAke25ld05hbWV9XFxgIGluc3RlYWQuIFxcYCR7b2xkTmFtZX1cXGAgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uYFxuICAgICk7XG4gIH1cbiAgcmVuYW1lZE1ldGhvZChjbGFzc05hbWUsIG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICB0aGlzLmRlcHJlY2F0aW9uV2FybmluZyhcbiAgICAgIGBcXGAke2NsYXNzTmFtZX1cXGBcXHUyMDE5cyBcXGAke29sZE5hbWV9XFxgIG1ldGhvZCBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYCR7bmV3TmFtZX1cXGAuIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlIHRvIHVzZSBcXGAke25ld05hbWV9XFxgIGluc3RlYWQuIFxcYCR7b2xkTmFtZX1cXGAgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uYFxuICAgICk7XG4gIH1cbiAgZGVwcmVjYXRpb25XYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2coMSAvKiBFcnJvciAqLykpIHtcbiAgICAgIHRoaXMubG9nRXJyb3JIYW5kbGVyKGBBYmx5OiBEZXByZWNhdGlvbiB3YXJuaW5nIC0gJHttZXNzYWdlfWAsIDEgLyogRXJyb3IgKi8pO1xuICAgIH1cbiAgfVxufTtcbl9Mb2dnZXIuZGVmYXVsdExvZ0xldmVsID0gMSAvKiBFcnJvciAqLztcbi8vIHB1YmxpYyBjb25zdGFudHNcbl9Mb2dnZXIuTE9HX05PTkUgPSAwIC8qIE5vbmUgKi87XG5fTG9nZ2VyLkxPR19FUlJPUiA9IDEgLyogRXJyb3IgKi87XG5fTG9nZ2VyLkxPR19NQUpPUiA9IDIgLyogTWFqb3IgKi87XG5fTG9nZ2VyLkxPR19NSU5PUiA9IDMgLyogTWlub3IgKi87XG5fTG9nZ2VyLkxPR19NSUNSTyA9IDQgLyogTWljcm8gKi87XG4vKiBwdWJsaWMgc3RhdGljIGZ1bmN0aW9ucyAqL1xuLyoqXG4gKiBJbiB0aGUgbW9kdWxhciB2YXJpYW50IG9mIHRoZSBTREssIHRoZSBgc3RyaXBMb2dzYCBlc2J1aWxkIHBsdWdpbiBzdHJpcHMgb3V0IGFsbCBjYWxscyB0byB0aGlzIG1ldGhvZCAod2hlbiBpbnZva2VkIGFzIGBMb2dnZXIubG9nQWN0aW9uKC4uLilgKSBleGNlcHQgd2hlbiBjYWxsZWQgd2l0aCBsZXZlbCBgTG9nZ2VyLkxPR19FUlJPUmAuIElmIHlvdSB3aXNoIGZvciBhIGxvZyBzdGF0ZW1lbnQgdG8gbmV2ZXIgYmUgc3RyaXBwZWQsIHVzZSB0aGUge0BsaW5rIGxvZ0FjdGlvbk5vU3RyaXB9IG1ldGhvZCBpbnN0ZWFkLlxuICpcbiAqIFRoZSBhZm9yZW1lbnRpb25lZCBwbHVnaW4gZXhwZWN0cyBgbGV2ZWxgIHRvIGJlIGFuIGV4cHJlc3Npb24gb2YgdGhlIGZvcm0gYExvZ2dlci5MT0dfKmA7IHRoYXQgaXMsIHlvdSBjYW7igJl0IGR5bmFtaWNhbGx5IHNwZWNpZnkgdGhlIGxvZyBsZXZlbC5cbiAqL1xuX0xvZ2dlci5sb2dBY3Rpb24gPSAobG9nZ2VyLCBsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSA9PiB7XG4gIF9Mb2dnZXIubG9nQWN0aW9uTm9TdHJpcChsb2dnZXIsIGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpO1xufTtcbnZhciBMb2dnZXIgPSBfTG9nZ2VyO1xudmFyIGxvZ2dlcl9kZWZhdWx0ID0gTG9nZ2VyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL3V0aWxzLnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBGb3JtYXQ6ICgpID0+IEZvcm1hdCxcbiAgYWxsU2FtZTogKCkgPT4gYWxsU2FtZSxcbiAgYWxsVG9Mb3dlckNhc2U6ICgpID0+IGFsbFRvTG93ZXJDYXNlLFxuICBhbGxUb1VwcGVyQ2FzZTogKCkgPT4gYWxsVG9VcHBlckNhc2UsXG4gIGFyckNob29zZU46ICgpID0+IGFyckNob29zZU4sXG4gIGFyckRlbGV0ZVZhbHVlOiAoKSA9PiBhcnJEZWxldGVWYWx1ZSxcbiAgYXJyRXF1YWxzOiAoKSA9PiBhcnJFcXVhbHMsXG4gIGFyckludGVyc2VjdDogKCkgPT4gYXJySW50ZXJzZWN0LFxuICBhcnJJbnRlcnNlY3RPYjogKCkgPT4gYXJySW50ZXJzZWN0T2IsXG4gIGFyclBvcFJhbmRvbUVsZW1lbnQ6ICgpID0+IGFyclBvcFJhbmRvbUVsZW1lbnQsXG4gIGFycldpdGhvdXRWYWx1ZTogKCkgPT4gYXJyV2l0aG91dFZhbHVlLFxuICBjaGVhcFJhbmRTdHI6ICgpID0+IGNoZWFwUmFuZFN0cixcbiAgY29udGFpbnNWYWx1ZTogKCkgPT4gY29udGFpbnNWYWx1ZSxcbiAgY29weTogKCkgPT4gY29weSxcbiAgY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yOiAoKSA9PiBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IsXG4gIGRhdGFTaXplQnl0ZXM6ICgpID0+IGRhdGFTaXplQnl0ZXMsXG4gIGRlY29kZUJvZHk6ICgpID0+IGRlY29kZUJvZHksXG4gIGVuY29kZUJvZHk6ICgpID0+IGVuY29kZUJvZHksXG4gIGVuc3VyZUFycmF5OiAoKSA9PiBlbnN1cmVBcnJheSxcbiAgZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllczogKCkgPT4gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyxcbiAgZ2V0QmFja29mZkNvZWZmaWNpZW50OiAoKSA9PiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQsXG4gIGdldEdsb2JhbE9iamVjdDogKCkgPT4gZ2V0R2xvYmFsT2JqZWN0LFxuICBnZXRKaXR0ZXJDb2VmZmljaWVudDogKCkgPT4gZ2V0Sml0dGVyQ29lZmZpY2llbnQsXG4gIGdldFJldHJ5VGltZTogKCkgPT4gZ2V0UmV0cnlUaW1lLFxuICBpbmhlcml0czogKCkgPT4gaW5oZXJpdHMsXG4gIGluc3BlY3RCb2R5OiAoKSA9PiBpbnNwZWN0Qm9keSxcbiAgaW5zcGVjdEVycm9yOiAoKSA9PiBpbnNwZWN0RXJyb3IsXG4gIGludGVyc2VjdDogKCkgPT4gaW50ZXJzZWN0LFxuICBpc0VtcHR5OiAoKSA9PiBpc0VtcHR5LFxuICBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbzogKCkgPT4gaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8sXG4gIGlzTmlsOiAoKSA9PiBpc05pbCxcbiAgaXNPYmplY3Q6ICgpID0+IGlzT2JqZWN0LFxuICBrZXlzQXJyYXk6ICgpID0+IGtleXNBcnJheSxcbiAgbGlzdGVuZXJUb0FzeW5jSXRlcmF0b3I6ICgpID0+IGxpc3RlbmVyVG9Bc3luY0l0ZXJhdG9yLFxuICBtYXRjaERlcml2ZWRDaGFubmVsOiAoKSA9PiBtYXRjaERlcml2ZWRDaGFubmVsLFxuICBtaXhpbjogKCkgPT4gbWl4aW4sXG4gIHBhcnNlUXVlcnlTdHJpbmc6ICgpID0+IHBhcnNlUXVlcnlTdHJpbmcsXG4gIHByb3RvdHlwaWNhbENsb25lOiAoKSA9PiBwcm90b3R5cGljYWxDbG9uZSxcbiAgcmFuZG9tU3RyaW5nOiAoKSA9PiByYW5kb21TdHJpbmcsXG4gIHNoYWxsb3dDbG9uZTogKCkgPT4gc2hhbGxvd0Nsb25lLFxuICBzaGFsbG93RXF1YWxzOiAoKSA9PiBzaGFsbG93RXF1YWxzLFxuICBzdHJpbmdpZnlWYWx1ZXM6ICgpID0+IHN0cmluZ2lmeVZhbHVlcyxcbiAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3I6ICgpID0+IHRocm93TWlzc2luZ1BsdWdpbkVycm9yLFxuICB0b0Jhc2U2NDogKCkgPT4gdG9CYXNlNjQsXG4gIHRvUXVlcnlTdHJpbmc6ICgpID0+IHRvUXVlcnlTdHJpbmcsXG4gIHZhbHVlc0FycmF5OiAoKSA9PiB2YWx1ZXNBcnJheSxcbiAgd2hlblByb21pc2VTZXR0bGVzOiAoKSA9PiB3aGVuUHJvbWlzZVNldHRsZXMsXG4gIHdpdGhUaW1lb3V0QXN5bmM6ICgpID0+IHdpdGhUaW1lb3V0QXN5bmNcbn0pO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8udHNcbmZ1bmN0aW9uIHRvU3RyaW5nKGVycikge1xuICBsZXQgcmVzdWx0ID0gXCJbXCIgKyBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKGVyci5tZXNzYWdlKVxuICAgIHJlc3VsdCArPSBcIjogXCIgKyBlcnIubWVzc2FnZTtcbiAgaWYgKGVyci5zdGF0dXNDb2RlKVxuICAgIHJlc3VsdCArPSBcIjsgc3RhdHVzQ29kZT1cIiArIGVyci5zdGF0dXNDb2RlO1xuICBpZiAoZXJyLmNvZGUpXG4gICAgcmVzdWx0ICs9IFwiOyBjb2RlPVwiICsgZXJyLmNvZGU7XG4gIGlmIChlcnIuY2F1c2UpXG4gICAgcmVzdWx0ICs9IFwiOyBjYXVzZT1cIiArIGluc3BlY3RFcnJvcihlcnIuY2F1c2UpO1xuICBpZiAoZXJyLmhyZWYgJiYgIShlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmRleE9mKFwiaGVscC5hYmx5LmlvXCIpID4gLTEpKVxuICAgIHJlc3VsdCArPSBcIjsgc2VlIFwiICsgZXJyLmhyZWYgKyBcIiBcIjtcbiAgcmVzdWx0ICs9IFwiXVwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEVycm9ySW5mbyA9IGNsYXNzIF9FcnJvckluZm8gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfRXJyb3JJbmZvLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSB9ID0gdmFsdWVzO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc3RhdHVzQ29kZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JJbmZvLmZyb21WYWx1ZXMoKTogaW52YWxpZCB2YWx1ZXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QodmFsdWVzKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24obmV3IF9FcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuICAgICAgcmVzdWx0LmhyZWYgPSBcImh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yL1wiICsgcmVzdWx0LmNvZGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgUGFydGlhbEVycm9ySW5mbyA9IGNsYXNzIF9QYXJ0aWFsRXJyb3JJbmZvIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1BhcnRpYWxFcnJvckluZm8ucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlIH0gPSB2YWx1ZXM7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiIHx8ICFpc05pbChjb2RlKSAmJiB0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCAhaXNOaWwoc3RhdHVzQ29kZSkgJiYgdHlwZW9mIHN0YXR1c0NvZGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnRpYWxFcnJvckluZm8uZnJvbVZhbHVlcygpOiBpbnZhbGlkIHZhbHVlczogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdCh2YWx1ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihuZXcgX1BhcnRpYWxFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuICAgICAgcmVzdWx0LmhyZWYgPSBcImh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yL1wiICsgcmVzdWx0LmNvZGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvdXRpbHMudHNcbmZ1bmN0aW9uIHJhbmRvbVBvc24oYXJyT3JTdHIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyck9yU3RyLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJnc1tpXTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGNvcHkoc3JjKSB7XG4gIHJldHVybiBtaXhpbih7fSwgc3JjKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFycmF5KG9iaikge1xuICBpZiAoaXNOaWwob2JqKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXR1cm4gW29ial07XG59XG5mdW5jdGlvbiBpc09iamVjdChvYikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iKSA9PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gaXNFbXB0eShvYikge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzTmlsKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUob2IpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE9iamVjdCgpO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpXG4gICAgcmVzdWx0W3Byb3BdID0gb2JbcHJvcF07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwcm90b3R5cGljYWxDbG9uZShvYiwgb3duUHJvcGVydGllcykge1xuICBjbGFzcyBGIHtcbiAgfVxuICBGLnByb3RvdHlwZSA9IG9iO1xuICBjb25zdCByZXN1bHQgPSBuZXcgRigpO1xuICBpZiAob3duUHJvcGVydGllcylcbiAgICBtaXhpbihyZXN1bHQsIG93blByb3BlcnRpZXMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGlmIChQbGF0Zm9ybS5Db25maWcuaW5oZXJpdHMpIHtcbiAgICBQbGF0Zm9ybS5Db25maWcuaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gcHJvdG90eXBpY2FsQ2xvbmUoc3VwZXJDdG9yLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogY3RvciB9KTtcbn07XG5mdW5jdGlvbiBjb250YWluc1ZhbHVlKG9iLCB2YWwpIHtcbiAgZm9yIChjb25zdCBpIGluIG9iKSB7XG4gICAgaWYgKG9iW2ldID09IHZhbClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdChhcnIsIG9iKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iKSA/IGFyckludGVyc2VjdChhcnIsIG9iKSA6IGFyckludGVyc2VjdE9iKGFyciwgb2IpO1xufVxuZnVuY3Rpb24gYXJySW50ZXJzZWN0KGFycjEsIGFycjIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1lbWJlciA9IGFycjFbaV07XG4gICAgaWYgKGFycjIuaW5kZXhPZihtZW1iZXIpICE9IC0xKVxuICAgICAgcmVzdWx0LnB1c2gobWVtYmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXJySW50ZXJzZWN0T2IoYXJyLCBvYikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZW1iZXIgPSBhcnJbaV07XG4gICAgaWYgKG1lbWJlciBpbiBvYilcbiAgICAgIHJlc3VsdC5wdXNoKG1lbWJlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFyckRlbGV0ZVZhbHVlKGFyciwgdmFsKSB7XG4gIGNvbnN0IGlkeCA9IGFyci5pbmRleE9mKHZhbCk7XG4gIGNvbnN0IHJlcyA9IGlkeCAhPSAtMTtcbiAgaWYgKHJlcylcbiAgICBhcnIuc3BsaWNlKGlkeCwgMSk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBhcnJXaXRob3V0VmFsdWUoYXJyLCB2YWwpIHtcbiAgY29uc3QgbmV3QXJyID0gYXJyLnNsaWNlKCk7XG4gIGFyckRlbGV0ZVZhbHVlKG5ld0FyciwgdmFsKTtcbiAgcmV0dXJuIG5ld0Fycjtcbn1cbmZ1bmN0aW9uIGtleXNBcnJheShvYiwgb3duT25seSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKSB7XG4gICAgaWYgKG93bk9ubHkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpXG4gICAgICBjb250aW51ZTtcbiAgICByZXN1bHQucHVzaChwcm9wKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsdWVzQXJyYXkob2IsIG93bk9ubHkpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYikge1xuICAgIGlmIChvd25Pbmx5ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKVxuICAgICAgY29udGludWU7XG4gICAgcmVzdWx0LnB1c2gob2JbcHJvcF0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzKG9iLCBmbikge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSAmJiBvYltwcm9wXSkge1xuICAgICAgZm4ocHJvcCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhbGxTYW1lKGFyciwgcHJvcCkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGZpcnN0ID0gYXJyWzBdW3Byb3BdO1xuICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVtwcm9wXSA9PT0gZmlyc3Q7XG4gIH0pO1xufVxudmFyIEZvcm1hdCA9IC8qIEBfX1BVUkVfXyAqLyAoKEZvcm1hdDIpID0+IHtcbiAgRm9ybWF0MltcIm1zZ3BhY2tcIl0gPSBcIm1zZ3BhY2tcIjtcbiAgRm9ybWF0MltcImpzb25cIl0gPSBcImpzb25cIjtcbiAgcmV0dXJuIEZvcm1hdDI7XG59KShGb3JtYXQgfHwge30pO1xuZnVuY3Rpb24gYXJyUG9wUmFuZG9tRWxlbWVudChhcnIpIHtcbiAgcmV0dXJuIGFyci5zcGxpY2UocmFuZG9tUG9zbihhcnIpLCAxKVswXTtcbn1cbmZ1bmN0aW9uIHRvUXVlcnlTdHJpbmcocGFyYW1zKSB7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGlmIChwYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpXG4gICAgICBwYXJ0cy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pKTtcbiAgfVxuICByZXR1cm4gcGFydHMubGVuZ3RoID8gXCI/XCIgKyBwYXJ0cy5qb2luKFwiJlwiKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlWYWx1ZXMocGFyYW1zKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocGFyYW1zKS5tYXAoKFtrLCB2XSkgPT4gW2ssIFN0cmluZyh2KV0pKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmcocXVlcnkpIHtcbiAgbGV0IG1hdGNoO1xuICBjb25zdCBzZWFyY2ggPSAvKFtePyY9XSspPT8oW14mXSopL2c7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICB3aGlsZSAobWF0Y2ggPSBzZWFyY2guZXhlYyhxdWVyeSkpXG4gICAgcmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzJdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGVycikge1xuICByZXR1cm4gdHlwZW9mIGVyciA9PSBcIm9iamVjdFwiICYmIGVyciAhPT0gbnVsbCAmJiAoZXJyIGluc3RhbmNlb2YgRXJyb3JJbmZvIHx8IGVyciBpbnN0YW5jZW9mIFBhcnRpYWxFcnJvckluZm8pO1xufVxuZnVuY3Rpb24gaW5zcGVjdEVycm9yKGVycikge1xuICB2YXIgX2EyLCBfYjtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8ICgoX2EyID0gZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubmFtZSkgPT09IFwiRXJyb3JJbmZvXCIgfHwgKChfYiA9IGVyciA9PSBudWxsID8gdm9pZCAwIDogZXJyLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkgPT09IFwiUGFydGlhbEVycm9ySW5mb1wiKVxuICAgIHJldHVybiBlcnIudG9TdHJpbmcoKTtcbiAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGVycik7XG59XG5mdW5jdGlvbiBpbnNwZWN0Qm9keShib2R5KSB7XG4gIGlmIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSkge1xuICAgIHJldHVybiBib2R5LnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYm9keSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRhdGFTaXplQnl0ZXMoZGF0YSkge1xuICBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYnl0ZUxlbmd0aChkYXRhKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uQ29uZmlnLnN0cmluZ0J5dGVTaXplKGRhdGEpO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiA4O1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYEV4cGVjdGVkIGlucHV0IG9mIFV0aWxzLmRhdGFTaXplQnl0ZXMgdG8gYmUgYSBzdHJpbmcsIGEgbnVtYmVyLCBhIGJvb2xlYW4gb3IgYSBidWZmZXIsIGJ1dCB3YXM6ICR7dHlwZW9mIGRhdGF9YFxuICApO1xufVxuZnVuY3Rpb24gY2hlYXBSYW5kU3RyKCkge1xuICByZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpLnN1YnN0cigyKTtcbn1cbnZhciByYW5kb21TdHJpbmcgPSBhc3luYyAobnVtQnl0ZXMpID0+IHtcbiAgY29uc3QgYnVmZmVyID0gYXdhaXQgUGxhdGZvcm0uQ29uZmlnLmdldFJhbmRvbUFycmF5QnVmZmVyKG51bUJ5dGVzKTtcbiAgcmV0dXJuIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShidWZmZXIpO1xufTtcbmZ1bmN0aW9uIGFyckNob29zZU4oYXJyLCBuMikge1xuICBjb25zdCBudW1JdGVtcyA9IE1hdGgubWluKG4yLCBhcnIubGVuZ3RoKSwgbXV0YWJsZUFyciA9IGFyci5zbGljZSgpLCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JdGVtczsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2goYXJyUG9wUmFuZG9tRWxlbWVudChtdXRhYmxlQXJyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdoZW5Qcm9taXNlU2V0dGxlcyhwcm9taXNlLCBjYWxsYmFjaykge1xuICBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVycik7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PSBcIm1zZ3BhY2tcIikge1xuICAgIGlmICghTXNnUGFjaykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTXNnUGFjay5kZWNvZGUoYm9keSk7XG4gIH1cbiAgcmV0dXJuIEpTT04ucGFyc2UoU3RyaW5nKGJvZHkpKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQgPT0gXCJtc2dwYWNrXCIpIHtcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiTXNnUGFja1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1zZ1BhY2suZW5jb2RlKGJvZHksIHRydWUpO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShib2R5KTtcbn1cbmZ1bmN0aW9uIGFsbFRvTG93ZXJDYXNlKGFycikge1xuICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFsbFRvVXBwZXJDYXNlKGFycikge1xuICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tvZmZDb2VmZmljaWVudChjb3VudCkge1xuICByZXR1cm4gTWF0aC5taW4oKGNvdW50ICsgMikgLyAzLCAyKTtcbn1cbmZ1bmN0aW9uIGdldEppdHRlckNvZWZmaWNpZW50KCkge1xuICByZXR1cm4gMSAtIE1hdGgucmFuZG9tKCkgKiAwLjI7XG59XG5mdW5jdGlvbiBnZXRSZXRyeVRpbWUoaW5pdGlhbFRpbWVvdXQsIHJldHJ5QXR0ZW1wdCkge1xuICByZXR1cm4gaW5pdGlhbFRpbWVvdXQgKiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQocmV0cnlBdHRlbXB0KSAqIGdldEppdHRlckNvZWZmaWNpZW50KCk7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxPYmplY3QoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWxzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLmV2ZXJ5KChrZXkpID0+IHNvdXJjZVtrZXldID09PSB0YXJnZXRba2V5XSkgJiYgT2JqZWN0LmtleXModGFyZ2V0KS5ldmVyeSgoa2V5KSA9PiB0YXJnZXRba2V5XSA9PT0gc291cmNlW2tleV0pO1xufVxuZnVuY3Rpb24gbWF0Y2hEZXJpdmVkQ2hhbm5lbChuYW1lKSB7XG4gIGNvbnN0IHJlZ2V4ID0gL14oXFxbKFteP10qKSg/OiguKikpXFxdKT8oLispJC87XG4gIGNvbnN0IG1hdGNoID0gbmFtZS5tYXRjaChyZWdleCk7XG4gIGlmICghbWF0Y2ggfHwgIW1hdGNoLmxlbmd0aCB8fCBtYXRjaC5sZW5ndGggPCA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcInJlZ2V4IG1hdGNoIGZhaWxlZFwiLCA0MDAsIDQwMDEwKTtcbiAgfVxuICBpZiAobWF0Y2hbMl0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKGBjYW5ub3QgdXNlIGEgZGVyaXZlZCBvcHRpb24gd2l0aCBhICR7bWF0Y2hbMl19IGNoYW5uZWxgLCA0MDAsIDQwMDEwKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHF1YWxpZmllclBhcmFtOiBtYXRjaFszXSB8fCBcIlwiLFxuICAgIGNoYW5uZWxOYW1lOiBtYXRjaFs0XVxuICB9O1xufVxuZnVuY3Rpb24gdG9CYXNlNjQoc3RyKSB7XG4gIGNvbnN0IGJ1ZmZlclV0aWxzID0gUGxhdGZvcm0uQnVmZmVyVXRpbHM7XG4gIGNvbnN0IHRleHRCdWZmZXIgPSBidWZmZXJVdGlscy51dGY4RW5jb2RlKHN0cik7XG4gIHJldHVybiBidWZmZXJVdGlscy5iYXNlNjRFbmNvZGUodGV4dEJ1ZmZlcik7XG59XG5mdW5jdGlvbiBhcnJFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24odmFsLCBpKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gYltpXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IocGx1Z2luTmFtZSkge1xuICByZXR1cm4gbmV3IEVycm9ySW5mbyhgJHtwbHVnaW5OYW1lfSBwbHVnaW4gbm90IHByb3ZpZGVkYCwgNDAwMTksIDQwMCk7XG59XG5mdW5jdGlvbiB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihwbHVnaW5OYW1lKSB7XG4gIHRocm93IGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcihwbHVnaW5OYW1lKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0QXN5bmMocHJvbWlzZSwgdGltZW91dCA9IDVlMywgZXJyID0gXCJUaW1lb3V0IGV4cGlyZWRcIikge1xuICBjb25zdCBlID0gbmV3IEVycm9ySW5mbyhlcnIsIDVlNCwgNTAwKTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KGUpLCB0aW1lb3V0KSldKTtcbn1cbmZ1bmN0aW9uIGxpc3RlbmVyVG9Bc3luY0l0ZXJhdG9yKHJlZ2lzdGVyTGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBldmVudFF1ZXVlID0gW107XG4gICAgbGV0IHJlc29sdmVOZXh0ID0gbnVsbDtcbiAgICBjb25zdCByZW1vdmVMaXN0ZW5lcjIgPSByZWdpc3Rlckxpc3RlbmVyKChldmVudCkgPT4ge1xuICAgICAgaWYgKHJlc29sdmVOZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSByZXNvbHZlTmV4dDtcbiAgICAgICAgcmVzb2x2ZU5leHQgPSBudWxsO1xuICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50UXVldWUucHVzaChldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChldmVudFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB5aWVsZCBldmVudFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVOZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiQ29uY3VycmVudCBuZXh0KCkgY2FsbHMgYXJlIG5vdCBzdXBwb3J0ZWRcIiwgNGU0LCA0MDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBldmVudCA9IHlpZWxkIG5ldyBfX2F3YWl0KG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlTmV4dCA9IHJlc29sdmU7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyMigpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjIuMTcuMVwiO1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL2RlZmF1bHRzLnRzXG52YXIgYWdlbnQgPSBcImFibHktanMvXCIgKyB2ZXJzaW9uO1xudmFyIERlZmF1bHRzID0ge1xuICBFTkRQT0lOVDogXCJtYWluXCIsXG4gIEVOVklST05NRU5UOiBcIlwiLFxuICBSRVNUX0hPU1Q6IFwicmVzdC5hYmx5LmlvXCIsXG4gIFJFQUxUSU1FX0hPU1Q6IFwicmVhbHRpbWUuYWJseS5pb1wiLFxuICBGQUxMQkFDS19IT1NUUzogW1xuICAgIFwibWFpbi5hLmZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgXCJtYWluLmIuZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIm1haW4uYy5mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwibWFpbi5kLmZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgXCJtYWluLmUuZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb21cIlxuICBdLFxuICBQT1JUOiA4MCxcbiAgVExTX1BPUlQ6IDQ0MyxcbiAgVElNRU9VVFM6IHtcbiAgICAvKiBEb2N1bWVudGVkIGFzIG9wdGlvbnMgcGFyYW1zOiAqL1xuICAgIGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dDogMTVlMyxcbiAgICBzdXNwZW5kZWRSZXRyeVRpbWVvdXQ6IDNlNCxcbiAgICAvKiBVbmRvY3VtZW50ZWQsIGJ1dCBwYXJ0IG9mIHRoZSBhcGkgYW5kIGNhbiBiZSB1c2VkIGJ5IGN1c3RvbWVyczogKi9cbiAgICBodHRwUmVxdWVzdFRpbWVvdXQ6IDFlNCxcbiAgICBodHRwTWF4UmV0cnlEdXJhdGlvbjogMTVlMyxcbiAgICBjaGFubmVsUmV0cnlUaW1lb3V0OiAxNWUzLFxuICAgIGZhbGxiYWNrUmV0cnlUaW1lb3V0OiA2ZTUsXG4gICAgLyogRm9yIGludGVybmFsIC8gdGVzdCB1c2Ugb25seTogKi9cbiAgICBjb25uZWN0aW9uU3RhdGVUdGw6IDEyZTQsXG4gICAgcmVhbHRpbWVSZXF1ZXN0VGltZW91dDogMWU0LFxuICAgIHJlY3ZUaW1lb3V0OiA5ZTQsXG4gICAgd2ViU29ja2V0Q29ubmVjdFRpbWVvdXQ6IDFlNCxcbiAgICB3ZWJTb2NrZXRTbG93VGltZW91dDogNGUzXG4gIH0sXG4gIGh0dHBNYXhSZXRyeUNvdW50OiAzLFxuICBtYXhNZXNzYWdlU2l6ZTogNjU1MzYsXG4gIHZlcnNpb24sXG4gIHByb3RvY29sVmVyc2lvbjogNSxcbiAgYWdlbnQsXG4gIGdldFBvcnQsXG4gIGdldEh0dHBTY2hlbWUsXG4gIGdldFByaW1hcnlEb21haW5Gcm9tRW5kcG9pbnQsXG4gIGdldEVuZHBvaW50RmFsbGJhY2tIb3N0cyxcbiAgZ2V0RmFsbGJhY2tIb3N0cyxcbiAgZ2V0SG9zdHMsXG4gIGNoZWNrSG9zdCxcbiAgb2JqZWN0aWZ5T3B0aW9ucyxcbiAgbm9ybWFsaXNlT3B0aW9ucyxcbiAgZGVmYXVsdEdldEhlYWRlcnMsXG4gIGRlZmF1bHRQb3N0SGVhZGVyc1xufTtcbmZ1bmN0aW9uIGdldFBvcnQob3B0aW9ucywgdGxzKSB7XG4gIHJldHVybiB0bHMgfHwgb3B0aW9ucy50bHMgPyBvcHRpb25zLnRsc1BvcnQgOiBvcHRpb25zLnBvcnQ7XG59XG5mdW5jdGlvbiBnZXRIdHRwU2NoZW1lKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMudGxzID8gXCJodHRwczovL1wiIDogXCJodHRwOi8vXCI7XG59XG5mdW5jdGlvbiBpc0ZxZG5JcE9yTG9jYWxob3N0KGVuZHBvaW50KSB7XG4gIHJldHVybiBlbmRwb2ludC5pbmNsdWRlcyhcIi5cIikgfHwgZW5kcG9pbnQuaW5jbHVkZXMoXCI6OlwiKSB8fCBlbmRwb2ludCA9PT0gXCJsb2NhbGhvc3RcIjtcbn1cbmZ1bmN0aW9uIGdldFByaW1hcnlEb21haW5Gcm9tRW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgaWYgKGlzRnFkbklwT3JMb2NhbGhvc3QoZW5kcG9pbnQpKVxuICAgIHJldHVybiBlbmRwb2ludDtcbiAgaWYgKGVuZHBvaW50LnN0YXJ0c1dpdGgoXCJub25wcm9kOlwiKSkge1xuICAgIGNvbnN0IHJvdXRpbmdQb2xpY3lJZCA9IGVuZHBvaW50LnJlcGxhY2UoXCJub25wcm9kOlwiLCBcIlwiKTtcbiAgICByZXR1cm4gYCR7cm91dGluZ1BvbGljeUlkfS5yZWFsdGltZS5hYmx5LW5vbnByb2QubmV0YDtcbiAgfVxuICByZXR1cm4gYCR7ZW5kcG9pbnR9LnJlYWx0aW1lLmFibHkubmV0YDtcbn1cbmZ1bmN0aW9uIGdldEVuZHBvaW50RmFsbGJhY2tIb3N0cyhlbmRwb2ludCkge1xuICBpZiAoaXNGcWRuSXBPckxvY2FsaG9zdChlbmRwb2ludCkpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aChcIm5vbnByb2Q6XCIpKSB7XG4gICAgY29uc3Qgcm91dGluZ1BvbGljeUlkID0gZW5kcG9pbnQucmVwbGFjZShcIm5vbnByb2Q6XCIsIFwiXCIpO1xuICAgIHJldHVybiBlbmRwb2ludEZhbGxiYWNrcyhyb3V0aW5nUG9saWN5SWQsIFwiYWJseS1yZWFsdGltZS1ub25wcm9kLmNvbVwiKTtcbiAgfVxuICByZXR1cm4gZW5kcG9pbnRGYWxsYmFja3MoZW5kcG9pbnQsIFwiYWJseS1yZWFsdGltZS5jb21cIik7XG59XG5mdW5jdGlvbiBlbmRwb2ludEZhbGxiYWNrcyhyb3V0aW5nUG9saWN5SWQsIGRvbWFpbikge1xuICByZXR1cm4gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIl0ubWFwKChpZCkgPT4gYCR7cm91dGluZ1BvbGljeUlkfS4ke2lkfS5mYWxsYmFjay4ke2RvbWFpbn1gKTtcbn1cbmZ1bmN0aW9uIGdldEZhbGxiYWNrSG9zdHMob3B0aW9ucykge1xuICBjb25zdCBmYWxsYmFja0hvc3RzID0gb3B0aW9ucy5mYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCA9IHR5cGVvZiBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50ICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCA6IERlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50O1xuICByZXR1cm4gZmFsbGJhY2tIb3N0cyA/IGFyckNob29zZU4oZmFsbGJhY2tIb3N0cywgaHR0cE1heFJldHJ5Q291bnQpIDogW107XG59XG5mdW5jdGlvbiBnZXRIb3N0cyhvcHRpb25zKSB7XG4gIHJldHVybiBbb3B0aW9ucy5wcmltYXJ5RG9tYWluXS5jb25jYXQoZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBjaGVja0hvc3QoaG9zdCkge1xuICBpZiAodHlwZW9mIGhvc3QgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiaG9zdCBtdXN0IGJlIGEgc3RyaW5nOyB3YXMgYSBcIiArIHR5cGVvZiBob3N0LCA0ZTQsIDQwMCk7XG4gIH1cbiAgaWYgKCFob3N0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJob3N0IG11c3Qgbm90IGJlIHplcm8tbGVuZ3RoXCIsIDRlNCwgNDAwKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGltZW91dHMob3B0aW9ucykge1xuICBjb25zdCB0aW1lb3V0cyA9IHt9O1xuICBmb3IgKGNvbnN0IHByb3AgaW4gRGVmYXVsdHMuVElNRU9VVFMpIHtcbiAgICB0aW1lb3V0c1twcm9wXSA9IG9wdGlvbnNbcHJvcF0gfHwgRGVmYXVsdHMuVElNRU9VVFNbcHJvcF07XG4gIH1cbiAgcmV0dXJuIHRpbWVvdXRzO1xufVxuZnVuY3Rpb24gZ2V0QWdlbnRTdHJpbmcob3B0aW9ucykge1xuICBsZXQgYWdlbnRTdHIgPSBEZWZhdWx0cy5hZ2VudDtcbiAgaWYgKG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgZm9yICh2YXIgYWdlbnQyIGluIG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgICBhZ2VudFN0ciArPSBcIiBcIiArIGFnZW50MiArIFwiL1wiICsgb3B0aW9ucy5hZ2VudHNbYWdlbnQyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFnZW50U3RyO1xufVxuZnVuY3Rpb24gb2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCBhbGxvd0tleU9yVG9rZW4sIHNvdXJjZUZvckVycm9yTWVzc2FnZSwgbG9nZ2VyLCBtb2R1bGFyUGx1Z2luc1RvSW5jbHVkZSkge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbXNnID0gYWxsb3dLZXlPclRva2VuID8gYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggZWl0aGVyIGEgY2xpZW50IG9wdGlvbnMgb2JqZWN0LCBhbiBBYmx5IEFQSSBrZXksIG9yIGFuIEFibHkgVG9rZW5gIDogYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggYSBjbGllbnQgb3B0aW9ucyBvYmplY3RgO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSgpYCwgbXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxuICBsZXQgb3B0aW9uc09iajtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5kZXhPZihcIjpcIikgPT0gLTEpIHtcbiAgICAgIGlmICghYWxsb3dLZXlPclRva2VuKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGAke3NvdXJjZUZvckVycm9yTWVzc2FnZX0gY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGgganVzdCBhbiBBYmx5IFRva2VuOyB5b3UgbXVzdCBwcm92aWRlIGEgY2xpZW50IG9wdGlvbnMgb2JqZWN0IHdpdGggYSBcXGBwbHVnaW5zXFxgIHByb3BlcnR5LiAoU2V0IHRoaXMgQWJseSBUb2tlbiBhcyB0aGUgb2JqZWN0XFx1MjAxOXMgXFxgdG9rZW5cXGAgcHJvcGVydHkuKWA7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSgpYCwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zT2JqID0geyB0b2tlbjogb3B0aW9ucyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWFsbG93S2V5T3JUb2tlbikge1xuICAgICAgICBjb25zdCBtc2cgPSBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRoIGp1c3QgYW4gQWJseSBBUEkga2V5OyB5b3UgbXVzdCBwcm92aWRlIGEgY2xpZW50IG9wdGlvbnMgb2JqZWN0IHdpdGggYSBcXGBwbHVnaW5zXFxgIHByb3BlcnR5LiAoU2V0IHRoaXMgQWJseSBBUEkga2V5IGFzIHRoZSBvYmplY3RcXHUyMDE5cyBcXGBrZXlcXGAgcHJvcGVydHkuKWA7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSgpYCwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zT2JqID0geyBrZXk6IG9wdGlvbnMgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9uc09iaiA9IG9wdGlvbnM7XG4gIH1cbiAgaWYgKG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSB7XG4gICAgb3B0aW9uc09iaiA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnNPYmopLCB7IHBsdWdpbnM6IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBtb2R1bGFyUGx1Z2luc1RvSW5jbHVkZSksIG9wdGlvbnNPYmoucGx1Z2lucykgfSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNPYmo7XG59XG5mdW5jdGlvbiBjaGVja0lmQ2xpZW50T3B0aW9uc0FyZVZhbGlkKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuZW5kcG9pbnQgJiYgKG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgb3B0aW9ucy5yZXN0SG9zdCB8fCBvcHRpb25zLnJlYWx0aW1lSG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgXCJUaGUgYGVuZHBvaW50YCBvcHRpb24gY2Fubm90IGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYGVudmlyb25tZW50YCwgYHJlc3RIb3N0YCwgb3IgYHJlYWx0aW1lSG9zdGAgb3B0aW9ucy5cIixcbiAgICAgIDQwMTA2LFxuICAgICAgNDAwXG4gICAgKTtcbiAgfVxuICBpZiAob3B0aW9ucy5lbnZpcm9ubWVudCAmJiAob3B0aW9ucy5yZXN0SG9zdCB8fCBvcHRpb25zLnJlYWx0aW1lSG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgXCJUaGUgYGVudmlyb25tZW50YCBvcHRpb24gY2Fubm90IGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHJlc3RIb3N0YCwgb3IgYHJlYWx0aW1lSG9zdGAgb3B0aW9ucy5cIixcbiAgICAgIDQwMTA2LFxuICAgICAgNDAwXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zLCBNc2dQYWNrLCBsb2dnZXIpIHtcbiAgY29uc3QgbG9nZ2VyVG9Vc2UgPSBsb2dnZXIgIT0gbnVsbCA/IGxvZ2dlciA6IGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXI7XG4gIGlmIChvcHRpb25zLmVudmlyb25tZW50KSB7XG4gICAgbG9nZ2VyVG9Vc2UuZGVwcmVjYXRlZChcIlRoZSBgZW52aXJvbm1lbnRgIGNsaWVudCBvcHRpb25cIiwgXCJVc2UgdGhlIGBlbmRwb2ludGAgY2xpZW50IG9wdGlvbiBpbnN0ZWFkLlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZXN0SG9zdCkge1xuICAgIGxvZ2dlclRvVXNlLmRlcHJlY2F0ZWQoXCJUaGUgYHJlc3RIb3N0YCBjbGllbnQgb3B0aW9uXCIsIFwiVXNlIHRoZSBgZW5kcG9pbnRgIGNsaWVudCBvcHRpb24gaW5zdGVhZC5cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVhbHRpbWVIb3N0KSB7XG4gICAgbG9nZ2VyVG9Vc2UuZGVwcmVjYXRlZChcIlRoZSBgcmVhbHRpbWVIb3N0YCBjbGllbnQgb3B0aW9uXCIsIFwiVXNlIHRoZSBgZW5kcG9pbnRgIGNsaWVudCBvcHRpb24gaW5zdGVhZC5cIik7XG4gIH1cbiAgY2hlY2tJZkNsaWVudE9wdGlvbnNBcmVWYWxpZChvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICBsb2dnZXJUb1VzZSxcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgIFwiRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9uc1wiLFxuICAgICAgXCJjbG9zZU9uVW5sb2FkIHdhcyB0cnVlIGFuZCBhIHNlc3Npb24gcmVjb3ZlcnkgZnVuY3Rpb24gd2FzIHNldCAtIHRoZXNlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIHVuc2V0dGluZyB0aGUgbGF0dGVyXCJcbiAgICApO1xuICAgIG9wdGlvbnMucmVjb3ZlciA9IHZvaWQgMDtcbiAgfVxuICBpZiAoIShcImNsb3NlT25VbmxvYWRcIiBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9ICFvcHRpb25zLnJlY292ZXI7XG4gIH1cbiAgaWYgKCEoXCJxdWV1ZU1lc3NhZ2VzXCIgaW4gb3B0aW9ucykpXG4gICAgb3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gdHJ1ZTtcbiAgY29uc3QgZW5kcG9pbnQgPSBvcHRpb25zLmVuZHBvaW50IHx8IERlZmF1bHRzLkVORFBPSU5UO1xuICBpZiAoIW9wdGlvbnMuZmFsbGJhY2tIb3N0cyAmJiAhb3B0aW9ucy5yZXN0SG9zdCAmJiAhb3B0aW9ucy5yZWFsdGltZUhvc3QgJiYgIW9wdGlvbnMucG9ydCAmJiAhb3B0aW9ucy50bHNQb3J0KSB7XG4gICAgb3B0aW9ucy5mYWxsYmFja0hvc3RzID0gZ2V0RW5kcG9pbnRGYWxsYmFja0hvc3RzKG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgZW5kcG9pbnQpO1xuICB9XG4gIGNvbnN0IHByaW1hcnlEb21haW5Gcm9tRW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50ICYmIGAke29wdGlvbnMuZW52aXJvbm1lbnR9LnJlYWx0aW1lLmFibHkubmV0YDtcbiAgY29uc3QgcHJpbWFyeURvbWFpbkZyb21MZWdhY3lPcHRpb25zID0gb3B0aW9ucy5yZXN0SG9zdCB8fCBvcHRpb25zLnJlYWx0aW1lSG9zdCB8fCBwcmltYXJ5RG9tYWluRnJvbUVudmlyb25tZW50O1xuICBjb25zdCBwcmltYXJ5RG9tYWluID0gcHJpbWFyeURvbWFpbkZyb21MZWdhY3lPcHRpb25zIHx8IGdldFByaW1hcnlEb21haW5Gcm9tRW5kcG9pbnQoZW5kcG9pbnQpO1xuICAob3B0aW9ucy5mYWxsYmFja0hvc3RzIHx8IFtdKS5jb25jYXQocHJpbWFyeURvbWFpbikuZm9yRWFjaChjaGVja0hvc3QpO1xuICBvcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgRGVmYXVsdHMuUE9SVDtcbiAgb3B0aW9ucy50bHNQb3J0ID0gb3B0aW9ucy50bHNQb3J0IHx8IERlZmF1bHRzLlRMU19QT1JUO1xuICBpZiAoIShcInRsc1wiIGluIG9wdGlvbnMpKVxuICAgIG9wdGlvbnMudGxzID0gdHJ1ZTtcbiAgY29uc3QgdGltZW91dHMgPSBnZXRUaW1lb3V0cyhvcHRpb25zKTtcbiAgaWYgKE1zZ1BhY2spIHtcbiAgICBpZiAoXCJ1c2VCaW5hcnlQcm90b2NvbFwiIGluIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBQbGF0Zm9ybS5Db25maWcuc3VwcG9ydHNCaW5hcnkgJiYgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IFBsYXRmb3JtLkNvbmZpZy5wcmVmZXJCaW5hcnk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmIChvcHRpb25zLmNsaWVudElkKSB7XG4gICAgaGVhZGVyc1tcIlgtQWJseS1DbGllbnRJZFwiXSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKG9wdGlvbnMuY2xpZW50SWQpKTtcbiAgfVxuICBpZiAoIShcImlkZW1wb3RlbnRSZXN0UHVibGlzaGluZ1wiIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5pZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSB0cnVlO1xuICB9XG4gIGxldCBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyA9IG51bGw7XG4gIGxldCBjb25uZWN0aXZpdHlDaGVja1VybCA9IG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gIGlmIChvcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsKSB7XG4gICAgbGV0IFt1cmksIHFzXSA9IG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwuc3BsaXQoXCI/XCIpO1xuICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gcXMgPyBwYXJzZVF1ZXJ5U3RyaW5nKHFzKSA6IHt9O1xuICAgIGlmICh1cmkuaW5kZXhPZihcIjovL1wiKSA9PT0gLTEpIHtcbiAgICAgIHVyaSA9IFwiaHR0cHM6Ly9cIiArIHVyaTtcbiAgICB9XG4gICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSB1cmk7XG4gIH1cbiAgbGV0IHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgPSBvcHRpb25zLndzQ29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gIGlmICh3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsICYmIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwuaW5kZXhPZihcIjovL1wiKSA9PT0gLTEpIHtcbiAgICB3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsID0gXCJ3c3M6Ly9cIiArIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gIH1cbiAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgcHJpbWFyeURvbWFpbixcbiAgICBtYXhNZXNzYWdlU2l6ZTogb3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSB8fCBEZWZhdWx0cy5tYXhNZXNzYWdlU2l6ZSxcbiAgICB0aW1lb3V0cyxcbiAgICBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyxcbiAgICBjb25uZWN0aXZpdHlDaGVja1VybCxcbiAgICB3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsLFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpc2VDaGFubmVsT3B0aW9ucyhDcnlwdG8yLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhbm5lbE9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoY2hhbm5lbE9wdGlvbnMuY2lwaGVyKSB7XG4gICAgaWYgKCFDcnlwdG8yKVxuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJDcnlwdG9cIik7XG4gICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvMi5nZXRDaXBoZXIoY2hhbm5lbE9wdGlvbnMuY2lwaGVyLCBsb2dnZXIpO1xuICAgIGNoYW5uZWxPcHRpb25zLmNpcGhlciA9IGNpcGhlci5jaXBoZXJQYXJhbXM7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlciA9IGNpcGhlci5jaXBoZXI7XG4gIH0gZWxzZSBpZiAoXCJjaXBoZXJcIiBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgIGNoYW5uZWxPcHRpb25zLmNpcGhlciA9IHZvaWQgMDtcbiAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gbnVsbDtcbiAgfVxuICByZXR1cm4gY2hhbm5lbE9wdGlvbnM7XG59XG52YXIgY29udGVudFR5cGVzID0ge1xuICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgeG1sOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBodG1sOiBcInRleHQvaHRtbFwiLFxuICBtc2dwYWNrOiBcImFwcGxpY2F0aW9uL3gtbXNncGFja1wiLFxuICB0ZXh0OiBcInRleHQvcGxhaW5cIlxufTtcbnZhciBkZWZhdWx0SGVhZGVyc09wdGlvbnMgPSB7XG4gIGZvcm1hdDogXCJqc29uXCIgLyoganNvbiAqLyxcbiAgcHJvdG9jb2xWZXJzaW9uOiBEZWZhdWx0cy5wcm90b2NvbFZlcnNpb25cbn07XG5mdW5jdGlvbiBkZWZhdWx0R2V0SGVhZGVycyhvcHRpb25zLCB7IGZvcm1hdCwgcHJvdG9jb2xWZXJzaW9uID0gZGVmYXVsdEhlYWRlcnNPcHRpb25zLnByb3RvY29sVmVyc2lvbiB9ID0ge30pIHtcbiAgY29uc3QgYWNjZXB0ID0gY29udGVudFR5cGVzW2Zvcm1hdCAhPSBudWxsID8gZm9ybWF0IDogb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovXTtcbiAgcmV0dXJuIHtcbiAgICBhY2NlcHQsXG4gICAgXCJYLUFibHktVmVyc2lvblwiOiBwcm90b2NvbFZlcnNpb24udG9TdHJpbmcoKSxcbiAgICBcIkFibHktQWdlbnRcIjogZ2V0QWdlbnRTdHJpbmcob3B0aW9ucylcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQb3N0SGVhZGVycyhvcHRpb25zLCB7IGZvcm1hdCwgcHJvdG9jb2xWZXJzaW9uID0gZGVmYXVsdEhlYWRlcnNPcHRpb25zLnByb3RvY29sVmVyc2lvbiB9ID0ge30pIHtcbiAgY29uc3QgYWNjZXB0ID0gY29udGVudFR5cGVzW2Zvcm1hdCAhPSBudWxsID8gZm9ybWF0IDogb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovXTtcbiAgY29uc3QgY29udGVudFR5cGUgPSBhY2NlcHQ7XG4gIHJldHVybiB7XG4gICAgYWNjZXB0LFxuICAgIFwiY29udGVudC10eXBlXCI6IGNvbnRlbnRUeXBlLFxuICAgIFwiWC1BYmx5LVZlcnNpb25cIjogcHJvdG9jb2xWZXJzaW9uLnRvU3RyaW5nKCksXG4gICAgXCJBYmx5LUFnZW50XCI6IGdldEFnZW50U3RyaW5nKG9wdGlvbnMpXG4gIH07XG59XG52YXIgZGVmYXVsdHNfZGVmYXVsdCA9IERlZmF1bHRzO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdHMocGxhdGZvcm1EZWZhdWx0cykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihEZWZhdWx0cywgcGxhdGZvcm1EZWZhdWx0cyk7XG59XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvbXVsdGljYXN0ZXIudHNcbnZhciBNdWx0aWNhc3RlciA9IGNsYXNzIF9NdWx0aWNhc3RlciB7XG4gIC8vIFByaXZhdGUgY29uc3RydWN0b3I7IHVzZSBzdGF0aWMgTXVsdGljYXN0ZXIuY3JlYXRlIGluc3RlYWRcbiAgY29uc3RydWN0b3IobG9nZ2VyLCBtZW1iZXJzKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycyB8fCBbXTtcbiAgfVxuICBjYWxsKGVyciwgcmVzdWx0KSB7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGhpcy5tZW1iZXJzKSB7XG4gICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWVtYmVyKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJNdWx0aWNhc3RlciBtdWx0aXBsZSBjYWxsYmFjayBoYW5kbGVyXCIsXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uOiBcIiArIGUgKyBcIjsgc3RhY2sgPSBcIiArIGUuc3RhY2tcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHB1c2goLi4uYXJncykge1xuICAgIHRoaXMubWVtYmVycy5wdXNoKC4uLmFyZ3MpO1xuICB9XG4gIGNyZWF0ZVByb21pc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHVzaCgoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXNvbHZlQWxsKHJlc3VsdCkge1xuICAgIHRoaXMuY2FsbChudWxsLCByZXN1bHQpO1xuICB9XG4gIHJlamVjdEFsbChlcnIpIHtcbiAgICB0aGlzLmNhbGwoZXJyKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGxvZ2dlciwgbWVtYmVycykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IF9NdWx0aWNhc3Rlcihsb2dnZXIsIG1lbWJlcnMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKChlcnIsIHJlc3VsdCkgPT4gaW5zdGFuY2UuY2FsbChlcnIsIHJlc3VsdCksIHtcbiAgICAgIHB1c2g6IChmbikgPT4gaW5zdGFuY2UucHVzaChmbiksXG4gICAgICBjcmVhdGVQcm9taXNlOiAoKSA9PiBpbnN0YW5jZS5jcmVhdGVQcm9taXNlKCksXG4gICAgICByZXNvbHZlQWxsOiAocmVzdWx0KSA9PiBpbnN0YW5jZS5yZXNvbHZlQWxsKHJlc3VsdCksXG4gICAgICByZWplY3RBbGw6IChlcnIpID0+IGluc3RhbmNlLnJlamVjdEFsbChlcnIpXG4gICAgfSk7XG4gIH1cbn07XG52YXIgbXVsdGljYXN0ZXJfZGVmYXVsdCA9IE11bHRpY2FzdGVyO1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9IdHRwTWV0aG9kcy50c1xudmFyIEh0dHBNZXRob2RzID0gLyogQF9fUFVSRV9fICovICgoSHR0cE1ldGhvZHMyKSA9PiB7XG4gIEh0dHBNZXRob2RzMltcIkdldFwiXSA9IFwiZ2V0XCI7XG4gIEh0dHBNZXRob2RzMltcIkRlbGV0ZVwiXSA9IFwiZGVsZXRlXCI7XG4gIEh0dHBNZXRob2RzMltcIlBvc3RcIl0gPSBcInBvc3RcIjtcbiAgSHR0cE1ldGhvZHMyW1wiUHV0XCJdID0gXCJwdXRcIjtcbiAgSHR0cE1ldGhvZHMyW1wiUGF0Y2hcIl0gPSBcInBhdGNoXCI7XG4gIHJldHVybiBIdHRwTWV0aG9kczI7XG59KShIdHRwTWV0aG9kcyB8fCB7fSk7XG52YXIgSHR0cE1ldGhvZHNfZGVmYXVsdCA9IEh0dHBNZXRob2RzO1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9IdHRwU3RhdHVzQ29kZXMudHNcbnZhciBIdHRwU3RhdHVzQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChIdHRwU3RhdHVzQ29kZXMyKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIlN1Y2Nlc3NcIl0gPSAyMDBdID0gXCJTdWNjZXNzXCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIk5vQ29udGVudFwiXSA9IDIwNF0gPSBcIk5vQ29udGVudFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJCYWRSZXF1ZXN0XCJdID0gNDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJVbmF1dGhvcml6ZWRcIl0gPSA0MDFdID0gXCJVbmF1dGhvcml6ZWRcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiRm9yYmlkZGVuXCJdID0gNDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIlJlcXVlc3RUaW1lb3V0XCJdID0gNDA4XSA9IFwiUmVxdWVzdFRpbWVvdXRcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiXSA9IDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbiAgcmV0dXJuIEh0dHBTdGF0dXNDb2RlczI7XG59KShIdHRwU3RhdHVzQ29kZXMgfHwge30pO1xuZnVuY3Rpb24gaXNTdWNjZXNzQ29kZShzdGF0dXNDb2RlKSB7XG4gIHJldHVybiBzdGF0dXNDb2RlID49IDIwMCAvKiBTdWNjZXNzICovICYmIHN0YXR1c0NvZGUgPCA0MDAgLyogQmFkUmVxdWVzdCAqLztcbn1cbnZhciBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdCA9IEh0dHBTdGF0dXNDb2RlcztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2F1dGgudHNcbnZhciBNQVhfVE9LRU5fTEVOR1RIID0gTWF0aC5wb3coMiwgMTcpO1xuZnVuY3Rpb24gcmFuZG9tKCkge1xuICByZXR1cm4gKFwiMDAwMDAwXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTE2KSkuc2xpY2UoLTE2KTtcbn1cbmZ1bmN0aW9uIGlzUmVhbHRpbWUoY2xpZW50KSB7XG4gIHJldHVybiAhIWNsaWVudC5jb25uZWN0aW9uO1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSB7XG4gIGlmICghaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZXJyKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKGluc3BlY3RFcnJvcihlcnIpLCBlcnIuY29kZSB8fCA0MDE3MCwgZXJyLnN0YXR1c0NvZGUgfHwgNDAxKTtcbiAgfVxuICBpZiAoIWVyci5jb2RlKSB7XG4gICAgaWYgKGVyci5zdGF0dXNDb2RlID09PSA0MDMpIHtcbiAgICAgIGVyci5jb2RlID0gNDAzMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVyci5jb2RlID0gNDAxNzA7XG4gICAgICBlcnIuc3RhdHVzQ29kZSA9IDQwMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cbnZhciBobWFjID0gKHRleHQsIGtleSkgPT4ge1xuICBjb25zdCBidWZmZXJVdGlscyA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gYnVmZmVyVXRpbHMudXRmOEVuY29kZSh0ZXh0KTtcbiAgY29uc3Qga2V5QnVmZmVyID0gYnVmZmVyVXRpbHMudXRmOEVuY29kZShrZXkpO1xuICBjb25zdCBkaWdlc3QgPSBidWZmZXJVdGlscy5obWFjU2hhMjU2KHRleHRCdWZmZXIsIGtleUJ1ZmZlcik7XG4gIHJldHVybiBidWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoZGlnZXN0KTtcbn07XG5mdW5jdGlvbiBjMTRuKGNhcGFiaWxpdHkpIHtcbiAgaWYgKCFjYXBhYmlsaXR5KVxuICAgIHJldHVybiBcIlwiO1xuICBpZiAodHlwZW9mIGNhcGFiaWxpdHkgPT0gXCJzdHJpbmdcIilcbiAgICBjYXBhYmlsaXR5ID0gSlNPTi5wYXJzZShjYXBhYmlsaXR5KTtcbiAgY29uc3QgYzE0bkNhcGFiaWxpdHkgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qga2V5cyA9IGtleXNBcnJheShjYXBhYmlsaXR5LCB0cnVlKTtcbiAgaWYgKCFrZXlzKVxuICAgIHJldHVybiBcIlwiO1xuICBrZXlzLnNvcnQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgYzE0bkNhcGFiaWxpdHlba2V5c1tpXV0gPSBjYXBhYmlsaXR5W2tleXNbaV1dLnNvcnQoKTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYzE0bkNhcGFiaWxpdHkpO1xufVxuZnVuY3Rpb24gbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QoYXV0aE9wdGlvbnMsIGxvZ2dlcikge1xuICBpZiAoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2tcIik7XG4gIH0gZWxzZSBpZiAoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybFwiKTtcbiAgfSBlbHNlIGlmIChhdXRoT3B0aW9ucy5rZXkpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmdcIik7XG4gIH0gZWxzZSBpZiAoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBzdXBwbGllZCB0b2tlbiBvbmx5XCIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IFwiYXV0aE9wdGlvbnMgbXVzdCBpbmNsdWRlIHZhbGlkIGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnNcIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aCgpXCIsIG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSB7XG4gIHJldHVybiBcInVzZVRva2VuQXV0aFwiIGluIG9wdGlvbnMgJiYgIW9wdGlvbnMudXNlVG9rZW5BdXRoO1xufVxuZnVuY3Rpb24gdXNlVG9rZW5BdXRoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMudXNlVG9rZW5BdXRoIHx8ICFiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykgJiYgKG9wdGlvbnMuYXV0aENhbGxiYWNrIHx8IG9wdGlvbnMuYXV0aFVybCB8fCBvcHRpb25zLnRva2VuIHx8IG9wdGlvbnMudG9rZW5EZXRhaWxzKTtcbn1cbmZ1bmN0aW9uIG5vV2F5VG9SZW5ldyhvcHRpb25zKSB7XG4gIHJldHVybiAhb3B0aW9ucy5rZXkgJiYgIW9wdGlvbnMuYXV0aENhbGxiYWNrICYmICFvcHRpb25zLmF1dGhVcmw7XG59XG52YXIgdHJJZCA9IDA7XG5mdW5jdGlvbiBnZXRUb2tlblJlcXVlc3RJZCgpIHtcbiAgcmV0dXJuIHRySWQrKztcbn1cbnZhciBBdXRoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGluaXRpYWxpemF0aW9uIGlzIGFsd2F5cyBvdmVyd3JpdHRlbiBhbmQgb25seSB1c2VkIHRvIHByZXZlbnQgYSBUeXBlU2NyaXB0IGNvbXBpbGVyIGVycm9yXG4gICAgdGhpcy5hdXRoT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMudG9rZW5QYXJhbXMgPSBvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcyB8fCB7fTtcbiAgICB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG4gICAgdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodXNlVG9rZW5BdXRoKG9wdGlvbnMpKSB7XG4gICAgICBpZiAobm9XYXlUb1JlbmV3KG9wdGlvbnMpKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJBdXRoKClcIixcbiAgICAgICAgICBcIldhcm5pbmc6IGxpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NhdmVUb2tlbk9wdGlvbnMob3B0aW9ucy5kZWZhdWx0VG9rZW5QYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucywgdGhpcy5sb2dnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW9wdGlvbnMua2V5KSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiTm8gYXV0aGVudGljYXRpb24gb3B0aW9ucyBwcm92aWRlZDsgbmVlZCBvbmUgb2Y6IGtleSwgYXV0aFVybCwgb3IgYXV0aENhbGxiYWNrIChvciBmb3IgdGVzdGluZyBvbmx5LCB0b2tlbiBvciB0b2tlbkRldGFpbHMpXCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgoKVwiLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKG1zZywgNDAxNjAsIDQwMSk7XG4gICAgICB9XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJhbm9ueW1vdXMsIHVzaW5nIGJhc2ljIGF1dGhcIik7XG4gICAgICB0aGlzLl9zYXZlQmFzaWNPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5sb2dnZXI7XG4gIH1cbiAgYXN5bmMgYXV0aG9yaXplKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIGlmIChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5rZXkgJiYgdGhpcy5hdXRoT3B0aW9ucy5rZXkgIT09IGF1dGhPcHRpb25zLmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byB1cGRhdGUgYXV0aCBvcHRpb25zIHdpdGggaW5jb21wYXRpYmxlIGtleVwiLCA0MDEwMiwgNDAxKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0b2tlbkRldGFpbHMgPSBhd2FpdCB0aGlzLl9mb3JjZU5ld1Rva2VuKHRva2VuUGFyYW1zICE9IG51bGwgPyB0b2tlblBhcmFtcyA6IG51bGwsIGF1dGhPcHRpb25zICE9IG51bGwgPyBhdXRoT3B0aW9ucyA6IG51bGwpO1xuICAgICAgaWYgKGlzUmVhbHRpbWUodGhpcy5jbGllbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKFxuICAgICAgICAgICAgdG9rZW5EZXRhaWxzLFxuICAgICAgICAgICAgKGVyciwgdG9rZW5EZXRhaWxzMikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHRva2VuRGV0YWlsczIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW5EZXRhaWxzO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRoaXMuY2xpZW50LmNvbm5lY3Rpb24gJiYgZXJyLnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0LkZvcmJpZGRlbikge1xuICAgICAgICB0aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIC8qIEZvciBpbnRlcm5hbCB1c2UsIGVnIGJ5IGNvbm5lY3Rpb25NYW5hZ2VyIC0gdXNlZnVsIHdoZW4gd2FudCB0byBjYWxsIGJhY2tcbiAgICogYXMgc29vbiBhcyB3ZSBoYXZlIHRoZSBuZXcgdG9rZW4sIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGl0IHRvIHRha2VcbiAgICogZWZmZWN0IG9uIHRoZSBjb25uZWN0aW9uIGFzICNhdXRob3JpemUgZG9lcyAqL1xuICBhc3luYyBfZm9yY2VOZXdUb2tlbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpO1xuICAgIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMsIHRoaXMubG9nZ2VyKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKHRydWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZWxldGUgdGhpcy50b2tlblBhcmFtcy50aW1lc3RhbXA7XG4gICAgICBkZWxldGUgdGhpcy5hdXRoT3B0aW9ucy5xdWVyeVRpbWU7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlcXVlc3RUb2tlbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNvbHZlZEF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcbiAgICBjb25zdCByZXNvbHZlZFRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICBsZXQgdG9rZW5SZXF1ZXN0Q2FsbGJhY2ssIGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2tcIik7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmxcIik7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IChwYXJhbXMsIGNiKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gbWl4aW4oXG4gICAgICAgICAgeyBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpblwiIH0sXG4gICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoSGVhZGVyc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCB1c2VQb3N0ID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoTWV0aG9kICYmIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aE1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcInBvc3RcIjtcbiAgICAgICAgbGV0IHByb3ZpZGVkUXNQYXJhbXM7XG4gICAgICAgIGNvbnN0IHF1ZXJ5SWR4ID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLmluZGV4T2YoXCI/XCIpO1xuICAgICAgICBpZiAocXVlcnlJZHggPiAtMSkge1xuICAgICAgICAgIHByb3ZpZGVkUXNQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZShxdWVyeUlkeCkpO1xuICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCA9IHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZSgwLCBxdWVyeUlkeCk7XG4gICAgICAgICAgaWYgKCF1c2VQb3N0KSB7XG4gICAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhQYXJhbXMgPSBtaXhpbihcbiAgICAgICAgICAgICAgcHJvdmlkZWRRc1BhcmFtcyxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoUGFyYW1zXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoUGFyYW1zID0gbWl4aW4oe30sIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFBhcmFtcyB8fCB7fSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgYXV0aFVybFJlcXVlc3RDYWxsYmFjayA9IChyZXN1bHQpID0+IHtcbiAgICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgICBsZXQgYm9keSA9IChfYTIgPSByZXN1bHQuYm9keSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFja1wiLFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIEVycm9yOiBcIiArIGluc3BlY3RFcnJvcihyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycyA9IChfYiA9IHJlc3VsdC5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudFR5cGVIZWFkZXJPckhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVIZWFkZXJPckhlYWRlcnMuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrXCIsXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQ7IGNvbnRlbnQtdHlwZTogXCIgKyBjb250ZW50VHlwZSArIFwiOyBib2R5OiBcIiArIGluc3BlY3RCb2R5KGJvZHkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICBjYihyZXN1bHQuZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0LnVucGFja2VkKSB7XG4gICAgICAgICAgICBjYihudWxsLCBib2R5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpKVxuICAgICAgICAgICAgYm9keSA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYihuZXcgRXJyb3JJbmZvKFwiYXV0aFVybCByZXNwb25zZSBpcyBtaXNzaW5nIGEgY29udGVudC10eXBlIGhlYWRlclwiLCA0MDE3MCwgNDAxKSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGpzb24gPSBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSA+IC0xLCB0ZXh0ID0gY29udGVudFR5cGUuaW5kZXhPZihcInRleHQvcGxhaW5cIikgPiAtMSB8fCBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vand0XCIpID4gLTE7XG4gICAgICAgICAgaWYgKCFqc29uICYmICF0ZXh0KSB7XG4gICAgICAgICAgICBjYihcbiAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcImF1dGhVcmwgcmVzcG9uZGVkIHdpdGggdW5hY2NlcHRhYmxlIGNvbnRlbnQtdHlwZSBcIiArIGNvbnRlbnRUeXBlICsgXCIsIHNob3VsZCBiZSBlaXRoZXIgdGV4dC9wbGFpbiwgYXBwbGljYXRpb24vand0IG9yIGFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGpzb24pIHtcbiAgICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgY2IobmV3IEVycm9ySW5mbyhcImF1dGhVcmwgcmVzcG9uc2UgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGhcIiwgNDAxNzAsIDQwMSksIG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY2IoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBlcnJvciBwcm9jZXNzaW5nIGF1dGhVUkwgcmVzcG9uc2U7IGVyciA9IFwiICsgZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgNDAxNzAsXG4gICAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYihudWxsLCBib2R5LCBjb250ZW50VHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrXCIsXG4gICAgICAgICAgXCJSZXF1ZXN0aW5nIHRva2VuIGZyb20gXCIgKyByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwgKyBcIjsgUGFyYW1zOiBcIiArIEpTT04uc3RyaW5naWZ5KGF1dGhQYXJhbXMpICsgXCI7IG1ldGhvZDogXCIgKyAodXNlUG9zdCA/IFwiUE9TVFwiIDogXCJHRVRcIilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHVzZVBvc3QpIHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXV0aEhlYWRlcnMgfHwge307XG4gICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG4gICAgICAgICAgY29uc3QgYm9keSA9IHRvUXVlcnlTdHJpbmcoYXV0aFBhcmFtcykuc2xpY2UoMSk7XG4gICAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuaHR0cC5kb1VyaShcbiAgICAgICAgICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LFxuICAgICAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwsXG4gICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgIHByb3ZpZGVkUXNQYXJhbXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZXJyLCByZXN1bHQpID0+IGVyciA/IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2soZXJyKSA6IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2socmVzdWx0KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuaHR0cC5kb1VyaShIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLCBhdXRoSGVhZGVycyB8fCB7fSwgbnVsbCwgYXV0aFBhcmFtcyksXG4gICAgICAgICAgICAoZXJyLCByZXN1bHQpID0+IGVyciA/IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2soZXJyKSA6IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2socmVzdWx0KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLmtleSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKClcIixcbiAgICAgICAgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZ1wiXG4gICAgICApO1xuICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSAocGFyYW1zLCBjYikgPT4ge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgICAgdGhpcy5jcmVhdGVUb2tlblJlcXVlc3QocGFyYW1zLCByZXNvbHZlZEF1dGhPcHRpb25zKSxcbiAgICAgICAgICAoZXJyLCByZXN1bHQpID0+IGNiKGVyciwgcmVzdWx0ICE9IG51bGwgPyByZXN1bHQgOiBudWxsKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gXCJOZWVkIGEgbmV3IHRva2VuLCBidXQgYXV0aE9wdGlvbnMgZG9lcyBub3QgaW5jbHVkZSBhbnkgd2F5IHRvIHJlcXVlc3Qgb25lIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSlcIjtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJBdXRoKClcIixcbiAgICAgICAgXCJsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscFwiXG4gICAgICApO1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhtc2csIDQwMTcxLCA0MDMpO1xuICAgIH1cbiAgICBpZiAoXCJjYXBhYmlsaXR5XCIgaW4gcmVzb2x2ZWRUb2tlblBhcmFtcylcbiAgICAgIHJlc29sdmVkVG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4oXG4gICAgICAgIHJlc29sdmVkVG9rZW5QYXJhbXMuY2FwYWJpbGl0eVxuICAgICAgKTtcbiAgICBjb25zdCB0b2tlblJlcXVlc3QgPSAoc2lnbmVkVG9rZW5QYXJhbXMsIHRva2VuQ2IpID0+IHtcbiAgICAgIGNvbnN0IGtleU5hbWUgPSBzaWduZWRUb2tlblBhcmFtcy5rZXlOYW1lLCBwYXRoID0gXCIva2V5cy9cIiArIGtleU5hbWUgKyBcIi9yZXF1ZXN0VG9rZW5cIiwgdG9rZW5VcmkgPSBmdW5jdGlvbihob3N0KSB7XG4gICAgICAgIHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdDogXCJqc29uXCIgLyoganNvbiAqLyB9KTtcbiAgICAgIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKVxuICAgICAgICBtaXhpbihyZXF1ZXN0SGVhZGVycywgcmVzb2x2ZWRBdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKS5yZXF1ZXN0VG9rZW5cIixcbiAgICAgICAgXCJTZW5kaW5nIFBPU1QgdG8gXCIgKyBwYXRoICsgXCI7IFRva2VuIHBhcmFtczogXCIgKyBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcylcbiAgICAgICk7XG4gICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgIHRoaXMuY2xpZW50Lmh0dHAuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCB0b2tlblVyaSwgcmVxdWVzdEhlYWRlcnMsIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKSwgbnVsbCksXG4gICAgICAgIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gdG9rZW5DYihlcnIpIDogdG9rZW5DYihyZXN1bHQuZXJyb3IsIHJlc3VsdC5ib2R5LCByZXN1bHQudW5wYWNrZWQpXG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gZmFsc2UsIHRpbWVvdXRMZW5ndGggPSB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbXNnID0gXCJUb2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWVvdXRMZW5ndGggLyAxZTMgKyBcIiBzZWNvbmRzXCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgbXNnKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8obXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICB9LCB0aW1lb3V0TGVuZ3RoKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrKHJlc29sdmVkVG9rZW5QYXJhbXMsIChlcnIsIHRva2VuUmVxdWVzdE9yRGV0YWlscywgY29udGVudFR5cGUpID0+IHtcbiAgICAgICAgaWYgKHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbGVhclRpbWVvdXQodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0KTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsXG4gICAgICAgICAgICBcInRva2VuIHJlcXVlc3Qgc2lnbmluZyBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWplY3Qobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVG9rZW4gc3RyaW5nIGlzIGVtcHR5XCIsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJUb2tlbiBzdHJpbmcgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGggKHdhcyBcIiArIHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggKyBcIiBieXRlcylcIixcbiAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIlRva2VuIHN0cmluZyB3YXMgbGl0ZXJhbCBudWxsL3VuZGVmaW5lZFwiLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHNbMF0gPT09IFwie1wiICYmICEoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2p3dFwiKSA+IC0xKSkge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgIFwiVG9rZW4gd2FzIGRvdWJsZS1lbmNvZGVkOyBtYWtlIHN1cmUgeW91J3JlIG5vdCBKU09OLWVuY29kaW5nIGFuIGFscmVhZHkgZW5jb2RlZCB0b2tlbiByZXF1ZXN0IG9yIGRldGFpbHNcIixcbiAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHRva2VuOiB0b2tlblJlcXVlc3RPckRldGFpbHMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscyAhPT0gXCJvYmplY3RcIiB8fCB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBcIkV4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcgb3IgdG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCwgYnV0IGdvdCBhIFwiICsgdHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscztcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIG1zZyk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8obXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBKU09OLnN0cmluZ2lmeSh0b2tlblJlcXVlc3RPckRldGFpbHMpLmxlbmd0aDtcbiAgICAgICAgaWYgKG9iamVjdFNpemUgPiBNQVhfVE9LRU5fTEVOR1RIICYmICFyZXNvbHZlZEF1dGhPcHRpb25zLnN1cHByZXNzTWF4TGVuZ3RoQ2hlY2spIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICBcIlRva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBzdHJpbmdpZmllZCBzaXplICh3YXMgXCIgKyBvYmplY3RTaXplICsgXCIgYnl0ZXMpXCIsXG4gICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJpc3N1ZWRcIiBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpIHtcbiAgICAgICAgICByZXNvbHZlKHRva2VuUmVxdWVzdE9yRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKFwia2V5TmFtZVwiIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBcIkV4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcsIHRva2VuIHJlcXVlc3Qgb2JqZWN0LCBvciB0b2tlbiBkZXRhaWxzIG9iamVjdFwiO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgbXNnKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5SZXF1ZXN0KHRva2VuUmVxdWVzdE9yRGV0YWlscywgKGVycjIsIHRva2VuUmVzcG9uc2UsIHVucGFja2VkKSA9PiB7XG4gICAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsXG4gICAgICAgICAgICAgIFwidG9rZW4gcmVxdWVzdCBBUEkgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyMilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWplY3Qobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyMikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXVucGFja2VkKVxuICAgICAgICAgICAgdG9rZW5SZXNwb25zZSA9IEpTT04ucGFyc2UodG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5nZXRUb2tlbigpXCIsIFwidG9rZW4gcmVjZWl2ZWRcIik7XG4gICAgICAgICAgcmVzb2x2ZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBzaWduIGEgdG9rZW4gcmVxdWVzdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICogTk9URSB0aGlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiB0aGUga2V5IHZhbHVlIGlzIGF2YWlsYWJsZSBsb2NhbGx5LlxuICAgKiBPdGhlcndpc2UsIHNpZ25lZCB0b2tlbiByZXF1ZXN0cyBtdXN0IGJlIG9idGFpbmVkIGZyb20gdGhlIGtleVxuICAgKiBvd25lciAoZWl0aGVyIHVzaW5nIHRoZSB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIG9yIHVybCkuXG4gICAqXG4gICAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuICAgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdCBvcHRpb25zOlxuICAgKiAtIGtleTogICAgICAgICAgIHRoZSBrZXkgdG8gdXNlLiBJZiBub3Qgc3BlY2lmaWVkLCBhIGtleSBwYXNzZWQgaW4gY29uc3RydWN0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgKlxuICAgKiAtIHF1ZXJ5VGltZSAgICAgIChvcHRpb25hbCkgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIGFibHkgc3lzdGVtIHNob3VsZCBiZVxuICAgKiAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5XG4gICAqXG4gICAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHRva2VuUGFyYW1zXG4gICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxuICAgKiAtIHR0bDogICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgdGhlIHRva2VuIGluIG1zLiBJZiBub25lIGlzIHNwZWNpZmllZFxuICAgKiAgICAgICAgICAgICAgICAgIGEgZGVmYXVsdCBvZiAxIGhvdXIgaXMgcHJvdmlkZWQuIFRoZSBtYXhpbXVtIGxpZmV0aW1lIGlzIDI0aG91cnM7IGFueSByZXF1ZXN0XG4gICAqICAgICAgICAgICAgICAgICAgZXhjZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuICAgKlxuICAgKiAtIGNhcGFiaWxpdHk6ICAgIChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cbiAgICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAqXG4gICAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJRCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxuICAgKiAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgYSBjbGllbnRJZCBwYXNzZWQgaW4gY29uc3RydWN0aW5nIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcbiAgICpcbiAgICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG4gICAqICAgICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG4gICAqL1xuICBhc3luYyBjcmVhdGVUb2tlblJlcXVlc3QodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuICAgIHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICBjb25zdCBrZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJObyBrZXkgc3BlY2lmaWVkXCIsIDQwMTAxLCA0MDMpO1xuICAgIH1cbiAgICBjb25zdCBrZXlQYXJ0cyA9IGtleS5zcGxpdChcIjpcIiksIGtleU5hbWUgPSBrZXlQYXJ0c1swXSwga2V5U2VjcmV0ID0ga2V5UGFydHNbMV07XG4gICAgaWYgKCFrZXlTZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJJbnZhbGlkIGtleSBzcGVjaWZpZWRcIiwgNDAxMDEsIDQwMyk7XG4gICAgfVxuICAgIGlmICh0b2tlblBhcmFtcy5jbGllbnRJZCA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIGNhblxcdTIwMTl0IGJlIGFuIGVtcHR5IHN0cmluZ1wiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgaWYgKFwiY2FwYWJpbGl0eVwiIGluIHRva2VuUGFyYW1zKSB7XG4gICAgICB0b2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bih0b2tlblBhcmFtcy5jYXBhYmlsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdCA9IG1peGluKHsga2V5TmFtZSB9LCB0b2tlblBhcmFtcyksIGNsaWVudElkID0gdG9rZW5QYXJhbXMuY2xpZW50SWQgfHwgXCJcIiwgdHRsID0gdG9rZW5QYXJhbXMudHRsIHx8IFwiXCIsIGNhcGFiaWxpdHkgPSB0b2tlblBhcmFtcy5jYXBhYmlsaXR5IHx8IFwiXCI7XG4gICAgaWYgKCFyZXF1ZXN0LnRpbWVzdGFtcCkge1xuICAgICAgcmVxdWVzdC50aW1lc3RhbXAgPSBhd2FpdCB0aGlzLl9nZXRUaW1lc3RhbXAoYXV0aE9wdGlvbnMgJiYgYXV0aE9wdGlvbnMucXVlcnlUaW1lKTtcbiAgICB9XG4gICAgY29uc3Qgbm9uY2UgPSByZXF1ZXN0Lm5vbmNlIHx8IChyZXF1ZXN0Lm5vbmNlID0gcmFuZG9tKCkpLCB0aW1lc3RhbXAgPSByZXF1ZXN0LnRpbWVzdGFtcDtcbiAgICBjb25zdCBzaWduVGV4dCA9IHJlcXVlc3Qua2V5TmFtZSArIFwiXFxuXCIgKyB0dGwgKyBcIlxcblwiICsgY2FwYWJpbGl0eSArIFwiXFxuXCIgKyBjbGllbnRJZCArIFwiXFxuXCIgKyB0aW1lc3RhbXAgKyBcIlxcblwiICsgbm9uY2UgKyBcIlxcblwiO1xuICAgIHJlcXVlc3QubWFjID0gcmVxdWVzdC5tYWMgfHwgaG1hYyhzaWduVGV4dCwga2V5U2VjcmV0KTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLmdldFRva2VuUmVxdWVzdCgpXCIsIFwiZ2VuZXJhdGVkIHNpZ25lZCByZXF1ZXN0XCIpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGF1dGggcXVlcnkgcGFyYW1zIHRvIHVzZSBmb3IgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbixcbiAgICogYmFzZWQgb24gdGhlIGN1cnJlbnQgYXV0aCBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRBdXRoUGFyYW1zKCkge1xuICAgIGlmICh0aGlzLm1ldGhvZCA9PSBcImJhc2ljXCIpXG4gICAgICByZXR1cm4geyBrZXk6IHRoaXMua2V5IH07XG4gICAgZWxzZSB7XG4gICAgICBsZXQgdG9rZW5EZXRhaWxzID0gYXdhaXQgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UpO1xuICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aC5nZXRBdXRoUGFyYW1zKCk6IF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyByZXR1cm5lZCBubyBlcnJvciBvciB0b2tlbkRldGFpbHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhdXRob3JpemF0aW9uIGhlYWRlciB0byB1c2UgZm9yIGEgUkVTVCBvciBjb21ldCByZXF1ZXN0LFxuICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEF1dGhIZWFkZXJzKCkge1xuICAgIGlmICh0aGlzLm1ldGhvZCA9PSBcImJhc2ljXCIpIHtcbiAgICAgIHJldHVybiB7IGF1dGhvcml6YXRpb246IFwiQmFzaWMgXCIgKyB0aGlzLmJhc2ljS2V5IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRva2VuRGV0YWlscyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlKTtcbiAgICAgIGlmICghdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGguZ2V0QXV0aFBhcmFtcygpOiBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgcmV0dXJuZWQgbm8gZXJyb3Igb3IgdG9rZW5EZXRhaWxzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgYXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIgKyB0b0Jhc2U2NCh0b2tlbkRldGFpbHMudG9rZW4pIH07XG4gICAgfVxuICB9XG4gIF9zYXZlQmFzaWNPcHRpb25zKGF1dGhPcHRpb25zKSB7XG4gICAgdGhpcy5tZXRob2QgPSBcImJhc2ljXCI7XG4gICAgdGhpcy5rZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG4gICAgdGhpcy5iYXNpY0tleSA9IHRvQmFzZTY0KGF1dGhPcHRpb25zLmtleSk7XG4gICAgdGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHt9O1xuICAgIGlmIChcImNsaWVudElkXCIgaW4gYXV0aE9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG4gICAgfVxuICB9XG4gIF9zYXZlVG9rZW5PcHRpb25zKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIHRoaXMubWV0aG9kID0gXCJ0b2tlblwiO1xuICAgIGlmICh0b2tlblBhcmFtcykge1xuICAgICAgdGhpcy50b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zO1xuICAgIH1cbiAgICBpZiAoYXV0aE9wdGlvbnMpIHtcbiAgICAgIGlmIChhdXRoT3B0aW9ucy50b2tlbikge1xuICAgICAgICBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMgPSB0eXBlb2YgYXV0aE9wdGlvbnMudG9rZW4gPT09IFwic3RyaW5nXCIgPyB7IHRva2VuOiBhdXRoT3B0aW9ucy50b2tlbiB9IDogYXV0aE9wdGlvbnMudG9rZW47XG4gICAgICB9XG4gICAgICBpZiAoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzO1xuICAgICAgfVxuICAgICAgaWYgKFwiY2xpZW50SWRcIiBpbiBhdXRoT3B0aW9ucykge1xuICAgICAgICB0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zO1xuICAgIH1cbiAgfVxuICAvKiBAcGFyYW0gZm9yY2VTdXBlcnNlZGU6IGZvcmNlIGEgbmV3IHRva2VuIHJlcXVlc3QgZXZlbiBpZiB0aGVyZSdzIG9uZSBpblxuICAgKiBwcm9ncmVzcywgbWFraW5nIGFsbCBwZW5kaW5nIGNhbGxiYWNrcyB3YWl0IGZvciB0aGUgbmV3IG9uZSAqL1xuICBhc3luYyBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZm9yY2VTdXBlcnNlZGUpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5EZXRhaWxzO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgaWYgKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbi5jbGllbnRJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIk1pc21hdGNoIGJldHdlZW4gY2xpZW50SWQgaW4gdG9rZW4gKFwiICsgdG9rZW4uY2xpZW50SWQgKyBcIikgYW5kIGN1cnJlbnQgY2xpZW50SWQgKFwiICsgdGhpcy5jbGllbnRJZCArIFwiKVwiLFxuICAgICAgICAgIDQwMTAyLFxuICAgICAgICAgIDQwM1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNsaWVudC5pc1RpbWVPZmZzZXRTZXQoKSB8fCAhdG9rZW4uZXhwaXJlcyB8fCB0b2tlbi5leHBpcmVzID49IHRoaXMuY2xpZW50LmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkF1dGguZ2V0VG9rZW4oKVwiLFxuICAgICAgICAgIFwidXNpbmcgY2FjaGVkIHRva2VuOyBleHBpcmVzID0gXCIgKyB0b2tlbi5leHBpcmVzXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGguZ2V0VG9rZW4oKVwiLCBcImRlbGV0aW5nIGV4cGlyZWQgdG9rZW5cIik7XG4gICAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSAodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8ICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBtdWx0aWNhc3Rlcl9kZWZhdWx0LmNyZWF0ZSh0aGlzLmxvZ2dlcikpKS5jcmVhdGVQcm9taXNlKCk7XG4gICAgaWYgKHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkICE9PSBudWxsICYmICFmb3JjZVN1cGVyc2VkZSkge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuUmVxdWVzdElkID0gdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBnZXRUb2tlblJlcXVlc3RJZCgpO1xuICAgIGxldCB0b2tlblJlc3BvbnNlLCBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHRva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3RUb2tlbih0aGlzLnRva2VuUGFyYW1zLCB0aGlzLmF1dGhPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhdWdodEVycm9yID0gZXJyO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPiB0b2tlblJlcXVlc3RJZCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkF1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKClcIixcbiAgICAgICAgXCJEaXNjYXJkaW5nIHRva2VuIHJlcXVlc3QgcmVzcG9uc2U7IG92ZXJ0YWtlbiBieSBuZXdlciBvbmVcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG4gICAgY29uc3QgbXVsdGljYXN0ZXIgPSB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3Q7XG4gICAgdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIG11bHRpY2FzdGVyID09IG51bGwgPyB2b2lkIDAgOiBtdWx0aWNhc3Rlci5yZWplY3RBbGwoY2F1Z2h0RXJyb3IpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIG11bHRpY2FzdGVyID09IG51bGwgPyB2b2lkIDAgOiBtdWx0aWNhc3Rlci5yZXNvbHZlQWxsKHRoaXMudG9rZW5EZXRhaWxzID0gdG9rZW5SZXNwb25zZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyogVXNlci1zZXQ6IGNoZWNrIHR5cGVzLCAnKicgaXMgZGlzYWxsb3dlZCwgdGhyb3cgYW55IGVycm9ycyAqL1xuICBfdXNlclNldENsaWVudElkKGNsaWVudElkKSB7XG4gICAgaWYgKCEodHlwZW9mIGNsaWVudElkID09PSBcInN0cmluZ1wiIHx8IGNsaWVudElkID09PSBudWxsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGxcIiwgNDAwMTIsIDQwMCk7XG4gICAgfSBlbHNlIGlmIChjbGllbnRJZCA9PT0gXCIqXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICdDYW5cXHUyMDE5dCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgaW5zdGFudGlhdGUgdGhlIGxpYnJhcnkgd2l0aCB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pLCBvciBpZiBjYWxsaW5nIGF1dGhvcml6ZSgpLCBwYXNzIGl0IGluIGFzIGEgdG9rZW5QYXJhbTogYXV0aG9yaXplKHtjbGllbnRJZDogXCIqXCJ9LCBhdXRoT3B0aW9ucyknLFxuICAgICAgICA0MDAxMixcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG4gICAgICBpZiAoZXJyKVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIC8qIEFibHktc2V0OiBubyB0eXBlY2hlY2tpbmcsICcqJyBpcyBhbGxvd2VkIGJ1dCBub3Qgc2V0IG9uIHRoaXMuY2xpZW50SWQpLCByZXR1cm4gZXJyb3JzIHRvIHRoZSBjYWxsZXIgKi9cbiAgX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKSB7XG4gICAgaWYgKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaChjbGllbnRJZCkpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiVW5leHBlY3RlZCBjbGllbnRJZCBtaXNtYXRjaDogY2xpZW50IGhhcyBcIiArIHRoaXMuY2xpZW50SWQgKyBcIiwgcmVxdWVzdGVkIFwiICsgY2xpZW50SWQ7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKG1zZywgNDAxMDIsIDQwMSk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoLl91bmNoZWNrZWRTZXRDbGllbnRJZCgpXCIsIG1zZyk7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsaWVudElkID0gdGhpcy50b2tlblBhcmFtcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIF90b2tlbkNsaWVudElkTWlzbWF0Y2godG9rZW5DbGllbnRJZCkge1xuICAgIHJldHVybiAhISh0aGlzLmNsaWVudElkICYmIHRoaXMuY2xpZW50SWQgIT09IFwiKlwiICYmIHRva2VuQ2xpZW50SWQgJiYgdG9rZW5DbGllbnRJZCAhPT0gXCIqXCIgJiYgdGhpcy5jbGllbnRJZCAhPT0gdG9rZW5DbGllbnRJZCk7XG4gIH1cbiAgc3RhdGljIGlzVG9rZW5FcnIoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuY29kZSAmJiBlcnJvci5jb2RlID49IDQwMTQwICYmIGVycm9yLmNvZGUgPCA0MDE1MDtcbiAgfVxuICByZXZva2VUb2tlbnMoc3BlY2lmaWVycywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LnJldm9rZVRva2VucyhzcGVjaWZpZXJzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgQmFzZUNsaWVudC5nZXRUaW1lc3RhbXB9IGJ1dCBhbHNvIHRha2VzIGludG8gYWNjb3VudCB7QGxpbmsgQXV0aC5hdXRoT3B0aW9uc31cbiAgICovXG4gIGFzeW5jIF9nZXRUaW1lc3RhbXAocXVlcnlUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldFRpbWVzdGFtcChxdWVyeVRpbWUgfHwgISF0aGlzLmF1dGhPcHRpb25zLnF1ZXJ5VGltZSk7XG4gIH1cbn07XG52YXIgYXV0aF9kZWZhdWx0ID0gQXV0aDtcblxuLy8gc3JjL2NvbW1vbi90eXBlcy9odHRwLnRzXG5mdW5jdGlvbiBwYXJhbVN0cmluZyhwYXJhbXMpIHtcbiAgY29uc3QgcGFyYW1QYWlycyA9IFtdO1xuICBpZiAocGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBuZWVkbGUgaW4gcGFyYW1zKSB7XG4gICAgICBwYXJhbVBhaXJzLnB1c2gobmVlZGxlICsgXCI9XCIgKyBwYXJhbXNbbmVlZGxlXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbVBhaXJzLmpvaW4oXCImXCIpO1xufVxuZnVuY3Rpb24gYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSB7XG4gIHJldHVybiB1cmkgKyAocGFyYW1zID8gXCI/XCIgOiBcIlwiKSArIHBhcmFtU3RyaW5nKHBhcmFtcyk7XG59XG5mdW5jdGlvbiBsb2dSZXN1bHQocmVzdWx0LCBtZXRob2QsIHVyaSwgcGFyYW1zLCBsb2dnZXIpIHtcbiAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkh0dHAuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkIEVycm9yOyBcIiArIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykgKyBcIjsgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnJvcilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkh0dHAuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkOyBcIiArIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykgKyBcIjsgSGVhZGVyczogXCIgKyBwYXJhbVN0cmluZyhyZXN1bHQuaGVhZGVycykgKyBcIjsgU3RhdHVzQ29kZTogXCIgKyByZXN1bHQuc3RhdHVzQ29kZSArIFwiOyBCb2R5XCIgKyAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIocmVzdWx0LmJvZHkpID8gXCIgKEJhc2U2NCk6IFwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHJlc3VsdC5ib2R5KSA6IFwiOiBcIiArIHJlc3VsdC5ib2R5KVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxvZ1JlcXVlc3QobWV0aG9kLCB1cmksIGJvZHksIHBhcmFtcywgbG9nZ2VyKSB7XG4gIGlmIChsb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJIdHRwLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJTZW5kaW5nOyBcIiArIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykgKyBcIjsgQm9keVwiICsgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpID8gXCIgKEJhc2U2NCk6IFwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGJvZHkpIDogXCI6IFwiICsgYm9keSlcbiAgICApO1xuICB9XG59XG52YXIgSHR0cCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wbGF0Zm9ybUh0dHAgPSBuZXcgUGxhdGZvcm0uSHR0cChjbGllbnQpO1xuICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSB0aGlzLnBsYXRmb3JtSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSA/ICgpID0+IHRoaXMucGxhdGZvcm1IdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCkgOiB2b2lkIDA7XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hMiA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvZ2dlcikgIT0gbnVsbCA/IF9iIDogbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcjtcbiAgfVxuICBnZXQgc3VwcG9ydHNBdXRoSGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybUh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycztcbiAgfVxuICBnZXQgc3VwcG9ydHNMaW5rSGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybUh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycztcbiAgfVxuICBfZ2V0SG9zdHMoY2xpZW50KSB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGNsaWVudC5jb25uZWN0aW9uLCBjb25uZWN0aW9uSG9zdCA9IGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5ob3N0O1xuICAgIGlmIChjb25uZWN0aW9uSG9zdCkge1xuICAgICAgcmV0dXJuIFtjb25uZWN0aW9uSG9zdF0uY29uY2F0KGRlZmF1bHRzX2RlZmF1bHQuZ2V0RmFsbGJhY2tIb3N0cyhjbGllbnQub3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0cyhjbGllbnQub3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgbm90IHRocm93IGFueSBlcnJvcnM7IHJhdGhlciwgaXQgd2lsbCBjb21tdW5pY2F0ZSBhbnkgZXJyb3IgYnkgcG9wdWxhdGluZyB0aGUge0BsaW5rIFJlcXVlc3RSZXN1bHQuZXJyb3J9IHByb3BlcnR5IG9mIHRoZSByZXR1cm5lZCB7QGxpbmsgUmVxdWVzdFJlc3VsdH0uXG4gICAqL1xuICBhc3luYyBkbyhtZXRob2QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgRXJyb3JJbmZvKFwiaHR0cC5kbyBjYWxsZWQgd2l0aG91dCBjbGllbnRcIiwgNWU0LCA1MDApIH07XG4gICAgICB9XG4gICAgICBjb25zdCB1cmlGcm9tSG9zdCA9IHR5cGVvZiBwYXRoID09PSBcImZ1bmN0aW9uXCIgPyBwYXRoIDogZnVuY3Rpb24oaG9zdCkge1xuICAgICAgICByZXR1cm4gY2xpZW50LmJhc2VVcmkoaG9zdCkgKyBwYXRoO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGYWxsYmFjayA9IGNsaWVudC5fY3VycmVudEZhbGxiYWNrO1xuICAgICAgaWYgKGN1cnJlbnRGYWxsYmFjaykge1xuICAgICAgICBpZiAoY3VycmVudEZhbGxiYWNrLnZhbGlkVW50aWwgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kb1VyaShtZXRob2QsIHVyaUZyb21Ib3N0KGN1cnJlbnRGYWxsYmFjay5ob3N0KSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yICYmIHRoaXMucGxhdGZvcm1IdHRwLnNob3VsZEZhbGxiYWNrKHJlc3VsdC5lcnJvcikpIHtcbiAgICAgICAgICAgIGNsaWVudC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvKG1ldGhvZCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnQuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGhvc3RzID0gdGhpcy5fZ2V0SG9zdHMoY2xpZW50KTtcbiAgICAgIGlmIChob3N0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9VcmkobWV0aG9kLCB1cmlGcm9tSG9zdChob3N0c1swXSksIGhlYWRlcnMsIGJvZHksIHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBsZXQgdHJ5QUhvc3RTdGFydGVkQXQgPSBudWxsO1xuICAgICAgY29uc3QgdHJ5QUhvc3QgPSBhc3luYyAoY2FuZGlkYXRlSG9zdHMsIHBlcnNpc3RPblN1Y2Nlc3MpID0+IHtcbiAgICAgICAgY29uc3QgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG4gICAgICAgIHRyeUFIb3N0U3RhcnRlZEF0ID0gdHJ5QUhvc3RTdGFydGVkQXQgIT0gbnVsbCA/IHRyeUFIb3N0U3RhcnRlZEF0IDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZG9VcmkobWV0aG9kLCB1cmlGcm9tSG9zdChob3N0KSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvciAmJiB0aGlzLnBsYXRmb3JtSHR0cC5zaG91bGRGYWxsYmFjayhyZXN1bHQuZXJyb3IpICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gRGF0ZS5ub3coKSAtIHRyeUFIb3N0U3RhcnRlZEF0LmdldFRpbWUoKTtcbiAgICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPiBjbGllbnQub3B0aW9ucy50aW1lb3V0cy5odHRwTWF4UmV0cnlEdXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgYFRpbWVvdXQgZm9yIHRyeWluZyBmYWxsYmFjayBob3N0cyByZXRyaWVzLiBUb3RhbCBlbGFwc2VkIHRpbWUgZXhjZWVkZWQgdGhlICR7Y2xpZW50Lm9wdGlvbnMudGltZW91dHMuaHR0cE1heFJldHJ5RHVyYXRpb259bXMgbGltaXRgLFxuICAgICAgICAgICAgICAgIDUwMDAzLFxuICAgICAgICAgICAgICAgIDUwMFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ5QUhvc3QoY2FuZGlkYXRlSG9zdHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJzaXN0T25TdWNjZXNzKSB7XG4gICAgICAgICAgY2xpZW50Ll9jdXJyZW50RmFsbGJhY2sgPSB7XG4gICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgdmFsaWRVbnRpbDogRGF0ZS5ub3coKSArIGNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmZhbGxiYWNrUmV0cnlUaW1lb3V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0cnlBSG9zdChob3N0cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogbmV3IEVycm9ySW5mbyhgVW5leHBlY3RlZCBlcnJvciBpbiBIdHRwLmRvOiAke2luc3BlY3RFcnJvcihlcnIpfWAsIDUwMCwgNWU0KSB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBub3QgdGhyb3cgYW55IGVycm9yczsgcmF0aGVyLCBpdCB3aWxsIGNvbW11bmljYXRlIGFueSBlcnJvciBieSBwb3B1bGF0aW5nIHRoZSB7QGxpbmsgUmVxdWVzdFJlc3VsdC5lcnJvcn0gcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIHtAbGluayBSZXF1ZXN0UmVzdWx0fS5cbiAgICovXG4gIGFzeW5jIGRvVXJpKG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgbG9nUmVxdWVzdChtZXRob2QsIHVyaSwgYm9keSwgcGFyYW1zLCB0aGlzLmxvZ2dlcik7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnBsYXRmb3JtSHR0cC5kb1VyaShtZXRob2QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgIGlmICh0aGlzLmxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICBsb2dSZXN1bHQocmVzdWx0LCBtZXRob2QsIHVyaSwgcGFyYW1zLCB0aGlzLmxvZ2dlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBFcnJvckluZm8oYFVuZXhwZWN0ZWQgZXJyb3IgaW4gSHR0cC5kb1VyaTogJHtpbnNwZWN0RXJyb3IoZXJyKX1gLCA1MDAsIDVlNCkgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvZXZlbnRlbWl0dGVyLnRzXG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIobG9nZ2VyLCBldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgbGlzdGVuZXIuYXBwbHkoZXZlbnRUaGlzLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgIFwiRXZlbnRFbWl0dGVyLmVtaXQoKVwiLFxuICAgICAgXCJVbmV4cGVjdGVkIGxpc3RlbmVyIGV4Y2VwdGlvbjogXCIgKyBlICsgXCI7IHN0YWNrID0gXCIgKyAoZSAmJiBlLnN0YWNrKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHRhcmdldExpc3RlbmVycywgbGlzdGVuZXIsIGV2ZW50RmlsdGVyKSB7XG4gIGxldCBsaXN0ZW5lcnM7XG4gIGxldCBpbmRleDtcbiAgbGV0IGV2ZW50TmFtZTtcbiAgZm9yIChsZXQgdGFyZ2V0TGlzdGVuZXJzSW5kZXggPSAwOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCA8IHRhcmdldExpc3RlbmVycy5sZW5ndGg7IHRhcmdldExpc3RlbmVyc0luZGV4KyspIHtcbiAgICBsaXN0ZW5lcnMgPSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdO1xuICAgIGlmIChldmVudEZpbHRlcikge1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzW2V2ZW50RmlsdGVyXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSkge1xuICAgICAgd2hpbGUgKChpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSkgIT09IC0xKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50RmlsdGVyICYmIGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF1bZXZlbnRGaWx0ZXJdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdGVuZXJzKSkge1xuICAgICAgZm9yIChldmVudE5hbWUgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGlzdGVuZXJzLCBldmVudE5hbWUpICYmIEFycmF5LmlzQXJyYXkobGlzdGVuZXJzW2V2ZW50TmFtZV0pKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoW2xpc3RlbmVyc10sIGxpc3RlbmVyLCBldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgRXZlbnRFbWl0dGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmFueSA9IFtdO1xuICAgIHRoaXMuZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbnlPbmNlID0gW107XG4gICAgdGhpcy5ldmVudHNPbmNlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgb24oLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzBdO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgW2V2ZW50LCBsaXN0ZW5lcl0gPSBhcmdzO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50TGlzdGVuZXIub24oKTogSW52YWxpZCBhcmd1bWVudHM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmlsKGV2ZW50KSkge1xuICAgICAgICB0aGlzLmFueS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgZXZlbnQuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8ICh0aGlzLmV2ZW50c1tldmVudF0gPSBbXSk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb2ZmKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMCB8fCBpc05pbChhcmdzWzBdKSAmJiBpc05pbChhcmdzWzFdKSkge1xuICAgICAgdGhpcy5hbnkgPSBbXTtcbiAgICAgIHRoaXMuZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICAgIHRoaXMuZXZlbnRzT25jZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbZmlyc3RBcmcsIHNlY29uZEFyZ10gPSBhcmdzO1xuICAgIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gICAgbGV0IGV2ZW50ID0gbnVsbDtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgfHwgIXNlY29uZEFyZykge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGxpc3RlbmVyID0gZmlyc3RBcmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudCA9IGZpcnN0QXJnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vZmYoKTogaW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBbZXZlbnQsIGxpc3RlbmVyXSA9IFtmaXJzdEFyZywgc2Vjb25kQXJnXTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyICYmIGlzTmlsKGV2ZW50KSkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoW3RoaXMuYW55LCB0aGlzLmV2ZW50cywgdGhpcy5hbnlPbmNlLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZXZlbnQuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vZmYoKTogaW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoW3RoaXMuZXZlbnRzLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lciwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBldmVudDsgZXhjbHVkZXMgb25jZSBldmVudHNcbiAgICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBvciBub25lIGZvciAnYW55J1xuICAgKiBAcmV0dXJuIGFycmF5IG9mIGV2ZW50cywgb3IgbnVsbCBpZiBub25lXG4gICAqL1xuICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICAgIGlmICh0aGlzLmV2ZW50c09uY2VbZXZlbnRdKVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuZXZlbnRzT25jZVtldmVudF0pO1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGggPyBsaXN0ZW5lcnMgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbnkubGVuZ3RoID8gdGhpcy5hbnkgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IGFuIGV2ZW50XG4gICAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gYXJncyB0aGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGxpc3RlbmVyXG4gICAqL1xuICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXZlbnRUaGlzID0geyBldmVudCB9O1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgIGlmICh0aGlzLmFueU9uY2UubGVuZ3RoKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55T25jZSk7XG4gICAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW55Lmxlbmd0aCkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueSk7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50c09uY2VMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuICAgIGlmIChldmVudHNPbmNlTGlzdGVuZXJzKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c09uY2VMaXN0ZW5lcnMpO1xuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50c0xpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoZXZlbnRzTGlzdGVuZXJzKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c0xpc3RlbmVycyk7XG4gICAgfVxuICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgY2FsbExpc3RlbmVyKHRoaXMubG9nZ2VyLCBldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxuICBvbmNlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgIGlmIChhcmdDb3VudCA9PT0gMCB8fCBhcmdDb3VudCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5vbmNlKGV2ZW50LCByZXNvbHZlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBbZmlyc3RBcmcsIHNlY29uZEFyZ10gPSBhcmdzO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZmlyc3RBcmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5hbnlPbmNlLnB1c2goZmlyc3RBcmcpO1xuICAgIH0gZWxzZSBpZiAoaXNOaWwoZmlyc3RBcmcpKSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgfVxuICAgICAgdGhpcy5hbnlPbmNlLnB1c2goc2Vjb25kQXJnKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3RBcmcpKSB7XG4gICAgICBjb25zdCBzZWxmMiA9IHRoaXM7XG4gICAgICBjb25zdCBsaXN0ZW5lcldyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgaW5uZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgZmlyc3RBcmcuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICBzZWxmMi5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHNlY29uZEFyZy5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGZpcnN0QXJnLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgIHNlbGYyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXJXcmFwcGVyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNPbmNlW2ZpcnN0QXJnXSB8fCAodGhpcy5ldmVudHNPbmNlW2ZpcnN0QXJnXSA9IFtdKTtcbiAgICAgIGlmIChzZWNvbmRBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHNlY29uZEFyZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYSBzdGF0ZSBldmVudCBhbmQgZmlyZSBpbW1lZGlhdGVseSBpZiBjdXJyZW50U3RhdGUgbWF0Y2hlcyB0YXJnZXRTdGF0ZVxuICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIGV2ZW50IHRvIGxpc3RlbiB0b1xuICAgKiBAcGFyYW0gY3VycmVudFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgb2JqZWN0XG4gICAqL1xuICBhc3luYyB3aGVuU3RhdGUodGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0U3RhdGUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGN1cnJlbnRTdGF0ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hlblN0YXRlIHJlcXVpcmVzIGEgdmFsaWQgc3RhdGUgU3RyaW5nIGFyZ3VtZW50XCIpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0U3RhdGUgPT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm9uY2UodGFyZ2V0U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcbnZhciBldmVudGVtaXR0ZXJfZGVmYXVsdCA9IEV2ZW50RW1pdHRlcjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvcHJvdG9jb2xtZXNzYWdlY29tbW9uLnRzXG52YXIgYWN0aW9ucyA9IHtcbiAgSEVBUlRCRUFUOiAwLFxuICBBQ0s6IDEsXG4gIE5BQ0s6IDIsXG4gIENPTk5FQ1Q6IDMsXG4gIENPTk5FQ1RFRDogNCxcbiAgRElTQ09OTkVDVDogNSxcbiAgRElTQ09OTkVDVEVEOiA2LFxuICBDTE9TRTogNyxcbiAgQ0xPU0VEOiA4LFxuICBFUlJPUjogOSxcbiAgQVRUQUNIOiAxMCxcbiAgQVRUQUNIRUQ6IDExLFxuICBERVRBQ0g6IDEyLFxuICBERVRBQ0hFRDogMTMsXG4gIFBSRVNFTkNFOiAxNCxcbiAgTUVTU0FHRTogMTUsXG4gIFNZTkM6IDE2LFxuICBBVVRIOiAxNyxcbiAgQUNUSVZBVEU6IDE4LFxuICBPQkpFQ1Q6IDE5LFxuICBPQkpFQ1RfU1lOQzogMjAsXG4gIEFOTk9UQVRJT046IDIxXG59O1xudmFyIEFjdGlvbk5hbWUgPSBbXTtcbk9iamVjdC5rZXlzKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICBBY3Rpb25OYW1lW2FjdGlvbnNbbmFtZV1dID0gbmFtZTtcbn0pO1xudmFyIGZsYWdzID0ge1xuICAvKiBDaGFubmVsIGF0dGFjaCBzdGF0ZSBmbGFncyAqL1xuICBIQVNfUFJFU0VOQ0U6IDEgPDwgMCxcbiAgSEFTX0JBQ0tMT0c6IDEgPDwgMSxcbiAgUkVTVU1FRDogMSA8PCAyLFxuICBUUkFOU0lFTlQ6IDEgPDwgNCxcbiAgQVRUQUNIX1JFU1VNRTogMSA8PCA1LFxuICBIQVNfT0JKRUNUUzogMSA8PCA3LFxuICAvKiBDaGFubmVsIG1vZGUgZmxhZ3MgKi9cbiAgUFJFU0VOQ0U6IDEgPDwgMTYsXG4gIFBVQkxJU0g6IDEgPDwgMTcsXG4gIFNVQlNDUklCRTogMSA8PCAxOCxcbiAgUFJFU0VOQ0VfU1VCU0NSSUJFOiAxIDw8IDE5LFxuICBBTk5PVEFUSU9OX1BVQkxJU0g6IDEgPDwgMjEsXG4gIEFOTk9UQVRJT05fU1VCU0NSSUJFOiAxIDw8IDIyLFxuICBPQkpFQ1RfU1VCU0NSSUJFOiAxIDw8IDI0LFxuICBPQkpFQ1RfUFVCTElTSDogMSA8PCAyNVxufTtcbnZhciBmbGFnTmFtZXMgPSBPYmplY3Qua2V5cyhmbGFncyk7XG5mbGFncy5NT0RFX0FMTCA9IGZsYWdzLlBSRVNFTkNFIHwgZmxhZ3MuUFVCTElTSCB8IGZsYWdzLlNVQlNDUklCRSB8IGZsYWdzLlBSRVNFTkNFX1NVQlNDUklCRSB8IGZsYWdzLkFOTk9UQVRJT05fUFVCTElTSCB8IGZsYWdzLkFOTk9UQVRJT05fU1VCU0NSSUJFIHwgZmxhZ3MuT0JKRUNUX1NVQlNDUklCRSB8IGZsYWdzLk9CSkVDVF9QVUJMSVNIO1xudmFyIGNoYW5uZWxNb2RlcyA9IFtcbiAgXCJQUkVTRU5DRVwiLFxuICBcIlBVQkxJU0hcIixcbiAgXCJTVUJTQ1JJQkVcIixcbiAgXCJQUkVTRU5DRV9TVUJTQ1JJQkVcIixcbiAgXCJBTk5PVEFUSU9OX1BVQkxJU0hcIixcbiAgXCJBTk5PVEFUSU9OX1NVQlNDUklCRVwiLFxuICBcIk9CSkVDVF9TVUJTQ1JJQkVcIixcbiAgXCJPQkpFQ1RfUFVCTElTSFwiXG5dO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9iYXNlbWVzc2FnZS50c1xuZnVuY3Rpb24gbm9ybWFsaXNlQ29udGV4dChjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCB8fCAhY29udGV4dC5jaGFubmVsT3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFubmVsT3B0aW9uczogY29udGV4dCxcbiAgICAgIHBsdWdpbnM6IHt9LFxuICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaXBoZXJPcHRpb25zKENyeXB0bzIsIGxvZ2dlciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNpcGhlcikge1xuICAgIGlmICghQ3J5cHRvMilcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiQ3J5cHRvXCIpO1xuICAgIGNvbnN0IGNpcGhlciA9IENyeXB0bzIuZ2V0Q2lwaGVyKG9wdGlvbnMuY2lwaGVyLCBsb2dnZXIpO1xuICAgIHJldHVybiB7XG4gICAgICBjaXBoZXI6IGNpcGhlci5jaXBoZXJQYXJhbXMsXG4gICAgICBjaGFubmVsQ2lwaGVyOiBjaXBoZXIuY2lwaGVyXG4gICAgfTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChtc2csIGNpcGhlck9wdGlvbnMpIHtcbiAgY29uc3QgeyBkYXRhLCBlbmNvZGluZyB9ID0gYXdhaXQgZW5jcnlwdERhdGEobXNnLmRhdGEsIG1zZy5lbmNvZGluZywgY2lwaGVyT3B0aW9ucyk7XG4gIG1zZy5kYXRhID0gZGF0YTtcbiAgbXNnLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiBtc2c7XG59XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0RGF0YShkYXRhLCBlbmNvZGluZywgY2lwaGVyT3B0aW9ucykge1xuICBsZXQgY2lwaGVyID0gY2lwaGVyT3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuICBsZXQgZGF0YVRvRW5jcnlwdCA9IGRhdGE7XG4gIGxldCBmaW5hbEVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZyArIFwiL1wiIDogXCJcIjtcbiAgaWYgKCFQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhVG9FbmNyeXB0KSkge1xuICAgIGRhdGFUb0VuY3J5cHQgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKFN0cmluZyhkYXRhVG9FbmNyeXB0KSk7XG4gICAgZmluYWxFbmNvZGluZyA9IGZpbmFsRW5jb2RpbmcgKyBcInV0Zi04L1wiO1xuICB9XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBhd2FpdCBjaXBoZXIuZW5jcnlwdChkYXRhVG9FbmNyeXB0KTtcbiAgZmluYWxFbmNvZGluZyA9IGZpbmFsRW5jb2RpbmcgKyBcImNpcGhlcitcIiArIGNpcGhlci5hbGdvcml0aG07XG4gIHJldHVybiB7XG4gICAgZGF0YTogY2lwaGVydGV4dCxcbiAgICBlbmNvZGluZzogZmluYWxFbmNvZGluZ1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jb2RlKG1zZywgb3B0aW9ucykge1xuICBjb25zdCB7IGRhdGEsIGVuY29kaW5nIH0gPSBlbmNvZGVEYXRhKG1zZy5kYXRhLCBtc2cuZW5jb2RpbmcpO1xuICBtc2cuZGF0YSA9IGRhdGE7XG4gIG1zZy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuY2lwaGVyKSB7XG4gICAgcmV0dXJuIGVuY3J5cHQobXNnLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbXNnO1xuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhKGRhdGEsIGVuY29kaW5nKSB7XG4gIGNvbnN0IG5hdGl2ZURhdGFUeXBlID0gdHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIiB8fCBQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMDtcbiAgaWYgKG5hdGl2ZURhdGFUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBlbmNvZGluZ1xuICAgIH07XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcgPyBlbmNvZGluZyArIFwiL2pzb25cIiA6IFwianNvblwiXG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiRGF0YSB0eXBlIGlzIHVuc3VwcG9ydGVkXCIsIDQwMDEzLCA0MDApO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlKG1lc3NhZ2UsIGlucHV0Q29udGV4dCkge1xuICBjb25zdCB7IGRhdGEsIGVuY29kaW5nLCBlcnJvciB9ID0gYXdhaXQgZGVjb2RlRGF0YShtZXNzYWdlLmRhdGEsIG1lc3NhZ2UuZW5jb2RpbmcsIGlucHV0Q29udGV4dCk7XG4gIG1lc3NhZ2UuZGF0YSA9IGRhdGE7XG4gIG1lc3NhZ2UuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZURhdGEoZGF0YSwgZW5jb2RpbmcsIGlucHV0Q29udGV4dCkge1xuICBjb25zdCBjb250ZXh0ID0gbm9ybWFsaXNlQ29udGV4dChpbnB1dENvbnRleHQpO1xuICBsZXQgbGFzdFBheWxvYWQgPSBkYXRhO1xuICBsZXQgZGVjb2RlZERhdGEgPSBkYXRhO1xuICBsZXQgZmluYWxFbmNvZGluZyA9IGVuY29kaW5nO1xuICBsZXQgZGVjb2RpbmdFcnJvcjtcbiAgaWYgKGVuY29kaW5nKSB7XG4gICAgY29uc3QgeGZvcm1zID0gZW5jb2Rpbmcuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleDtcbiAgICBsZXQgZW5jb2RpbmdzVG9Qcm9jZXNzID0geGZvcm1zLmxlbmd0aDtcbiAgICBsZXQgeGZvcm0gPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID0gZW5jb2RpbmdzVG9Qcm9jZXNzKSA+IDApIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB4Zm9ybXNbLS1lbmNvZGluZ3NUb1Byb2Nlc3NdLm1hdGNoKC8oWy1cXHddKykoXFwrKFtcXHctXSspKT8vKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgeGZvcm0gPSBtYXRjaFsxXTtcbiAgICAgICAgc3dpdGNoICh4Zm9ybSkge1xuICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGRlY29kZWREYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RGVjb2RlKFN0cmluZyhkZWNvZGVkRGF0YSkpO1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID09IHhmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbGFzdFBheWxvYWQgPSBkZWNvZGVkRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RGVjb2RlKGRlY29kZWREYXRhKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICBkZWNvZGVkRGF0YSA9IEpTT04ucGFyc2UoZGVjb2RlZERhdGEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBcImNpcGhlclwiOlxuICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hhbm5lbE9wdGlvbnMgIT0gbnVsbCAmJiBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNpcGhlciAmJiBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXIpIHtcbiAgICAgICAgICAgICAgY29uc3QgeGZvcm1BbGdvcml0aG0gPSBtYXRjaFszXSwgY2lwaGVyID0gY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuICAgICAgICAgICAgICBpZiAoeGZvcm1BbGdvcml0aG0gIT0gY2lwaGVyLmFsZ29yaXRobSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2Ugd2l0aCBnaXZlbiBjaXBoZXI7IGluY29tcGF0aWJsZSBjaXBoZXIgcGFyYW1zXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlY29kZWREYXRhID0gYXdhaXQgY2lwaGVyLmRlY3J5cHQoZGVjb2RlZERhdGEpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2U7IG5vdCBhbiBlbmNyeXB0ZWQgY2hhbm5lbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidmNkaWZmXCI6XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQucGx1Z2lucyB8fCAhY29udGV4dC5wbHVnaW5zLnZjZGlmZikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiTWlzc2luZyBWY2RpZmYgZGVjb2RlciAoaHR0cHM6Ly9naXRodWIuY29tL2FibHktZm9ya3MvdmNkaWZmLWRlY29kZXIpXCIsIDQwMDE5LCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJEZWx0YSBkZWNvZGluZyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlciAobmVlZCBBcnJheUJ1ZmZlciAmIFVpbnQ4QXJyYXkpXCIsXG4gICAgICAgICAgICAgICAgNDAwMjAsXG4gICAgICAgICAgICAgICAgNDAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgZGVsdGFCYXNlID0gY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWx0YUJhc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBkZWx0YUJhc2UgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKGRlbHRhQmFzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGVsdGFCYXNlQnVmZmVyID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMudG9CdWZmZXIoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy50b0J1ZmZlcihkZWNvZGVkRGF0YSk7XG4gICAgICAgICAgICAgIGRlY29kZWREYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYXJyYXlCdWZmZXJWaWV3VG9CdWZmZXIoXG4gICAgICAgICAgICAgICAgY29udGV4dC5wbHVnaW5zLnZjZGlmZi5kZWNvZGUoZGVjb2RlZERhdGEsIGRlbHRhQmFzZUJ1ZmZlcilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbGFzdFBheWxvYWQgPSBkZWNvZGVkRGF0YTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlZjZGlmZiBkZWx0YSBkZWNvZGUgZmFpbGVkIHdpdGggXCIgKyBlLCA0MDAxOCwgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyID0gZTtcbiAgICAgIGRlY29kaW5nRXJyb3IgPSBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBgRXJyb3IgcHJvY2Vzc2luZyB0aGUgJHt4Zm9ybX0gZW5jb2RpbmcsIGRlY29kZXIgcmV0dXJuZWQgXFx1MjAxOCR7ZXJyLm1lc3NhZ2V9XFx1MjAxOWAsXG4gICAgICAgIGVyci5jb2RlIHx8IDQwMDEzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGZpbmFsRW5jb2RpbmcgPSBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA8PSAwID8gbnVsbCA6IHhmb3Jtcy5zbGljZSgwLCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCkuam9pbihcIi9cIik7XG4gICAgfVxuICB9XG4gIGlmIChkZWNvZGluZ0Vycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBkZWNvZGluZ0Vycm9yLFxuICAgICAgZGF0YTogZGVjb2RlZERhdGEsXG4gICAgICBlbmNvZGluZzogZmluYWxFbmNvZGluZ1xuICAgIH07XG4gIH1cbiAgY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZCA9IGxhc3RQYXlsb2FkO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IGRlY29kZWREYXRhLFxuICAgIGVuY29kaW5nOiBmaW5hbEVuY29kaW5nXG4gIH07XG59XG5mdW5jdGlvbiB3aXJlVG9KU09OKC4uLmFyZ3MpIHtcbiAgY29uc3QgZm9ybWF0ID0gYXJncy5sZW5ndGggPiAwID8gXCJqc29uXCIgLyoganNvbiAqLyA6IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi87XG4gIGNvbnN0IHsgZGF0YSwgZW5jb2RpbmcgfSA9IGVuY29kZURhdGFGb3JXaXJlKHRoaXMuZGF0YSwgdGhpcy5lbmNvZGluZywgZm9ybWF0KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMsIHsgZW5jb2RpbmcsIGRhdGEgfSk7XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhRm9yV2lyZShkYXRhLCBlbmNvZGluZywgZm9ybWF0KSB7XG4gIGlmICghZGF0YSB8fCAhUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGVuY29kaW5nXG4gICAgfTtcbiAgfVxuICBpZiAoZm9ybWF0ID09PSBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpLFxuICAgICAgZW5jb2RpbmdcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YTogUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGRhdGEpLFxuICAgIGVuY29kaW5nOiBlbmNvZGluZyA/IGVuY29kaW5nICsgXCIvYmFzZTY0XCIgOiBcImJhc2U2NFwiXG4gIH07XG59XG52YXIgTWVzc2FnZUVuY29kaW5nID0ge1xuICBlbmNyeXB0RGF0YSxcbiAgZW5jb2RlRGF0YSxcbiAgZW5jb2RlRGF0YUZvcldpcmUsXG4gIGRlY29kZURhdGFcbn07XG5mdW5jdGlvbiBwb3B1bGF0ZUZpZWxkc0Zyb21QYXJlbnQocGFyZW50KSB7XG4gIGNvbnN0IHsgaWQsIGNvbm5lY3Rpb25JZCwgdGltZXN0YW1wIH0gPSBwYXJlbnQ7XG4gIGxldCBtc2dzO1xuICBzd2l0Y2ggKHBhcmVudC5hY3Rpb24pIHtcbiAgICBjYXNlIGFjdGlvbnMuTUVTU0FHRToge1xuICAgICAgbXNncyA9IHBhcmVudC5tZXNzYWdlcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIGFjdGlvbnMuUFJFU0VOQ0U6XG4gICAgY2FzZSBhY3Rpb25zLlNZTkM6XG4gICAgICBtc2dzID0gcGFyZW50LnByZXNlbmNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhY3Rpb25zLkFOTk9UQVRJT046XG4gICAgICBtc2dzID0gcGFyZW50LmFubm90YXRpb25zO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhY3Rpb25zLk9CSkVDVDpcbiAgICBjYXNlIGFjdGlvbnMuT0JKRUNUX1NZTkM6XG4gICAgICBtc2dzID0gcGFyZW50LnN0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJVbmV4cGVjdGVkIGFjdGlvbiBcIiArIHBhcmVudC5hY3Rpb24sIDRlNCwgNDAwKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtc2cgPSBtc2dzW2ldO1xuICAgIGlmICghbXNnLmNvbm5lY3Rpb25JZCkge1xuICAgICAgbXNnLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICB9XG4gICAgaWYgKCFtc2cudGltZXN0YW1wKSB7XG4gICAgICBtc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIH1cbiAgICBpZiAoaWQgJiYgIW1zZy5pZCkge1xuICAgICAgbXNnLmlkID0gaWQgKyBcIjpcIiArIGk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJNc2cobSwgY2xzKSB7XG4gIGxldCByZXN1bHQgPSBcIltcIiArIGNscztcbiAgZm9yIChjb25zdCBhdHRyIGluIG0pIHtcbiAgICBpZiAoYXR0ciA9PT0gXCJkYXRhXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgbS5kYXRhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhPVwiICsgbS5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihtLmRhdGEpKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YSAoYnVmZmVyKT1cIiArIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShtLmRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbS5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YSAoanNvbik9XCIgKyBKU09OLnN0cmluZ2lmeShtLmRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0ciAmJiAoYXR0ciA9PT0gXCJleHRyYXNcIiB8fCBhdHRyID09PSBcIm9wZXJhdGlvblwiKSkge1xuICAgICAgcmVzdWx0ICs9IFwiOyBcIiArIGF0dHIgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KG1bYXR0cl0pO1xuICAgIH0gZWxzZSBpZiAoYXR0ciA9PT0gXCJ2ZXJzaW9uXCIpIHtcbiAgICAgIHJlc3VsdCArPSBcIjsgdmVyc2lvbj1cIiArIEpTT04uc3RyaW5naWZ5KG1bYXR0cl0pO1xuICAgIH0gZWxzZSBpZiAoYXR0ciA9PT0gXCJhbm5vdGF0aW9uc1wiKSB7XG4gICAgICByZXN1bHQgKz0gXCI7IGFubm90YXRpb25zPVwiICsgSlNPTi5zdHJpbmdpZnkobVthdHRyXSk7XG4gICAgfSBlbHNlIGlmIChtW2F0dHJdICE9PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdCArPSBcIjsgXCIgKyBhdHRyICsgXCI9XCIgKyBtW2F0dHJdO1xuICAgIH1cbiAgfVxuICByZXN1bHQgKz0gXCJdXCI7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgQmFzZU1lc3NhZ2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZWNsaWVudC50c1xudmFyIEJhc2VDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGVzZSBleHBvcnRzIGFyZSBmb3IgdXNlIGJ5IFVNRCBwbHVnaW5zOyByZWFzb24gYmVpbmcgc28gdGhhdCBjb25zdHJ1Y3RvcnMgYW5kIHN0YXRpYyBtZXRob2RzIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGVzZSBwbHVnaW5zIHdpdGhvdXQgbmVlZGluZyB0byBpbXBvcnQgdGhlIGNsYXNzZXMgZGlyZWN0bHkgYW5kIHJlc3VsdCBpbiB0aGUgY2xhc3MgZXhpc3RpbmcgaW4gYm90aCB0aGUgcGx1Z2luIGFuZCB0aGUgY29yZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIHRoaXMuUGxhdGZvcm0gPSBQbGF0Zm9ybTtcbiAgICB0aGlzLkVycm9ySW5mbyA9IEVycm9ySW5mbztcbiAgICB0aGlzLkxvZ2dlciA9IGxvZ2dlcl9kZWZhdWx0O1xuICAgIHRoaXMuRGVmYXVsdHMgPSBkZWZhdWx0c19kZWZhdWx0O1xuICAgIHRoaXMuVXRpbHMgPSB1dGlsc19leHBvcnRzO1xuICAgIHRoaXMuRXZlbnRFbWl0dGVyID0gZXZlbnRlbWl0dGVyX2RlZmF1bHQ7XG4gICAgdGhpcy5NZXNzYWdlRW5jb2RpbmcgPSBNZXNzYWdlRW5jb2Rpbmc7XG4gICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfajtcbiAgICB0aGlzLl9hZGRpdGlvbmFsSFRUUFJlcXVlc3RJbXBsZW1lbnRhdGlvbnMgPSAoX2EyID0gb3B0aW9ucy5wbHVnaW5zKSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgICB0aGlzLmxvZ2dlciA9IG5ldyBsb2dnZXJfZGVmYXVsdCgpO1xuICAgIHRoaXMubG9nZ2VyLnNldExvZyhvcHRpb25zLmxvZ0xldmVsLCBvcHRpb25zLmxvZ0hhbmRsZXIpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJCYXNlQ2xpZW50KClcIixcbiAgICAgIFwiaW5pdGlhbGl6ZWQgd2l0aCBjbGllbnRPcHRpb25zIFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3Qob3B0aW9ucylcbiAgICApO1xuICAgIHRoaXMuX01zZ1BhY2sgPSAoX2MgPSAoX2IgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5Nc2dQYWNrKSAhPSBudWxsID8gX2MgOiBudWxsO1xuICAgIGNvbnN0IG5vcm1hbE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0c19kZWZhdWx0Lm5vcm1hbGlzZU9wdGlvbnMob3B0aW9ucywgdGhpcy5fTXNnUGFjaywgdGhpcy5sb2dnZXIpO1xuICAgIGlmIChub3JtYWxPcHRpb25zLmtleSkge1xuICAgICAgY29uc3Qga2V5TWF0Y2ggPSBub3JtYWxPcHRpb25zLmtleS5tYXRjaCgvXihbXjpcXHNdKyk6KFteOi5cXHNdKykkLyk7XG4gICAgICBpZiAoIWtleU1hdGNoKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiaW52YWxpZCBrZXkgcGFyYW1ldGVyXCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkJhc2VDbGllbnQoKVwiLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKG1zZywgNDA0MDAsIDQwNCk7XG4gICAgICB9XG4gICAgICBub3JtYWxPcHRpb25zLmtleU5hbWUgPSBrZXlNYXRjaFsxXTtcbiAgICAgIG5vcm1hbE9wdGlvbnMua2V5U2VjcmV0ID0ga2V5TWF0Y2hbMl07XG4gICAgfVxuICAgIGlmIChcImNsaWVudElkXCIgaW4gbm9ybWFsT3B0aW9ucykge1xuICAgICAgaWYgKCEodHlwZW9mIG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09IFwic3RyaW5nXCIgfHwgbm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gbnVsbCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsXCIsIDQwMDEyLCA0MDApO1xuICAgICAgZWxzZSBpZiAobm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gXCIqXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgJ0NhblxcdTIwMTl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCB1c2Uge2RlZmF1bHRUb2tlblBhcmFtczoge2NsaWVudElkOiBcIipcIn19KScsXG4gICAgICAgICAgNDAwMTIsXG4gICAgICAgICAgNDAwXG4gICAgICAgICk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkJhc2VDbGllbnQoKVwiLCBcInN0YXJ0ZWQ7IHZlcnNpb24gPSBcIiArIGRlZmF1bHRzX2RlZmF1bHQudmVyc2lvbik7XG4gICAgdGhpcy5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLnNlcnZlclRpbWVPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMuaHR0cCA9IG5ldyBIdHRwKHRoaXMpO1xuICAgIHRoaXMuYXV0aCA9IG5ldyBhdXRoX2RlZmF1bHQodGhpcywgbm9ybWFsT3B0aW9ucyk7XG4gICAgdGhpcy5fcmVzdCA9ICgoX2QgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5SZXN0KSA/IG5ldyBvcHRpb25zLnBsdWdpbnMuUmVzdCh0aGlzKSA6IG51bGw7XG4gICAgdGhpcy5fQ3J5cHRvID0gKF9mID0gKF9lID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2UuQ3J5cHRvKSAhPSBudWxsID8gX2YgOiBudWxsO1xuICAgIHRoaXMuX19GaWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSAoX2ggPSAoX2cgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZy5NZXNzYWdlSW50ZXJhY3Rpb25zKSAhPSBudWxsID8gX2ggOiBudWxsO1xuICAgIHRoaXMuX0Fubm90YXRpb25zID0gKF9qID0gKF9pID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2kuQW5ub3RhdGlvbnMpICE9IG51bGwgPyBfaiA6IG51bGw7XG4gIH1cbiAgZ2V0IHJlc3QoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXN0KSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlJlc3RcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXN0O1xuICB9XG4gIGdldCBfRmlsdGVyZWRTdWJzY3JpcHRpb25zKCkge1xuICAgIGlmICghdGhpcy5fX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNZXNzYWdlSW50ZXJhY3Rpb25zXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucztcbiAgfVxuICBnZXQgY2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5jaGFubmVscztcbiAgfVxuICBnZXQgcHVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnB1c2g7XG4gIH1cbiAgLyoqIFJTSDggKi9cbiAgZGV2aWNlKCkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKCEoKF9hMiA9IHRoaXMub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpIHx8ICF0aGlzLnB1c2guTG9jYWxEZXZpY2UpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZXZpY2UpIHtcbiAgICAgIHRoaXMuX2RldmljZSA9IHRoaXMucHVzaC5Mb2NhbERldmljZS5sb2FkKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGV2aWNlO1xuICB9XG4gIGJhc2VVcmkoaG9zdCkge1xuICAgIHJldHVybiBkZWZhdWx0c19kZWZhdWx0LmdldEh0dHBTY2hlbWUodGhpcy5vcHRpb25zKSArIGhvc3QgKyBcIjpcIiArIGRlZmF1bHRzX2RlZmF1bHQuZ2V0UG9ydCh0aGlzLm9wdGlvbnMsIGZhbHNlKTtcbiAgfVxuICBhc3luYyBzdGF0cyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnN0YXRzKHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgdGltZShwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnRpbWUocGFyYW1zKTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KG1ldGhvZCwgcGF0aCwgdmVyc2lvbjIsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycykge1xuICAgIHJldHVybiB0aGlzLnJlc3QucmVxdWVzdChtZXRob2QsIHBhdGgsIHZlcnNpb24yLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMpO1xuICB9XG4gIGJhdGNoUHVibGlzaChzcGVjT3JTcGVjcykge1xuICAgIHJldHVybiB0aGlzLnJlc3QuYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKTtcbiAgfVxuICBiYXRjaFByZXNlbmNlKGNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5iYXRjaFByZXNlbmNlKGNoYW5uZWxzKTtcbiAgfVxuICBzZXRMb2cobG9nT3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyLnNldExvZyhsb2dPcHRpb25zLmxldmVsLCBsb2dPcHRpb25zLmhhbmRsZXIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdGltZSBiYXNlZCBvbiB0aGUgbG9jYWwgY2xvY2ssXG4gICAqIG9yIGlmIHRoZSBvcHRpb24gcXVlcnlUaW1lIGlzIHRydWUsIHJldHVybiB0aGUgc2VydmVyIHRpbWUuXG4gICAqIFRoZSBzZXJ2ZXIgdGltZSBvZmZzZXQgZnJvbSB0aGUgbG9jYWwgdGltZSBpcyBzdG9yZWQgc28gdGhhdFxuICAgKiBvbmx5IG9uZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IHRoZSB0aW1lIGlzIGV2ZXIgbmVlZGVkXG4gICAqL1xuICBhc3luYyBnZXRUaW1lc3RhbXAocXVlcnlUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpICYmIHF1ZXJ5VGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpO1xuICB9XG4gIGdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpICsgKHRoaXMuc2VydmVyVGltZU9mZnNldCB8fCAwKTtcbiAgfVxuICBpc1RpbWVPZmZzZXRTZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyVGltZU9mZnNldCAhPT0gbnVsbDtcbiAgfVxufTtcbkJhc2VDbGllbnQuUGxhdGZvcm0gPSBQbGF0Zm9ybTtcbnZhciBiYXNlY2xpZW50X2RlZmF1bHQgPSBCYXNlQ2xpZW50O1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZXZpY2VkZXRhaWxzLnRzXG52YXIgRGV2aWNlRGV0YWlscyA9IGNsYXNzIF9EZXZpY2VEZXRhaWxzIHtcbiAgdG9KU09OKCkge1xuICAgIHZhciBfYTIsIF9iLCBfYztcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBkZXZpY2VTZWNyZXQ6IHRoaXMuZGV2aWNlU2VjcmV0LFxuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICBmb3JtRmFjdG9yOiB0aGlzLmZvcm1GYWN0b3IsXG4gICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgZGV2aWNlSWRlbnRpdHlUb2tlbjogdGhpcy5kZXZpY2VJZGVudGl0eVRva2VuLFxuICAgICAgcHVzaDoge1xuICAgICAgICByZWNpcGllbnQ6IChfYTIgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVjaXBpZW50LFxuICAgICAgICBzdGF0ZTogKF9iID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc3RhdGUsXG4gICAgICAgIGVycm9yOiAoX2MgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYy5lcnJvclxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jLCBfZDtcbiAgICBsZXQgcmVzdWx0ID0gXCJbRGV2aWNlRGV0YWlsc1wiO1xuICAgIGlmICh0aGlzLmlkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBpZD1cIiArIHRoaXMuaWQ7XG4gICAgaWYgKHRoaXMucGxhdGZvcm0pXG4gICAgICByZXN1bHQgKz0gXCI7IHBsYXRmb3JtPVwiICsgdGhpcy5wbGF0Zm9ybTtcbiAgICBpZiAodGhpcy5mb3JtRmFjdG9yKVxuICAgICAgcmVzdWx0ICs9IFwiOyBmb3JtRmFjdG9yPVwiICsgdGhpcy5mb3JtRmFjdG9yO1xuICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBjbGllbnRJZD1cIiArIHRoaXMuY2xpZW50SWQ7XG4gICAgaWYgKHRoaXMubWV0YWRhdGEpXG4gICAgICByZXN1bHQgKz0gXCI7IG1ldGFkYXRhPVwiICsgdGhpcy5tZXRhZGF0YTtcbiAgICBpZiAodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKVxuICAgICAgcmVzdWx0ICs9IFwiOyBkZXZpY2VJZGVudGl0eVRva2VuPVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKTtcbiAgICBpZiAoKF9hMiA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZWNpcGllbnQpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2gucmVjaXBpZW50PVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLnJlY2lwaWVudCk7XG4gICAgaWYgKChfYiA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXRlKVxuICAgICAgcmVzdWx0ICs9IFwiOyBwdXNoLnN0YXRlPVwiICsgdGhpcy5wdXNoLnN0YXRlO1xuICAgIGlmICgoX2MgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYy5lcnJvcilcbiAgICAgIHJlc3VsdCArPSBcIjsgcHVzaC5lcnJvcj1cIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucHVzaC5lcnJvcik7XG4gICAgaWYgKChfZCA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLm1ldGFkYXRhKVxuICAgICAgcmVzdWx0ICs9IFwiOyBwdXNoLm1ldGFkYXRhPVwiICsgdGhpcy5wdXNoLm1ldGFkYXRhO1xuICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyB0b1JlcXVlc3RCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICAgIHJldHVybiBlbmNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gIH1cbiAgc3RhdGljIGZyb21SZXNwb25zZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgYm9keSA9IGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYm9keSkpIHtcbiAgICAgIHJldHVybiBfRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzQXJyYXkoYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzKGJvZHkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICB2YWx1ZXMuZXJyb3IgPSB2YWx1ZXMuZXJyb3IgJiYgRXJyb3JJbmZvLmZyb21WYWx1ZXModmFsdWVzLmVycm9yKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX0RldmljZURldGFpbHMoKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUxvY2FsRGV2aWNlKGRldmljZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfRGV2aWNlRGV0YWlscygpLCBkZXZpY2UpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgY29uc3QgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgIHJlc3VsdFtpXSA9IF9EZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xudmFyIGRldmljZWRldGFpbHNfZGVmYXVsdCA9IERldmljZURldGFpbHM7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXNvdXJjZS50c1xuYXN5bmMgZnVuY3Rpb24gd2l0aEF1dGhEZXRhaWxzKGNsaWVudCwgaGVhZGVycywgcGFyYW1zLCBvcENhbGxiYWNrKSB7XG4gIGlmIChjbGllbnQuaHR0cC5zdXBwb3J0c0F1dGhIZWFkZXJzKSB7XG4gICAgY29uc3QgYXV0aEhlYWRlcnMgPSBhd2FpdCBjbGllbnQuYXV0aC5nZXRBdXRoSGVhZGVycygpO1xuICAgIHJldHVybiBvcENhbGxiYWNrKG1peGluKGF1dGhIZWFkZXJzLCBoZWFkZXJzKSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhdXRoUGFyYW1zID0gYXdhaXQgY2xpZW50LmF1dGguZ2V0QXV0aFBhcmFtcygpO1xuICAgIHJldHVybiBvcENhbGxiYWNrKGhlYWRlcnMsIG1peGluKGF1dGhQYXJhbXMsIHBhcmFtcykpO1xuICB9XG59XG5mdW5jdGlvbiB1bmVudmVsb3BlKHJlc3VsdCwgTXNnUGFjaywgZm9ybWF0KSB7XG4gIGlmIChyZXN1bHQuZXJyICYmICFyZXN1bHQuYm9keSkge1xuICAgIHJldHVybiB7IGVycjogcmVzdWx0LmVyciB9O1xuICB9XG4gIGlmIChyZXN1bHQuc3RhdHVzQ29kZSA9PT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuTm9Db250ZW50KSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdCksIHsgYm9keTogW10sIHVucGFja2VkOiB0cnVlIH0pO1xuICB9XG4gIGxldCBib2R5ID0gcmVzdWx0LmJvZHk7XG4gIGlmICghcmVzdWx0LnVucGFja2VkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGUpKSB7XG4gICAgICAgIHJldHVybiB7IGVycjogZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBuZXcgUGFydGlhbEVycm9ySW5mbyhpbnNwZWN0RXJyb3IoZSksIG51bGwpIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghYm9keSkge1xuICAgIHJldHVybiB7IGVycjogbmV3IFBhcnRpYWxFcnJvckluZm8oXCJ1bmVudmVsb3BlKCk6IFJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZ1wiLCBudWxsKSB9O1xuICB9XG4gIGNvbnN0IHsgc3RhdHVzQ29kZTogd3JhcHBlZFN0YXR1c0NvZGUsIHJlc3BvbnNlLCBoZWFkZXJzOiB3cmFwcGVkSGVhZGVycyB9ID0gYm9keTtcbiAgaWYgKHdyYXBwZWRTdGF0dXNDb2RlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVzdWx0KSwgeyBib2R5LCB1bnBhY2tlZDogdHJ1ZSB9KTtcbiAgfVxuICBpZiAod3JhcHBlZFN0YXR1c0NvZGUgPCAyMDAgfHwgd3JhcHBlZFN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgbGV0IHdyYXBwZWRFcnIgPSByZXNwb25zZSAmJiByZXNwb25zZS5lcnJvciB8fCByZXN1bHQuZXJyO1xuICAgIGlmICghd3JhcHBlZEVycikge1xuICAgICAgd3JhcHBlZEVyciA9IG5ldyBFcnJvcihcIkVycm9yIGluIHVuZW52ZWxvcGluZyBcIiArIGJvZHkpO1xuICAgICAgd3JhcHBlZEVyci5zdGF0dXNDb2RlID0gd3JhcHBlZFN0YXR1c0NvZGU7XG4gICAgfVxuICAgIHJldHVybiB7IGVycjogd3JhcHBlZEVyciwgYm9keTogcmVzcG9uc2UsIGhlYWRlcnM6IHdyYXBwZWRIZWFkZXJzLCB1bnBhY2tlZDogdHJ1ZSwgc3RhdHVzQ29kZTogd3JhcHBlZFN0YXR1c0NvZGUgfTtcbiAgfVxuICByZXR1cm4geyBlcnI6IHJlc3VsdC5lcnIsIGJvZHk6IHJlc3BvbnNlLCBoZWFkZXJzOiB3cmFwcGVkSGVhZGVycywgdW5wYWNrZWQ6IHRydWUsIHN0YXR1c0NvZGU6IHdyYXBwZWRTdGF0dXNDb2RlIH07XG59XG5mdW5jdGlvbiBsb2dSZXN1bHQyKHJlc3VsdCwgbWV0aG9kLCBwYXRoLCBwYXJhbXMsIGxvZ2dlcikge1xuICBpZiAocmVzdWx0LmVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVzb3VyY2UuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkIEVycm9yOyBcIiArIGFwcGVuZGluZ1BhcmFtcyhwYXRoLCBwYXJhbXMpICsgXCI7IEVycm9yOiBcIiArIGluc3BlY3RFcnJvcihyZXN1bHQuZXJyKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQ7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHBhdGgsIHBhcmFtcykgKyBcIjsgSGVhZGVyczogXCIgKyBwYXJhbVN0cmluZyhyZXN1bHQuaGVhZGVycykgKyBcIjsgU3RhdHVzQ29kZTogXCIgKyByZXN1bHQuc3RhdHVzQ29kZSArIFwiOyBCb2R5OiBcIiArIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihyZXN1bHQuYm9keSkgPyBcIiAoQmFzZTY0KTogXCIgKyBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUocmVzdWx0LmJvZHkpIDogXCI6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QocmVzdWx0LmJvZHkpKVxuICAgICk7XG4gIH1cbn1cbnZhciBSZXNvdXJjZSA9IGNsYXNzIF9SZXNvdXJjZSB7XG4gIHN0YXRpYyBhc3luYyBnZXQoY2xpZW50LCBwYXRoLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgY2xpZW50LCBwYXRoLCBudWxsLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yICE9IG51bGwgPyB0aHJvd0Vycm9yIDogZmFsc2UpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZWxldGUoY2xpZW50LCBwYXRoLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LkRlbGV0ZSwgY2xpZW50LCBwYXRoLCBudWxsLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgcG9zdChjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuUG9zdCwgY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgcGF0Y2goY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LlBhdGNoLCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBwdXQoY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LlB1dCwgY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZG8obWV0aG9kLCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICBpZiAoZW52ZWxvcGUpIHtcbiAgICAgIChwYXJhbXMgPSBwYXJhbXMgfHwge30pW1wiZW52ZWxvcGVcIl0gPSBlbnZlbG9wZTtcbiAgICB9XG4gICAgY29uc3QgbG9nZ2VyID0gY2xpZW50LmxvZ2dlcjtcbiAgICBhc3luYyBmdW5jdGlvbiBkb1JlcXVlc3QoaGVhZGVyczIsIHBhcmFtczIpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAobG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgIGxldCBkZWNvZGVkQm9keSA9IGJvZHk7XG4gICAgICAgIGlmICgoKF9hMiA9IGhlYWRlcnMyW1wiY29udGVudC10eXBlXCJdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmluZGV4T2YoXCJtc2dwYWNrXCIpKSA+IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFjbGllbnQuX01zZ1BhY2spIHtcbiAgICAgICAgICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZEJvZHkgPSBjbGllbnQuX01zZ1BhY2suZGVjb2RlKGJvZHkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGRlY29kZUVycikge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgICAgICAgICAgXCJTZW5kaW5nIE1zZ1BhY2sgRGVjb2RpbmcgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKGRlY29kZUVycilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiUmVzb3VyY2UuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICAgICAgXCJTZW5kaW5nOyBcIiArIGFwcGVuZGluZ1BhcmFtcyhwYXRoLCBwYXJhbXMyKSArIFwiOyBCb2R5OiBcIiArIGRlY29kZWRCb2R5XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBodHRwUmVzdWx0ID0gYXdhaXQgY2xpZW50Lmh0dHAuZG8obWV0aG9kLCBwYXRoLCBoZWFkZXJzMiwgYm9keSwgcGFyYW1zMik7XG4gICAgICBpZiAoaHR0cFJlc3VsdC5lcnJvciAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycihodHRwUmVzdWx0LmVycm9yKSkge1xuICAgICAgICBhd2FpdCBjbGllbnQuYXV0aC5hdXRob3JpemUobnVsbCwgbnVsbCk7XG4gICAgICAgIHJldHVybiB3aXRoQXV0aERldGFpbHMoY2xpZW50LCBoZWFkZXJzMiwgcGFyYW1zMiwgZG9SZXF1ZXN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycjogaHR0cFJlc3VsdC5lcnJvcixcbiAgICAgICAgYm9keTogaHR0cFJlc3VsdC5ib2R5LFxuICAgICAgICBoZWFkZXJzOiBodHRwUmVzdWx0LmhlYWRlcnMsXG4gICAgICAgIHVucGFja2VkOiBodHRwUmVzdWx0LnVucGFja2VkLFxuICAgICAgICBzdGF0dXNDb2RlOiBodHRwUmVzdWx0LnN0YXR1c0NvZGVcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCB3aXRoQXV0aERldGFpbHMoY2xpZW50LCBoZWFkZXJzLCBwYXJhbXMsIGRvUmVxdWVzdCk7XG4gICAgaWYgKGVudmVsb3BlKSB7XG4gICAgICByZXN1bHQgPSB1bmVudmVsb3BlKHJlc3VsdCwgY2xpZW50Ll9Nc2dQYWNrLCBlbnZlbG9wZSk7XG4gICAgfVxuICAgIGlmIChsb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ1Jlc3VsdDIocmVzdWx0LCBtZXRob2QsIHBhdGgsIHBhcmFtcywgbG9nZ2VyKTtcbiAgICB9XG4gICAgaWYgKHRocm93RXJyb3IpIHtcbiAgICAgIGlmIChyZXN1bHQuZXJyKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IF9fc3ByZWFkVmFsdWVzKHt9LCByZXN1bHQpO1xuICAgICAgICBkZWxldGUgcmVzcG9uc2UuZXJyO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgcmVzb3VyY2VfZGVmYXVsdCA9IFJlc291cmNlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcGFnaW5hdGVkcmVzb3VyY2UudHNcbmZ1bmN0aW9uIGdldFJlbFBhcmFtcyhsaW5rVXJsKSB7XG4gIGNvbnN0IHVybE1hdGNoID0gbGlua1VybC5tYXRjaCgvXlxcLlxcLyhcXHcrKVxcPyguKikkLyk7XG4gIHJldHVybiB1cmxNYXRjaCAmJiB1cmxNYXRjaFsyXSAmJiBwYXJzZVF1ZXJ5U3RyaW5nKHVybE1hdGNoWzJdKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVsTGlua3MobGlua0hlYWRlcikge1xuICBpZiAodHlwZW9mIGxpbmtIZWFkZXIgPT0gXCJzdHJpbmdcIilcbiAgICBsaW5rSGVhZGVyID0gbGlua0hlYWRlci5zcGxpdChcIixcIik7XG4gIGNvbnN0IHJlbFBhcmFtcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtIZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5rTWF0Y2ggPSBsaW5rSGVhZGVyW2ldLm1hdGNoKC9eXFxzKjwoLispPjtcXHMqcmVsPVwiKFxcdyspXCIkLyk7XG4gICAgaWYgKGxpbmtNYXRjaCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZ2V0UmVsUGFyYW1zKGxpbmtNYXRjaFsxXSk7XG4gICAgICBpZiAocGFyYW1zKVxuICAgICAgICByZWxQYXJhbXNbbGlua01hdGNoWzJdXSA9IHBhcmFtcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbFBhcmFtcztcbn1cbmZ1bmN0aW9uIHJldHVybkVyck9ubHkoZXJyLCBib2R5LCB1c2VIUFIpIHtcbiAgcmV0dXJuICEodXNlSFBSICYmIChib2R5IHx8IHR5cGVvZiBlcnIuY29kZSA9PT0gXCJudW1iZXJcIikpO1xufVxudmFyIFBhZ2luYXRlZFJlc291cmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIHBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBib2R5SGFuZGxlciwgdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuZW52ZWxvcGUgPSBlbnZlbG9wZSAhPSBudWxsID8gZW52ZWxvcGUgOiBudWxsO1xuICAgIHRoaXMuYm9keUhhbmRsZXIgPSBib2R5SGFuZGxlcjtcbiAgICB0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSB8fCBmYWxzZTtcbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5sb2dnZXI7XG4gIH1cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmRlbGV0ZSh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBwb3N0KHBhcmFtcywgYm9keSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdCh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBwdXQocGFyYW1zLCBib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wdXQodGhpcy5jbGllbnQsIHRoaXMucGF0aCwgYm9keSwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgcGF0Y2gocGFyYW1zLCBib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wYXRjaCh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBoYW5kbGVQYWdlKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuZXJyICYmIHJldHVybkVyck9ubHkocmVzdWx0LmVyciwgcmVzdWx0LmJvZHksIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIlBhZ2luYXRlZFJlc291cmNlLmhhbmRsZVBhZ2UoKVwiLFxuICAgICAgICBcIlVuZXhwZWN0ZWQgZXJyb3IgZ2V0dGluZyByZXNvdXJjZTogZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IocmVzdWx0LmVycilcbiAgICAgICk7XG4gICAgICB0aHJvdyByZXN1bHQuZXJyO1xuICAgIH1cbiAgICBsZXQgaXRlbXMsIGxpbmtIZWFkZXIsIHJlbFBhcmFtcztcbiAgICB0cnkge1xuICAgICAgaXRlbXMgPSByZXN1bHQuc3RhdHVzQ29kZSA9PSBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdC5Ob0NvbnRlbnQgPyBbXSA6IGF3YWl0IHRoaXMuYm9keUhhbmRsZXIocmVzdWx0LmJvZHksIHJlc3VsdC5oZWFkZXJzIHx8IHt9LCByZXN1bHQudW5wYWNrZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IHJlc3VsdC5lcnIgfHwgZTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5oZWFkZXJzICYmIChsaW5rSGVhZGVyID0gcmVzdWx0LmhlYWRlcnNbXCJMaW5rXCJdIHx8IHJlc3VsdC5oZWFkZXJzW1wibGlua1wiXSkpIHtcbiAgICAgIHJlbFBhcmFtcyA9IHBhcnNlUmVsTGlua3MobGlua0hlYWRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIG5ldyBIdHRwUGFnaW5hdGVkUmVzcG9uc2UoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICByZXN1bHQuaGVhZGVycyB8fCB7fSxcbiAgICAgICAgcmVzdWx0LnN0YXR1c0NvZGUsXG4gICAgICAgIHJlbFBhcmFtcyxcbiAgICAgICAgcmVzdWx0LmVyclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQYWdpbmF0ZWRSZXN1bHQodGhpcywgaXRlbXMsIHJlbFBhcmFtcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFBhZ2luYXRlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpIHtcbiAgICB0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgIHRoaXMuX3JlbFBhcmFtcyA9IHJlbFBhcmFtcztcbiAgfVxuICBhc3luYyBmaXJzdCgpIHtcbiAgICBpZiAodGhpcy5oYXNGaXJzdCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5fcmVsUGFyYW1zLmZpcnN0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIk5vIGxpbmsgdG8gdGhlIGZpcnN0IHBhZ2Ugb2YgcmVzdWx0c1wiLCA0MDQwMCwgNDA0KTtcbiAgfVxuICBhc3luYyBjdXJyZW50KCkge1xuICAgIGlmICh0aGlzLmhhc0N1cnJlbnQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuX3JlbFBhcmFtcy5jdXJyZW50KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIk5vIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGFnZSBvZiByZXN1bHRzXCIsIDQwNDAwLCA0MDQpO1xuICB9XG4gIGFzeW5jIG5leHQoKSB7XG4gICAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5fcmVsUGFyYW1zLm5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoYXNGaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVsUGFyYW1zICE9IG51bGwgJiYgXCJmaXJzdFwiIGluIHRoaXMuX3JlbFBhcmFtcztcbiAgfVxuICBoYXNDdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxQYXJhbXMgIT0gbnVsbCAmJiBcImN1cnJlbnRcIiBpbiB0aGlzLl9yZWxQYXJhbXM7XG4gIH1cbiAgaGFzTmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVsUGFyYW1zICE9IG51bGwgJiYgXCJuZXh0XCIgaW4gdGhpcy5fcmVsUGFyYW1zO1xuICB9XG4gIGlzTGFzdCgpIHtcbiAgICByZXR1cm4gIXRoaXMuaGFzTmV4dCgpO1xuICB9XG4gIC8qIFdlIGFzc3VtZSB0aGF0IG9ubHkgdGhlIGluaXRpYWwgcmVxdWVzdCBjYW4gYmUgYSBQT1NULCBhbmQgdGhhdCBhY2Nlc3NpbmdcbiAgICogdGhlIHJlc3Qgb2YgYSBtdWx0aXBhZ2Ugc2V0IG9mIHJlc3VsdHMgY2FuIGFsd2F5cyBiZSBkb25lIHdpdGggR0VUICovXG4gIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICBjb25zdCByZXMgPSB0aGlzLnJlc291cmNlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KHJlcy5jbGllbnQsIHJlcy5wYXRoLCByZXMuaGVhZGVycywgcGFyYW1zLCByZXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gcmVzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxufTtcbnZhciBIdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIFBhZ2luYXRlZFJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yKHJlc291cmNlLCBpdGVtcywgaGVhZGVycywgc3RhdHVzQ29kZSwgcmVsUGFyYW1zLCBlcnIpIHtcbiAgICBzdXBlcihyZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcyk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN1Y2Nlc3MgPSBzdGF0dXNDb2RlIDwgMzAwICYmIHN0YXR1c0NvZGUgPj0gMjAwO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnIgJiYgZXJyLmNvZGU7XG4gICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgIHN1Y2Nlc3M6IHRoaXMuc3VjY2VzcyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGVycm9yQ29kZTogdGhpcy5lcnJvckNvZGUsXG4gICAgICBlcnJvck1lc3NhZ2U6IHRoaXMuZXJyb3JNZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0ID0gUGFnaW5hdGVkUmVzb3VyY2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3B1c2hjaGFubmVsc3Vic2NyaXB0aW9uLnRzXG52YXIgX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uID0gY2xhc3MgX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uIHtcbiAgLyoqXG4gICAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcbiAgICAgIGRldmljZUlkOiB0aGlzLmRldmljZUlkLFxuICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWRcbiAgICB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCByZXN1bHQgPSBcIltQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvblwiO1xuICAgIGlmICh0aGlzLmNoYW5uZWwpXG4gICAgICByZXN1bHQgKz0gXCI7IGNoYW5uZWw9XCIgKyB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKHRoaXMuZGV2aWNlSWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGRldmljZUlkPVwiICsgdGhpcy5kZXZpY2VJZDtcbiAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgIHJlc3VsdCArPSBcIjsgY2xpZW50SWQ9XCIgKyB0aGlzLmNsaWVudElkO1xuICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBmcm9tUmVzcG9uc2VCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIGJvZHkgPSBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGJvZHkpKSB7XG4gICAgICByZXR1cm4gX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXNBcnJheShib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKGJvZHkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICBjb25zdCBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgcmVzdWx0W2ldID0gX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnRvUmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5O1xudmFyIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uID0gX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uO1xudmFyIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX2RlZmF1bHQgPSBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbjtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3B1c2gudHNcbnZhciBQdXNoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuYWRtaW4gPSBuZXcgQWRtaW4oY2xpZW50KTtcbiAgICBpZiAoUGxhdGZvcm0uQ29uZmlnLnB1c2ggJiYgKChfYTIgPSBjbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpKSB7XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZSA9IG5ldyBjbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guQWN0aXZhdGlvblN0YXRlTWFjaGluZShjbGllbnQpO1xuICAgICAgdGhpcy5Mb2NhbERldmljZSA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5sb2NhbERldmljZUZhY3RvcnkoZGV2aWNlZGV0YWlsc19kZWZhdWx0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWN0aXZhdGUocmVnaXN0ZXJDYWxsYmFjaywgdXBkYXRlRmFpbGVkQ2FsbGJhY2spIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKCEoKF9hMiA9IHRoaXMuY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5QdXNoKSkge1xuICAgICAgICByZWplY3QoY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJUaGlzIHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYSB0YXJnZXQgb2YgcHVzaCBub3RpZmljYXRpb25zXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlTWFjaGluZS5hY3RpdmF0ZWRDYWxsYmFjaykge1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIkFjdGl2YXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiLCA0ZTQsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS5hY3RpdmF0ZWRDYWxsYmFjayA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUudXBkYXRlRmFpbGVkQ2FsbGJhY2sgPSB1cGRhdGVGYWlsZWRDYWxsYmFjaztcbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLmhhbmRsZUV2ZW50KFxuICAgICAgICBuZXcgdGhpcy5jbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guQ2FsbGVkQWN0aXZhdGUodGhpcy5zdGF0ZU1hY2hpbmUsIHJlZ2lzdGVyQ2FsbGJhY2spXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlYWN0aXZhdGUoZGVyZWdpc3RlckNhbGxiYWNrKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICghKChfYTIgPSB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkpIHtcbiAgICAgICAgcmVqZWN0KGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcihcIlB1c2hcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVNYWNoaW5lKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVGhpcyBwbGF0Zm9ybSBpcyBub3Qgc3VwcG9ydGVkIGFzIGEgdGFyZ2V0IG9mIHB1c2ggbm90aWZpY2F0aW9uc1wiLCA0ZTQsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZU1hY2hpbmUuZGVhY3RpdmF0ZWRDYWxsYmFjaykge1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIkRlYWN0aXZhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLmRlYWN0aXZhdGVkQ2FsbGJhY2sgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLmhhbmRsZUV2ZW50KFxuICAgICAgICBuZXcgdGhpcy5jbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guQ2FsbGVkRGVhY3RpdmF0ZSh0aGlzLnN0YXRlTWFjaGluZSwgZGVyZWdpc3RlckNhbGxiYWNrKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBBZG1pbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5kZXZpY2VSZWdpc3RyYXRpb25zID0gbmV3IERldmljZVJlZ2lzdHJhdGlvbnMoY2xpZW50KTtcbiAgICB0aGlzLmNoYW5uZWxTdWJzY3JpcHRpb25zID0gbmV3IENoYW5uZWxTdWJzY3JpcHRpb25zKGNsaWVudCk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChyZWNpcGllbnQsIHBheWxvYWQpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpLCBwYXJhbXMgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gbWl4aW4oeyByZWNpcGllbnQgfSwgcGF5bG9hZCk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoY2xpZW50LCBcIi9wdXNoL3B1Ymxpc2hcIiwgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgdHJ1ZSk7XG4gIH1cbn07XG52YXIgRGV2aWNlUmVnaXN0cmF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgYXN5bmMgc2F2ZShkZXZpY2UpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBib2R5ID0gZGV2aWNlZGV0YWlsc19kZWZhdWx0LmZyb21WYWx1ZXMoZGV2aWNlKTtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpLCBwYXJhbXMgPSB7fTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wdXQoXG4gICAgICBjbGllbnQsXG4gICAgICBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlLmlkKSxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gZGV2aWNlZGV0YWlsc19kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgcmVzcG9uc2UudW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldChkZXZpY2VJZE9yRGV0YWlscykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyksIGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG4gICAgaWYgKHR5cGVvZiBkZXZpY2VJZCAhPT0gXCJzdHJpbmdcIiB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIkZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjZ2V0IG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlsc1wiLFxuICAgICAgICA0ZTQsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldChcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksXG4gICAgICBoZWFkZXJzLFxuICAgICAge30sXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIGRldmljZWRldGFpbHNfZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgIHJlc3BvbnNlLnVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgKTtcbiAgfVxuICBhc3luYyBsaXN0KHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9uc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICByZXR1cm4gZGV2aWNlZGV0YWlsc19kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgICAgdW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICAgICk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlKGRldmljZUlkT3JEZXRhaWxzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKSwgcGFyYW1zID0ge30sIGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG4gICAgaWYgKHR5cGVvZiBkZXZpY2VJZCAhPT0gXCJzdHJpbmdcIiB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIkZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjcmVtb3ZlIG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlsc1wiLFxuICAgICAgICA0ZTQsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgYXdhaXQgcmVzb3VyY2VfZGVmYXVsdFtcImRlbGV0ZVwiXShcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zLFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG4gIGFzeW5jIHJlbW92ZVdoZXJlKHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgYXdhaXQgcmVzb3VyY2VfZGVmYXVsdFtcImRlbGV0ZVwiXShjbGllbnQsIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9uc1wiLCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIHRydWUpO1xuICB9XG59O1xudmFyIENoYW5uZWxTdWJzY3JpcHRpb25zID0gY2xhc3MgX0NoYW5uZWxTdWJzY3JpcHRpb25zIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgLyogQ2hhbm5lbFN1YnNjcmlwdGlvbnMgaGF2ZSBubyB1bmlxdWUgaWQ7IHJlbW92aW5nIG9uZSBpcyBlcXVpdmFsZW50IHRvIHJlbW92ZVdoZXJlIGJ5IGl0cyBwcm9wZXJ0aWVzICovXG4gICAgdGhpcy5yZW1vdmUgPSBfQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIGFzeW5jIHNhdmUoc3Vic2NyaXB0aW9uKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgYm9keSA9IHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX2RlZmF1bHQuZnJvbVZhbHVlcyhzdWJzY3JpcHRpb24pO1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucyksIHBhcmFtcyA9IHt9O1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoXG4gICAgICBjbGllbnQsXG4gICAgICBcIi9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zXCIsXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICByZXNwb25zZS51bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICk7XG4gIH1cbiAgYXN5bmMgbGlzdChwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSB0aGlzLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoY2xpZW50LCBcIi9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zXCIsIGhlYWRlcnMsIGVudmVsb3BlLCBhc3luYyBmdW5jdGlvbihib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpIHtcbiAgICAgIHJldHVybiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgICAgdW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICAgICk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlV2hlcmUocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0W1wiZGVsZXRlXCJdKGNsaWVudCwgXCIvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9uc1wiLCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIHRydWUpO1xuICB9XG4gIGFzeW5jIGxpc3RDaGFubmVscyhwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSB0aGlzLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoY2xpZW50LCBcIi9wdXNoL2NoYW5uZWxzXCIsIGhlYWRlcnMsIGVudmVsb3BlLCBhc3luYyBmdW5jdGlvbihib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSAhdW5wYWNrZWQgJiYgZm9ybWF0ID8gZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCkgOiBib2R5O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWRCb2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnNlZEJvZHlbaV0gPSBTdHJpbmcocGFyc2VkQm9keVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkQm9keTtcbiAgICB9KS5nZXQocGFyYW1zKTtcbiAgfVxufTtcbnZhciBwdXNoX2RlZmF1bHQgPSBQdXNoO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wcmVzZW5jZW1lc3NhZ2UudHNcbnZhciBhY3Rpb25zMiA9IFtcImFic2VudFwiLCBcInByZXNlbnRcIiwgXCJlbnRlclwiLCBcImxlYXZlXCIsIFwidXBkYXRlXCJdO1xuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWQobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkLCBpbnB1dE9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMoQ3J5cHRvMiwgbG9nZ2VyLCBpbnB1dE9wdGlvbnMgIT0gbnVsbCA/IGlucHV0T3B0aW9ucyA6IG51bGwpO1xuICBjb25zdCB3cG0gPSBXaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XG4gIHJldHVybiB3cG0uZGVjb2RlKG9wdGlvbnMsIGxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZEFycmF5KGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHJldHVybiBmcm9tRW5jb2RlZChsb2dnZXIsIENyeXB0bzIsIGVuY29kZWQsIG9wdGlvbnMpO1xuICAgIH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWQoZW5jb2RlZCwgY2hhbm5lbCkge1xuICByZXR1cm4gV2lyZVByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQpLmRlY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zLCBjaGFubmVsLmxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIGNoYW5uZWwpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZChlbmNvZGVkLCBjaGFubmVsKTtcbiAgICB9KVxuICApO1xufVxudmFyIFByZXNlbmNlTWVzc2FnZSA9IGNsYXNzIF9QcmVzZW5jZU1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIC8qIFJldHVybnMgd2hldGhlciB0aGlzIHByZXNlbmNlTWVzc2FnZSBpcyBzeW50aGVzaXplZCwgaS5lLiB3YXMgbm90IGFjdHVhbGx5XG4gICAqIHNlbnQgYnkgdGhlIGNvbm5lY3Rpb24gKHVzdWFsbHkgbWVhbnMgYSBsZWF2ZSBldmVudCBzZW50IDE1cyBhZnRlciBhXG4gICAqIGRpc2Nvbm5lY3Rpb24pLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIHN5bnRoZXNpemVkIG1lc3NhZ2VzIGNhbm5vdCBiZVxuICAgKiBjb21wYXJlZCBmb3IgbmV3bmVzcyBieSBpZCBsZXhpY29ncmFwaGljYWxseSAtIFJUUDJiMVxuICAgKi9cbiAgaXNTeW50aGVzaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaWQgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWQuc3Vic3RyaW5nKHRoaXMuY29ubmVjdGlvbklkLmxlbmd0aCwgMCkgIT09IHRoaXMuY29ubmVjdGlvbklkO1xuICB9XG4gIC8qIFJUUDJiMiAqL1xuICBwYXJzZUlkKCkge1xuICAgIGlmICghdGhpcy5pZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBhcnNlSWQoKTogUHJlc2VuY2UgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGFuIGlkXCIpO1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5pZC5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbm5lY3Rpb25JZDogcGFydHNbMF0sXG4gICAgICBtc2dTZXJpYWw6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgICBpbmRleDogcGFyc2VJbnQocGFydHNbMl0sIDEwKVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZW5jb2RlKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBXaXJlUHJlc2VuY2VNZXNzYWdlKCksIHRoaXMsIHtcbiAgICAgIGFjdGlvbjogYWN0aW9uczIuaW5kZXhPZih0aGlzLmFjdGlvbiB8fCBcInByZXNlbnRcIilcbiAgICB9KTtcbiAgICByZXR1cm4gZW5jb2RlKHJlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9QcmVzZW5jZU1lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXModikpO1xuICB9XG4gIHN0YXRpYyBmcm9tRGF0YShkYXRhKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBfUHJlc2VuY2VNZXNzYWdlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIF9QcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh7XG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIlByZXNlbmNlTWVzc2FnZVwiKTtcbiAgfVxufTtcbnZhciBXaXJlUHJlc2VuY2VNZXNzYWdlID0gY2xhc3MgX1dpcmVQcmVzZW5jZU1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIHRvSlNPTiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHdpcmVUb0pTT04uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1dpcmVQcmVzZW5jZU1lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfV2lyZVByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHYpKTtcbiAgfVxuICBhc3luYyBkZWNvZGUoY2hhbm5lbE9wdGlvbnMsIGxvZ2dlcikge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFByZXNlbmNlTWVzc2FnZSgpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzKSwge1xuICAgICAgYWN0aW9uOiBhY3Rpb25zMlt0aGlzLmFjdGlvbl1cbiAgICB9KSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGRlY29kZShyZXMsIGNoYW5uZWxPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2lyZVByZXNlbmNlTWVzc2FnZS5kZWNvZGUoKVwiLCBpbnNwZWN0RXJyb3IoZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJNc2codGhpcywgXCJXaXJlUHJlc2VuY2VNZXNzYWdlXCIpO1xuICB9XG59O1xudmFyIHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0ID0gUHJlc2VuY2VNZXNzYWdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdHByZXNlbmNlLnRzXG52YXIgUmVzdFByZXNlbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwubG9nZ2VyO1xuICB9XG4gIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0UHJlc2VuY2UuZ2V0KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSk7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jaGFubmVsLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSB0aGlzLmNoYW5uZWwuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChcbiAgICAgIGNsaWVudCxcbiAgICAgIHRoaXMuY2hhbm5lbC5jbGllbnQucmVzdC5wcmVzZW5jZU1peGluLmJhc2VQYXRoKHRoaXMpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkgPT4ge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICAgIHJldHVybiBfZnJvbUVuY29kZWRBcnJheShkZWNvZGVkLCB0aGlzLmNoYW5uZWwpO1xuICAgICAgfVxuICAgICkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgaGlzdG9yeShwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0UHJlc2VuY2UuaGlzdG9yeSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuY2xpZW50LnJlc3QucHJlc2VuY2VNaXhpbi5oaXN0b3J5KHRoaXMsIHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcmVzdHByZXNlbmNlX2RlZmF1bHQgPSBSZXN0UHJlc2VuY2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL21lc3NhZ2UudHNcbnZhciBhY3Rpb25zMyA9IFtcbiAgXCJtZXNzYWdlLmNyZWF0ZVwiLFxuICBcIm1lc3NhZ2UudXBkYXRlXCIsXG4gIFwibWVzc2FnZS5kZWxldGVcIixcbiAgXCJtZXRhXCIsXG4gIFwibWVzc2FnZS5zdW1tYXJ5XCIsXG4gIFwibWVzc2FnZS5hcHBlbmRcIlxuXTtcbmZ1bmN0aW9uIHN0cmluZ2lmeUFjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIGFjdGlvbnMzW2FjdGlvbiB8fCAwXSB8fCBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VTaXplKG1zZykge1xuICBsZXQgc2l6ZSA9IDA7XG4gIGlmIChtc2cubmFtZSkge1xuICAgIHNpemUgKz0gbXNnLm5hbWUubGVuZ3RoO1xuICB9XG4gIGlmIChtc2cuY2xpZW50SWQpIHtcbiAgICBzaXplICs9IG1zZy5jbGllbnRJZC5sZW5ndGg7XG4gIH1cbiAgaWYgKG1zZy5leHRyYXMpIHtcbiAgICBzaXplICs9IEpTT04uc3RyaW5naWZ5KG1zZy5leHRyYXMpLmxlbmd0aDtcbiAgfVxuICBpZiAobXNnLmRhdGEpIHtcbiAgICBzaXplICs9IGRhdGFTaXplQnl0ZXMobXNnLmRhdGEpO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWQyKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVDaXBoZXJPcHRpb25zKENyeXB0bzIsIGxvZ2dlciwgaW5wdXRPcHRpb25zICE9IG51bGwgPyBpbnB1dE9wdGlvbnMgOiBudWxsKTtcbiAgY29uc3Qgd20gPSBXaXJlTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQpO1xuICByZXR1cm4gd20uZGVjb2RlKG9wdGlvbnMsIGxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZEFycmF5Mihsb2dnZXIsIENyeXB0bzIsIGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gZnJvbUVuY29kZWQyKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZDIoZW5jb2RlZCwgY2hhbm5lbCkge1xuICBjb25zdCB3bSA9IFdpcmVNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XG4gIHJldHVybiB3bS5kZWNvZGUoY2hhbm5lbC5jaGFubmVsT3B0aW9ucywgY2hhbm5lbC5sb2dnZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gX2Zyb21FbmNvZGVkQXJyYXkyKGVuY29kZWRBcnJheSwgY2hhbm5lbCkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkMihlbmNvZGVkLCBjaGFubmVsKTtcbiAgICB9KVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jb2RlQXJyYXkobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5lbmNvZGUob3B0aW9ucykpKTtcbn1cbnZhciBzZXJpYWxpemUgPSBlbmNvZGVCb2R5O1xuZnVuY3Rpb24gZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKSB7XG4gIGxldCBtc2csIHRvdGFsID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgIG1zZyA9IG1lc3NhZ2VzW2ldO1xuICAgIHRvdGFsICs9IG1zZy5zaXplIHx8IChtc2cuc2l6ZSA9IGdldE1lc3NhZ2VTaXplKG1zZykpO1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn1cbnZhciBNZXNzYWdlID0gY2xhc3MgX01lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIGV4cGFuZEZpZWxkcygpIHtcbiAgICBpZiAoIXRoaXMudmVyc2lvbikge1xuICAgICAgdGhpcy52ZXJzaW9uID0ge307XG4gICAgfVxuICAgIGlmICghdGhpcy52ZXJzaW9uLnNlcmlhbCAmJiB0aGlzLnNlcmlhbCkge1xuICAgICAgdGhpcy52ZXJzaW9uLnNlcmlhbCA9IHRoaXMuc2VyaWFsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudmVyc2lvbi50aW1lc3RhbXAgJiYgdGhpcy50aW1lc3RhbXApIHtcbiAgICAgIHRoaXMudmVyc2lvbi50aW1lc3RhbXAgPSB0aGlzLnRpbWVzdGFtcDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25zKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zID0ge1xuICAgICAgICBzdW1tYXJ5OiB7fVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmFubm90YXRpb25zLnN1bW1hcnkpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuc3VtbWFyeSA9IHt9O1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9ucyAmJiB0aGlzLmFubm90YXRpb25zLnN1bW1hcnkpIHtcbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHN1bW1hcnlFbnRyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5hbm5vdGF0aW9ucy5zdW1tYXJ5KSkge1xuICAgICAgICBpZiAodHlwZS5lbmRzV2l0aChcIjpkaXN0aW5jdC52MVwiKSB8fCB0eXBlLmVuZHNXaXRoKFwiOnVuaXF1ZS52MVwiKSB8fCB0eXBlLmVuZHNXaXRoKFwiOm11bHRpcGxlLnYxXCIpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbLCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXMoc3VtbWFyeUVudHJ5KSkge1xuICAgICAgICAgICAgaWYgKCFlbnRyeS5jbGlwcGVkKSB7XG4gICAgICAgICAgICAgIGVudHJ5LmNsaXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5lbmRzV2l0aChcIjpmbGFnLnYxXCIpKSB7XG4gICAgICAgICAgaWYgKCFzdW1tYXJ5RW50cnkuY2xpcHBlZCkge1xuICAgICAgICAgICAgc3VtbWFyeUVudHJ5LmNsaXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZW5jb2RlKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBXaXJlTWVzc2FnZSgpLCB0aGlzLCB7XG4gICAgICBhY3Rpb246IGFjdGlvbnMzLmluZGV4T2YodGhpcy5hY3Rpb24gfHwgXCJtZXNzYWdlLmNyZWF0ZVwiKVxuICAgIH0pO1xuICAgIHJldHVybiBlbmNvZGUocmVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX01lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfTWVzc2FnZS5mcm9tVmFsdWVzKHYpKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiTWVzc2FnZVwiKTtcbiAgfVxufTtcbnZhciBXaXJlTWVzc2FnZSA9IGNsYXNzIF9XaXJlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgLy8gT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcbiAgdG9KU09OKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gd2lyZVRvSlNPTi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfV2lyZU1lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfV2lyZU1lc3NhZ2UuZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgLy8gZm9yIGNvbnRleHRzIHdoZXJlIHNvbWUgZGVjb2RpbmcgZXJyb3JzIG5lZWQgdG8gYmUgaGFuZGxlZCBzcGVjaWFsbHkgYnkgdGhlIGNhbGxlclxuICBhc3luYyBkZWNvZGVXaXRoRXJyKGlucHV0Q29udGV4dCwgbG9nZ2VyKSB7XG4gICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbihuZXcgTWVzc2FnZSgpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzKSwge1xuICAgICAgYWN0aW9uOiBzdHJpbmdpZnlBY3Rpb24odGhpcy5hY3Rpb24pXG4gICAgfSkpO1xuICAgIGxldCBlcnI7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGRlY29kZShyZXMsIGlucHV0Q29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIldpcmVNZXNzYWdlLmRlY29kZSgpXCIsIGluc3BlY3RFcnJvcihlKSk7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICByZXMuZXhwYW5kRmllbGRzKCk7XG4gICAgcmV0dXJuIHsgZGVjb2RlZDogcmVzLCBlcnIgfTtcbiAgfVxuICBhc3luYyBkZWNvZGUoaW5wdXRDb250ZXh0LCBsb2dnZXIpIHtcbiAgICBjb25zdCB7IGRlY29kZWQgfSA9IGF3YWl0IHRoaXMuZGVjb2RlV2l0aEVycihpbnB1dENvbnRleHQsIGxvZ2dlcik7XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIldpcmVNZXNzYWdlXCIpO1xuICB9XG59O1xudmFyIG1lc3NhZ2VfZGVmYXVsdCA9IE1lc3NhZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0Y2hhbm5lbC50c1xudmFyIE1TR19JRF9FTlRST1BZX0JZVEVTID0gOTtcbmZ1bmN0aW9uIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSB7XG4gIHJldHVybiBtZXNzYWdlcy5ldmVyeShmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgcmV0dXJuICFtZXNzYWdlLmlkO1xuICB9KTtcbn1cbnZhciBSZXN0Q2hhbm5lbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIHRoaXMuX2Fubm90YXRpb25zID0gbnVsbDtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oY2xpZW50LmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlc3RDaGFubmVsKClcIiwgXCJzdGFydGVkOyBuYW1lID0gXCIgKyBuYW1lKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucHJlc2VuY2UgPSBuZXcgcmVzdHByZXNlbmNlX2RlZmF1bHQodGhpcyk7XG4gICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKChfYTIgPSBjbGllbnQuX0NyeXB0bykgIT0gbnVsbCA/IF9hMiA6IG51bGwsIHRoaXMubG9nZ2VyLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgaWYgKChfYiA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5QdXNoKSB7XG4gICAgICB0aGlzLl9wdXNoID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5QdXNoQ2hhbm5lbCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKGNsaWVudC5fQW5ub3RhdGlvbnMpIHtcbiAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gbmV3IGNsaWVudC5fQW5ub3RhdGlvbnMuUmVzdEFubm90YXRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBnZXQgYW5ub3RhdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLl9hbm5vdGF0aW9ucykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJBbm5vdGF0aW9uc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Fubm90YXRpb25zO1xuICB9XG4gIGdldCBwdXNoKCkge1xuICAgIGlmICghdGhpcy5fcHVzaCkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVzaDtcbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5sb2dnZXI7XG4gIH1cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9hMjtcbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IHRoaXMuY2xpZW50Ll9DcnlwdG8pICE9IG51bGwgPyBfYTIgOiBudWxsLCB0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgaGlzdG9yeShwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0Q2hhbm5lbC5oaXN0b3J5KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5oaXN0b3J5KHRoaXMsIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaCguLi5hcmdzKSB7XG4gICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdLCBzZWNvbmQgPSBhcmdzWzFdO1xuICAgIGxldCBtZXNzYWdlcztcbiAgICBsZXQgcGFyYW1zO1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgfHwgZmlyc3QgPT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKHsgbmFtZTogZmlyc3QsIGRhdGE6IHNlY29uZCB9KV07XG4gICAgICBwYXJhbXMgPSBhcmdzWzJdO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlyc3QpKSB7XG4gICAgICBtZXNzYWdlcyA9IFttZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyhmaXJzdCldO1xuICAgICAgcGFyYW1zID0gYXJnc1sxXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3QpKSB7XG4gICAgICBtZXNzYWdlcyA9IG1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzQXJyYXkoZmlyc3QpO1xuICAgICAgcGFyYW1zID0gYXJnc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJUaGUgc2luZ2xlLWFyZ3VtZW50IGZvcm0gb2YgcHVibGlzaCgpIGV4cGVjdHMgYSBtZXNzYWdlIG9iamVjdCBvciBhbiBhcnJheSBvZiBtZXNzYWdlIG9iamVjdHNcIixcbiAgICAgICAgNDAwMTMsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHBhcmFtcyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgb3B0aW9ucyA9IGNsaWVudC5vcHRpb25zLCBmb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IGNsaWVudC5vcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgJiYgYWxsRW1wdHlJZHMobWVzc2FnZXMpKSB7XG4gICAgICBjb25zdCBtc2dJZEJhc2UgPSBhd2FpdCByYW5kb21TdHJpbmcoTVNHX0lEX0VOVFJPUFlfQllURVMpO1xuICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbihtZXNzYWdlLCBpbmRleCkge1xuICAgICAgICBtZXNzYWdlLmlkID0gbXNnSWRCYXNlICsgXCI6XCIgKyBpbmRleC50b1N0cmluZygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHdpcmVNZXNzYWdlcyA9IGF3YWl0IGVuY29kZUFycmF5KG1lc3NhZ2VzLCB0aGlzLmNoYW5uZWxPcHRpb25zKTtcbiAgICBjb25zdCBzaXplID0gZ2V0TWVzc2FnZXNTaXplKHdpcmVNZXNzYWdlcyksIG1heE1lc3NhZ2VTaXplID0gb3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICBpZiAoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBgTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICh3YXMgJHtzaXplfSBieXRlczsgbGltaXQgaXMgJHttYXhNZXNzYWdlU2l6ZX0gYnl0ZXMpYCxcbiAgICAgICAgNDAwMDksXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1Ymxpc2goc2VyaWFsaXplKHdpcmVNZXNzYWdlcywgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpLCBoZWFkZXJzLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIF9wdWJsaXNoKHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovO1xuICAgIGNvbnN0IHsgYm9keSwgdW5wYWNrZWQgfSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIGNsaWVudCxcbiAgICAgIGNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5iYXNlUGF0aCh0aGlzKSArIFwiL21lc3NhZ2VzXCIsXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3QgZGVjb2RlZCA9ICh1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KSkgfHwge307XG4gICAgZGVsZXRlIGRlY29kZWRbXCJjaGFubmVsXCJdO1xuICAgIGRlbGV0ZSBkZWNvZGVkW1wibWVzc2FnZUlkXCJdO1xuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG4gIGFzeW5jIHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uc3RhdHVzKHRoaXMpO1xuICB9XG4gIGFzeW5jIGdldE1lc3NhZ2Uoc2VyaWFsT3JNZXNzYWdlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVzdENoYW5uZWwuZ2V0TWVzc2FnZSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uZ2V0TWVzc2FnZSh0aGlzLCBzZXJpYWxPck1lc3NhZ2UpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1lc3NhZ2UobWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0Q2hhbm5lbC51cGRhdGVNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi51cGRhdGVEZWxldGVNZXNzYWdlKHRoaXMsIFwibWVzc2FnZS51cGRhdGVcIiwgbWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGRlbGV0ZU1lc3NhZ2UobWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0Q2hhbm5lbC5kZWxldGVNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi51cGRhdGVEZWxldGVNZXNzYWdlKHRoaXMsIFwibWVzc2FnZS5kZWxldGVcIiwgbWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGFwcGVuZE1lc3NhZ2UobWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0Q2hhbm5lbC5hcHBlbmRNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi51cGRhdGVEZWxldGVNZXNzYWdlKHRoaXMsIFwibWVzc2FnZS5hcHBlbmRcIiwgbWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGdldE1lc3NhZ2VWZXJzaW9ucyhzZXJpYWxPck1lc3NhZ2UsIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLmdldE1lc3NhZ2VWZXJzaW9ucygpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uZ2V0TWVzc2FnZVZlcnNpb25zKHRoaXMsIHNlcmlhbE9yTWVzc2FnZSwgcGFyYW1zKTtcbiAgfVxufTtcbnZhciByZXN0Y2hhbm5lbF9kZWZhdWx0ID0gUmVzdENoYW5uZWw7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3N0YXRzLnRzXG52YXIgU3RhdHMgPSBjbGFzcyBfU3RhdHMge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICB0aGlzLmVudHJpZXMgPSB2YWx1ZXMgJiYgdmFsdWVzLmVudHJpZXMgfHwgdm9pZCAwO1xuICAgIHRoaXMuc2NoZW1hID0gdmFsdWVzICYmIHZhbHVlcy5zY2hlbWEgfHwgdm9pZCAwO1xuICAgIHRoaXMuYXBwSWQgPSB2YWx1ZXMgJiYgdmFsdWVzLmFwcElkIHx8IHZvaWQgMDtcbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSB2YWx1ZXMgJiYgdmFsdWVzLmluUHJvZ3Jlc3MgfHwgdm9pZCAwO1xuICAgIHRoaXMudW5pdCA9IHZhbHVlcyAmJiB2YWx1ZXMudW5pdCB8fCB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcnZhbElkID0gdmFsdWVzICYmIHZhbHVlcy5pbnRlcnZhbElkIHx8IHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IF9TdGF0cyh2YWx1ZXMpO1xuICB9XG59O1xudmFyIHN0YXRzX2RlZmF1bHQgPSBTdGF0cztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3RjaGFubmVsbWl4aW4udHNcbnZhciBSZXN0Q2hhbm5lbE1peGluID0gY2xhc3Mge1xuICBzdGF0aWMgYmFzZVBhdGgoY2hhbm5lbCkge1xuICAgIHJldHVybiBcIi9jaGFubmVscy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChjaGFubmVsLm5hbWUpO1xuICB9XG4gIHN0YXRpYyBoaXN0b3J5KGNoYW5uZWwsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IGNoYW5uZWwuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IGNoYW5uZWwuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIHRoaXMuYmFzZVBhdGgoY2hhbm5lbCkgKyBcIi9tZXNzYWdlc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkQXJyYXkyKGRlY29kZWQsIGNoYW5uZWwpO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBzdGF0dXMoY2hhbm5lbCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IGNoYW5uZWwuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2hhbm5lbC5jbGllbnQub3B0aW9ucyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldChcbiAgICAgIGNoYW5uZWwuY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChjaGFubmVsKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB7fSxcbiAgICAgIGZvcm1hdCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuICB9XG4gIHN0YXRpYyBhc3luYyBnZXRNZXNzYWdlKGNoYW5uZWwsIHNlcmlhbE9yTWVzc2FnZSkge1xuICAgIGNvbnN0IHNlcmlhbCA9IHR5cGVvZiBzZXJpYWxPck1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBzZXJpYWxPck1lc3NhZ2UgOiBzZXJpYWxPck1lc3NhZ2Uuc2VyaWFsO1xuICAgIGlmICghc2VyaWFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAnVGhpcyBtZXNzYWdlIGxhY2tzIGEgc2VyaWFsLiBNYWtlIHN1cmUgeW91IGhhdmUgZW5hYmxlZCBcIk1lc3NhZ2UgYW5ub3RhdGlvbnMsIHVwZGF0ZXMsIGFuZCBkZWxldGVzXCIgaW4gY2hhbm5lbCBzZXR0aW5ncyBvbiB5b3VyIGRhc2hib2FyZC4nLFxuICAgICAgICA0MDAwMyxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBjaGFubmVsLmNsaWVudDtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCB7IGJvZHksIHVucGFja2VkIH0gPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldChcbiAgICAgIGNsaWVudCxcbiAgICAgIHRoaXMuYmFzZVBhdGgoY2hhbm5lbCkgKyBcIi9tZXNzYWdlcy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChzZXJpYWwpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICByZXR1cm4gX2Zyb21FbmNvZGVkMihkZWNvZGVkLCBjaGFubmVsKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgdXBkYXRlRGVsZXRlTWVzc2FnZShjaGFubmVsLCBhY3Rpb24sIG1lc3NhZ2UsIG9wZXJhdGlvbiwgcGFyYW1zKSB7XG4gICAgaWYgKCFtZXNzYWdlLnNlcmlhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgJ1RoaXMgbWVzc2FnZSBsYWNrcyBhIHNlcmlhbCBhbmQgY2Fubm90IGJlIHVwZGF0ZWQuIE1ha2Ugc3VyZSB5b3UgaGF2ZSBlbmFibGVkIFwiTWVzc2FnZSBhbm5vdGF0aW9ucywgdXBkYXRlcywgYW5kIGRlbGV0ZXNcIiBpbiBjaGFubmVsIHNldHRpbmdzIG9uIHlvdXIgZGFzaGJvYXJkLicsXG4gICAgICAgIDQwMDAzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IGNoYW5uZWwuY2xpZW50O1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi87XG4gICAgY29uc3QgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXF1ZXN0TWVzc2FnZSA9IG1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKG1lc3NhZ2UpO1xuICAgIHJlcXVlc3RNZXNzYWdlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICByZXF1ZXN0TWVzc2FnZS52ZXJzaW9uID0gb3BlcmF0aW9uO1xuICAgIGNvbnN0IGVuY29kZWQgPSBhd2FpdCByZXF1ZXN0TWVzc2FnZS5lbmNvZGUoY2hhbm5lbC5jaGFubmVsT3B0aW9ucyk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBzZXJpYWxpemUoZW5jb2RlZCwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGxldCBtZXRob2QgPSByZXNvdXJjZV9kZWZhdWx0LnBhdGNoO1xuICAgIGNvbnN0IHsgYm9keSwgdW5wYWNrZWQgfSA9IGF3YWl0IG1ldGhvZChcbiAgICAgIGNsaWVudCxcbiAgICAgIHRoaXMuYmFzZVBhdGgoY2hhbm5lbCkgKyBcIi9tZXNzYWdlcy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChtZXNzYWdlLnNlcmlhbCksXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMgfHwge30sXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3QgZGVjb2RlZCA9IHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIHJldHVybiBkZWNvZGVkIHx8IHsgdmVyc2lvblNlcmlhbDogbnVsbCB9O1xuICB9XG4gIHN0YXRpYyBnZXRNZXNzYWdlVmVyc2lvbnMoY2hhbm5lbCwgc2VyaWFsT3JNZXNzYWdlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZXJpYWwgPSB0eXBlb2Ygc2VyaWFsT3JNZXNzYWdlID09PSBcInN0cmluZ1wiID8gc2VyaWFsT3JNZXNzYWdlIDogc2VyaWFsT3JNZXNzYWdlLnNlcmlhbDtcbiAgICBpZiAoIXNlcmlhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgJ1RoaXMgbWVzc2FnZSBsYWNrcyBhIHNlcmlhbC4gTWFrZSBzdXJlIHlvdSBoYXZlIGVuYWJsZWQgXCJNZXNzYWdlIGFubm90YXRpb25zLCB1cGRhdGVzLCBhbmQgZGVsZXRlc1wiIGluIGNoYW5uZWwgc2V0dGluZ3Mgb24geW91ciBkYXNoYm9hcmQuJyxcbiAgICAgICAgNDAwMDMsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gY2hhbm5lbC5jbGllbnQ7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgICBjb25zdCBlbnZlbG9wZSA9IGNoYW5uZWwuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdDtcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChjaGFubmVsKSArIFwiL21lc3NhZ2VzL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNlcmlhbCkgKyBcIi92ZXJzaW9uc1wiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkgPT4ge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICAgIHJldHVybiBfZnJvbUVuY29kZWRBcnJheTIoZGVjb2RlZCwgY2hhbm5lbCk7XG4gICAgICB9XG4gICAgKS5nZXQocGFyYW1zIHx8IHt9KTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3RwcmVzZW5jZW1peGluLnRzXG52YXIgUmVzdFByZXNlbmNlTWl4aW4gPSBjbGFzcyB7XG4gIHN0YXRpYyBiYXNlUGF0aChwcmVzZW5jZSkge1xuICAgIHJldHVybiBSZXN0Q2hhbm5lbE1peGluLmJhc2VQYXRoKHByZXNlbmNlLmNoYW5uZWwpICsgXCIvcHJlc2VuY2VcIjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgaGlzdG9yeShwcmVzZW5jZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gcHJlc2VuY2UuY2hhbm5lbC5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gcHJlc2VuY2UuY2hhbm5lbC5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChwcmVzZW5jZSkgKyBcIi9oaXN0b3J5XCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgZW52ZWxvcGUsXG4gICAgICBhc3luYyAoYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZEFycmF5KGRlY29kZWQsIHByZXNlbmNlLmNoYW5uZWwpO1xuICAgICAgfVxuICAgICkuZ2V0KHBhcmFtcyk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0LnRzXG52YXIgUmVzdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jaGFubmVsTWl4aW4gPSBSZXN0Q2hhbm5lbE1peGluO1xuICAgIHRoaXMucHJlc2VuY2VNaXhpbiA9IFJlc3RQcmVzZW5jZU1peGluO1xuICAgIC8vIGV4cG9zZWQgZm9yIHBsdWdpbnMgYnV0IHNob3VsZG4ndCBiZSBidW5kbGVkIHdpdGggbWluaW1hbCByZWFsdGltZVxuICAgIHRoaXMuUmVzb3VyY2UgPSByZXNvdXJjZV9kZWZhdWx0O1xuICAgIHRoaXMuUGFnaW5hdGVkUmVzb3VyY2UgPSBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0O1xuICAgIHRoaXMuRGV2aWNlRGV0YWlscyA9IGRldmljZWRldGFpbHNfZGVmYXVsdDtcbiAgICB0aGlzLlB1c2hDaGFubmVsU3Vic2NyaXB0aW9uID0gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdDtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmNoYW5uZWxzID0gbmV3IENoYW5uZWxzKHRoaXMuY2xpZW50KTtcbiAgICB0aGlzLnB1c2ggPSBuZXcgcHVzaF9kZWZhdWx0KHRoaXMuY2xpZW50KTtcbiAgfVxuICBhc3luYyBzdGF0cyhwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKSwgZm9ybWF0ID0gdGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdDtcbiAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdCh0aGlzLmNsaWVudCwgXCIvc3RhdHNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIChib2R5LCBfLCB1bnBhY2tlZCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHNWYWx1ZXMgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0c1ZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RhdHNWYWx1ZXNbaV0gPSBzdGF0c19kZWZhdWx0LmZyb21WYWx1ZXMoc3RhdHNWYWx1ZXNbaV0pO1xuICAgICAgcmV0dXJuIHN0YXRzVmFsdWVzO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHRpbWUocGFyYW1zKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQ6IFwianNvblwiIC8qIGpzb24gKi8gfSk7XG4gICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgdGltZVVyaSA9IChob3N0KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQuYmFzZVVyaShob3N0KSArIFwiL3RpbWVcIjtcbiAgICB9O1xuICAgIGxldCB7IGVycm9yLCBib2R5LCB1bnBhY2tlZCB9ID0gYXdhaXQgdGhpcy5jbGllbnQuaHR0cC5kbyhcbiAgICAgIEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LFxuICAgICAgdGltZVVyaSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBudWxsLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoIXVucGFja2VkKVxuICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgY29uc3QgdGltZSA9IGJvZHlbMF07XG4gICAgaWYgKCF0aW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiSW50ZXJuYWwgZXJyb3IgKHVuZXhwZWN0ZWQgcmVzdWx0IHR5cGUgZnJvbSBHRVQgL3RpbWUpXCIsIDVlNCwgNTAwKTtcbiAgICB9XG4gICAgdGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCA9IHRpbWUgLSBEYXRlLm5vdygpO1xuICAgIHJldHVybiB0aW1lO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QobWV0aG9kLCBwYXRoLCB2ZXJzaW9uMiwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBbZW5jb2RlciwgZGVjb2RlciwgZm9ybWF0XSA9ICgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50Ll9Nc2dQYWNrKSB7XG4gICAgICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGhpcy5jbGllbnQuX01zZ1BhY2suZW5jb2RlLCB0aGlzLmNsaWVudC5fTXNnUGFjay5kZWNvZGUsIFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi9dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtKU09OLnN0cmluZ2lmeSwgSlNPTi5wYXJzZSwgXCJqc29uXCIgLyoganNvbiAqL107XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICBjb25zdCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdDtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgY29uc3QgX21ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBfbWV0aG9kID09IFwiZ2V0XCIgPyBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0LCBwcm90b2NvbFZlcnNpb246IHZlcnNpb24yIH0pIDogZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQsIHByb3RvY29sVmVyc2lvbjogdmVyc2lvbjIgfSk7XG4gICAgaWYgKHR5cGVvZiBib2R5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBib2R5ID0gKF9hMiA9IGVuY29kZXIoYm9keSkpICE9IG51bGwgPyBfYTIgOiBudWxsO1xuICAgIH1cbiAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjdXN0b21IZWFkZXJzKSB7XG4gICAgICBtaXhpbihoZWFkZXJzLCBjdXN0b21IZWFkZXJzKTtcbiAgICB9XG4gICAgY29uc3QgcGFnaW5hdGVkUmVzb3VyY2UgPSBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChcbiAgICAgIHRoaXMuY2xpZW50LFxuICAgICAgcGF0aCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnZlbG9wZSxcbiAgICAgIGFzeW5jIGZ1bmN0aW9uKHJlc2JvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgICByZXR1cm4gZW5zdXJlQXJyYXkodW5wYWNrZWQgPyByZXNib2R5IDogZGVjb2RlcihyZXNib2R5KSk7XG4gICAgICB9LFxuICAgICAgLyogdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlOiAqL1xuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgaWYgKCFQbGF0Zm9ybS5IdHRwLm1ldGhvZHMuaW5jbHVkZXMoX21ldGhvZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJVbnN1cHBvcnRlZCBtZXRob2QgXCIgKyBfbWV0aG9kLCA0MDUwMCwgNDA1KTtcbiAgICB9XG4gICAgaWYgKFBsYXRmb3JtLkh0dHAubWV0aG9kc1dpdGhCb2R5LmluY2x1ZGVzKF9tZXRob2QpKSB7XG4gICAgICByZXR1cm4gcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zLCBib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhZ2luYXRlZFJlc291cmNlW19tZXRob2RdKHBhcmFtcyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJhdGNoUHVibGlzaChzcGVjT3JTcGVjcykge1xuICAgIGxldCByZXF1ZXN0Qm9keURUTztcbiAgICBsZXQgc2luZ2xlU3BlY01vZGU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3BlY09yU3BlY3MpKSB7XG4gICAgICByZXF1ZXN0Qm9keURUTyA9IHNwZWNPclNwZWNzO1xuICAgICAgc2luZ2xlU3BlY01vZGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdEJvZHlEVE8gPSBbc3BlY09yU3BlY3NdO1xuICAgICAgc2luZ2xlU3BlY01vZGUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkocmVxdWVzdEJvZHlEVE8sIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KHRoaXMuY2xpZW50LCBcIi9tZXNzYWdlc1wiLCByZXF1ZXN0Qm9keSwgaGVhZGVycywge30sIG51bGwsIHRydWUpO1xuICAgIGNvbnN0IGJhdGNoUmVzdWx0cyA9IHJlc3BvbnNlLnVucGFja2VkID8gcmVzcG9uc2UuYm9keSA6IGRlY29kZUJvZHkocmVzcG9uc2UuYm9keSwgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgaWYgKHNpbmdsZVNwZWNNb2RlKSB7XG4gICAgICByZXR1cm4gYmF0Y2hSZXN1bHRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmF0Y2hSZXN1bHRzO1xuICAgIH1cbiAgfVxuICBhc3luYyBiYXRjaFByZXNlbmNlKGNoYW5uZWxzKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCBjaGFubmVsc1BhcmFtID0gY2hhbm5lbHMuam9pbihcIixcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldCh0aGlzLmNsaWVudCwgXCIvcHJlc2VuY2VcIiwgaGVhZGVycywgeyBjaGFubmVsczogY2hhbm5lbHNQYXJhbSB9LCBudWxsLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgfVxuICBhc3luYyByZXZva2VUb2tlbnMoc3BlY2lmaWVycywgb3B0aW9ucykge1xuICAgIGlmICh1c2VUb2tlbkF1dGgodGhpcy5jbGllbnQub3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJDYW5ub3QgcmV2b2tlIHRva2VucyB3aGVuIHVzaW5nIHRva2VuIGF1dGhcIiwgNDAxNjIsIDQwMSk7XG4gICAgfVxuICAgIGNvbnN0IGtleU5hbWUgPSB0aGlzLmNsaWVudC5vcHRpb25zLmtleU5hbWU7XG4gICAgbGV0IHJlc29sdmVkT3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keURUTyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHRhcmdldHM6IHNwZWNpZmllcnMubWFwKChzcGVjaWZpZXIpID0+IGAke3NwZWNpZmllci50eXBlfToke3NwZWNpZmllci52YWx1ZX1gKVxuICAgIH0sIHJlc29sdmVkT3B0aW9ucyk7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KHJlcXVlc3RCb2R5RFRPLCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIHRoaXMuY2xpZW50LFxuICAgICAgYC9rZXlzLyR7a2V5TmFtZX0vcmV2b2tlVG9rZW5zYCxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS51bnBhY2tlZCA/IHJlc3BvbnNlLmJvZHkgOiBkZWNvZGVCb2R5KHJlc3BvbnNlLmJvZHksIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICB9XG59O1xudmFyIENoYW5uZWxzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmFsbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHRoaXMuYWxsW25hbWVdID0gY2hhbm5lbCA9IG5ldyByZXN0Y2hhbm5lbF9kZWZhdWx0KHRoaXMuY2xpZW50LCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cbiAgLyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG4gICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gIHJlbGVhc2UobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmFsbFtTdHJpbmcobmFtZSldO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZXJlc3QudHNcbnZhciBCYXNlUmVzdCA9IGNsYXNzIGV4dGVuZHMgYmFzZWNsaWVudF9kZWZhdWx0IHtcbiAgLypcbiAgICogVGhlIHB1YmxpYyB0eXBpbmdzIGRlY2xhcmUgdGhhdCB0aGlzIG9ubHkgYWNjZXB0cyBhbiBvYmplY3QsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgb25lIG9mIHRoZXNlIHRoaW5nczpcbiAgICpcbiAgICogMS4gcGFzc2VzIGEgc3RyaW5nICh3aGljaCBpcyBxdWl0ZSBsaWtlbHkgaWYgdGhleeKAmXJlIGUuZy4gbWlncmF0aW5nIGZyb20gdGhlIGRlZmF1bHQgdmFyaWFudCB0byB0aGUgbW9kdWxhciB2YXJpYW50KVxuICAgKiAyLiBwYXNzZXMgbm8gYXJndW1lbnQgYXQgYWxsXG4gICAqXG4gICAqIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhlc2UgY2FzZXMgYXJlIHBvc3NpYmxlIHNvIHRoYXQgaXQgZm9yY2VzIHVzIHRvIGhhbmRsZSB0aGVtLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCBmYWxzZSwgXCJCYXNlUmVzdFwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCB7IFJlc3QgfSkpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvbW9kdWxhcnBsdWdpbnMudHNcbnZhciBhbGxDb21tb25Nb2R1bGFyUGx1Z2lucyA9IHsgUmVzdCB9O1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZWZhdWx0bWVzc2FnZS50c1xudmFyIERlZmF1bHRNZXNzYWdlID0gY2xhc3MgZXh0ZW5kcyBtZXNzYWdlX2RlZmF1bHQge1xuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWQoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkMihsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWQsIGlucHV0T3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkQXJyYXkoZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkQXJyYXkyKGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIFBsYXRmb3JtLkNyeXB0bywgZW5jb2RlZEFycmF5LCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXModmFsdWVzKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGVmYXVsdHByZXNlbmNlbWVzc2FnZS50c1xudmFyIERlZmF1bHRQcmVzZW5jZU1lc3NhZ2UgPSBjbGFzcyBleHRlbmRzIHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0IHtcbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkKGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZChsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWQsIGlucHV0T3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkQXJyYXkoZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkQXJyYXkobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgUGxhdGZvcm0uQ3J5cHRvLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKHZhbHVlcyk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2Fubm90YXRpb24udHNcbnZhciBhY3Rpb25zNCA9IFtcImFubm90YXRpb24uY3JlYXRlXCIsIFwiYW5ub3RhdGlvbi5kZWxldGVcIl07XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZDMobG9nZ2VyLCBlbmNvZGVkLCBvcHRpb25zKSB7XG4gIGNvbnN0IHdhID0gV2lyZUFubm90YXRpb24uZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgcmV0dXJuIHdhLmRlY29kZShvcHRpb25zIHx8IHt9LCBsb2dnZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWRBcnJheTMobG9nZ2VyLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIGZyb21FbmNvZGVkMyhsb2dnZXIsIGVuY29kZWQsIG9wdGlvbnMpO1xuICAgIH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWQzKGVuY29kZWQsIGNoYW5uZWwpIHtcbiAgcmV0dXJuIFdpcmVBbm5vdGF0aW9uLmZyb21WYWx1ZXMoZW5jb2RlZCkuZGVjb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGNoYW5uZWwubG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZEFycmF5MyhlbmNvZGVkQXJyYXksIGNoYW5uZWwpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZDMoZW5jb2RlZCwgY2hhbm5lbCk7XG4gICAgfSlcbiAgKTtcbn1cbnZhciBBbm5vdGF0aW9uID0gY2xhc3MgX0Fubm90YXRpb24gZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIGFzeW5jIGVuY29kZSgpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBXaXJlQW5ub3RhdGlvbigpLCB0aGlzLCB7XG4gICAgICBhY3Rpb246IGFjdGlvbnM0LmluZGV4T2YodGhpcy5hY3Rpb24gfHwgXCJhbm5vdGF0aW9uLmNyZWF0ZVwiKVxuICAgIH0pO1xuICAgIHJldHVybiBlbmNvZGUocmVzLCB7fSk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9Bbm5vdGF0aW9uKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgodikgPT4gX0Fubm90YXRpb24uZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIkFubm90YXRpb25cIik7XG4gIH1cbn07XG52YXIgV2lyZUFubm90YXRpb24gPSBjbGFzcyBfV2lyZUFubm90YXRpb24gZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIHRvSlNPTiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHdpcmVUb0pTT04uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1dpcmVBbm5vdGF0aW9uKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgodikgPT4gX1dpcmVBbm5vdGF0aW9uLmZyb21WYWx1ZXModikpO1xuICB9XG4gIGFzeW5jIGRlY29kZShjaGFubmVsT3B0aW9ucywgbG9nZ2VyKSB7XG4gICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbihuZXcgQW5ub3RhdGlvbigpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzKSwge1xuICAgICAgYWN0aW9uOiBhY3Rpb25zNFt0aGlzLmFjdGlvbl1cbiAgICB9KSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGRlY29kZShyZXMsIGNoYW5uZWxPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2lyZUFubm90YXRpb24uZGVjb2RlKClcIiwgaW5zcGVjdEVycm9yKGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiV2lyZUFubm90YXRpb25cIik7XG4gIH1cbn07XG52YXIgYW5ub3RhdGlvbl9kZWZhdWx0ID0gQW5ub3RhdGlvbjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGVmYXVsdGFubm90YXRpb24udHNcbnZhciBEZWZhdWx0QW5ub3RhdGlvbiA9IGNsYXNzIGV4dGVuZHMgYW5ub3RhdGlvbl9kZWZhdWx0IHtcbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkKGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZDMobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgZW5jb2RlZCwgaW5wdXRPcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWRBcnJheTMobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgZW5jb2RlZEFycmF5LCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gYW5ub3RhdGlvbl9kZWZhdWx0LmZyb21WYWx1ZXModmFsdWVzKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3Rhbm5vdGF0aW9ucy50c1xuZnVuY3Rpb24gc2VyaWFsRnJvbU1zZ09yU2VyaWFsKG1zZ09yU2VyaWFsKSB7XG4gIGxldCBtZXNzYWdlU2VyaWFsO1xuICBzd2l0Y2ggKHR5cGVvZiBtc2dPclNlcmlhbCkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIG1lc3NhZ2VTZXJpYWwgPSBtc2dPclNlcmlhbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIG1lc3NhZ2VTZXJpYWwgPSBtc2dPclNlcmlhbC5zZXJpYWw7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIW1lc3NhZ2VTZXJpYWwgfHwgdHlwZW9mIG1lc3NhZ2VTZXJpYWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgXCJGaXJzdCBhcmd1bWVudCBvZiBhbm5vdGF0aW9ucy5wdWJsaXNoKCkgbXVzdCBiZSBlaXRoZXIgYSBNZXNzYWdlIChvciBhdCBsZWFzdCBhbiBvYmplY3Qgd2l0aCBhIHN0cmluZyBgc2VyaWFsYCBwcm9wZXJ0eSkgb3IgYSBtZXNzYWdlIHNlcmlhbCAoc3RyaW5nKVwiLFxuICAgICAgNDAwMDMsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG4gIHJldHVybiBtZXNzYWdlU2VyaWFsO1xufVxuZnVuY3Rpb24gY29uc3RydWN0VmFsaWRhdGVBbm5vdGF0aW9uKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKSB7XG4gIGNvbnN0IG1lc3NhZ2VTZXJpYWwgPSBzZXJpYWxGcm9tTXNnT3JTZXJpYWwobXNnT3JTZXJpYWwpO1xuICBpZiAoIWFubm90YXRpb25WYWx1ZXMgfHwgdHlwZW9mIGFubm90YXRpb25WYWx1ZXMgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgXCJTZWNvbmQgYXJndW1lbnQgb2YgYW5ub3RhdGlvbnMucHVibGlzaCgpIG11c3QgYmUgYW4gb2JqZWN0ICh0aGUgaW50ZW5kZWQgYW5ub3RhdGlvbiB0byBwdWJsaXNoKVwiLFxuICAgICAgNDAwMDMsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG4gIGNvbnN0IGFubm90YXRpb24gPSBhbm5vdGF0aW9uX2RlZmF1bHQuZnJvbVZhbHVlcyhhbm5vdGF0aW9uVmFsdWVzKTtcbiAgYW5ub3RhdGlvbi5tZXNzYWdlU2VyaWFsID0gbWVzc2FnZVNlcmlhbDtcbiAgaWYgKCFhbm5vdGF0aW9uLmFjdGlvbikge1xuICAgIGFubm90YXRpb24uYWN0aW9uID0gXCJhbm5vdGF0aW9uLmNyZWF0ZVwiO1xuICB9XG4gIHJldHVybiBhbm5vdGF0aW9uO1xufVxuZnVuY3Rpb24gYmFzZVBhdGhGb3JTZXJpYWwoY2hhbm5lbCwgc2VyaWFsKSB7XG4gIHJldHVybiBjaGFubmVsLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5iYXNlUGF0aChjaGFubmVsKSArIFwiL21lc3NhZ2VzL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNlcmlhbCkgKyBcIi9hbm5vdGF0aW9uc1wiO1xufVxudmFyIFJlc3RBbm5vdGF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcykge1xuICAgIGNvbnN0IGFubm90YXRpb24gPSBjb25zdHJ1Y3RWYWxpZGF0ZUFubm90YXRpb24obXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpO1xuICAgIGNvbnN0IHdpcmVBbm5vdGF0aW9uID0gYXdhaXQgYW5ub3RhdGlvbi5lbmNvZGUoKTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNoYW5uZWwuY2xpZW50LCBvcHRpb25zID0gY2xpZW50Lm9wdGlvbnMsIGZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zKSwgcGFyYW1zID0ge307XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KFt3aXJlQW5ub3RhdGlvbl0sIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoXG4gICAgICBjbGllbnQsXG4gICAgICBiYXNlUGF0aEZvclNlcmlhbCh0aGlzLmNoYW5uZWwsIGFubm90YXRpb24ubWVzc2FnZVNlcmlhbCksXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKSB7XG4gICAgYW5ub3RhdGlvblZhbHVlcy5hY3Rpb24gPSBcImFubm90YXRpb24uZGVsZXRlXCI7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaChtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcyk7XG4gIH1cbiAgYXN5bmMgZ2V0KG1zZ09yU2VyaWFsLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNoYW5uZWwuY2xpZW50LCBtZXNzYWdlU2VyaWFsID0gc2VyaWFsRnJvbU1zZ09yU2VyaWFsKG1zZ09yU2VyaWFsKSwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSBjbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucyk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgY2xpZW50LFxuICAgICAgYmFzZVBhdGhGb3JTZXJpYWwodGhpcy5jaGFubmVsLCBtZXNzYWdlU2VyaWFsKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnZlbG9wZSxcbiAgICAgIGFzeW5jIChib2R5LCBfLCB1bnBhY2tlZCkgPT4ge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICAgIHJldHVybiBfZnJvbUVuY29kZWRBcnJheTMoZGVjb2RlZCwgdGhpcy5jaGFubmVsKTtcbiAgICAgIH1cbiAgICApLmdldChwYXJhbXMpO1xuICB9XG59O1xudmFyIHJlc3Rhbm5vdGF0aW9uc19kZWZhdWx0ID0gUmVzdEFubm90YXRpb25zO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wcm90b2NvbG1lc3NhZ2UudHNcbnZhciBzZXJpYWxpemUyID0gZW5jb2RlQm9keTtcbmZ1bmN0aW9uIHRvU3RyaW5nQXJyYXkoYXJyYXkpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJbIFwiICsgcmVzdWx0LmpvaW4oXCIsIFwiKSArIFwiIF1cIjtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQsIE1zZ1BhY2ssIHByZXNlbmNlTWVzc2FnZVBsdWdpbiwgYW5ub3RhdGlvbnNQbHVnaW4sIG9iamVjdHNQbHVnaW4sIGZvcm1hdCkge1xuICBjb25zdCBkZXNlcmlhbGl6ZWQgPSBkZWNvZGVCb2R5KHNlcmlhbGl6ZWQsIE1zZ1BhY2ssIGZvcm1hdCk7XG4gIHJldHVybiBmcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplZCwgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBhbm5vdGF0aW9uc1BsdWdpbiwgb2JqZWN0c1BsdWdpbik7XG59XG5mdW5jdGlvbiBmcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplZCwgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBhbm5vdGF0aW9uc1BsdWdpbiwgb2JqZWN0c1BsdWdpbikge1xuICBsZXQgZXJyb3I7XG4gIGlmIChkZXNlcmlhbGl6ZWQuZXJyb3IpIHtcbiAgICBlcnJvciA9IEVycm9ySW5mby5mcm9tVmFsdWVzKGRlc2VyaWFsaXplZC5lcnJvcik7XG4gIH1cbiAgbGV0IG1lc3NhZ2VzO1xuICBpZiAoZGVzZXJpYWxpemVkLm1lc3NhZ2VzKSB7XG4gICAgbWVzc2FnZXMgPSBXaXJlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkoZGVzZXJpYWxpemVkLm1lc3NhZ2VzKTtcbiAgfVxuICBsZXQgcHJlc2VuY2U7XG4gIGlmIChwcmVzZW5jZU1lc3NhZ2VQbHVnaW4gJiYgZGVzZXJpYWxpemVkLnByZXNlbmNlKSB7XG4gICAgcHJlc2VuY2UgPSBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4uV2lyZVByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkoXG4gICAgICBkZXNlcmlhbGl6ZWQucHJlc2VuY2VcbiAgICApO1xuICB9XG4gIGxldCBhbm5vdGF0aW9ucztcbiAgaWYgKGFubm90YXRpb25zUGx1Z2luICYmIGRlc2VyaWFsaXplZC5hbm5vdGF0aW9ucykge1xuICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnNQbHVnaW4uV2lyZUFubm90YXRpb24uZnJvbVZhbHVlc0FycmF5KFxuICAgICAgZGVzZXJpYWxpemVkLmFubm90YXRpb25zXG4gICAgKTtcbiAgfVxuICBsZXQgc3RhdGU7XG4gIGlmIChvYmplY3RzUGx1Z2luICYmIGRlc2VyaWFsaXplZC5zdGF0ZSkge1xuICAgIHN0YXRlID0gb2JqZWN0c1BsdWdpbi5XaXJlT2JqZWN0TWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkoXG4gICAgICBkZXNlcmlhbGl6ZWQuc3RhdGUsXG4gICAgICB1dGlsc19leHBvcnRzLFxuICAgICAgTWVzc2FnZUVuY29kaW5nXG4gICAgKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGRlc2VyaWFsaXplZCksIHsgcHJlc2VuY2UsIG1lc3NhZ2VzLCBhbm5vdGF0aW9ucywgc3RhdGUsIGVycm9yIH0pKTtcbn1cbmZ1bmN0aW9uIG1ha2VGcm9tRGVzZXJpYWxpemVkV2l0aERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcbiAgcmV0dXJuIChkZXNlcmlhbGl6ZWQpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiBmcm9tRGVzZXJpYWxpemVkKFxuICAgICAgZGVzZXJpYWxpemVkLFxuICAgICAge1xuICAgICAgICBQcmVzZW5jZU1lc3NhZ2U6IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LFxuICAgICAgICBXaXJlUHJlc2VuY2VNZXNzYWdlXG4gICAgICB9LFxuICAgICAgeyBBbm5vdGF0aW9uOiBhbm5vdGF0aW9uX2RlZmF1bHQsIFdpcmVBbm5vdGF0aW9uLCBSZWFsdGltZUFubm90YXRpb25zOiByZWFsdGltZWFubm90YXRpb25zX2RlZmF1bHQsIFJlc3RBbm5vdGF0aW9uczogcmVzdGFubm90YXRpb25zX2RlZmF1bHQgfSxcbiAgICAgIChfYTIgPSBkZXBlbmRlbmNpZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGRlcGVuZGVuY2llcy5MaXZlT2JqZWN0c1BsdWdpbikgIT0gbnVsbCA/IF9hMiA6IG51bGxcbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFByb3RvY29sTWVzc2FnZSgpLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KG1zZywgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBhbm5vdGF0aW9uc1BsdWdpbiwgb2JqZWN0c1BsdWdpbikge1xuICBsZXQgcmVzdWx0ID0gXCJbUHJvdG9jb2xNZXNzYWdlXCI7XG4gIGlmIChtc2cuYWN0aW9uICE9PSB2b2lkIDApXG4gICAgcmVzdWx0ICs9IFwiOyBhY3Rpb249XCIgKyBBY3Rpb25OYW1lW21zZy5hY3Rpb25dIHx8IG1zZy5hY3Rpb247XG4gIGNvbnN0IHNpbXBsZUF0dHJpYnV0ZXMgPSBbXCJpZFwiLCBcImNoYW5uZWxcIiwgXCJjaGFubmVsU2VyaWFsXCIsIFwiY29ubmVjdGlvbklkXCIsIFwiY291bnRcIiwgXCJtc2dTZXJpYWxcIiwgXCJ0aW1lc3RhbXBcIl07XG4gIGxldCBhdHRyaWJ1dGU7XG4gIGZvciAobGV0IGF0dHJpYkluZGV4ID0gMDsgYXR0cmliSW5kZXggPCBzaW1wbGVBdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cmliSW5kZXgrKykge1xuICAgIGF0dHJpYnV0ZSA9IHNpbXBsZUF0dHJpYnV0ZXNbYXR0cmliSW5kZXhdO1xuICAgIGlmIChtc2dbYXR0cmlidXRlXSAhPT0gdm9pZCAwKVxuICAgICAgcmVzdWx0ICs9IFwiOyBcIiArIGF0dHJpYnV0ZSArIFwiPVwiICsgbXNnW2F0dHJpYnV0ZV07XG4gIH1cbiAgaWYgKG1zZy5tZXNzYWdlcylcbiAgICByZXN1bHQgKz0gXCI7IG1lc3NhZ2VzPVwiICsgdG9TdHJpbmdBcnJheShXaXJlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkobXNnLm1lc3NhZ2VzKSk7XG4gIGlmIChtc2cucHJlc2VuY2UgJiYgcHJlc2VuY2VNZXNzYWdlUGx1Z2luKVxuICAgIHJlc3VsdCArPSBcIjsgcHJlc2VuY2U9XCIgKyB0b1N0cmluZ0FycmF5KHByZXNlbmNlTWVzc2FnZVBsdWdpbi5XaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShtc2cucHJlc2VuY2UpKTtcbiAgaWYgKG1zZy5hbm5vdGF0aW9ucyAmJiBhbm5vdGF0aW9uc1BsdWdpbikge1xuICAgIHJlc3VsdCArPSBcIjsgYW5ub3RhdGlvbnM9XCIgKyB0b1N0cmluZ0FycmF5KGFubm90YXRpb25zUGx1Z2luLldpcmVBbm5vdGF0aW9uLmZyb21WYWx1ZXNBcnJheShtc2cuYW5ub3RhdGlvbnMpKTtcbiAgfVxuICBpZiAobXNnLnN0YXRlICYmIG9iamVjdHNQbHVnaW4pIHtcbiAgICByZXN1bHQgKz0gXCI7IHN0YXRlPVwiICsgdG9TdHJpbmdBcnJheShvYmplY3RzUGx1Z2luLldpcmVPYmplY3RNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShtc2cuc3RhdGUsIHV0aWxzX2V4cG9ydHMsIE1lc3NhZ2VFbmNvZGluZykpO1xuICB9XG4gIGlmIChtc2cuZXJyb3IpXG4gICAgcmVzdWx0ICs9IFwiOyBlcnJvcj1cIiArIEVycm9ySW5mby5mcm9tVmFsdWVzKG1zZy5lcnJvcikudG9TdHJpbmcoKTtcbiAgaWYgKG1zZy5hdXRoICYmIG1zZy5hdXRoLmFjY2Vzc1Rva2VuKVxuICAgIHJlc3VsdCArPSBcIjsgdG9rZW49XCIgKyBtc2cuYXV0aC5hY2Nlc3NUb2tlbjtcbiAgaWYgKG1zZy5mbGFncylcbiAgICByZXN1bHQgKz0gXCI7IGZsYWdzPVwiICsgZmxhZ05hbWVzLmZpbHRlcihtc2cuaGFzRmxhZykuam9pbihcIixcIik7XG4gIGlmIChtc2cucGFyYW1zKSB7XG4gICAgbGV0IHN0cmluZ2lmaWVkUGFyYW1zID0gXCJcIjtcbiAgICBmb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzKG1zZy5wYXJhbXMsIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGlmIChzdHJpbmdpZmllZFBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0cmluZ2lmaWVkUGFyYW1zICs9IFwiOyBcIjtcbiAgICAgIH1cbiAgICAgIHN0cmluZ2lmaWVkUGFyYW1zICs9IHByb3AgKyBcIj1cIiArIG1zZy5wYXJhbXNbcHJvcF07XG4gICAgfSk7XG4gICAgaWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdCArPSBcIjsgcGFyYW1zPVtcIiArIHN0cmluZ2lmaWVkUGFyYW1zICsgXCJdXCI7XG4gICAgfVxuICB9XG4gIHJlc3VsdCArPSBcIl1cIjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBQcm90b2NvbE1lc3NhZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFzRmxhZyA9IChmbGFnKSA9PiB7XG4gICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBmbGFnc1tmbGFnXSkgPiAwO1xuICAgIH07XG4gIH1cbiAgc2V0RmxhZyhmbGFnKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHwgZmxhZ3NbZmxhZ107XG4gIH1cbiAgZ2V0TW9kZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgfHwgMCkgJiBmbGFncy5NT0RFX0FMTDtcbiAgfVxuICBlbmNvZGVNb2Rlc1RvRmxhZ3MobW9kZXMpIHtcbiAgICBtb2Rlcy5mb3JFYWNoKChtb2RlKSA9PiB0aGlzLnNldEZsYWcobW9kZSkpO1xuICB9XG4gIGRlY29kZU1vZGVzRnJvbUZsYWdzKCkge1xuICAgIGNvbnN0IG1vZGVzID0gW107XG4gICAgY2hhbm5lbE1vZGVzLmZvckVhY2goKG1vZGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0ZsYWcobW9kZSkpIHtcbiAgICAgICAgbW9kZXMucHVzaChtb2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbW9kZXMubGVuZ3RoID4gMCA/IG1vZGVzIDogdm9pZCAwO1xuICB9XG59O1xudmFyIHByb3RvY29sbWVzc2FnZV9kZWZhdWx0ID0gUHJvdG9jb2xNZXNzYWdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvY2hhbm5lbHN0YXRlY2hhbmdlLnRzXG52YXIgQ2hhbm5lbFN0YXRlQ2hhbmdlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwcmV2aW91cywgY3VycmVudCwgcmVzdW1lZCwgaGFzQmFja2xvZywgcmVhc29uKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgdGhpcy5yZXN1bWVkID0gcmVzdW1lZDtcbiAgICAgIHRoaXMuaGFzQmFja2xvZyA9IGhhc0JhY2tsb2c7XG4gICAgfVxuICAgIGlmIChyZWFzb24pXG4gICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgfVxufTtcbnZhciBjaGFubmVsc3RhdGVjaGFuZ2VfZGVmYXVsdCA9IENoYW5uZWxTdGF0ZUNoYW5nZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lY2hhbm5lbC50c1xudmFyIG5vb3AgPSBmdW5jdGlvbigpIHtcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgXCJwYXJhbXNcIiBpbiBvcHRpb25zICYmICFpc09iamVjdChvcHRpb25zLnBhcmFtcykpIHtcbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcIm9wdGlvbnMucGFyYW1zIG11c3QgYmUgYW4gb2JqZWN0XCIsIDRlNCwgNDAwKTtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBcIm1vZGVzXCIgaW4gb3B0aW9ucykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLm1vZGVzKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXCJvcHRpb25zLm1vZGVzIG11c3QgYmUgYW4gYXJyYXlcIiwgNGU0LCA0MDApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubW9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRNb2RlID0gb3B0aW9ucy5tb2Rlc1tpXTtcbiAgICAgIGlmICghY3VycmVudE1vZGUgfHwgdHlwZW9mIGN1cnJlbnRNb2RlICE9PSBcInN0cmluZ1wiIHx8ICFjaGFubmVsTW9kZXMuaW5jbHVkZXMoU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZS5jYWxsKGN1cnJlbnRNb2RlKSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXCJJbnZhbGlkIGNoYW5uZWwgbW9kZTogXCIgKyBjdXJyZW50TW9kZSwgNGU0LCA0MDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIFJlYWx0aW1lQ2hhbm5lbCA9IGNsYXNzIF9SZWFsdGltZUNoYW5uZWwgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgbmFtZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTIsIF9iLCBfYztcbiAgICBzdXBlcihjbGllbnQubG9nZ2VyKTtcbiAgICB0aGlzLl9hbm5vdGF0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5fbW9kZSA9IDA7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLmhpc3RvcnkgPSBhc3luYyBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5oaXN0b3J5KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgICAgY29uc3QgcmVzdE1peGluID0gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW47XG4gICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZFwiLCA0ZTQsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgIFwidW50aWxBdHRhY2ggd2FzIHNwZWNpZmllZCBhbmQgY2hhbm5lbCBpcyBhdHRhY2hlZCwgYnV0IGF0dGFjaFNlcmlhbCBpcyBub3QgZGVmaW5lZFwiLFxuICAgICAgICAgICAgNGU0LFxuICAgICAgICAgICAgNDAwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuICAgICAgICBwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3RNaXhpbi5oaXN0b3J5KHRoaXMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICB0aGlzLndoZW5TdGF0ZSA9IChzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIGV2ZW50ZW1pdHRlcl9kZWZhdWx0LnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgfTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZUNoYW5uZWwoKVwiLCBcInN0YXJ0ZWQ7IG5hbWUgPSBcIiArIG5hbWUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKChfYTIgPSBjbGllbnQuX0NyeXB0bykgIT0gbnVsbCA/IF9hMiA6IG51bGwsIHRoaXMubG9nZ2VyLCBvcHRpb25zKTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLl9wcmVzZW5jZSA9IGNsaWVudC5fUmVhbHRpbWVQcmVzZW5jZSA/IG5ldyBjbGllbnQuX1JlYWx0aW1lUHJlc2VuY2UuUmVhbHRpbWVQcmVzZW5jZSh0aGlzKSA6IG51bGw7XG4gICAgaWYgKGNsaWVudC5fQW5ub3RhdGlvbnMpIHtcbiAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gbmV3IGNsaWVudC5fQW5ub3RhdGlvbnMuUmVhbHRpbWVBbm5vdGF0aW9ucyh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIHRoaXMuc3RhdGUgPSBcImluaXRpYWxpemVkXCI7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcl9kZWZhdWx0KHRoaXMubG9nZ2VyKTtcbiAgICB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gdm9pZCAwO1xuICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgIGF0dGFjaFNlcmlhbDogdm9pZCAwLFxuICAgICAgY2hhbm5lbFNlcmlhbDogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG4gICAgdGhpcy5fZGVjb2RpbmdDb250ZXh0ID0ge1xuICAgICAgY2hhbm5lbE9wdGlvbnM6IHRoaXMuY2hhbm5lbE9wdGlvbnMsXG4gICAgICBwbHVnaW5zOiBjbGllbnQub3B0aW9ucy5wbHVnaW5zIHx8IHt9LFxuICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHZvaWQgMFxuICAgIH07XG4gICAgdGhpcy5fbGFzdFBheWxvYWQgPSB7XG4gICAgICBtZXNzYWdlSWQ6IG51bGwsXG4gICAgICBwcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsOiBudWxsLFxuICAgICAgZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzczogbnVsbFxuICAgIH07XG4gICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIGlmICgoX2IgPSBjbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2IuUHVzaCkge1xuICAgICAgdGhpcy5fcHVzaCA9IG5ldyBjbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guUHVzaENoYW5uZWwodGhpcyk7XG4gICAgfVxuICAgIGlmICgoX2MgPSBjbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2MuTGl2ZU9iamVjdHMpIHtcbiAgICAgIHRoaXMuX29iamVjdCA9IG5ldyBjbGllbnQub3B0aW9ucy5wbHVnaW5zLkxpdmVPYmplY3RzLlJlYWx0aW1lT2JqZWN0KHRoaXMpO1xuICAgIH1cbiAgfVxuICBnZXQgcHJlc2VuY2UoKSB7XG4gICAgaWYgKCF0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJSZWFsdGltZVByZXNlbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJlc2VuY2U7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25zKCkge1xuICAgIGlmICghdGhpcy5fYW5ub3RhdGlvbnMpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiQW5ub3RhdGlvbnNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucztcbiAgfVxuICBnZXQgcHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuX3B1c2gpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1c2g7XG4gIH1cbiAgLyoqIEBzcGVjIFJUTDI3ICovXG4gIGdldCBvYmplY3QoKSB7XG4gICAgaWYgKCF0aGlzLl9vYmplY3QpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiTGl2ZU9iamVjdHNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vYmplY3Q7XG4gIH1cbiAgaW52YWxpZFN0YXRlRXJyb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXG4gICAgICBcIkNoYW5uZWwgb3BlcmF0aW9uIGZhaWxlZCBhcyBjaGFubmVsIHN0YXRlIGlzIFwiICsgdGhpcy5zdGF0ZSxcbiAgICAgIDkwMDAxLFxuICAgICAgNDAwLFxuICAgICAgdGhpcy5lcnJvclJlYXNvbiB8fCB2b2lkIDBcbiAgICApO1xuICB9XG4gIHN0YXRpYyBwcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cbiAgYXN5bmMgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBwcmV2aW91c0NoYW5uZWxPcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICBjb25zdCBlcnIgPSB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKChfYTIgPSB0aGlzLmNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLl9kZWNvZGluZ0NvbnRleHQpXG4gICAgICB0aGlzLl9kZWNvZGluZ0NvbnRleHQuY2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgIGlmICh0aGlzLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhvcHRpb25zLCBwcmV2aW91c0NoYW5uZWxPcHRpb25zKSkge1xuICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5vbmNlKFxuICAgICAgICAgIFtcImF0dGFjaGVkXCIsIFwidXBkYXRlXCIsIFwiZGV0YWNoZWRcIiwgXCJmYWlsZWRcIl0sXG4gICAgICAgICAgZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWplY3Qoc3RhdGVDaGFuZ2UucmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMsIHByZXZPcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiIHx8IHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoaW5nXCIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcykge1xuICAgICAgY29uc3QgcmVxdWVzdGVkUGFyYW1zID0gb21pdEFnZW50KG9wdGlvbnMucGFyYW1zKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUGFyYW1zID0gb21pdEFnZW50KHByZXZPcHRpb25zLnBhcmFtcyk7XG4gICAgICBpZiAoT2JqZWN0LmtleXMocmVxdWVzdGVkUGFyYW1zKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGV4aXN0aW5nUGFyYW1zKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXNoYWxsb3dFcXVhbHMoZXhpc3RpbmdQYXJhbXMsIHJlcXVlc3RlZFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGVzKSB7XG4gICAgICBpZiAoIXByZXZPcHRpb25zLm1vZGVzIHx8ICFhcnJFcXVhbHMob3B0aW9ucy5tb2RlcywgcHJldk9wdGlvbnMubW9kZXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcHVibGlzaCguLi5hcmdzKSB7XG4gICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdLCBzZWNvbmQgPSBhcmdzWzFdO1xuICAgIGxldCBtZXNzYWdlcztcbiAgICBsZXQgcGFyYW1zO1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgfHwgZmlyc3QgPT09IG51bGwgfHwgZmlyc3QgPT09IHZvaWQgMCkge1xuICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoeyBuYW1lOiBmaXJzdCwgZGF0YTogc2Vjb25kIH0pXTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChmaXJzdCkpIHtcbiAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKGZpcnN0KV07XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIG1lc3NhZ2VzID0gbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShmaXJzdCk7XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIlRoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0c1wiLFxuICAgICAgICA0MDAxMyxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBtYXhNZXNzYWdlU2l6ZSA9IHRoaXMuY2xpZW50Lm9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2VzID0gYXdhaXQgZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMpO1xuICAgIGNvbnN0IHNpemUgPSBnZXRNZXNzYWdlc1NpemUod2lyZU1lc3NhZ2VzKTtcbiAgICBpZiAoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBgTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICh3YXMgJHtzaXplfSBieXRlczsgbGltaXQgaXMgJHttYXhNZXNzYWdlU2l6ZX0gYnl0ZXMpYCxcbiAgICAgICAgNDAwMDksXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy50aHJvd0lmVW5wdWJsaXNoYWJsZVN0YXRlKCk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKClcIixcbiAgICAgIFwic2VuZGluZyBtZXNzYWdlOyBjaGFubmVsIHN0YXRlIGlzIFwiICsgdGhpcy5zdGF0ZSArIFwiLCBtZXNzYWdlIGNvdW50ID0gXCIgKyB3aXJlTWVzc2FnZXMubGVuZ3RoXG4gICAgKTtcbiAgICBjb25zdCBwbSA9IGZyb21WYWx1ZXMoe1xuICAgICAgYWN0aW9uOiBhY3Rpb25zLk1FU1NBR0UsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlczogd2lyZU1lc3NhZ2VzLFxuICAgICAgcGFyYW1zOiBwYXJhbXMgPyBzdHJpbmdpZnlWYWx1ZXMocGFyYW1zKSA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UocG0pO1xuICAgIHJldHVybiByZXMgfHwgeyBzZXJpYWxzOiBbXSB9O1xuICB9XG4gIHRocm93SWZVbnB1Ymxpc2hhYmxlU3RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiZmFpbGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhyb3cgdGhpcy5pbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgIH1cbiAgfVxuICBvbkV2ZW50KG1lc3NhZ2VzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLm9uRXZlbnQoKVwiLCBcInJlY2VpdmVkIG1lc3NhZ2VcIik7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbaV07XG4gICAgICBzdWJzY3JpcHRpb25zLmVtaXQobWVzc2FnZS5uYW1lLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYXR0YWNoKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fYXR0YWNoKGZhbHNlLCBudWxsLCAoZXJyLCByZXN1bHQpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuICBfYXR0YWNoKGZvcmNlUmVhdHRhY2gsIGF0dGFjaFJlYXNvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwuX2F0dGFjaCgpXCIsXG4gICAgICAgICAgICBcIkNoYW5uZWwgYXR0YWNoIGZhaWxlZDogXCIgKyBlcnIudG9TdHJpbmcoKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIGNhbGxiYWNrKGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gXCJhdHRhY2hpbmdcIiB8fCBmb3JjZVJlYXR0YWNoKSB7XG4gICAgICB0aGlzLnJlcXVlc3RTdGF0ZShcImF0dGFjaGluZ1wiLCBhdHRhY2hSZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLm9uY2UoZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2sobnVsbCwgc3RhdGVDaGFuZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKFxuICAgICAgICAgICAgc3RhdGVDaGFuZ2UucmVhc29uIHx8IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkgfHwgbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBhdHRhY2g7IHJlYXNvbiB1bmtub3duOyBzdGF0ZSA9IFwiICsgdGhpcy5ldmVudCwgOWU0LCA1MDApXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhuZXcgRXJyb3JJbmZvKFwiQXR0YWNoIHJlcXVlc3Qgc3VwZXJzZWRlZCBieSBhIHN1YnNlcXVlbnQgZGV0YWNoIHJlcXVlc3RcIiwgOWU0LCA0MDkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhdHRhY2hJbXBsKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5hdHRhY2hJbXBsKClcIiwgXCJzZW5kaW5nIEFUVEFDSCBtZXNzYWdlXCIpO1xuICAgIGNvbnN0IGF0dGFjaE1zZyA9IGZyb21WYWx1ZXMoe1xuICAgICAgYWN0aW9uOiBhY3Rpb25zLkFUVEFDSCxcbiAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgIHBhcmFtczogdGhpcy5jaGFubmVsT3B0aW9ucy5wYXJhbXMsXG4gICAgICAvLyBSVEw0YzE6IEluY2x1ZGVzIHRoZSBjaGFubmVsIHNlcmlhbCB0byByZXN1bWUgZnJvbSBhIHByZXZpb3VzIG1lc3NhZ2VcbiAgICAgIC8vIG9yIGF0dGFjaG1lbnQuXG4gICAgICBjaGFubmVsU2VyaWFsOiB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbFxuICAgIH0pO1xuICAgIGlmICh0aGlzLmNoYW5uZWxPcHRpb25zLm1vZGVzKSB7XG4gICAgICBhdHRhY2hNc2cuZW5jb2RlTW9kZXNUb0ZsYWdzKGFsbFRvVXBwZXJDYXNlKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2F0dGFjaFJlc3VtZSkge1xuICAgICAgYXR0YWNoTXNnLnNldEZsYWcoXCJBVFRBQ0hfUkVTVU1FXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgYXR0YWNoTXNnLmNoYW5uZWxTZXJpYWwgPSB0aGlzLl9sYXN0UGF5bG9hZC5wcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsO1xuICAgIH1cbiAgICB0aGlzLnNlbmRNZXNzYWdlKGF0dGFjaE1zZykuY2F0Y2gobm9vcCk7XG4gIH1cbiAgYXN5bmMgZGV0YWNoKCkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImRldGFjaGVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGRldGFjaDsgY2hhbm5lbCBzdGF0ZSA9IGZhaWxlZFwiLCA5MDAwMSwgNDAwKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJkZXRhY2hlZFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoXCJkZXRhY2hpbmdcIik7XG4gICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgICAgc3RhdGVDaGFuZ2UucmVhc29uIHx8IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkgfHwgbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBkZXRhY2g7IHJlYXNvbiB1bmtub3duOyBzdGF0ZSA9IFwiICsgdGhpcy5ldmVudCwgOWU0LCA1MDApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImF0dGFjaGluZ1wiOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiRGV0YWNoIHJlcXVlc3Qgc3VwZXJzZWRlZCBieSBhIHN1YnNlcXVlbnQgYXR0YWNoIHJlcXVlc3RcIiwgOWU0LCA0MDkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGRldGFjaEltcGwoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmRldGFjaCgpXCIsIFwic2VuZGluZyBERVRBQ0ggbWVzc2FnZVwiKTtcbiAgICBjb25zdCBtc2cgPSBmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkRFVEFDSCwgY2hhbm5lbDogdGhpcy5uYW1lIH0pO1xuICAgIHRoaXMuc2VuZE1lc3NhZ2UobXNnKS5jYXRjaChub29wKTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUoLi4uYXJncykge1xuICAgIGNvbnN0IFtldmVudCwgbGlzdGVuZXJdID0gX1JlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aHJvdyBFcnJvckluZm8uZnJvbVZhbHVlcyh0aGlzLmludmFsaWRTdGF0ZUVycm9yKCkpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgJiYgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgdGhpcy5jbGllbnQuX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucy5zdWJzY3JpYmVGaWx0ZXIodGhpcywgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIGlmICh0aGlzLmNoYW5uZWxPcHRpb25zLmF0dGFjaE9uU3Vic2NyaWJlICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICB1bnN1YnNjcmliZSguLi5hcmdzKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBbZXZlbnQsIGxpc3RlbmVyXSA9IF9SZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmdzKTtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmICFsaXN0ZW5lciB8fCAoKF9hMiA9IHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmhhcyhsaXN0ZW5lcikpKSB7XG4gICAgICB0aGlzLmNsaWVudC5fRmlsdGVyZWRTdWJzY3JpcHRpb25zLmdldEFuZERlbGV0ZUZpbHRlcmVkU3Vic2NyaXB0aW9ucyh0aGlzLCBldmVudCwgbGlzdGVuZXIpLmZvckVhY2goKGwpID0+IHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYobCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgc3luYygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICAgIHRocm93IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHN5bmMgdG8gY2hhbm5lbDsgbm90IGF0dGFjaGVkXCIsIDRlNCk7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBjb25zdCBzeW5jTWVzc2FnZSA9IGZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuU1lOQywgY2hhbm5lbDogdGhpcy5uYW1lIH0pO1xuICAgIGlmICh0aGlzLnN5bmNDaGFubmVsU2VyaWFsKSB7XG4gICAgICBzeW5jTWVzc2FnZS5jaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbDtcbiAgICB9XG4gICAgY29ubmVjdGlvbk1hbmFnZXIuc2VuZChzeW5jTWVzc2FnZSk7XG4gIH1cbiAgYXN5bmMgc2VuZE1lc3NhZ2UobXNnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc2VuZChtc2csIHRoaXMuY2xpZW50Lm9wdGlvbnMucXVldWVNZXNzYWdlcywgKGVyciwgcHVibGlzaFJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHB1Ymxpc2hSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNlbmRQcmVzZW5jZShwcmVzZW5jZSkge1xuICAgIGNvbnN0IG1zZyA9IGZyb21WYWx1ZXMoe1xuICAgICAgYWN0aW9uOiBhY3Rpb25zLlBSRVNFTkNFLFxuICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgcHJlc2VuY2VcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlKG1zZyk7XG4gIH1cbiAgYXN5bmMgc2VuZFN0YXRlKG9iamVjdE1lc3NhZ2VzKSB7XG4gICAgY29uc3QgbXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuT0JKRUNULFxuICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgc3RhdGU6IG9iamVjdE1lc3NhZ2VzXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShtc2cpO1xuICB9XG4gIC8vIEFjY2VzcyB0byB0aGlzIG1ldGhvZCBpcyBzeW5jaHJvbmlzZWQgYnkgQ29ubmVjdGlvbk1hbmFnZXIjcHJvY2Vzc0NoYW5uZWxNZXNzYWdlLCBpbiBvcmRlciB0byBzeW5jaHJvbmlzZSBhY2Nlc3MgdG8gdGhlIHN0YXRlIHN0b3JlZCBpbiBfZGVjb2RpbmdDb250ZXh0LlxuICBhc3luYyBwcm9jZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLkFUVEFDSEVEIHx8IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLk1FU1NBR0UgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuT0JKRUNUIHx8IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLkFOTk9UQVRJT04pIHtcbiAgICAgIHRoaXMuc2V0Q2hhbm5lbFNlcmlhbChtZXNzYWdlLmNoYW5uZWxTZXJpYWwpO1xuICAgIH1cbiAgICBsZXQgc3luY0NoYW5uZWxTZXJpYWwsIGlzU3luYyA9IGZhbHNlO1xuICAgIHN3aXRjaCAobWVzc2FnZS5hY3Rpb24pIHtcbiAgICAgIGNhc2UgYWN0aW9ucy5BVFRBQ0hFRDoge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICB0aGlzLl9tb2RlID0gbWVzc2FnZS5nZXRNb2RlKCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gbWVzc2FnZS5wYXJhbXMgfHwge307XG4gICAgICAgIGNvbnN0IG1vZGVzRnJvbUZsYWdzID0gbWVzc2FnZS5kZWNvZGVNb2Rlc0Zyb21GbGFncygpO1xuICAgICAgICB0aGlzLm1vZGVzID0gbW9kZXNGcm9tRmxhZ3MgJiYgYWxsVG9Mb3dlckNhc2UobW9kZXNGcm9tRmxhZ3MpIHx8IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcmVzdW1lZCA9IG1lc3NhZ2UuaGFzRmxhZyhcIlJFU1VNRURcIik7XG4gICAgICAgIGNvbnN0IGhhc1ByZXNlbmNlID0gbWVzc2FnZS5oYXNGbGFnKFwiSEFTX1BSRVNFTkNFXCIpO1xuICAgICAgICBjb25zdCBoYXNCYWNrbG9nID0gbWVzc2FnZS5oYXNGbGFnKFwiSEFTX0JBQ0tMT0dcIik7XG4gICAgICAgIGNvbnN0IGhhc09iamVjdHMgPSBtZXNzYWdlLmhhc0ZsYWcoXCJIQVNfT0JKRUNUU1wiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICAgIGlmICghcmVzdW1lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3ByZXNlbmNlLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29iamVjdCkge1xuICAgICAgICAgICAgICB0aGlzLl9vYmplY3Qub25BdHRhY2hlZChoYXNPYmplY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuc3RhdGUsIHRoaXMuc3RhdGUsIHJlc3VtZWQsIGhhc0JhY2tsb2csIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoXCJ1cGRhdGVcIiwgY2hhbmdlKTtcbiAgICAgICAgICBpZiAoIXJlc3VtZWQgfHwgdGhpcy5jaGFubmVsT3B0aW9ucy51cGRhdGVPbkF0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgY2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJkZXRhY2hpbmdcIikge1xuICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiYXR0YWNoZWRcIiwgbWVzc2FnZS5lcnJvciwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2csIGhhc09iamVjdHMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLkRFVEFDSEVEOiB7XG4gICAgICAgIGNvbnN0IGRldGFjaEVyciA9IG1lc3NhZ2UuZXJyb3IgPyBFcnJvckluZm8uZnJvbVZhbHVlcyhtZXNzYWdlLmVycm9yKSA6IG5ldyBFcnJvckluZm8oXCJDaGFubmVsIGRldGFjaGVkXCIsIDkwMDAxLCA0MDQpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJkZXRhY2hpbmdcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJkZXRhY2hlZFwiLCBkZXRhY2hFcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwic3VzcGVuZGVkXCIsIGRldGFjaEVycik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiIHx8IHRoaXMuc3RhdGUgPT09IFwic3VzcGVuZGVkXCIpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZShcImF0dGFjaGluZ1wiLCBkZXRhY2hFcnIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLlNZTkM6XG4gICAgICAgIGlzU3luYyA9IHRydWU7XG4gICAgICAgIHN5bmNDaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnByZXNlbmNlKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLlBSRVNFTkNFOiB7XG4gICAgICAgIGlmICghbWVzc2FnZS5wcmVzZW5jZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlRmllbGRzRnJvbVBhcmVudChtZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgICAgIGNvbnN0IHByZXNlbmNlTWVzc2FnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIG1lc3NhZ2UucHJlc2VuY2UubWFwKCh3cG0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdwbS5kZWNvZGUob3B0aW9ucywgdGhpcy5sb2dnZXIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX3ByZXNlbmNlLnNldFByZXNlbmNlKHByZXNlbmNlTWVzc2FnZXMsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLk9CSkVDVDpcbiAgICAgIGNhc2UgYWN0aW9ucy5PQkpFQ1RfU1lOQzoge1xuICAgICAgICBpZiAoIXRoaXMuX29iamVjdCB8fCAhbWVzc2FnZS5zdGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwb3B1bGF0ZUZpZWxkc0Zyb21QYXJlbnQobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuZ2V0QWN0aXZlVHJhbnNwb3J0Rm9ybWF0KCk7XG4gICAgICAgIGNvbnN0IG9iamVjdE1lc3NhZ2VzID0gbWVzc2FnZS5zdGF0ZS5tYXAoKG9tKSA9PiBvbS5kZWNvZGUodGhpcy5jbGllbnQsIGZvcm1hdCkpO1xuICAgICAgICBpZiAobWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuT0JKRUNUKSB7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0LmhhbmRsZU9iamVjdE1lc3NhZ2VzKG9iamVjdE1lc3NhZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3QuaGFuZGxlT2JqZWN0U3luY01lc3NhZ2VzKG9iamVjdE1lc3NhZ2VzLCBtZXNzYWdlLmNoYW5uZWxTZXJpYWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLk1FU1NBR0U6IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwucHJvY2Vzc01lc3NhZ2UoKVwiLFxuICAgICAgICAgICAgJ01lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBza2lwcGVkIGFzIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIgc3RhdGUgaXMgbm90IFwiYXR0YWNoZWRcIiAoc3RhdGUgaXMgXCInICsgdGhpcy5zdGF0ZSArICdcIikuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlRmllbGRzRnJvbVBhcmVudChtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZCA9IG1lc3NhZ2UubWVzc2FnZXMsIGZpcnN0TWVzc2FnZSA9IGVuY29kZWRbMF0sIGxhc3RNZXNzYWdlID0gZW5jb2RlZFtlbmNvZGVkLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZmlyc3RNZXNzYWdlLmV4dHJhcyAmJiBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEuZnJvbSAhPT0gdGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ0RlbHRhIG1lc3NhZ2UgZGVjb2RlIGZhaWx1cmUgLSBwcmV2aW91cyBtZXNzYWdlIG5vdCBhdmFpbGFibGUgZm9yIG1lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBvbiB0aGlzIGNoYW5uZWwgXCInICsgdGhpcy5uYW1lICsgJ1wiLic7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIiwgbXNnKTtcbiAgICAgICAgICB0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShuZXcgRXJyb3JJbmZvKG1zZywgNDAwMTgsIDQwMCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB7IGRlY29kZWQsIGVyciB9ID0gYXdhaXQgZW5jb2RlZFtpXS5kZWNvZGVXaXRoRXJyKHRoaXMuX2RlY29kaW5nQ29udGV4dCwgdGhpcy5sb2dnZXIpO1xuICAgICAgICAgIG1lc3NhZ2VzW2ldID0gZGVjb2RlZDtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgNDAwMTg6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGNhc2UgNDAwMTk6XG4gICAgICAgICAgICAgIGNhc2UgNDAwMjE6XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImZhaWxlZFwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkID0gbGFzdE1lc3NhZ2UuaWQ7XG4gICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgIHRoaXMub25FdmVudChtZXNzYWdlcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLkFOTk9UQVRJT046IHtcbiAgICAgICAgcG9wdWxhdGVGaWVsZHNGcm9tUGFyZW50KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuX2Fubm90YXRpb25zKSB7XG4gICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIChtZXNzYWdlLmFubm90YXRpb25zIHx8IFtdKS5tYXAoKHdwbSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gd3BtLmRlY29kZShvcHRpb25zLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMuX3Byb2Nlc3NJbmNvbWluZyhhbm5vdGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuRVJST1I6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PSA4MDAxNikge1xuICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiZmFpbGVkXCIsIEVycm9ySW5mby5mcm9tVmFsdWVzKGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgICAgXCJQcm90b2NvbCBlcnJvcjogdW5yZWNvZ25pc2VkIG1lc3NhZ2UgYWN0aW9uIChcIiArIG1lc3NhZ2UuYWN0aW9uICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbiAgX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgIFwiU3RhcnRpbmcgZGVjb2RlIGZhaWx1cmUgcmVjb3ZlcnkgcHJvY2Vzcy5cIlxuICAgICAgKTtcbiAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgdGhpcy5fYXR0YWNoKHRydWUsIHJlYXNvbiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25BdHRhY2hlZCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLm9uQXR0YWNoZWRcIixcbiAgICAgIFwiYWN0aXZhdGluZyBjaGFubmVsOyBuYW1lID0gXCIgKyB0aGlzLm5hbWVcbiAgICApO1xuICB9XG4gIG5vdGlmeVN0YXRlKHN0YXRlLCByZWFzb24sIHJlc3VtZWQsIGhhc1ByZXNlbmNlLCBoYXNCYWNrbG9nLCBoYXNPYmplY3RzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5ub3RpZnlTdGF0ZVwiLFxuICAgICAgXCJuYW1lID0gXCIgKyB0aGlzLm5hbWUgKyBcIiwgY3VycmVudCBzdGF0ZSA9IFwiICsgdGhpcy5zdGF0ZSArIFwiLCBub3RpZnlpbmcgc3RhdGUgXCIgKyBzdGF0ZVxuICAgICk7XG4gICAgdGhpcy5jbGVhclN0YXRlVGltZXIoKTtcbiAgICBpZiAoW1wiZGV0YWNoZWRcIiwgXCJzdXNwZW5kZWRcIiwgXCJmYWlsZWRcIl0uaW5jbHVkZXMoc3RhdGUpKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcHJlc2VuY2UpIHtcbiAgICAgIHRoaXMuX3ByZXNlbmNlLmFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgcmVhc29uKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29iamVjdCkge1xuICAgICAgdGhpcy5fb2JqZWN0LmFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNPYmplY3RzKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcInN1c3BlbmRlZFwiICYmIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc2VuZEV2ZW50cykge1xuICAgICAgdGhpcy5zdGFydFJldHJ5VGltZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgfVxuICAgIGlmIChyZWFzb24pIHtcbiAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSByZWFzb247XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2VfZGVmYXVsdCh0aGlzLnN0YXRlLCBzdGF0ZSwgcmVzdW1lZCwgaGFzQmFja2xvZywgcmVhc29uKTtcbiAgICBjb25zdCBhY3Rpb24gPSAnQ2hhbm5lbCBzdGF0ZSBmb3IgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCInO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBzdGF0ZSArIChyZWFzb24gPyBcIjsgcmVhc29uOiBcIiArIHJlYXNvbiA6IFwiXCIpO1xuICAgIGlmIChzdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgIT09IFwiYXR0YWNoaW5nXCIgJiYgc3RhdGUgIT09IFwic3VzcGVuZGVkXCIpIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICB0aGlzLm9uQXR0YWNoZWQoKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIHRoaXMuX2F0dGFjaFJlc3VtZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJkZXRhY2hpbmdcIiB8fCBzdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuICAgIHRoaXMuZW1pdChzdGF0ZSwgY2hhbmdlKTtcbiAgfVxuICByZXF1ZXN0U3RhdGUoc3RhdGUsIHJlYXNvbikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwucmVxdWVzdFN0YXRlXCIsXG4gICAgICBcIm5hbWUgPSBcIiArIHRoaXMubmFtZSArIFwiLCBzdGF0ZSA9IFwiICsgc3RhdGVcbiAgICApO1xuICAgIHRoaXMubm90aWZ5U3RhdGUoc3RhdGUsIHJlYXNvbik7XG4gICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICB9XG4gIGNoZWNrUGVuZGluZ1N0YXRlKCkge1xuICAgIGNvbnN0IGNtU3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlO1xuICAgIGlmICghY21TdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlXCIsXG4gICAgICAgIFwic2VuZEV2ZW50cyBpcyBmYWxzZTsgc3RhdGUgaXMgXCIgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlXCIsXG4gICAgICBcIm5hbWUgPSBcIiArIHRoaXMubmFtZSArIFwiLCBzdGF0ZSA9IFwiICsgdGhpcy5zdGF0ZVxuICAgICk7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCk7XG4gICAgICAgIHRoaXMuYXR0YWNoSW1wbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcbiAgICAgICAgdGhpcy5kZXRhY2hJbXBsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aW1lb3V0UGVuZGluZ1N0YXRlKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBcImF0dGFjaGluZ1wiOiB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckluZm8oXCJDaGFubmVsIGF0dGFjaCB0aW1lZCBvdXRcIiwgOTAwMDcsIDQwOCk7XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJzdXNwZW5kZWRcIiwgZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgZGV0YWNoIHRpbWVkIG91dFwiLCA5MDAwNywgNDA4KTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImF0dGFjaGVkXCIsIGVycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZVRpbWVyKSB7XG4gICAgICB0aGlzLnN0YXRlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWVDaGFubmVsLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZ1wiLCBcInRpbWVyIGV4cGlyZWRcIik7XG4gICAgICAgIHRoaXMuc3RhdGVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZW91dFBlbmRpbmdTdGF0ZSgpO1xuICAgICAgfSwgdGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgY2xlYXJTdGF0ZVRpbWVyKCkge1xuICAgIGNvbnN0IHN0YXRlVGltZXIgPSB0aGlzLnN0YXRlVGltZXI7XG4gICAgaWYgKHN0YXRlVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzdGF0ZVRpbWVyKTtcbiAgICAgIHRoaXMuc3RhdGVUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0UmV0cnlUaW1lcigpIHtcbiAgICBpZiAodGhpcy5yZXRyeVRpbWVyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucmV0cnlDb3VudCsrO1xuICAgIGNvbnN0IHJldHJ5RGVsYXkgPSBnZXRSZXRyeVRpbWUodGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cy5jaGFubmVsUmV0cnlUaW1lb3V0LCB0aGlzLnJldHJ5Q291bnQpO1xuICAgIHRoaXMucmV0cnlUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwgcmV0cnkgdGltZXIgZXhwaXJlZFwiLFxuICAgICAgICAgIFwiYXR0ZW1wdGluZyBhIG5ldyBhdHRhY2hcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZShcImF0dGFjaGluZ1wiKTtcbiAgICAgIH1cbiAgICB9LCByZXRyeURlbGF5KTtcbiAgfVxuICBjYW5jZWxSZXRyeVRpbWVyKCkge1xuICAgIGlmICh0aGlzLnJldHJ5VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZXIpO1xuICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyogQHJldHVybnMgbnVsbCAoaWYgY2FuIHNhZmVseSBiZSByZWxlYXNlZCkgfCBFcnJvckluZm8gKGlmIGNhbm5vdCkgKi9cbiAgZ2V0UmVsZWFzZUVycigpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAocyA9PT0gXCJpbml0aWFsaXplZFwiIHx8IHMgPT09IFwiZGV0YWNoZWRcIiB8fCBzID09PSBcImZhaWxlZFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXG4gICAgICBcIkNhbiBvbmx5IHJlbGVhc2UgYSBjaGFubmVsIGluIGEgc3RhdGUgd2hlcmUgdGhlcmUgaXMgbm8gcG9zc2liaWxpdHkgb2YgZnVydGhlciB1cGRhdGVzIGZyb20gdGhlIHNlcnZlciBiZWluZyByZWNlaXZlZCAoaW5pdGlhbGl6ZWQsIGRldGFjaGVkLCBvciBmYWlsZWQpOyB3YXMgXCIgKyBzLFxuICAgICAgOTAwMDEsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG4gIHNldENoYW5uZWxTZXJpYWwoY2hhbm5lbFNlcmlhbCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwuc2V0Q2hhbm5lbFNlcmlhbCgpXCIsXG4gICAgICBcIlVwZGF0aW5nIGNoYW5uZWwgc2VyaWFsOyBzZXJpYWwgPSBcIiArIGNoYW5uZWxTZXJpYWwgKyBcIjsgcHJldmlvdXMgPSBcIiArIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsXG4gICAgKTtcbiAgICBpZiAoY2hhbm5lbFNlcmlhbCkge1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgPSBjaGFubmVsU2VyaWFsO1xuICAgIH1cbiAgfVxuICBhc3luYyBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnN0YXR1cyh0aGlzKTtcbiAgfVxuICBhc3luYyBnZXRNZXNzYWdlKHNlcmlhbE9yTWVzc2FnZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5nZXRNZXNzYWdlKClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHJlc3RNaXhpbiA9IHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluO1xuICAgIHJldHVybiByZXN0TWl4aW4uZ2V0TWVzc2FnZSh0aGlzLCBzZXJpYWxPck1lc3NhZ2UpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1lc3NhZ2UobWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwudXBkYXRlTWVzc2FnZSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kVXBkYXRlKG1lc3NhZ2UsIFwibWVzc2FnZS51cGRhdGVcIiwgb3BlcmF0aW9uLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGRlbGV0ZU1lc3NhZ2UobWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwuZGVsZXRlTWVzc2FnZSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kVXBkYXRlKG1lc3NhZ2UsIFwibWVzc2FnZS5kZWxldGVcIiwgb3BlcmF0aW9uLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGFwcGVuZE1lc3NhZ2UobWVzc2FnZSwgb3BlcmF0aW9uLCBwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwuYXBwZW5kTWVzc2FnZSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kVXBkYXRlKG1lc3NhZ2UsIFwibWVzc2FnZS5hcHBlbmRcIiwgb3BlcmF0aW9uLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHNlbmRVcGRhdGUobWVzc2FnZSwgYWN0aW9uLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGlmICghbWVzc2FnZS5zZXJpYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICdUaGlzIG1lc3NhZ2UgbGFja3MgYSBzZXJpYWwgYW5kIGNhbm5vdCBiZSB1cGRhdGVkLiBNYWtlIHN1cmUgeW91IGhhdmUgZW5hYmxlZCBcIk1lc3NhZ2UgYW5ub3RhdGlvbnMsIHVwZGF0ZXMsIGFuZCBkZWxldGVzXCIgaW4gY2hhbm5lbCBzZXR0aW5ncyBvbiB5b3VyIGRhc2hib2FyZC4nLFxuICAgICAgICA0MDAwMyxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnRocm93SWZVbnB1Ymxpc2hhYmxlU3RhdGUoKTtcbiAgICBjb25zdCB1cGRhdGVEZWxldGVNc2cgPSBtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXNzYWdlKSwge1xuICAgICAgYWN0aW9uLFxuICAgICAgdmVyc2lvbjogb3BlcmF0aW9uXG4gICAgfSkpO1xuICAgIGNvbnN0IHdpcmVNZXNzYWdlID0gYXdhaXQgdXBkYXRlRGVsZXRlTXNnLmVuY29kZSh0aGlzLmNoYW5uZWxPcHRpb25zKTtcbiAgICBjb25zdCBwbSA9IGZyb21WYWx1ZXMoe1xuICAgICAgYWN0aW9uOiBhY3Rpb25zLk1FU1NBR0UsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlczogW3dpcmVNZXNzYWdlXSxcbiAgICAgIHBhcmFtczogcGFyYW1zID8gc3RyaW5naWZ5VmFsdWVzKHBhcmFtcykgOiB2b2lkIDBcbiAgICB9KTtcbiAgICBjb25zdCBwdWJsaXNoUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlKHBtKTtcbiAgICByZXR1cm4geyB2ZXJzaW9uU2VyaWFsOiAoX2IgPSAoX2EyID0gcHVibGlzaFJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiBwdWJsaXNoUmVzcG9uc2Uuc2VyaWFscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMlswXSkgIT0gbnVsbCA/IF9iIDogbnVsbCB9O1xuICB9XG4gIGFzeW5jIGdldE1lc3NhZ2VWZXJzaW9ucyhzZXJpYWxPck1lc3NhZ2UsIHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5nZXRNZXNzYWdlVmVyc2lvbnMoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgY29uc3QgcmVzdE1peGluID0gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW47XG4gICAgcmV0dXJuIHJlc3RNaXhpbi5nZXRNZXNzYWdlVmVyc2lvbnModGhpcywgc2VyaWFsT3JNZXNzYWdlLCBwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBjaGFubmVsIGlzIGF0dGFjaGVkLCBhdHRhY2hpbmcgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgdXNlIGJ5IGZlYXR1cmVzIGxpa2UgUHJlc2VuY2Ugb3IgT2JqZWN0cyB0aGF0IG5lZWQgdG9cbiAgICogaW1wbGljaXRseSBhdHRhY2ggdGhlIGNoYW5uZWwgd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FsbGVkIChlLmcuLCBgcHJlc2VuY2UuZ2V0KClgIHBlciBSVFAxMWIsXG4gICAqIG9yIGBvYmplY3RzLmdldCgpYCkuIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHRoZSBjb3JyZXNwb25kaW5nIHN5bmMgc2VxdWVuY2Ugd2lsbCBzdGFydCBhbmRcbiAgICogdGhhdCB0aGUgb3BlcmF0aW9uIHdpbGwgcmVzb2x2ZSBmb3IgY2FsbGVycyBldmVuIGlmIHRoZXkgZGlkIG5vdCBleHBsaWNpdGx5IGF0dGFjaCBiZWZvcmVoYW5kLlxuICAgKi9cbiAgYXN5bmMgZW5zdXJlQXR0YWNoZWQoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZWRcIjpcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgY2FzZSBcImF0dGFjaGluZ1wiOlxuICAgICAgICBhd2FpdCB0aGlzLmF0dGFjaCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKHRoaXMuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gb21pdEFnZW50KGNoYW5uZWxQYXJhbXMpIHtcbiAgY29uc3QgX2EyID0gY2hhbm5lbFBhcmFtcyB8fCB7fSwgeyBhZ2VudDogXyB9ID0gX2EyLCBwYXJhbXNXaXRob3V0QWdlbnQgPSBfX29ialJlc3QoX2EyLCBbXCJhZ2VudFwiXSk7XG4gIHJldHVybiBwYXJhbXNXaXRob3V0QWdlbnQ7XG59XG52YXIgcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQgPSBSZWFsdGltZUNoYW5uZWw7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZWFubm90YXRpb25zLnRzXG52YXIgUmVhbHRpbWVBbm5vdGF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgdGhpcy5sb2dnZXIgPSBjaGFubmVsLmxvZ2dlcjtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2gobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IHRoaXMuY2hhbm5lbC5uYW1lO1xuICAgIGNvbnN0IGFubm90YXRpb24gPSBjb25zdHJ1Y3RWYWxpZGF0ZUFubm90YXRpb24obXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpO1xuICAgIGNvbnN0IHdpcmVBbm5vdGF0aW9uID0gYXdhaXQgYW5ub3RhdGlvbi5lbmNvZGUoKTtcbiAgICB0aGlzLmNoYW5uZWwudGhyb3dJZlVucHVibGlzaGFibGVTdGF0ZSgpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZUFubm90YXRpb25zLnB1Ymxpc2goKVwiLFxuICAgICAgXCJjaGFubmVsTmFtZSA9IFwiICsgY2hhbm5lbE5hbWUgKyBcIiwgc2VuZGluZyBhbm5vdGF0aW9uIHdpdGggbWVzc2FnZVNlcmlhbCA9IFwiICsgYW5ub3RhdGlvbi5tZXNzYWdlU2VyaWFsICsgXCIsIHR5cGUgPSBcIiArIGFubm90YXRpb24udHlwZVxuICAgICk7XG4gICAgY29uc3QgcG0gPSBmcm9tVmFsdWVzKHtcbiAgICAgIGFjdGlvbjogYWN0aW9ucy5BTk5PVEFUSU9OLFxuICAgICAgY2hhbm5lbDogY2hhbm5lbE5hbWUsXG4gICAgICBhbm5vdGF0aW9uczogW3dpcmVBbm5vdGF0aW9uXVxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuY2hhbm5lbC5zZW5kTWVzc2FnZShwbSk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKSB7XG4gICAgYW5ub3RhdGlvblZhbHVlcy5hY3Rpb24gPSBcImFubm90YXRpb24uZGVsZXRlXCI7XG4gICAgYXdhaXQgdGhpcy5wdWJsaXNoKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUoLi4uX2FyZ3MpIHtcbiAgICBjb25zdCBhcmdzID0gcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgIGlmIChjaGFubmVsLnN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aHJvdyBFcnJvckluZm8uZnJvbVZhbHVlcyhjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpO1xuICAgIH1cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICBpZiAodGhpcy5jaGFubmVsLmNoYW5uZWxPcHRpb25zLmF0dGFjaE9uU3Vic2NyaWJlICE9PSBmYWxzZSkge1xuICAgICAgYXdhaXQgY2hhbm5lbC5hdHRhY2goKTtcbiAgICB9XG4gICAgaWYgKCh0aGlzLmNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIiAmJiB0aGlzLmNoYW5uZWwuX21vZGUgJiBmbGFncy5BTk5PVEFUSU9OX1NVQlNDUklCRSkgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiWW91IGFyZSB0cnlpbmcgdG8gYWRkIGFuIGFubm90YXRpb24gbGlzdGVuZXIsIGJ1dCB5b3UgaGF2ZW4ndCByZXF1ZXN0ZWQgdGhlIGFubm90YXRpb25fc3Vic2NyaWJlIGNoYW5uZWwgbW9kZSBpbiBDaGFubmVsT3B0aW9ucywgc28gdGhpcyB3b24ndCBkbyBhbnl0aGluZyAod2Ugb25seSBkZWxpdmVyIGFubm90YXRpb25zIHRvIGNsaWVudHMgd2hvIGhhdmUgZXhwbGljaXRseSByZXF1ZXN0ZWQgdGhlbSlcIixcbiAgICAgICAgOTMwMDEsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdW5zdWJzY3JpYmUoLi4uX2FyZ3MpIHtcbiAgICBjb25zdCBhcmdzID0gcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgX3Byb2Nlc3NJbmNvbWluZyhhbm5vdGF0aW9ucykge1xuICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmVtaXQoYW5ub3RhdGlvbi50eXBlIHx8IFwiXCIsIGFubm90YXRpb24pO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXQobXNnT3JTZXJpYWwsIHBhcmFtcykge1xuICAgIHJldHVybiByZXN0YW5ub3RhdGlvbnNfZGVmYXVsdC5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgbXNnT3JTZXJpYWwsIHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcmVhbHRpbWVhbm5vdGF0aW9uc19kZWZhdWx0ID0gUmVhbHRpbWVBbm5vdGF0aW9ucztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2RlZmF1bHRyZXN0LnRzXG52YXIgX0RlZmF1bHRSZXN0ID0gY2xhc3MgX0RlZmF1bHRSZXN0IGV4dGVuZHMgQmFzZVJlc3Qge1xuICAvLyBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgcmVxdWlyZXMgYW4gYXJndW1lbnQgdG8gYmUgcGFzc2VkLCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG5vdCBwYXNzIGFuIGFyZ3VtZW50LCB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoaXMgaXMgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIGl0LlxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgY29uc3QgTXNnUGFjayA9IF9EZWZhdWx0UmVzdC5fTXNnUGFjaztcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIERlZmF1bHRSZXN0Ll9Nc2dQYWNrIHRvIGhhdmUgYmVlbiBzZXRcIik7XG4gICAgfVxuICAgIHN1cGVyKFxuICAgICAgZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIHRydWUsIFwiUmVzdFwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhbGxDb21tb25Nb2R1bGFyUGx1Z2lucyksIHtcbiAgICAgICAgQ3J5cHRvOiAoX2EyID0gX0RlZmF1bHRSZXN0LkNyeXB0bykgIT0gbnVsbCA/IF9hMiA6IHZvaWQgMCxcbiAgICAgICAgTXNnUGFjazogKF9iID0gX0RlZmF1bHRSZXN0Ll9Nc2dQYWNrKSAhPSBudWxsID8gX2IgOiB2b2lkIDAsXG4gICAgICAgIEFubm90YXRpb25zOiB7XG4gICAgICAgICAgQW5ub3RhdGlvbjogYW5ub3RhdGlvbl9kZWZhdWx0LFxuICAgICAgICAgIFdpcmVBbm5vdGF0aW9uLFxuICAgICAgICAgIFJlYWx0aW1lQW5ub3RhdGlvbnM6IHJlYWx0aW1lYW5ub3RhdGlvbnNfZGVmYXVsdCxcbiAgICAgICAgICBSZXN0QW5ub3RhdGlvbnM6IHJlc3Rhbm5vdGF0aW9uc19kZWZhdWx0XG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGdldCBDcnlwdG8oKSB7XG4gICAgaWYgKHRoaXMuX0NyeXB0byA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fQ3J5cHRvO1xuICB9XG4gIHN0YXRpYyBzZXQgQ3J5cHRvKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fQ3J5cHRvID0gbmV3VmFsdWU7XG4gIH1cbn07XG5fRGVmYXVsdFJlc3QuX0NyeXB0byA9IG51bGw7XG5fRGVmYXVsdFJlc3QuTWVzc2FnZSA9IERlZmF1bHRNZXNzYWdlO1xuX0RlZmF1bHRSZXN0LlByZXNlbmNlTWVzc2FnZSA9IERlZmF1bHRQcmVzZW5jZU1lc3NhZ2U7XG5fRGVmYXVsdFJlc3QuQW5ub3RhdGlvbiA9IERlZmF1bHRBbm5vdGF0aW9uO1xuX0RlZmF1bHRSZXN0Ll9Nc2dQYWNrID0gbnVsbDtcbi8vIFVzZWQgYnkgdGVzdHNcbl9EZWZhdWx0UmVzdC5fSHR0cCA9IEh0dHA7XG52YXIgRGVmYXVsdFJlc3QgPSBfRGVmYXVsdFJlc3Q7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9tZXNzYWdlcXVldWUudHNcbnZhciBNZXNzYWdlUXVldWUgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgc3VwZXIobG9nZ2VyKTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gIH1cbiAgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICB9XG4gIHB1c2gobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgfVxuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5zaGlmdCgpO1xuICB9XG4gIGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXNbdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBjb3B5QWxsKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLnNsaWNlKCk7XG4gIH1cbiAgYXBwZW5kKG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoLmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgfVxuICBwcmVwZW5kKG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5tZXNzYWdlcy51bnNoaWZ0LmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgfVxuICAvKipcbiAgICogRm9yIGFsbCBtZXNzYWdlcyB0YXJnZXRlZCBieSB0aGUgc2VsZWN0b3IsIGNhbGxzIHRoZWlyIGNhbGxiYWNrIGFuZCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RvciAtIERlc2NyaWJlcyB3aGljaCBtZXNzYWdlcyB0byB0YXJnZXQuICdhbGwnIG1lYW5zIGFsbCBtZXNzYWdlcyBpbiB0aGUgcXVldWUgKHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGV5IGhhdmUgaGFkIGEgYG1zZ1NlcmlhbGAgYXNzaWduZWQpOyBgc2VyaWFsYCAvIGBjb3VudGAgdGFyZ2V0cyBhIHJhbmdlIG9mIG1lc3NhZ2VzIGRlc2NyaWJlZCBieSBhbiBgQUNLYCBvciBgTkFDS2AgcmVjZWl2ZWQgZnJvbSBBYmx5ICh0aGlzIGFzc3VtZXMgdGhhdCBhbGwgdGhlIG1lc3NhZ2VzIGluIHRoZSBxdWV1ZSBoYXZlIGhhZCBhIGBtc2dTZXJpYWxgIGFzc2lnbmVkKS5cbiAgICovXG4gIGNvbXBsZXRlTWVzc2FnZXMoc2VsZWN0b3IsIGVyciwgcmVzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIk1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKClcIixcbiAgICAgIHNlbGVjdG9yID09IFwiYWxsXCIgPyBcIihhbGwpXCIgOiBcInNlcmlhbCA9IFwiICsgc2VsZWN0b3Iuc2VyaWFsICsgXCI7IGNvdW50ID0gXCIgKyBzZWxlY3Rvci5jb3VudFxuICAgICk7XG4gICAgZXJyID0gZXJyIHx8IG51bGw7XG4gICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKCk6IGNvbXBsZXRlTWVzc2FnZXMgY2FsbGVkIG9uIGFueSBlbXB0eSBNZXNzYWdlUXVldWVcIik7XG4gICAgfVxuICAgIGxldCBjb21wbGV0ZU1lc3NhZ2VzID0gW107XG4gICAgaWYgKHNlbGVjdG9yID09PSBcImFsbFwiKSB7XG4gICAgICBjb21wbGV0ZU1lc3NhZ2VzID0gbWVzc2FnZXMuc3BsaWNlKDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaXJzdCA9IG1lc3NhZ2VzWzBdO1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U2VyaWFsID0gZmlyc3QubWVzc2FnZS5tc2dTZXJpYWw7XG4gICAgICAgIGNvbnN0IGVuZFNlcmlhbCA9IHNlbGVjdG9yLnNlcmlhbCArIHNlbGVjdG9yLmNvdW50O1xuICAgICAgICBpZiAoZW5kU2VyaWFsID4gc3RhcnRTZXJpYWwpIHtcbiAgICAgICAgICBjb21wbGV0ZU1lc3NhZ2VzID0gbWVzc2FnZXMuc3BsaWNlKDAsIGVuZFNlcmlhbCAtIHN0YXJ0U2VyaWFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBsZXRlTWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjb21wbGV0ZU1lc3NhZ2VzW2ldO1xuICAgICAgY29uc3QgcHVibGlzaFJlc3BvbnNlID0gcmVzID09IG51bGwgPyB2b2lkIDAgOiByZXNbaV07XG4gICAgICBtZXNzYWdlLmNhbGxiYWNrKGVyciwgcHVibGlzaFJlc3BvbnNlKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgdGhpcy5lbWl0KFwiaWRsZVwiKTtcbiAgfVxuICBjb21wbGV0ZUFsbE1lc3NhZ2VzKGVycikge1xuICAgIHRoaXMuY29tcGxldGVNZXNzYWdlcyhcImFsbFwiLCBlcnIpO1xuICB9XG4gIHJlc2V0U2VuZEF0dGVtcHRlZCgpIHtcbiAgICBmb3IgKGxldCBtc2cgb2YgdGhpcy5tZXNzYWdlcykge1xuICAgICAgbXNnLnNlbmRBdHRlbXB0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIk1lc3NhZ2VRdWV1ZS5jbGVhcigpXCIsXG4gICAgICBcImNsZWFyaW5nIFwiICsgdGhpcy5tZXNzYWdlcy5sZW5ndGggKyBcIiBtZXNzYWdlc1wiXG4gICAgKTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5lbWl0KFwiaWRsZVwiKTtcbiAgfVxufTtcbnZhciBtZXNzYWdlcXVldWVfZGVmYXVsdCA9IE1lc3NhZ2VRdWV1ZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L3Byb3RvY29sLnRzXG52YXIgUGVuZGluZ01lc3NhZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5tZXJnZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhY3Rpb24gPSBtZXNzYWdlLmFjdGlvbjtcbiAgICB0aGlzLnNlbmRBdHRlbXB0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFja1JlcXVpcmVkID0gdHlwZW9mIGFjdGlvbiA9PT0gXCJudW1iZXJcIiAmJiBbYWN0aW9ucy5NRVNTQUdFLCBhY3Rpb25zLlBSRVNFTkNFLCBhY3Rpb25zLkFOTk9UQVRJT04sIGFjdGlvbnMuT0JKRUNUXS5pbmNsdWRlcyhhY3Rpb24pO1xuICB9XG59O1xudmFyIFByb3RvY29sID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgIHN1cGVyKHRyYW5zcG9ydC5sb2dnZXIpO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gbmV3IG1lc3NhZ2VxdWV1ZV9kZWZhdWx0KHRoaXMubG9nZ2VyKTtcbiAgICB0cmFuc3BvcnQub24oXCJhY2tcIiwgKHNlcmlhbCwgY291bnQsIHJlcykgPT4ge1xuICAgICAgdGhpcy5vbkFjayhzZXJpYWwsIGNvdW50LCByZXMpO1xuICAgIH0pO1xuICAgIHRyYW5zcG9ydC5vbihcIm5hY2tcIiwgKHNlcmlhbCwgY291bnQsIGVycikgPT4ge1xuICAgICAgdGhpcy5vbk5hY2soc2VyaWFsLCBjb3VudCwgZXJyKTtcbiAgICB9KTtcbiAgfVxuICBvbkFjayhzZXJpYWwsIGNvdW50LCByZXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJQcm90b2NvbC5vbkFjaygpXCIsIFwic2VyaWFsID0gXCIgKyBzZXJpYWwgKyBcIjsgY291bnQgPSBcIiArIGNvdW50KTtcbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHsgc2VyaWFsLCBjb3VudCB9LCBudWxsLCByZXMpO1xuICB9XG4gIG9uTmFjayhzZXJpYWwsIGNvdW50LCBlcnIpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgIFwiUHJvdG9jb2wub25OYWNrKClcIixcbiAgICAgIFwic2VyaWFsID0gXCIgKyBzZXJpYWwgKyBcIjsgY291bnQgPSBcIiArIGNvdW50ICsgXCI7IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICApO1xuICAgIGlmICghZXJyKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHNlbmQgbWVzc2FnZTsgY2hhbm5lbCBub3QgcmVzcG9uZGluZ1wiLCA1MDAwMSwgNTAwKTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyh7IHNlcmlhbCwgY291bnQgfSwgZXJyKTtcbiAgfVxuICBvbmNlSWRsZShsaXN0ZW5lcikge1xuICAgIGNvbnN0IG1lc3NhZ2VRdWV1ZSA9IHRoaXMubWVzc2FnZVF1ZXVlO1xuICAgIGlmIChtZXNzYWdlUXVldWUuY291bnQoKSA9PT0gMCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWVzc2FnZVF1ZXVlLm9uY2UoXCJpZGxlXCIsIGxpc3RlbmVyKTtcbiAgfVxuICBzZW5kKHBlbmRpbmdNZXNzYWdlKSB7XG4gICAgaWYgKHBlbmRpbmdNZXNzYWdlLmFja1JlcXVpcmVkKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKHBlbmRpbmdNZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlByb3RvY29sLnNlbmQoKVwiLFxuICAgICAgICBcInNlbmRpbmcgbXNnOyBcIiArIHN0cmluZ2lmeShcbiAgICAgICAgICBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlLFxuICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlLFxuICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Bbm5vdGF0aW9ucyxcbiAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fbGl2ZU9iamVjdHNQbHVnaW5cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCA9IHRydWU7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZChwZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgfVxuICBnZXRUcmFuc3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0O1xuICB9XG4gIGdldFBlbmRpbmdNZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlUXVldWUuY29weUFsbCgpO1xuICB9XG4gIGNsZWFyUGVuZGluZ01lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jbGVhcigpO1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydDtcbiAgICB0aGlzLm9uY2VJZGxlKGZ1bmN0aW9uKCkge1xuICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBwcm90b2NvbF9kZWZhdWx0ID0gUHJvdG9jb2w7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jb25uZWN0aW9uc3RhdGVjaGFuZ2UudHNcbnZhciBDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBjdXJyZW50LCByZXRyeUluLCByZWFzb24pIHtcbiAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICBpZiAocmV0cnlJbilcbiAgICAgIHRoaXMucmV0cnlJbiA9IHJldHJ5SW47XG4gICAgaWYgKHJlYXNvbilcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59O1xudmFyIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0ID0gQ29ubmVjdGlvblN0YXRlQ2hhbmdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29ubmVjdGlvbmVycm9ycy50c1xudmFyIENvbm5lY3Rpb25FcnJvckNvZGVzID0ge1xuICBESVNDT05ORUNURUQ6IDgwMDAzLFxuICBTVVNQRU5ERUQ6IDgwMDAyLFxuICBGQUlMRUQ6IDhlNCxcbiAgQ0xPU0lORzogODAwMTcsXG4gIENMT1NFRDogODAwMTcsXG4gIFVOS05PV05fQ09OTkVDVElPTl9FUlI6IDUwMDAyLFxuICBVTktOT1dOX0NIQU5ORUxfRVJSOiA1MDAwMVxufTtcbnZhciBDb25uZWN0aW9uRXJyb3JzID0ge1xuICBkaXNjb25uZWN0ZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuRElTQ09OTkVDVEVELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGVcIlxuICB9KSxcbiAgc3VzcGVuZGVkOiAoKSA9PiBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG4gICAgc3RhdHVzQ29kZTogNDAwLFxuICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLlNVU1BFTkRFRCxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gdG8gc2VydmVyIHVuYXZhaWxhYmxlXCJcbiAgfSksXG4gIGZhaWxlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5GQUlMRUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIGZhaWxlZCBvciBkaXNjb25uZWN0ZWQgYnkgc2VydmVyXCJcbiAgfSksXG4gIGNsb3Npbmc6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuQ0xPU0lORyxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gY2xvc2luZ1wiXG4gIH0pLFxuICBjbG9zZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuQ0xPU0VELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBjbG9zZWRcIlxuICB9KSxcbiAgdW5rbm93bkNvbm5lY3Rpb25FcnI6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuVU5LTk9XTl9DT05ORUNUSU9OX0VSUixcbiAgICBtZXNzYWdlOiBcIkludGVybmFsIGNvbm5lY3Rpb24gZXJyb3JcIlxuICB9KSxcbiAgdW5rbm93bkNoYW5uZWxFcnI6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuVU5LTk9XTl9DT05ORUNUSU9OX0VSUixcbiAgICBtZXNzYWdlOiBcIkludGVybmFsIGNoYW5uZWwgZXJyb3JcIlxuICB9KVxufTtcbmZ1bmN0aW9uIGlzUmV0cmlhYmxlKGVycikge1xuICBpZiAoIWVyci5zdGF0dXNDb2RlIHx8ICFlcnIuY29kZSB8fCBlcnIuc3RhdHVzQ29kZSA+PSA1MDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhDb25uZWN0aW9uRXJyb3JDb2RlcykuaW5jbHVkZXMoZXJyLmNvZGUpO1xufVxudmFyIGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdCA9IENvbm5lY3Rpb25FcnJvcnM7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC90cmFuc3BvcnQudHNcbnZhciBjbG9zZU1lc3NhZ2UgPSBmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkNMT1NFIH0pO1xudmFyIGRpc2Nvbm5lY3RNZXNzYWdlID0gZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5ESVNDT05ORUNUIH0pO1xudmFyIFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBmb3JjZUpzb25Qcm90b2NvbCkge1xuICAgIHN1cGVyKGNvbm5lY3Rpb25NYW5hZ2VyLmxvZ2dlcik7XG4gICAgaWYgKGZvcmNlSnNvblByb3RvY29sKSB7XG4gICAgICBwYXJhbXMuZm9ybWF0ID0gdm9pZCAwO1xuICAgICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLnRpbWVvdXRzID0gcGFyYW1zLm9wdGlvbnMudGltZW91dHM7XG4gICAgdGhpcy5mb3JtYXQgPSBwYXJhbXMuZm9ybWF0O1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIHRoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcbiAgfVxuICBjb25uZWN0KCkge1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnJlcXVlc3RDbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaChcImNsb3NlZFwiLCBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQuY2xvc2VkKCkpO1xuICB9XG4gIGRpc2Nvbm5lY3QoZXJyKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyIHx8IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC5kaXNjb25uZWN0ZWQoKSk7XG4gIH1cbiAgZmFpbChlcnIpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaChcImZhaWxlZFwiLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmZhaWxlZCgpKTtcbiAgfVxuICBmaW5pc2goZXZlbnQsIGVycikge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KChfYTIgPSB0aGlzLmlkbGVUaW1lcikgIT0gbnVsbCA/IF9hMiA6IHZvaWQgMCk7XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuZW1pdChldmVudCwgZXJyKTtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgfVxuICBvblByb3RvY29sTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlRyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpXCIsXG4gICAgICAgIFwicmVjZWl2ZWQgb24gXCIgKyB0aGlzLnNob3J0TmFtZSArIFwiOiBcIiArIHN0cmluZ2lmeShcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fQW5ub3RhdGlvbnMsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fbGl2ZU9iamVjdHNQbHVnaW5cbiAgICAgICAgKSArIFwiOyBjb25uZWN0aW9uSWQgPSBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UuYWN0aW9uKSB7XG4gICAgICBjYXNlIGFjdGlvbnMuSEVBUlRCRUFUOlxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIlRyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpXCIsXG4gICAgICAgICAgdGhpcy5zaG9ydE5hbWUgKyBcIiBoZWFydGJlYXQ7IGNvbm5lY3Rpb25JZCA9IFwiICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiaGVhcnRiZWF0XCIsIG1lc3NhZ2UuaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5DT05ORUNURUQ6XG4gICAgICAgIHRoaXMub25Db25uZWN0KG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0ZWRcIiwgbWVzc2FnZS5lcnJvciwgbWVzc2FnZS5jb25uZWN0aW9uSWQsIG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMsIG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5DTE9TRUQ6XG4gICAgICAgIHRoaXMub25DbG9zZShtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuRElTQ09OTkVDVEVEOlxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdChtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuQUNLOlxuICAgICAgICB0aGlzLmVtaXQoXCJhY2tcIiwgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQsIG1lc3NhZ2UucmVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuTkFDSzpcbiAgICAgICAgdGhpcy5lbWl0KFwibmFja1wiLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLlNZTkM6XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuQUNUSVZBVEU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLkFVVEg6XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLmF1dGguYXV0aG9yaXplKCksIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgICAgICAgXCJBYmx5IHJlcXVlc3RlZCByZS1hdXRoZW50aWNhdGlvbiwgYnV0IHVuYWJsZSB0byBvYnRhaW4gYSBuZXcgdG9rZW46IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuRVJST1I6XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICAgIFwicmVjZWl2ZWQgZXJyb3IgYWN0aW9uOyBjb25uZWN0aW9uSWQgPSBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkICsgXCI7IGVyciA9IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QobWVzc2FnZS5lcnJvcikgKyAobWVzc2FnZS5jaGFubmVsID8gXCIsIGNoYW5uZWw6IFwiICsgbWVzc2FnZS5jaGFubmVsIDogXCJcIilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY2hhbm5lbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhpcy5vbkZhdGFsRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25Db25uZWN0KG1lc3NhZ2UpIHtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICBpZiAoIW1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydC5vbkNvbm5lY3QoKTogQ29ubmVjdCBtZXNzYWdlIHJlY2lldmVkIHdpdGhvdXQgY29ubmVjdGlvbkRldGFpbHNcIik7XG4gICAgfVxuICAgIGNvbnN0IG1heFByb21pc2VkSWRsZSA9IG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuICAgIGlmIChtYXhQcm9taXNlZElkbGUpIHtcbiAgICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbWF4UHJvbWlzZWRJZGxlICsgdGhpcy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG4gIG9uRGlzY29ubmVjdChtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5vbkRpc2Nvbm5lY3QoKVwiLCBcImVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycikpO1xuICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gIH1cbiAgb25GYXRhbEVycm9yKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0Lm9uRmF0YWxFcnJvcigpXCIsIFwiZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgdGhpcy5maW5pc2goXCJmYWlsZWRcIiwgZXJyKTtcbiAgfVxuICBvbkNsb3NlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0Lm9uQ2xvc2UoKVwiLCBcImVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycikpO1xuICAgIHRoaXMuZmluaXNoKFwiY2xvc2VkXCIsIGVycik7XG4gIH1cbiAgcmVxdWVzdENsb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLnNlbmQoY2xvc2VNZXNzYWdlKTtcbiAgfVxuICByZXF1ZXN0RGlzY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKVwiLCBcIlwiKTtcbiAgICB0aGlzLnNlbmQoZGlzY29ubmVjdE1lc3NhZ2UpO1xuICB9XG4gIHBpbmcoaWQpIHtcbiAgICBjb25zdCBtc2cgPSB7IGFjdGlvbjogYWN0aW9ucy5IRUFSVEJFQVQgfTtcbiAgICBpZiAoaWQpXG4gICAgICBtc2cuaWQgPSBpZDtcbiAgICB0aGlzLnNlbmQoZnJvbVZhbHVlcyhtc2cpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJcIik7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9mZigpO1xuICB9XG4gIG9uQWN0aXZpdHkoKSB7XG4gICAgaWYgKCF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIubGFzdEFjdGl2aXR5ID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnNldElkbGVUaW1lcih0aGlzLm1heElkbGVJbnRlcnZhbCArIDEwMCk7XG4gIH1cbiAgc2V0SWRsZVRpbWVyKHRpbWVvdXQpIHtcbiAgICBpZiAoIXRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICB0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLm9uSWRsZVRpbWVyRXhwaXJlKCk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgb25JZGxlVGltZXJFeHBpcmUoKSB7XG4gICAgaWYgKCF0aGlzLmxhc3RBY3Rpdml0eSB8fCAhdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydC5vbklkbGVUaW1lckV4cGlyZSgpOiBsYXN0QWN0aXZpdHkvbWF4SWRsZUludGVydmFsIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICBjb25zdCBzaW5jZUxhc3QgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG4gICAgY29uc3QgdGltZVJlbWFpbmluZyA9IHRoaXMubWF4SWRsZUludGVydmFsIC0gc2luY2VMYXN0O1xuICAgIGlmICh0aW1lUmVtYWluaW5nIDw9IDApIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiTm8gYWN0aXZpdHkgc2VlbiBmcm9tIHJlYWx0aW1lIGluIFwiICsgc2luY2VMYXN0ICsgXCJtczsgYXNzdW1pbmcgY29ubmVjdGlvbiBoYXMgZHJvcHBlZFwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKClcIiwgbXNnKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdChuZXcgRXJyb3JJbmZvKG1zZywgODAwMDMsIDQwOCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldElkbGVUaW1lcih0aW1lUmVtYWluaW5nICsgMTAwKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHRyeUNvbm5lY3QodHJhbnNwb3J0Q3RvciwgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHRyYW5zcG9ydFBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0Q3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zKTtcbiAgICBsZXQgdHJhbnNwb3J0QXR0ZW1wdFRpbWVyO1xuICAgIGNvbnN0IGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc3BvcnRBdHRlbXB0VGltZXIpO1xuICAgICAgY2FsbGJhY2soeyBldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVyciB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQgPSBjb25uZWN0aW9uTWFuYWdlci5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgdHJhbnNwb3J0QXR0ZW1wdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0cmFuc3BvcnQub2ZmKFtcInByZWNvbm5lY3RcIiwgXCJkaXNjb25uZWN0ZWRcIiwgXCJmYWlsZWRcIl0pO1xuICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgIGVycm9yQ2IuY2FsbChcbiAgICAgICAgeyBldmVudDogXCJkaXNjb25uZWN0ZWRcIiB9LFxuICAgICAgICBuZXcgRXJyb3JJbmZvKFwiVGltZW91dCB3YWl0aW5nIGZvciB0cmFuc3BvcnQgdG8gaW5kaWNhdGUgaXRzZWxmIHZpYWJsZVwiLCA1ZTQsIDUwMClcbiAgICAgICk7XG4gICAgfSwgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG4gICAgdHJhbnNwb3J0Lm9uKFtcImZhaWxlZFwiLCBcImRpc2Nvbm5lY3RlZFwiXSwgZXJyb3JDYik7XG4gICAgdHJhbnNwb3J0Lm9uKFwicHJlY29ubmVjdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiVHJhbnNwb3J0LnRyeUNvbm5lY3QoKVwiLFxuICAgICAgICBcInZpYWJsZSB0cmFuc3BvcnQgXCIgKyB0cmFuc3BvcnRcbiAgICAgICk7XG4gICAgICBjbGVhclRpbWVvdXQodHJhbnNwb3J0QXR0ZW1wdFRpbWVyKTtcbiAgICAgIHRyYW5zcG9ydC5vZmYoW1wiZmFpbGVkXCIsIFwiZGlzY29ubmVjdGVkXCJdLCBlcnJvckNiKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG4gICAgfSk7XG4gICAgdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gdHJhbnNwb3J0O1xuICB9XG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiaXNBdmFpbGFibGUgbm90IGltcGxlbWVudGVkIGZvciB0cmFuc3BvcnRcIiwgNWU0LCA1MDApO1xuICB9XG59O1xudmFyIHRyYW5zcG9ydF9kZWZhdWx0ID0gVHJhbnNwb3J0O1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9UcmFuc3BvcnROYW1lLnRzXG52YXIgVHJhbnNwb3J0TmFtZXM7XG4oKFRyYW5zcG9ydE5hbWVzMikgPT4ge1xuICBUcmFuc3BvcnROYW1lczIuV2ViU29ja2V0ID0gXCJ3ZWJfc29ja2V0XCI7XG4gIFRyYW5zcG9ydE5hbWVzMi5Db21ldCA9IFwiY29tZXRcIjtcbiAgVHJhbnNwb3J0TmFtZXMyLlhoclBvbGxpbmcgPSBcInhocl9wb2xsaW5nXCI7XG59KShUcmFuc3BvcnROYW1lcyB8fCAoVHJhbnNwb3J0TmFtZXMgPSB7fSkpO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29ubmVjdGlvbm1hbmFnZXIudHNcbnZhciBnbG9iYWxPYmplY3QyID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBzZWxmO1xudmFyIGhhdmVXZWJTdG9yYWdlID0gKCkgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gdHlwZW9mIFBsYXRmb3JtLldlYlN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIgJiYgKChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvY2FsU3VwcG9ydGVkKTtcbn07XG52YXIgaGF2ZVNlc3Npb25TdG9yYWdlID0gKCkgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gdHlwZW9mIFBsYXRmb3JtLldlYlN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIgJiYgKChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNlc3Npb25TdXBwb3J0ZWQpO1xufTtcbnZhciBub29wMiA9IGZ1bmN0aW9uKCkge1xufTtcbnZhciB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSA9IFwiYWJseS10cmFuc3BvcnQtcHJlZmVyZW5jZVwiO1xuZnVuY3Rpb24gZGVjb2RlUmVjb3ZlcnlLZXkocmVjb3ZlcnlLZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZWNvdmVyeUtleSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxudmFyIFRyYW5zcG9ydFBhcmFtcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaG9zdCwgbW9kZSwgY29ubmVjdGlvbktleSkge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25LZXk7XG4gICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi87XG4gIH1cbiAgZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gYXV0aFBhcmFtcyA/IGNvcHkoYXV0aFBhcmFtcykgOiB7fTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICBjYXNlIFwicmVzdW1lXCI6XG4gICAgICAgIHBhcmFtcy5yZXN1bWUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlY292ZXJcIjoge1xuICAgICAgICBjb25zdCByZWNvdmVyeUNvbnRleHQgPSBkZWNvZGVSZWNvdmVyeUtleShvcHRpb25zLnJlY292ZXIpO1xuICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgcGFyYW1zLnJlY292ZXIgPSByZWNvdmVyeUNvbnRleHQuY29ubmVjdGlvbktleTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNsaWVudElkICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50SWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVjaG9NZXNzYWdlcyA9PT0gZmFsc2UpIHtcbiAgICAgIHBhcmFtcy5lY2hvID0gXCJmYWxzZVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5mb3JtYXQgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJlYW0gIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLnN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuICAgIH1cbiAgICBpZiAodGhpcy5oZWFydGJlYXRzICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5oZWFydGJlYXRzID0gdGhpcy5oZWFydGJlYXRzO1xuICAgIH1cbiAgICBwYXJhbXMudiA9IGRlZmF1bHRzX2RlZmF1bHQucHJvdG9jb2xWZXJzaW9uO1xuICAgIHBhcmFtcy5hZ2VudCA9IGdldEFnZW50U3RyaW5nKHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNwb3J0UGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICAgIG1peGluKHBhcmFtcywgb3B0aW9ucy50cmFuc3BvcnRQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCByZXN1bHQgPSBcIlttb2RlPVwiICsgdGhpcy5tb2RlO1xuICAgIGlmICh0aGlzLmhvc3QpIHtcbiAgICAgIHJlc3VsdCArPSBcIixob3N0PVwiICsgdGhpcy5ob3N0O1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICByZXN1bHQgKz0gXCIsY29ubmVjdGlvbktleT1cIiArIHRoaXMuY29ubmVjdGlvbktleTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZm9ybWF0KSB7XG4gICAgICByZXN1bHQgKz0gXCIsZm9ybWF0PVwiICsgdGhpcy5mb3JtYXQ7XG4gICAgfVxuICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xudmFyIENvbm5lY3Rpb25NYW5hZ2VyID0gY2xhc3MgX0Nvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihyZWFsdGltZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKHJlYWx0aW1lLmxvZ2dlcik7XG4gICAgdGhpcy5zdXBwb3J0ZWRUcmFuc3BvcnRzID0ge307XG4gICAgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZSA9IHsgaXNQcm9jZXNzaW5nOiBmYWxzZSwgcXVldWU6IFtdIH07XG4gICAgdGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuICAgIHRoaXMuaW5pdFRyYW5zcG9ydHMoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGNvbnN0IHRpbWVvdXRzID0gb3B0aW9ucy50aW1lb3V0cztcbiAgICBjb25zdCBjb25uZWN0aW5nVGltZW91dCA9IHRpbWVvdXRzLndlYlNvY2tldENvbm5lY3RUaW1lb3V0ICsgdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICB0aGlzLnN0YXRlcyA9IHtcbiAgICAgIGluaXRpYWxpemVkOiB7XG4gICAgICAgIHN0YXRlOiBcImluaXRpYWxpemVkXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICBmYWlsU3RhdGU6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgIH0sXG4gICAgICBjb25uZWN0aW5nOiB7XG4gICAgICAgIHN0YXRlOiBcImNvbm5lY3RpbmdcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IGNvbm5lY3RpbmdUaW1lb3V0LFxuICAgICAgICBmYWlsU3RhdGU6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgIH0sXG4gICAgICBjb25uZWN0ZWQ6IHtcbiAgICAgICAgc3RhdGU6IFwiY29ubmVjdGVkXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICBzZW5kRXZlbnRzOiB0cnVlLFxuICAgICAgICBmYWlsU3RhdGU6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgIH0sXG4gICAgICBkaXNjb25uZWN0ZWQ6IHtcbiAgICAgICAgc3RhdGU6IFwiZGlzY29ubmVjdGVkXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5kaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIHN1c3BlbmRlZDoge1xuICAgICAgICBzdGF0ZTogXCJzdXNwZW5kZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5zdXNwZW5kZWRSZXRyeVRpbWVvdXQsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJzdXNwZW5kZWRcIlxuICAgICAgfSxcbiAgICAgIGNsb3Npbmc6IHtcbiAgICAgICAgc3RhdGU6IFwiY2xvc2luZ1wiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJjbG9zZWRcIlxuICAgICAgfSxcbiAgICAgIGNsb3NlZDogeyBzdGF0ZTogXCJjbG9zZWRcIiwgdGVybWluYWw6IHRydWUsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogXCJjbG9zZWRcIiB9LFxuICAgICAgZmFpbGVkOiB7IHN0YXRlOiBcImZhaWxlZFwiLCB0ZXJtaW5hbDogdHJ1ZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiBcImZhaWxlZFwiIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5pbml0aWFsaXplZDtcbiAgICB0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzID0gbmV3IG1lc3NhZ2VxdWV1ZV9kZWZhdWx0KHRoaXMubG9nZ2VyKTtcbiAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgdGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25JZCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25LZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSB0aW1lb3V0cy5jb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0cyA9IGludGVyc2VjdChvcHRpb25zLnRyYW5zcG9ydHMgfHwgZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0VHJhbnNwb3J0cywgdGhpcy5zdXBwb3J0ZWRUcmFuc3BvcnRzKTtcbiAgICB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuICAgIGlmICh0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXMoVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0KSkge1xuICAgICAgdGhpcy53ZWJTb2NrZXRUcmFuc3BvcnRBdmFpbGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFuc3BvcnRzLmluY2x1ZGVzKFRyYW5zcG9ydE5hbWVzLlhoclBvbGxpbmcpKSB7XG4gICAgICB0aGlzLmJhc2VUcmFuc3BvcnQgPSBUcmFuc3BvcnROYW1lcy5YaHJQb2xsaW5nO1xuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc3BvcnRzLmluY2x1ZGVzKFRyYW5zcG9ydE5hbWVzLkNvbWV0KSkge1xuICAgICAgdGhpcy5iYXNlVHJhbnNwb3J0ID0gVHJhbnNwb3J0TmFtZXMuQ29tZXQ7XG4gICAgfVxuICAgIHRoaXMuZG9tYWlucyA9IGRlZmF1bHRzX2RlZmF1bHQuZ2V0SG9zdHMob3B0aW9ucyk7XG4gICAgdGhpcy5hY3RpdmVQcm90b2NvbCA9IG51bGw7XG4gICAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xuICAgIHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcbiAgICB0aGlzLmNvbm5lY3RDb3VudGVyID0gMDtcbiAgICB0aGlzLndzQ2hlY2tSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMud2ViU29ja2V0U2xvd1RpbWVyID0gbnVsbDtcbiAgICB0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyID0gbnVsbDtcbiAgICB0aGlzLmFiYW5kb25lZFdlYlNvY2tldCA9IGZhbHNlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIiwgXCJzdGFydGVkXCIpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcInJlcXVlc3RlZCB0cmFuc3BvcnRzID0gW1wiICsgKG9wdGlvbnMudHJhbnNwb3J0cyB8fCBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRUcmFuc3BvcnRzKSArIFwiXVwiXG4gICAgKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLFxuICAgICAgXCJhdmFpbGFibGUgdHJhbnNwb3J0cyA9IFtcIiArIHRoaXMudHJhbnNwb3J0cyArIFwiXVwiXG4gICAgKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLFxuICAgICAgXCJodHRwIGRvbWFpbnMgPSBbXCIgKyB0aGlzLmRvbWFpbnMgKyBcIl1cIlxuICAgICk7XG4gICAgaWYgKCF0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtc2cgPSBcIm5vIHJlcXVlc3RlZCB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwicmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLCBtc2cpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIGNvbnN0IGFkZEV2ZW50TGlzdGVuZXIgPSBQbGF0Zm9ybS5Db25maWcuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICBpZiAoYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgaWYgKGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmIHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIHRoaXMucGVyc2lzdENvbm5lY3Rpb24uYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5jbG9zZU9uVW5sb2FkID09PSB0cnVlKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICAgICAgICBcImJlZm9yZXVubG9hZCBldmVudCBoYXMgdHJpZ2dlcmVkIHRoZSBjb25uZWN0aW9uIHRvIGNsb3NlIGFzIGNsb3NlT25VbmxvYWQgaXMgdHJ1ZVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNsb3NpbmdcIiB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsICgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZGlzY29ubmVjdGVkIHx8IHRoaXMuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuc3VzcGVuZGVkKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIGNhdWdodCBicm93c2VyIFxcdTIwMThvbmxpbmVcXHUyMDE5IGV2ZW50XCIsXG4gICAgICAgICAgICBcInJlYXR0ZW1wdGluZyBjb25uZWN0aW9uXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGluZ1wiIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgIChfYTIgPSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIub2ZmKCk7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIgXFx1MjAxOG9mZmxpbmVcXHUyMDE5IGV2ZW50XCIsXG4gICAgICAgICAgICBcImRpc2Nvbm5lY3RpbmcgYWN0aXZlIHRyYW5zcG9ydFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKioqKioqKioqKioqKioqKioqKioqXG4gICAqIHRyYW5zcG9ydCBtYW5hZ2VtZW50XG4gICAqKioqKioqKioqKioqKioqKioqKiovXG4gIC8vIFVzZWQgYnkgdGVzdHNcbiAgc3RhdGljIHN1cHBvcnRlZFRyYW5zcG9ydHMoYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucykge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB7IHN1cHBvcnRlZFRyYW5zcG9ydHM6IHt9IH07XG4gICAgdGhpcy5pbml0VHJhbnNwb3J0cyhhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zLCBzdG9yYWdlKTtcbiAgICByZXR1cm4gc3RvcmFnZS5zdXBwb3J0ZWRUcmFuc3BvcnRzO1xuICB9XG4gIHN0YXRpYyBpbml0VHJhbnNwb3J0cyhhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zLCBzdG9yYWdlKSB7XG4gICAgY29uc3QgaW1wbGVtZW50YXRpb25zID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIFBsYXRmb3JtLlRyYW5zcG9ydHMuYnVuZGxlZEltcGxlbWVudGF0aW9ucyksIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMpO1xuICAgIFtUcmFuc3BvcnROYW1lcy5XZWJTb2NrZXQsIC4uLlBsYXRmb3JtLlRyYW5zcG9ydHMub3JkZXJdLmZvckVhY2goKHRyYW5zcG9ydE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IGltcGxlbWVudGF0aW9uc1t0cmFuc3BvcnROYW1lXTtcbiAgICAgIGlmICh0cmFuc3BvcnQgJiYgdHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgc3RvcmFnZS5zdXBwb3J0ZWRUcmFuc3BvcnRzW3RyYW5zcG9ydE5hbWVdID0gdHJhbnNwb3J0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGluaXRUcmFuc3BvcnRzKCkge1xuICAgIF9Db25uZWN0aW9uTWFuYWdlci5pbml0VHJhbnNwb3J0cyh0aGlzLnJlYWx0aW1lLl9hZGRpdGlvbmFsVHJhbnNwb3J0SW1wbGVtZW50YXRpb25zLCB0aGlzKTtcbiAgfVxuICBjcmVhdGVUcmFuc3BvcnRQYXJhbXMoaG9zdCwgbW9kZSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNwb3J0UGFyYW1zKHRoaXMub3B0aW9ucywgaG9zdCwgbW9kZSwgdGhpcy5jb25uZWN0aW9uS2V5KTtcbiAgfVxuICBnZXRUcmFuc3BvcnRQYXJhbXMoY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWNpZGVNb2RlID0gKG1vZGVDYikgPT4ge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgICBtb2RlQ2IoXCJyZXN1bWVcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlY292ZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbW9kZUNiKFwicmVjb3ZlclwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVjb3ZlckZuID0gdGhpcy5vcHRpb25zLnJlY292ZXIsIGxhc3RTZXNzaW9uRGF0YSA9IHRoaXMuZ2V0U2Vzc2lvblJlY292ZXJEYXRhKCksIHNlc3Npb25SZWNvdmVyeU5hbWUgPSB0aGlzLnNlc3Npb25SZWNvdmVyeU5hbWUoKTtcbiAgICAgIGlmIChsYXN0U2Vzc2lvbkRhdGEgJiYgdHlwZW9mIHJlY292ZXJGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKVwiLFxuICAgICAgICAgIFwiQ2FsbGluZyBjbGllbnRPcHRpb25zLXByb3ZpZGVkIHJlY292ZXIgZnVuY3Rpb24gd2l0aCBsYXN0IHNlc3Npb24gZGF0YSAocmVjb3Zlcnkgc2NvcGU6IFwiICsgc2Vzc2lvblJlY292ZXJ5TmFtZSArIFwiKVwiXG4gICAgICAgICk7XG4gICAgICAgIHJlY292ZXJGbihsYXN0U2Vzc2lvbkRhdGEsIChzaG91bGRSZWNvdmVyKSA9PiB7XG4gICAgICAgICAgaWYgKHNob3VsZFJlY292ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZWNvdmVyID0gbGFzdFNlc3Npb25EYXRhLnJlY292ZXJ5S2V5O1xuICAgICAgICAgICAgbW9kZUNiKFwicmVjb3ZlclwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZUNiKFwiY2xlYW5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbW9kZUNiKFwiY2xlYW5cIik7XG4gICAgfTtcbiAgICBkZWNpZGVNb2RlKChtb2RlKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc3BvcnRQYXJhbXMgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhudWxsLCBtb2RlKTtcbiAgICAgIGlmIChtb2RlID09PSBcInJlY292ZXJcIikge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKClcIixcbiAgICAgICAgICBcIlRyYW5zcG9ydCByZWNvdmVyeSBtb2RlID0gcmVjb3ZlcjsgcmVjb3ZlcnlLZXkgPSBcIiArIHRoaXMub3B0aW9ucy5yZWNvdmVyXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KHRoaXMub3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgaWYgKHJlY292ZXJ5Q29udGV4dCkge1xuICAgICAgICAgIHRoaXMubXNnU2VyaWFsID0gcmVjb3ZlcnlDb250ZXh0Lm1zZ1NlcmlhbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpXCIsXG4gICAgICAgICAgXCJUcmFuc3BvcnQgcGFyYW1zID0gXCIgKyB0cmFuc3BvcnRQYXJhbXMudG9TdHJpbmcoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sodHJhbnNwb3J0UGFyYW1zKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdCB0byBjb25uZWN0IHVzaW5nIGEgZ2l2ZW4gdHJhbnNwb3J0XG4gICAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcbiAgICogQHBhcmFtIGNhbmRpZGF0ZSwgdGhlIHRyYW5zcG9ydCB0byB0cnlcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICB0cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLCBcInRyeWluZyBcIiArIGNhbmRpZGF0ZSk7XG4gICAgdGhpcy5wcm9wb3NlZFRyYW5zcG9ydCA9IHRyYW5zcG9ydF9kZWZhdWx0LnRyeUNvbm5lY3QoXG4gICAgICB0aGlzLnN1cHBvcnRlZFRyYW5zcG9ydHNbY2FuZGlkYXRlXSxcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLnJlYWx0aW1lLmF1dGgsXG4gICAgICB0cmFuc3BvcnRQYXJhbXMsXG4gICAgICAod3JhcHBlZEVyciwgdHJhbnNwb3J0KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3NpbmcgfHwgc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2VkIHx8IHN0YXRlID09IHRoaXMuc3RhdGVzLmZhaWxlZCkge1xuICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KClcIixcbiAgICAgICAgICAgICAgXCJjb25uZWN0aW9uIFwiICsgc3RhdGUuc3RhdGUgKyBcIiB3aGlsZSB3ZSB3ZXJlIGF0dGVtcHRpbmcgdGhlIHRyYW5zcG9ydDsgY2xvc2luZyBcIiArIHRyYW5zcG9ydFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBwZWRFcnIpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpXCIsXG4gICAgICAgICAgICBcInRyYW5zcG9ydCBcIiArIGNhbmRpZGF0ZSArIFwiIFwiICsgd3JhcHBlZEVyci5ldmVudCArIFwiLCBlcnI6IFwiICsgd3JhcHBlZEVyci5lcnJvci50b1N0cmluZygpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIod3JhcHBlZEVyci5lcnJvcikgJiYgISh0aGlzLmVycm9yUmVhc29uICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHdyYXBwZWRFcnIuZXJyb3I7XG4gICAgICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXModGhpcy5yZWFsdGltZS5hdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwpLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3cmFwcGVkRXJyLmV2ZW50ID09PSBcImZhaWxlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiZmFpbGVkXCIsIGVycm9yOiB3cmFwcGVkRXJyLmVycm9yIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3cmFwcGVkRXJyLmV2ZW50ID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKHdyYXBwZWRFcnIuZXJyb3IpKSB7XG4gICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUsIGVycm9yOiB3cmFwcGVkRXJyLmVycm9yIH0pO1xuICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KClcIixcbiAgICAgICAgICBcInZpYWJsZSB0cmFuc3BvcnQgXCIgKyBjYW5kaWRhdGUgKyBcIjsgc2V0dGluZyBwZW5kaW5nXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBpbmRpY2F0ZWQgdG8gYmUgdmlhYmxlLCBhbmQgdGhlIENvbm5lY3Rpb25NYW5hZ2VyXG4gICAqIGV4cGVjdHMgdG8gYWN0aXZhdGUgdGhpcyB0cmFuc3BvcnQgYXMgc29vbiBhcyBpdCBpcyBjb25uZWN0ZWQuXG4gICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgKi9cbiAgc2V0VHJhbnNwb3J0UGVuZGluZyh0cmFuc3BvcnQsIHRyYW5zcG9ydFBhcmFtcykge1xuICAgIGNvbnN0IG1vZGUgPSB0cmFuc3BvcnRQYXJhbXMubW9kZTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2V0VHJhbnNwb3J0UGVuZGluZygpXCIsXG4gICAgICBcInRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0ICsgXCI7IG1vZGUgPSBcIiArIG1vZGVcbiAgICApO1xuICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLmNhbmNlbFdlYlNvY2tldFNsb3dUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0R2l2ZVVwVGltZXIoKTtcbiAgICB0cmFuc3BvcnQub25jZShcImNvbm5lY3RlZFwiLCAoZXJyb3IsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpID0+IHtcbiAgICAgIHRoaXMuYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gICAgICBpZiAobW9kZSA9PT0gXCJyZWNvdmVyXCIgJiYgdGhpcy5vcHRpb25zLnJlY292ZXIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5yZWNvdmVyO1xuICAgICAgICB0aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzZWxmMiA9IHRoaXM7XG4gICAgdHJhbnNwb3J0Lm9uKFtcImRpc2Nvbm5lY3RlZFwiLCBcImNsb3NlZFwiLCBcImZhaWxlZFwiXSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHNlbGYyLmRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCB0aGlzLmV2ZW50LCBlcnJvcik7XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFwidHJhbnNwb3J0LnBlbmRpbmdcIiwgdHJhbnNwb3J0KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgY29ubmVjdGVkLCBhbmQgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIGRlY2lkZXMgdGhhdFxuICAgKiBpdCB3aWxsIG5vdyBiZSB0aGUgYWN0aXZlIHRyYW5zcG9ydC4gUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBpdCBhY3RpdmF0ZWRcbiAgICogdGhlIHRyYW5zcG9ydCAoaWYgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZy9jbG9zZWQgaXQgd2lsbCBjaG9vc2Ugbm90IHRvKS5cbiAgICogQHBhcmFtIHRyYW5zcG9ydCB0aGUgdHJhbnNwb3J0IGluc3RhbmNlXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uSWQgdGhlIGlkIG9mIHRoZSBuZXcgYWN0aXZlIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIGNvbm5lY3Rpb25EZXRhaWxzIHRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgYWN0aXZlIGNvbm5lY3Rpb25cbiAgICovXG4gIGFjdGl2YXRlVHJhbnNwb3J0KGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgXCJ0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydFxuICAgICk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsIFwiZXJyb3IgPSBcIiArIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25JZCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgICAgXCJjb25uZWN0aW9uSWQgPSAgXCIgKyBjb25uZWN0aW9uSWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgICAgXCJjb25uZWN0aW9uRGV0YWlscyA9ICBcIiArIEpTT04uc3RyaW5naWZ5KGNvbm5lY3Rpb25EZXRhaWxzKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnQpO1xuICAgIGNvbnN0IGV4aXN0aW5nU3RhdGUgPSB0aGlzLnN0YXRlLCBjb25uZWN0ZWRTdGF0ZSA9IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgXCJjdXJyZW50IHN0YXRlID0gXCIgKyBleGlzdGluZ1N0YXRlLnN0YXRlXG4gICAgKTtcbiAgICBpZiAoZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zaW5nLnN0YXRlIHx8IGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2VkLnN0YXRlIHx8IGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZmFpbGVkLnN0YXRlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgdHJhbnNwb3J0IGFuZCBhYmFuZG9uaW5nXCJcbiAgICAgICk7XG4gICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhbnNwb3J0O1xuICAgIGlmICghdHJhbnNwb3J0LmlzQ29ubmVjdGVkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcIkRlY2xpbmluZyB0byBhY3RpdmF0ZSB0cmFuc3BvcnQgXCIgKyB0cmFuc3BvcnQgKyBcIiBzaW5jZSBpdCBhcHBlYXJzIHRvIG5vIGxvbmdlciBiZSBjb25uZWN0ZWRcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdBY3RpdmVQcm90b2NvbCA9IHRoaXMuYWN0aXZlUHJvdG9jb2w7XG4gICAgdGhpcy5hY3RpdmVQcm90b2NvbCA9IG5ldyBwcm90b2NvbF9kZWZhdWx0KHRyYW5zcG9ydCk7XG4gICAgdGhpcy5ob3N0ID0gdHJhbnNwb3J0LnBhcmFtcy5ob3N0O1xuICAgIGNvbnN0IGNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5O1xuICAgIGlmIChjb25uZWN0aW9uS2V5ICYmIHRoaXMuY29ubmVjdGlvbktleSAhPSBjb25uZWN0aW9uS2V5KSB7XG4gICAgICB0aGlzLnNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgISFlcnJvcik7XG4gICAgfVxuICAgIHRoaXMub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KTtcbiAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgdHJhbnNwb3J0Lm9uKFxuICAgICAgICBcImNvbm5lY3RlZFwiLFxuICAgICAgICAoY29ubmVjdGVkRXJyLCBfY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlsczIpID0+IHtcbiAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoY29ubmVjdGlvbkRldGFpbHMyLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBjb25uZWN0ZWRFcnIpKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBpZiAoZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0KGNvbm5lY3RlZFN0YXRlLCBjb25uZWN0ZWRTdGF0ZSwgbnVsbCwgZXJyb3IpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RlZFwiLCBlcnJvciB9KTtcbiAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBlcnJvciB8fCBudWxsO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnQuYWN0aXZlXCIsIHRyYW5zcG9ydCk7XG4gICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgIGlmIChleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpID4gMCkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgIFwiUHJldmlvdXMgYWN0aXZlIHByb3RvY29sIChmb3IgdHJhbnNwb3J0IFwiICsgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQuc2hvcnROYW1lICsgXCIsIG5ldyBvbmUgaXMgXCIgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgXCIpIGZpbmlzaGluZyB3aXRoIFwiICsgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArIFwiIG1lc3NhZ2VzIHN0aWxsIHBlbmRpbmdcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wudHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gXCJBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgd2FzIGFsc28gdGhlIHRyYW5zcG9ydCBmb3IgdGhlIHByZXZpb3VzIGFjdGl2ZSBwcm90b2NvbDsgdHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgXCI7IHN0YWNrID0gXCIgKyBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLCBtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5maW5pc2goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIG5vIGxvbmdlciB0aGUgYWN0aXZlIHRyYW5zcG9ydC4gVGhpcyBjYW4gb2NjdXJcbiAgICogaW4gYW55IHRyYW5zcG9ydCBjb25uZWN0aW9uIHN0YXRlLlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0XG4gICAqL1xuICBkZWFjdGl2YXRlVHJhbnNwb3J0KHRyYW5zcG9ydCwgc3RhdGUsIGVycm9yKSB7XG4gICAgY29uc3QgY3VycmVudFByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbCwgd2FzQWN0aXZlID0gY3VycmVudFByb3RvY29sICYmIGN1cnJlbnRQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSA9PT0gdHJhbnNwb3J0LCB3YXNQZW5kaW5nID0gdHJhbnNwb3J0ID09PSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQsIG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPSB0aGlzLm5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24oKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcInRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0XG4gICAgKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcInN0YXRlID0gXCIgKyBzdGF0ZSArICh3YXNBY3RpdmUgPyBcIjsgd2FzIGFjdGl2ZVwiIDogd2FzUGVuZGluZyA/IFwiOyB3YXMgcGVuZGluZ1wiIDogXCJcIikgKyAobm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA/IFwiXCIgOiBcIjsgYW5vdGhlciB0cmFuc3BvcnQgaXMgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uXCIpXG4gICAgKTtcbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSlcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgICAgXCJyZWFzb24gPSAgXCIgKyBlcnJvci5tZXNzYWdlXG4gICAgICApO1xuICAgIGlmICh3YXNBY3RpdmUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgICAgXCJHZXR0aW5nLCBjbGVhcmluZywgYW5kIHJlcXVldWluZyBcIiArIHRoaXMuYWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgKyBcIiBwZW5kaW5nIG1lc3NhZ2VzXCJcbiAgICAgICk7XG4gICAgICB0aGlzLnF1ZXVlUGVuZGluZ01lc3NhZ2VzKGN1cnJlbnRQcm90b2NvbC5nZXRQZW5kaW5nTWVzc2FnZXMoKSk7XG4gICAgICBjdXJyZW50UHJvdG9jb2wuY2xlYXJQZW5kaW5nTWVzc2FnZXMoKTtcbiAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wgPSB0aGlzLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnQuaW5hY3RpdmVcIiwgdHJhbnNwb3J0KTtcbiAgICBpZiAod2FzQWN0aXZlICYmIG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gfHwgd2FzQWN0aXZlICYmIHN0YXRlID09PSBcImZhaWxlZFwiIHx8IHN0YXRlID09PSBcImNsb3NlZFwiIHx8IGN1cnJlbnRQcm90b2NvbCA9PT0gbnVsbCAmJiB3YXNQZW5kaW5nKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IFwiZGlzY29ubmVjdGVkXCIgJiYgZXJyb3IgJiYgZXJyb3Iuc3RhdHVzQ29kZSA+IDUwMCAmJiB0aGlzLmRvbWFpbnMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IHRydWU7XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZSwgZXJyb3IsIHJldHJ5SW1tZWRpYXRlbHk6IHRydWUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb25TdGF0ZSA9IHN0YXRlID09PSBcImZhaWxlZFwiICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKGVycm9yKSA/IFwiZGlzY29ubmVjdGVkXCIgOiBzdGF0ZTtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogbmV3Q29ubmVjdGlvblN0YXRlLCBlcnJvciB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLyogSGVscGVyIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIHdoaWNoIGFyZSBwZW5kaW5nLFxuICAgKiBoYXZlIGJlZW4gY29ubmVjdGVkLCBhbmQgYXJlIGp1c3Qgd2FpdGluZyBmb3Igb25jZU5vUGVuZGluZyB0byBmaXJlIGJlZm9yZVxuICAgKiBiZWluZyBhY3RpdmF0ZWQgKi9cbiAgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMucGVuZGluZ1RyYW5zcG9ydCB8fCAhdGhpcy5wZW5kaW5nVHJhbnNwb3J0LmlzQ29ubmVjdGVkO1xuICB9XG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgaGFzQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgY29uc3QgcHJldkNvbm5JZCA9IHRoaXMuY29ubmVjdGlvbklkLCBjb25uSWRDaGFuZ2VkID0gcHJldkNvbm5JZCAmJiBwcmV2Q29ubklkICE9PSBjb25uZWN0aW9uSWQsIHJlY292ZXJGYWlsdXJlID0gIXByZXZDb25uSWQgJiYgaGFzQ29ubmVjdGlvbkVycm9yO1xuICAgIGlmIChjb25uSWRDaGFuZ2VkIHx8IHJlY292ZXJGYWlsdXJlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKClcIiwgXCJSZXNldHRpbmcgbXNnU2VyaWFsXCIpO1xuICAgICAgdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5yZXNldFNlbmRBdHRlbXB0ZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbklkICE9PSBjb25uZWN0aW9uSWQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKClcIixcbiAgICAgICAgXCJOZXcgY29ubmVjdGlvbklkOyByZWF0dGFjaGluZyBhbnkgYXR0YWNoZWQgY2hhbm5lbHNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmlkID0gdGhpcy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gIH1cbiAgY2xlYXJDb25uZWN0aW9uKCkge1xuICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gdm9pZCAwO1xuICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5rZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgIHRoaXMucXVldWVkTWVzc2FnZXMucmVzZXRTZW5kQXR0ZW1wdGVkKCk7XG4gICAgdGhpcy51bnBlcnNpc3RDb25uZWN0aW9uKCk7XG4gIH1cbiAgY3JlYXRlUmVjb3ZlcnlLZXkoKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY29ubmVjdGlvbktleTogdGhpcy5jb25uZWN0aW9uS2V5LFxuICAgICAgbXNnU2VyaWFsOiB0aGlzLm1zZ1NlcmlhbCxcbiAgICAgIGNoYW5uZWxTZXJpYWxzOiB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLmNoYW5uZWxTZXJpYWxzKClcbiAgICB9KTtcbiAgfVxuICBjaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpIHtcbiAgICBpZiAoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLmNvbm5lY3Rpb25JZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaW5jZUxhc3QgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG4gICAgaWYgKHNpbmNlTGFzdCA+IHRoaXMuY29ubmVjdGlvblN0YXRlVHRsICsgdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpXCIsXG4gICAgICAgIFwiTGFzdCBrbm93biBhY3Rpdml0eSBmcm9tIHJlYWx0aW1lIHdhcyBcIiArIHNpbmNlTGFzdCArIFwibXMgYWdvOyBkaXNjYXJkaW5nIGNvbm5lY3Rpb24gc3RhdGVcIlxuICAgICAgKTtcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uKCk7XG4gICAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9IFwic3VzcGVuZGVkXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcbiAgICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cbiAgICovXG4gIHBlcnNpc3RDb25uZWN0aW9uKCkge1xuICAgIGlmIChoYXZlU2Vzc2lvblN0b3JhZ2UoKSkge1xuICAgICAgY29uc3QgcmVjb3ZlcnlLZXkgPSB0aGlzLmNyZWF0ZVJlY292ZXJ5S2V5KCk7XG4gICAgICBpZiAocmVjb3ZlcnlLZXkpIHtcbiAgICAgICAgdGhpcy5zZXRTZXNzaW9uUmVjb3ZlckRhdGEoe1xuICAgICAgICAgIHJlY292ZXJ5S2V5LFxuICAgICAgICAgIGRpc2Nvbm5lY3RlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgIGxvY2F0aW9uOiBnbG9iYWxPYmplY3QyLmxvY2F0aW9uLFxuICAgICAgICAgIGNsaWVudElkOiB0aGlzLnJlYWx0aW1lLmF1dGguY2xpZW50SWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcbiAgICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cbiAgICovXG4gIHVucGVyc2lzdENvbm5lY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpO1xuICB9XG4gIGdldEFjdGl2ZVRyYW5zcG9ydEZvcm1hdCgpIHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoX2EyID0gdGhpcy5hY3RpdmVQcm90b2NvbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRUcmFuc3BvcnQoKS5mb3JtYXQ7XG4gIH1cbiAgLyoqKioqKioqKioqKioqKioqKioqKlxuICAgKiBzdGF0ZSBtYW5hZ2VtZW50XG4gICAqKioqKioqKioqKioqKioqKioqKiovXG4gIGdldEVycm9yKCkge1xuICAgIGlmICh0aGlzLmVycm9yUmVhc29uKSB7XG4gICAgICBjb25zdCBuZXdFcnJvciA9IFBhcnRpYWxFcnJvckluZm8uZnJvbVZhbHVlcyh0aGlzLmVycm9yUmVhc29uKTtcbiAgICAgIG5ld0Vycm9yLmNhdXNlID0gdGhpcy5lcnJvclJlYXNvbjtcbiAgICAgIHJldHVybiBuZXdFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVFcnJvcigpO1xuICB9XG4gIGdldFN0YXRlRXJyb3IoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYTIgPSBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQpW3RoaXMuc3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpO1xuICB9XG4gIGFjdGl2ZVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzIHx8IHRoaXMuc3RhdGUuc2VuZEV2ZW50cztcbiAgfVxuICBlbmFjdFN0YXRlQ2hhbmdlKHN0YXRlQ2hhbmdlKSB7XG4gICAgY29uc3QgYWN0aW9uID0gXCJDb25uZWN0aW9uIHN0YXRlXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyAoc3RhdGVDaGFuZ2UucmVhc29uID8gXCI7IHJlYXNvbjogXCIgKyBzdGF0ZUNoYW5nZS5yZWFzb24gOiBcIlwiKTtcbiAgICBpZiAoc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZW5hY3RTdGF0ZUNoYW5nZVwiLFxuICAgICAgXCJzZXR0aW5nIG5ldyBzdGF0ZTogXCIgKyBzdGF0ZUNoYW5nZS5jdXJyZW50ICsgXCI7IHJlYXNvbiA9IFwiICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiAmJiBzdGF0ZUNoYW5nZS5yZWFzb24ubWVzc2FnZSlcbiAgICApO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlQ2hhbmdlLmN1cnJlbnRdO1xuICAgIGlmIChzdGF0ZUNoYW5nZS5yZWFzb24pIHtcbiAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgfVxuICAgIGlmIChuZXdTdGF0ZS50ZXJtaW5hbCB8fCBuZXdTdGF0ZS5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbnN0YXRlXCIsIHN0YXRlQ2hhbmdlKTtcbiAgfVxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBDb25uZWN0aW9uTWFuYWdlciBjb25uZWN0aW9uIGxpZmVjeWNsZVxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgc3RhcnRUcmFuc2l0aW9uVGltZXIodHJhbnNpdGlvblN0YXRlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKClcIixcbiAgICAgIFwidHJhbnNpdGlvblN0YXRlOiBcIiArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZVxuICAgICk7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKVwiLFxuICAgICAgICBcImNsZWFyaW5nIGFscmVhZHktcnVubmluZyB0aW1lclwiXG4gICAgICApO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhbnNpdGlvblRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25UaW1lcikge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBcIiArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZSArIFwiIHRpbWVyIGV4cGlyZWRcIixcbiAgICAgICAgICBcInJlcXVlc3RpbmcgbmV3IHN0YXRlOiBcIiArIHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlIH0pO1xuICAgICAgfVxuICAgIH0sIHRyYW5zaXRpb25TdGF0ZS5yZXRyeURlbGF5KTtcbiAgfVxuICBjYW5jZWxUcmFuc2l0aW9uVGltZXIoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2FuY2VsVHJhbnNpdGlvblRpbWVyKClcIiwgXCJcIik7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFN1c3BlbmRUaW1lcigpIHtcbiAgICBpZiAodGhpcy5zdXNwZW5kVGltZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdXNwZW5kVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgICB0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBzdXNwZW5kIHRpbWVyIGV4cGlyZWRcIixcbiAgICAgICAgICBcInJlcXVlc3RpbmcgbmV3IHN0YXRlOiBzdXNwZW5kZWRcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9IFwic3VzcGVuZGVkXCI7XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJzdXNwZW5kZWRcIiB9KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XG4gIH1cbiAgY2hlY2tTdXNwZW5kVGltZXIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgIT09IFwiZGlzY29ubmVjdGVkXCIgJiYgc3RhdGUgIT09IFwic3VzcGVuZGVkXCIgJiYgc3RhdGUgIT09IFwiY29ubmVjdGluZ1wiKVxuICAgICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgfVxuICBjYW5jZWxTdXNwZW5kVGltZXIoKSB7XG4gICAgdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3VzcGVuZFRpbWVyKTtcbiAgICAgIHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRSZXRyeVRpbWVyKGludGVydmFsKSB7XG4gICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlciByZXRyeSB0aW1lciBleHBpcmVkXCIsIFwicmV0cnlpbmdcIik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9XG4gIGNhbmNlbFJldHJ5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFdlYlNvY2tldFNsb3dUaW1lcigpIHtcbiAgICB0aGlzLndlYlNvY2tldFNsb3dUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgIFwiY2hlY2tpbmcgY29ubmVjdGl2aXR5XCJcbiAgICAgICk7XG4gICAgICB0aGlzLmNoZWNrV3NDb25uZWN0aXZpdHkoKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgXCJ3cyBjb25uZWN0aXZpdHkgY2hlY2sgc3VjY2VlZGVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgXCJ3cyBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbGVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkpIHtcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpLCAoZXJyLCBjb25uZWN0aXZpdHkpID0+IHtcbiAgICAgICAgICBpZiAoZXJyIHx8ICFjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgICBcImh0dHAgY29ubmVjdGl2aXR5IGNoZWNrIGZhaWxlZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7XG4gICAgICAgICAgICAgIHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKVwiLCA4MDAwMywgNDA0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgICBcImh0dHAgY29ubmVjdGl2aXR5IGNoZWNrIHN1Y2NlZWRlZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLndlYlNvY2tldFNsb3dUaW1lb3V0KTtcbiAgfVxuICBjYW5jZWxXZWJTb2NrZXRTbG93VGltZXIoKSB7XG4gICAgaWYgKHRoaXMud2ViU29ja2V0U2xvd1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53ZWJTb2NrZXRTbG93VGltZXIpO1xuICAgICAgdGhpcy53ZWJTb2NrZXRTbG93VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFdlYlNvY2tldEdpdmVVcFRpbWVyKHRyYW5zcG9ydFBhcmFtcykge1xuICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgaWYgKCF0aGlzLndzQ2hlY2tSZXN1bHQpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBnaXZlIHVwIHRpbWVyXCIsXG4gICAgICAgICAgXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiB0b29rIG1vcmUgdGhhbiAxMHM7IFwiICsgKHRoaXMuYmFzZVRyYW5zcG9ydCA/IFwidHJ5aW5nIGJhc2UgdHJhbnNwb3J0XCIgOiBcIlwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5iYXNlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgdGhpcy5hYmFuZG9uZWRXZWJTb2NrZXQgPSB0cnVlO1xuICAgICAgICAgIChfYTIgPSB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAoX2IgPSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsICsrdGhpcy5jb25uZWN0Q291bnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBnaXZlIHVwIHRpbWVyXCIsXG4gICAgICAgICAgICBcIndlYnNvY2tldCBjb25uZWN0aXZpdHkgYXBwZWFycyB0byBiZSB1bmF2YWlsYWJsZSBidXQgbm8gb3RoZXIgdHJhbnNwb3J0cyB0byB0cnlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dHMud2ViU29ja2V0Q29ubmVjdFRpbWVvdXQpO1xuICB9XG4gIGNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCkge1xuICAgIGlmICh0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53ZWJTb2NrZXRHaXZlVXBUaW1lcik7XG4gICAgICB0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgbm90aWZ5U3RhdGUoaW5kaWNhdGVkKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgY29uc3Qgc3RhdGUgPSBpbmRpY2F0ZWQuc3RhdGU7XG4gICAgY29uc3QgcmV0cnlJbW1lZGlhdGVseSA9IHN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiICYmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgfHwgaW5kaWNhdGVkLnJldHJ5SW1tZWRpYXRlbHkgfHwgdGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZyAmJiBpbmRpY2F0ZWQuZXJyb3IgJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoaW5kaWNhdGVkLmVycm9yKSAmJiAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgXCJuZXcgc3RhdGU6IFwiICsgc3RhdGUgKyAocmV0cnlJbW1lZGlhdGVseSA/IFwiOyB3aWxsIHJldHJ5IGNvbm5lY3Rpb24gaW1tZWRpYXRlbHlcIiA6IFwiXCIpXG4gICAgKTtcbiAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoaW5kaWNhdGVkLnN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgfHwgc3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLnRlcm1pbmFsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbaW5kaWNhdGVkLnN0YXRlXTtcbiAgICBsZXQgcmV0cnlEZWxheSA9IG5ld1N0YXRlLnJldHJ5RGVsYXk7XG4gICAgaWYgKG5ld1N0YXRlLnN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQrKztcbiAgICAgIHJldHJ5RGVsYXkgPSBnZXRSZXRyeVRpbWUobmV3U3RhdGUucmV0cnlEZWxheSwgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0KFxuICAgICAgdGhpcy5zdGF0ZS5zdGF0ZSxcbiAgICAgIG5ld1N0YXRlLnN0YXRlLFxuICAgICAgcmV0cnlEZWxheSxcbiAgICAgIGluZGljYXRlZC5lcnJvciB8fCAoKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpKVxuICAgICk7XG4gICAgaWYgKHJldHJ5SW1tZWRpYXRlbHkpIHtcbiAgICAgIGNvbnN0IGF1dG9SZWNvbm5lY3QgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzaW5jZUxhc3QgPSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCAmJiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgKyAxO1xuICAgICAgaWYgKHNpbmNlTGFzdCAmJiBzaW5jZUxhc3QgPCAxZTMpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKClcIixcbiAgICAgICAgICBcIkxhc3QgcmVjb25uZWN0IGF0dGVtcHQgd2FzIG9ubHkgXCIgKyBzaW5jZUxhc3QgKyBcIm1zIGFnbywgd2FpdGluZyBhbm90aGVyIFwiICsgKDFlMyAtIHNpbmNlTGFzdCkgKyBcIm1zIGJlZm9yZSB0cnlpbmcgYWdhaW5cIlxuICAgICAgICApO1xuICAgICAgICBzZXRUaW1lb3V0KGF1dG9SZWNvbm5lY3QsIDFlMyAtIHNpbmNlTGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soYXV0b1JlY29ubmVjdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiB8fCBzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5zdGFydFJldHJ5VGltZXIocmV0cnlEZWxheSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiAhcmV0cnlJbW1lZGlhdGVseSB8fCBzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiB8fCBuZXdTdGF0ZS50ZXJtaW5hbCkge1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PSBcImNvbm5lY3RlZFwiICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgICBcIkJyb2tlbiBpbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBnbyBpbnRvIGNvbm5lY3RlZCBzdGF0ZSwgYnV0IHRoZXJlIGlzIG5vIGFjdGl2ZSBwcm90b2NvbFwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICB0aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUucXVldWVFdmVudHMpIHtcbiAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbihzdGF0ZSwgY2hhbmdlLnJlYXNvbik7XG4gICAgICB0aGlzLmZhaWxRdWV1ZWRNZXNzYWdlcyhjaGFuZ2UucmVhc29uKTtcbiAgICB9XG4gIH1cbiAgcmVxdWVzdFN0YXRlKHJlcXVlc3QpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBjb25zdCBzdGF0ZSA9IHJlcXVlc3Quc3RhdGU7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSgpXCIsXG4gICAgICBcInJlcXVlc3RlZCBzdGF0ZTogXCIgKyBzdGF0ZSArIFwiOyBjdXJyZW50IHN0YXRlOiBcIiArIHRoaXMuc3RhdGUuc3RhdGVcbiAgICApO1xuICAgIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgdGhpcy5jaGVja1N1c3BlbmRUaW1lcihzdGF0ZSk7XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGluZ1wiICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gXCJjb25uZWN0ZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdGUgPT0gXCJjbG9zaW5nXCIgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSBcImNsb3NlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVdLCBjaGFuZ2UgPSBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoXG4gICAgICB0aGlzLnN0YXRlLnN0YXRlLFxuICAgICAgbmV3U3RhdGUuc3RhdGUsXG4gICAgICBudWxsLFxuICAgICAgcmVxdWVzdC5lcnJvciB8fCAoKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpKVxuICAgICk7XG4gICAgdGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PSBcImNsb3NpbmdcIikge1xuICAgICAgdGhpcy5jbG9zZUltcGwoKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRDb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KClcIixcbiAgICAgICAgXCJNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCwgYnV0IHdhcyBcIiArIHRoaXMuc3RhdGUuc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1dGggPSB0aGlzLnJlYWx0aW1lLmF1dGg7XG4gICAgY29uc3QgY29ubmVjdENvdW50ID0gKyt0aGlzLmNvbm5lY3RDb3VudGVyO1xuICAgIGNvbnN0IGNvbm5lY3QgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCk7XG4gICAgICB0aGlzLmdldFRyYW5zcG9ydFBhcmFtcygodHJhbnNwb3J0UGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFuc3BvcnRQYXJhbXMubW9kZSA9PT0gXCJyZWNvdmVyXCIgJiYgdHJhbnNwb3J0UGFyYW1zLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICAgIGNvbnN0IHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KHRyYW5zcG9ydFBhcmFtcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucmVjb3ZlckNoYW5uZWxzKHJlY292ZXJ5Q29udGV4dC5jaGFubmVsU2VyaWFscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpXCIsIFwic3RhcnRpbmcgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XG4gICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcbiAgICBpZiAoYXV0aC5tZXRob2QgPT09IFwiYmFzaWNcIikge1xuICAgICAgY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhdXRoQ2IgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsKSwgYXV0aENiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhhdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSksIGF1dGhDYik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIHRoZXJlIGFyZSwgYXQgbW9zdCwgdHdvIHRyYW5zcG9ydHMgYXZhaWxhYmxlIHdpdGggd2hpY2ggYSBjb25uZWN0aW9uIG1heVxuICAgKiBiZSBhdHRlbXB0ZWQ6IHdlYl9zb2NrZXQgYW5kL29yIGEgYmFzZSB0cmFuc3BvcnQgKHhocl9wb2xsaW5nIGluIGJyb3dzZXJzLFxuICAgKiBjb21ldCBpbiBub2RlanMpLiB3ZWJfc29ja2V0IGlzIGFsd2F5cyBwcmVmZXJyZWQsIGFuZCB0aGUgYmFzZSB0cmFuc3BvcnQgaXNcbiAgICogb25seSB1c2VkIGluIGNhc2Ugd2ViX3NvY2tldCBjb25uZWN0aXZpdHkgYXBwZWFycyB0byBiZSB1bmF2YWlsYWJsZS5cbiAgICpcbiAgICogY29ubmVjdEltcGwgYmVnaW5zIHRoZSB0cmFuc3BvcnQgc2VsZWN0aW9uIHByb2Nlc3MgYnkgY2hlY2tpbmcgd2hpY2ggdHJhbnNwb3J0c1xuICAgKiBhcmUgYXZhaWxhYmxlLCBhbmQgaWYgdGhlcmUgaXMgYSBjYWNoZWQgcHJlZmVyZW5jZS4gSXQgdGhlbiBkZWZlcnMgdG8gdGhlXG4gICAqIHRyYW5zcG9ydC1zcGVjaWZpYyBjb25uZWN0IG1ldGhvZHM6IGNvbm5lY3RXcyBhbmQgY29ubmVjdEJhc2UuXG4gICAqXG4gICAqIEl0IGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGludmFsaWRhdGluZyB0aGUgY2FjaGUgaW4gdGhlIGNhc2UgdGhhdCBhIGJhc2VcbiAgICogdHJhbnNwb3J0IHByZWZlcmVuY2UgaXMgc3RvcmVkIGJ1dCB3ZWIgc29ja2V0IGNvbm5lY3Rpdml0eSBpcyBub3cgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBoYW5kbGluZyBvZiB0aGUgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIGZhaWxvdmVyIGZyb20gd2ViX3NvY2tldCB0byB0aGUgYmFzZVxuICAgKiB0cmFuc3BvcnQgaXMgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbm5lY3RXcyBtZXRob2QuXG4gICAqL1xuICBjb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3Rpbmcuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpXCIsXG4gICAgICAgIFwiTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QsIGJ1dCB3YXMgXCIgKyBzdGF0ZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgIGlmICh0cmFuc3BvcnRQcmVmZXJlbmNlICYmIHRyYW5zcG9ydFByZWZlcmVuY2UgPT09IHRoaXMuYmFzZVRyYW5zcG9ydCAmJiB0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5jaGVja1dzQ29ubmVjdGl2aXR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpOlwiLFxuICAgICAgICAgICAgXCJ3ZWIgc29ja2V0IGNvbm5lY3Rpdml0eSBhdmFpbGFibGUsIGNhbmNlbGxpbmcgY29ubmVjdGlvbiBhdHRlbXB0IHdpdGggXCIgKyB0aGlzLmJhc2VUcmFuc3BvcnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RXcyh0cmFuc3BvcnRQYXJhbXMsICsrdGhpcy5jb25uZWN0Q291bnRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKG5vb3AyKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zcG9ydFByZWZlcmVuY2UgJiYgdHJhbnNwb3J0UHJlZmVyZW5jZSA9PT0gdGhpcy5iYXNlVHJhbnNwb3J0IHx8IHRoaXMuYmFzZVRyYW5zcG9ydCAmJiAhdGhpcy53ZWJTb2NrZXRUcmFuc3BvcnRBdmFpbGFibGUpIHtcbiAgICAgIHRoaXMuY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbm5lY3RXcyh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIGNvbm5lY3RXcyBzdGFydHMgdHdvIHRpbWVycyB0byBtb25pdG9yIHRoZSBzdWNjZXNzIG9mIGEgd2ViX3NvY2tldCBjb25uZWN0aW9uIGF0dGVtcHQ6XG4gICAqIC0gd2ViU29ja2V0U2xvd1RpbWVyOiBpZiB0aGlzIHRpbWVyIGZpcmVzIGJlZm9yZSB0aGUgY29ubmVjdGlvbiBzdWNjZWVkcyxcbiAgICogICBjbSB3aWxsIHNpbXVsdGFuZW91c2x5IGNoZWNrIHdlYnNvY2tldCBhbmQgaHR0cC94aHIgY29ubmVjdGl2aXR5LiBpZiB0aGUgaHR0cFxuICAgKiAgIGNvbm5lY3Rpdml0eSBjaGVjayBmYWlscywgd2UgZ2l2ZSB1cCB0aGUgY29ubmVjdGlvbiBzZXF1ZW5jZSBlbnRpcmVseSBhbmRcbiAgICogICB0cmFuc2l0aW9uIHRvIGRpc2Nvbm5lY3RlZC4gaWYgdGhlIHdlYnNvY2tldCBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbHMgdGhlblxuICAgKiAgIHdlIGFzc3VtZSBubyB3cyBjb25uZWN0aXZpdHkgYW5kIGZhaWxvdmVyIHRvIGJhc2UgdHJhbnNwb3J0LiBpbiB0aGUgY2FzZSB0aGF0XG4gICAqICAgdGhlIGNoZWNrcyBzdWNjZWVkLCB3ZSBjb250aW51ZSB3aXRoIHdlYnNvY2tldCBhbmQgd2FpdCBmb3IgaXQgdG8gdHJ5IGZhbGxiYWNrIGhvc3RzXG4gICAqICAgYW5kLCBpZiB1bnN1Y2Nlc3NmdWwsIHVsdGltYXRlbHkgdHJhbnNpdGlvbiB0byBkaXNjb25uZWN0ZWQuXG4gICAqIC0gd2ViU29ja2V0R2l2ZVVwVGltZXI6IGlmIHRoaXMgdGltZXIgZmlyZXMsIGFuZCB0aGUgcHJlY2VkaW5nIHdlYnNvY2tldFxuICAgKiAgIGNvbm5lY3Rpdml0eSBjaGVjayBpcyBzdGlsbCBwZW5kaW5nIHRoZW4gd2UgYXNzdW1lIHRoYXQgdGhlcmUgaXMgYW4gaXNzdWVcbiAgICogICB3aXRoIHRoZSB0cmFuc3BvcnQgYW5kIGZhbGxiYWNrIHRvIGJhc2UgdHJhbnNwb3J0LlxuICAgKi9cbiAgY29ubmVjdFdzKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdFdzKClcIik7XG4gICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLmFiYW5kb25lZFdlYlNvY2tldCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRXZWJTb2NrZXRTbG93VGltZXIoKTtcbiAgICB0aGlzLnN0YXJ0V2ViU29ja2V0R2l2ZVVwVGltZXIodHJhbnNwb3J0UGFyYW1zKTtcbiAgICB0aGlzLnRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3MoXCJ3ZWJfc29ja2V0XCIsIHRyYW5zcG9ydFBhcmFtcywgdHJ1ZSwgY29ubmVjdENvdW50LCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy53c0NoZWNrUmVzdWx0ICE9PSBmYWxzZSAmJiAhdGhpcy5hYmFuZG9uZWRXZWJTb2NrZXQ7XG4gICAgfSk7XG4gIH1cbiAgY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0QmFzZSgpXCIpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc3BvcnQpIHtcbiAgICAgIHRoaXMudHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcyh0aGlzLmJhc2VUcmFuc3BvcnQsIHRyYW5zcG9ydFBhcmFtcywgZmFsc2UsIGNvbm5lY3RDb3VudCwgKCkgPT4gdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoe1xuICAgICAgICBzdGF0ZTogXCJkaXNjb25uZWN0ZWRcIixcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvckluZm8oXCJObyB0cmFuc3BvcnRzIGxlZnQgdG8gdHJ5XCIsIDhlNCwgNDA0KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3ModHJhbnNwb3J0TmFtZSwgdHJhbnNwb3J0UGFyYW1zLCB3cywgY29ubmVjdENvdW50LCBzaG91bGRDb250aW51ZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlUcmFuc3BvcnRXaXRoRmFsbGJhY2tzKClcIixcbiAgICAgIHRyYW5zcG9ydE5hbWVcbiAgICApO1xuICAgIGNvbnN0IGdpdmVVcCA9IChlcnIpID0+IHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUsIGVycm9yOiBlcnIgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjYW5kaWRhdGVIb3N0cyA9IHRoaXMuZG9tYWlucy5zbGljZSgpO1xuICAgIGNvbnN0IGhvc3RBdHRlbXB0Q2IgPSAoZmF0YWwsIHRyYW5zcG9ydCkgPT4ge1xuICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZENvbnRpbnVlKCkpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc3BvcnQgJiYgIWZhdGFsKSB7XG4gICAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuICAgIGlmICghaG9zdCkge1xuICAgICAgZ2l2ZVVwKG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gY29ubmVjdCAobm8gYXZhaWxhYmxlIGhvc3QpXCIsIDgwMDAzLCA0MDQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBob3N0O1xuICAgIGNvbnN0IHRyeUZhbGxiYWNrSG9zdHMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICBnaXZlVXAobmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChhbmQgbm8gbW9yZSBmYWxsYmFjayBob3N0cyB0byB0cnkpXCIsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkpIHtcbiAgICAgICAgZ2l2ZVVwKG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiSW50ZXJuYWwgZXJyb3I6IEh0dHAuY2hlY2tDb25uZWN0aXZpdHkgbm90IHNldFwiLCBudWxsLCA1MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICB0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKSxcbiAgICAgICAgKGVyciwgY29ubmVjdGl2aXR5KSA9PiB7XG4gICAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZ2l2ZVVwKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICBnaXZlVXAobmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKVwiLCA4MDAwMywgNDA0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gYXJyUG9wUmFuZG9tRWxlbWVudChjYW5kaWRhdGVIb3N0cyk7XG4gICAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0TmFtZSwgaG9zdEF0dGVtcHRDYik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5mb3JjZUZhbGxiYWNrSG9zdCAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcbiAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0TmFtZSwgaG9zdEF0dGVtcHRDYik7XG4gIH1cbiAgY2xvc2VJbXBsKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpXCIsIFwiY2xvc2luZyBjb25uZWN0aW9uXCIpO1xuICAgIHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG4gICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jbG9zaW5nKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhbnNwb3J0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKClcIixcbiAgICAgICAgXCJDbG9zaW5nIHBlbmRpbmcgdHJhbnNwb3J0OiBcIiArIHRoaXMucGVuZGluZ1RyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpXCIsXG4gICAgICAgIFwiQ2xvc2luZyBhY3RpdmUgdHJhbnNwb3J0OiBcIiArIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KClcbiAgICAgICk7XG4gICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJjbG9zZWRcIiB9KTtcbiAgfVxuICBvbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscywgY2FsbGJhY2spIHtcbiAgICB2YXIgX2EyO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5zdGF0ZSkge1xuICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKClcIixcbiAgICAgICAgICBcIlNlbmRpbmcgQVVUSCBtZXNzYWdlIG9uIGFjdGl2ZSB0cmFuc3BvcnRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBhY3RpdmVUcmFuc3BvcnQgPSAoX2EyID0gdGhpcy5hY3RpdmVQcm90b2NvbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRUcmFuc3BvcnQoKTtcbiAgICAgICAgaWYgKGFjdGl2ZVRyYW5zcG9ydCAmJiBhY3RpdmVUcmFuc3BvcnQub25BdXRoVXBkYXRlZCkge1xuICAgICAgICAgIGFjdGl2ZVRyYW5zcG9ydC5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aE1zZyA9IGZyb21WYWx1ZXMoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5BVVRILFxuICAgICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmQoYXV0aE1zZyk7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihmYWlsdXJlTGlzdGVuZXIpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZhaWx1cmVMaXN0ZW5lciA9IChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSBcImZhaWxlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLm9mZihzdWNjZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoXCJjb25uZWN0aW9uZGV0YWlsc1wiLCBzdWNjZXNzTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm9uKFwiY29ubmVjdGlvbnN0YXRlXCIsIGZhaWx1cmVMaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKVwiLFxuICAgICAgICAgIFwiQWJvcnRpbmcgY3VycmVudCBjb25uZWN0aW9uIGF0dGVtcHRzIGluIG9yZGVyIHRvIHN0YXJ0IGFnYWluIHdpdGggdGhlIG5ldyBhdXRoIGRldGFpbHNcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKClcIixcbiAgICAgICAgICBcIkNvbm5lY3Rpb24gc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlLnN0YXRlICsgXCI7IHdhaXRpbmcgdW50aWwgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoc3RhdGVDaGFuZ2UuY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOlxuICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uKFwiY29ubmVjdGlvbnN0YXRlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdGUgPT09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgXCJEaXNjb25uZWN0aW5nIGFsbCB0cmFuc3BvcnRzXCJcbiAgICApO1xuICAgIHRoaXMuY29ubmVjdENvdW50ZXIrKztcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhbnNwb3J0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgcGVuZGluZyB0cmFuc3BvcnQ6IFwiICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0XG4gICAgICApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zcG9ydDtcbiAgICBpZiAodGhpcy5wcm9wb3NlZFRyYW5zcG9ydCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIHByb3Bvc2VkIHRyYW5zcG9ydDogXCIgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRcbiAgICAgICk7XG4gICAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zcG9ydDtcbiAgICBpZiAodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQ6IFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKVxuICAgICAgKTtcbiAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuICAvKioqKioqKioqKioqKioqKioqXG4gICAqIGV2ZW50IHF1ZXVlaW5nXG4gICAqKioqKioqKioqKioqKioqKiovXG4gIHNlbmQobXNnLCBxdWV1ZUV2ZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDI7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kKClcIiwgXCJzZW5kaW5nIGV2ZW50XCIpO1xuICAgICAgdGhpcy5zZW5kSW1wbChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRRdWV1ZSA9IHF1ZXVlRXZlbnQgJiYgc3RhdGUucXVldWVFdmVudHM7XG4gICAgaWYgKCFzaG91bGRRdWV1ZSkge1xuICAgICAgY29uc3QgZXJyID0gXCJyZWplY3RpbmcgZXZlbnQsIHF1ZXVlRXZlbnQgd2FzIFwiICsgcXVldWVFdmVudCArIFwiLCBzdGF0ZSB3YXMgXCIgKyBzdGF0ZS5zdGF0ZTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKVwiLCBlcnIpO1xuICAgICAgY2FsbGJhY2sodGhpcy5lcnJvclJlYXNvbiB8fCBuZXcgRXJyb3JJbmZvKGVyciwgOWU0LCA0MDApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpXCIsXG4gICAgICAgIFwicXVldWVpbmcgbXNnOyBcIiArIHN0cmluZ2lmeShcbiAgICAgICAgICBtc2csXG4gICAgICAgICAgdGhpcy5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICB0aGlzLnJlYWx0aW1lLl9Bbm5vdGF0aW9ucyxcbiAgICAgICAgICB0aGlzLnJlYWx0aW1lLl9saXZlT2JqZWN0c1BsdWdpblxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlKG1zZywgY2FsbGJhY2spO1xuICB9XG4gIHNlbmRJbXBsKHBlbmRpbmdNZXNzYWdlKSB7XG4gICAgY29uc3QgbXNnID0gcGVuZGluZ01lc3NhZ2UubWVzc2FnZTtcbiAgICBpZiAocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQgJiYgIXBlbmRpbmdNZXNzYWdlLnNlbmRBdHRlbXB0ZWQpIHtcbiAgICAgIG1zZy5tc2dTZXJpYWwgPSB0aGlzLm1zZ1NlcmlhbCsrO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5zZW5kKHBlbmRpbmdNZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZEltcGwoKVwiLFxuICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIGluIHRyYW5zcG9ydC5zZW5kKCk6IFwiICsgZS5zdGFja1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcXVldWUobXNnLCBjYWxsYmFjaykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlKClcIiwgXCJxdWV1ZWluZyBldmVudFwiKTtcbiAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnB1c2gobmV3IFBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcbiAgfVxuICBzZW5kUXVldWVkTWVzc2FnZXMoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmRRdWV1ZWRNZXNzYWdlcygpXCIsXG4gICAgICBcInNlbmRpbmcgXCIgKyB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCkgKyBcIiBxdWV1ZWQgbWVzc2FnZXNcIlxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdNZXNzYWdlO1xuICAgIHdoaWxlIChwZW5kaW5nTWVzc2FnZSA9IHRoaXMucXVldWVkTWVzc2FnZXMuc2hpZnQoKSlcbiAgICAgIHRoaXMuc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpO1xuICB9XG4gIHF1ZXVlUGVuZGluZ01lc3NhZ2VzKHBlbmRpbmdNZXNzYWdlcykge1xuICAgIGlmIChwZW5kaW5nTWVzc2FnZXMgJiYgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlUGVuZGluZ01lc3NhZ2VzKClcIixcbiAgICAgICAgXCJxdWV1ZWluZyBcIiArIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGggKyBcIiBwZW5kaW5nIG1lc3NhZ2VzXCJcbiAgICAgICk7XG4gICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnByZXBlbmQocGVuZGluZ01lc3NhZ2VzKTtcbiAgICB9XG4gIH1cbiAgZmFpbFF1ZXVlZE1lc3NhZ2VzKGVycikge1xuICAgIGNvbnN0IG51bVF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKTtcbiAgICBpZiAobnVtUXVldWVkID4gMCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmZhaWxRdWV1ZWRNZXNzYWdlcygpXCIsXG4gICAgICAgIFwiZmFpbGluZyBcIiArIG51bVF1ZXVlZCArIFwiIHF1ZXVlZCBtZXNzYWdlcywgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMuY29tcGxldGVBbGxNZXNzYWdlcyhlcnIpO1xuICAgIH1cbiAgfVxuICBvbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zcG9ydCkge1xuICAgIHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLnF1ZXVlLnB1c2goeyBtZXNzYWdlLCB0cmFuc3BvcnQgfSk7XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5pc1Byb2Nlc3NpbmcpIHtcbiAgICAgIHRoaXMucHJvY2Vzc05leHRQZW5kaW5nQ2hhbm5lbE1lc3NhZ2UoKTtcbiAgICB9XG4gIH1cbiAgcHJvY2Vzc05leHRQZW5kaW5nQ2hhbm5lbE1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICBjb25zdCBwZW5kaW5nQ2hhbm5lbE1lc3NhZ2UgPSB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5xdWV1ZS5zaGlmdCgpO1xuICAgICAgdGhpcy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UocGVuZGluZ0NoYW5uZWxNZXNzYWdlLm1lc3NhZ2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnByb2Nlc3NOZXh0UGVuZGluZ0NoYW5uZWxNZXNzYWdlKCkgcmVjZWl2ZWQgZXJyb3IgXCIsXG4gICAgICAgICAgZXJyXG4gICAgICAgICk7XG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc05leHRQZW5kaW5nQ2hhbm5lbE1lc3NhZ2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGF3YWl0IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIGFzeW5jIHBpbmcoKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0ZSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBwaW5nIHNlcnZpY2U7IG5vdCBjb25uZWN0ZWRcIiwgNGU0LCA0MDApO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc3BvcnQgPSAoX2EyID0gdGhpcy5hY3RpdmVQcm90b2NvbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRUcmFuc3BvcnQoKTtcbiAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgdGhyb3cgdGhpcy5nZXRTdGF0ZUVycm9yKCk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnBpbmcoKVwiLCBcInRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0KTtcbiAgICBjb25zdCBwaW5nU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGlkID0gY2hlYXBSYW5kU3RyKCk7XG4gICAgcmV0dXJuIHdpdGhUaW1lb3V0QXN5bmMoXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCBvbkhlYXJ0YmVhdCA9IChyZXNwb25zZUlkKSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlSWQgPT09IGlkKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQub2ZmKFwiaGVhcnRiZWF0XCIsIG9uSGVhcnRiZWF0KTtcbiAgICAgICAgICAgIHJlc29sdmUoRGF0ZS5ub3coKSAtIHBpbmdTdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cmFuc3BvcnQub24oXCJoZWFydGJlYXRcIiwgb25IZWFydGJlYXQpO1xuICAgICAgICB0cmFuc3BvcnQucGluZyhpZCk7XG4gICAgICB9KSxcbiAgICAgIHRoaXMub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LFxuICAgICAgXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGhlYXJ0YmVhdCByZXNwb25zZVwiXG4gICAgKTtcbiAgfVxuICBhYm9ydChlcnJvcikge1xuICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZmFpbChlcnJvcik7XG4gIH1cbiAgZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlIHx8IGhhdmVXZWJTdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSkpO1xuICB9XG4gIHBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRyYW5zcG9ydC5zaG9ydE5hbWU7XG4gICAgaWYgKGhhdmVXZWJTdG9yYWdlKCkpIHtcbiAgICAgIChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSwgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG4gICAgfVxuICB9XG4gIHVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcbiAgICBpZiAoaGF2ZVdlYlN0b3JhZ2UoKSkge1xuICAgICAgKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVtb3ZlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKTtcbiAgICB9XG4gIH1cbiAgLyogVGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGR1cmluZyBjb25uZWN0aW9uIGF0dGVtcHRzLCBzbyBpbXBsZW1lbnRzIFJTQTRjMSwgUlNBNGMyLFxuICAgKiBhbmQgUlNBNGQuIEl0IGlzIGdlbmVyYWxseSBub3QgaW52b2tlZCBmb3Igc2VydmVyc2lkZS10cmlnZ2VyZWQgcmVhdXRocyBvciBtYW51YWxcbiAgICogcmVhdXRocywgc28gUlNBNGMzIGRvZXMgbm90IGFwcGx5LCBleGNlcHQgKHBlciBwZXIgUlNBNGQxKSBpbiB0aGUgY2FzZSB0aGF0IHRoZSBhdXRoXG4gICAqIHNlcnZlciByZXR1cm5zIDQwMy4gKi9cbiAgYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSA0MDE3MSkge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImZhaWxlZFwiLCBlcnJvcjogZXJyIH0pO1xuICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IDQwMTAyKSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiZmFpbGVkXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgfSBlbHNlIGlmIChlcnIuc3RhdHVzQ29kZSA9PT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuRm9yYmlkZGVuKSB7XG4gICAgICBjb25zdCBtc2cgPSBcIkNsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJldHVybmVkIDQwMzsgZmFpbGluZyB0aGUgY29ubmVjdGlvblwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImZhaWxlZFwiLCBlcnJvcjogbmV3IEVycm9ySW5mbyhtc2csIDgwMDE5LCA0MDMsIGVycikgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmVxdWVzdCBmYWlsZWRcIjtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplXCIsIG1zZyk7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRoaXMuc3RhdGUuZmFpbFN0YXRlLCBlcnJvcjogbmV3IEVycm9ySW5mbyhtc2csIDgwMDE5LCA0MDEsIGVycikgfSk7XG4gICAgfVxuICB9XG4gIG9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoY29ubmVjdGlvbkRldGFpbHMsIHRyYW5zcG9ydCkge1xuICAgIGlmICghY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IGNvbm5lY3Rpb25EZXRhaWxzO1xuICAgIGlmIChjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplID0gY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemU7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudElkID0gY29ubmVjdGlvbkRldGFpbHMuY2xpZW50SWQ7XG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLnJlYWx0aW1lLmF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSgpXCIsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgdHJhbnNwb3J0LmZhaWwoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgaWYgKGNvbm5lY3Rpb25TdGF0ZVR0bCkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgfVxuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25kZXRhaWxzXCIsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgfVxuICBjaGVja1dzQ29ubmVjdGl2aXR5KCkge1xuICAgIGNvbnN0IHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgPSB0aGlzLm9wdGlvbnMud3NDb25uZWN0aXZpdHlDaGVja1VybCB8fCBkZWZhdWx0c19kZWZhdWx0LndzQ29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gICAgY29uc3Qgd3MgPSBuZXcgUGxhdGZvcm0uQ29uZmlnLldlYlNvY2tldCh3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHdzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBzZXNzaW9uUmVjb3ZlcnlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVjb3ZlcnlLZXlTdG9yYWdlTmFtZSB8fCBcImFibHktY29ubmVjdGlvbi1yZWNvdmVyeVwiO1xuICB9XG4gIGdldFNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCkpKTtcbiAgfVxuICBzZXRTZXNzaW9uUmVjb3ZlckRhdGEodmFsdWUpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNldFNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCksIHZhbHVlKSk7XG4gIH1cbiAgY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmICgoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmVTZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpKSk7XG4gIH1cbn07XG52YXIgY29ubmVjdGlvbm1hbmFnZXJfZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvY29ubmVjdGlvbi50c1xudmFyIENvbm5lY3Rpb24gPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoYWJseSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGFibHkubG9nZ2VyKTtcbiAgICB0aGlzLndoZW5TdGF0ZSA9IChzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIGV2ZW50ZW1pdHRlcl9kZWZhdWx0LnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgfTtcbiAgICB0aGlzLmFibHkgPSBhYmx5O1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgY29ubmVjdGlvbm1hbmFnZXJfZGVmYXVsdChhYmx5LCBvcHRpb25zKTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZTtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oXCJjb25uZWN0aW9uc3RhdGVcIiwgKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUgPSBzdGF0ZUNoYW5nZS5jdXJyZW50O1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHN0YXRlLCBzdGF0ZUNoYW5nZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKFwidXBkYXRlXCIsIChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHN0YXRlQ2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbi5jb25uZWN0KClcIiwgXCJcIik7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gIH1cbiAgYXN5bmMgcGluZygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uLnBpbmcoKVwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5waW5nKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbi5jbG9zZSgpXCIsIFwiY29ubmVjdGlvbktleSA9IFwiICsgdGhpcy5rZXkpO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY2xvc2luZ1wiIH0pO1xuICB9XG4gIGdldCByZWNvdmVyeUtleSgpIHtcbiAgICB0aGlzLmxvZ2dlci5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBcIlRoZSBgQ29ubmVjdGlvbi5yZWNvdmVyeUtleWAgYXR0cmlidXRlIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IHRoZSBgQ29ubmVjdGlvbi5jcmVhdGVSZWNvdmVyeUtleSgpYCBtZXRob2QuIFJlcGxhY2UgeW91ciB1c2FnZSBvZiBgcmVjb3ZlcnlLZXlgIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiBgY3JlYXRlUmVjb3ZlcnlLZXkoKWAuIGByZWNvdmVyeUtleWAgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlY292ZXJ5S2V5KCk7XG4gIH1cbiAgY3JlYXRlUmVjb3ZlcnlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgfVxufTtcbnZhciBjb25uZWN0aW9uX2RlZmF1bHQgPSBDb25uZWN0aW9uO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZXJlYWx0aW1lLnRzXG52YXIgX0Jhc2VSZWFsdGltZSA9IGNsYXNzIF9CYXNlUmVhbHRpbWUgZXh0ZW5kcyBiYXNlY2xpZW50X2RlZmF1bHQge1xuICAvKlxuICAgKiBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgb25seSBhY2NlcHRzIGFuIG9iamVjdCwgYnV0IHNpbmNlIHdlIHdhbnQgdG8gZW1pdCBhIGdvb2QgZXJyb3IgbWVzc2FnZSBpbiB0aGUgY2FzZSB3aGVyZSBhIG5vbi1UeXBlU2NyaXB0IHVzZXIgZG9lcyBvbmUgb2YgdGhlc2UgdGhpbmdzOlxuICAgKlxuICAgKiAxLiBwYXNzZXMgYSBzdHJpbmcgKHdoaWNoIGlzIHF1aXRlIGxpa2VseSBpZiB0aGV54oCZcmUgZS5nLiBtaWdyYXRpbmcgZnJvbSB0aGUgZGVmYXVsdCB2YXJpYW50IHRvIHRoZSBtb2R1bGFyIHZhcmlhbnQpXG4gICAqIDIuIHBhc3NlcyBubyBhcmd1bWVudCBhdCBhbGxcbiAgICpcbiAgICogdGVsbCB0aGUgY29tcGlsZXIgdGhhdCB0aGVzZSBjYXNlcyBhcmUgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIHRoZW0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jLCBfZDtcbiAgICBzdXBlcihkZWZhdWx0c19kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucywgZmFsc2UsIFwiQmFzZVJlYWx0aW1lXCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIpKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZSgpXCIsIFwiXCIpO1xuICAgIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGBBYmx5LlJlYWx0aW1lIGluc3RhbmNlIGNhbm5vdCBiZSB1c2VkIGluIFZlcmNlbCBFZGdlIHJ1bnRpbWUuIElmIHlvdSBhcmUgcnVubmluZyBWZXJjZWwgRWRnZSBmdW5jdGlvbnMsIHBsZWFzZSByZXBsYWNlIHlvdXIgXCJuZXcgQWJseS5SZWFsdGltZSgpXCIgd2l0aCBcIm5ldyBBYmx5LlJlc3QoKVwiIGFuZCB1c2UgQWJseSBSZXN0IEFQSSBpbnN0ZWFkIG9mIHRoZSBSZWFsdGltZSBBUEkuIElmIHlvdSBhcmUgc2VydmVyLXJlbmRlcmluZyB5b3VyIGFwcGxpY2F0aW9uIGluIHRoZSBWZXJjZWwgRWRnZSBydW50aW1lLCBwbGVhc2UgdXNlIHRoZSBjb25kaXRpb24gXCJpZiAodHlwZW9mIEVkZ2VSdW50aW1lID09PSAnc3RyaW5nJylcIiB0byBwcmV2ZW50IGluc3RhbnRpYXRpbmcgQWJseS5SZWFsdGltZSBpbnN0YW5jZSBkdXJpbmcgU1NSIGluIHRoZSBWZXJjZWwgRWRnZSBydW50aW1lLmAsXG4gICAgICAgIDRlNCxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9hZGRpdGlvbmFsVHJhbnNwb3J0SW1wbGVtZW50YXRpb25zID0gX0Jhc2VSZWFsdGltZS50cmFuc3BvcnRJbXBsZW1lbnRhdGlvbnNGcm9tUGx1Z2lucyh0aGlzLm9wdGlvbnMucGx1Z2lucyk7XG4gICAgdGhpcy5fUmVhbHRpbWVQcmVzZW5jZSA9IChfYiA9IChfYTIgPSB0aGlzLm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5SZWFsdGltZVByZXNlbmNlKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICAgIHRoaXMuX2xpdmVPYmplY3RzUGx1Z2luID0gKF9kID0gKF9jID0gdGhpcy5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5MaXZlT2JqZWN0cykgIT0gbnVsbCA/IF9kIDogbnVsbDtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgY29ubmVjdGlvbl9kZWZhdWx0KHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5fY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHMyKHRoaXMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlKVxuICAgICAgdGhpcy5jb25uZWN0KCk7XG4gIH1cbiAgc3RhdGljIHRyYW5zcG9ydEltcGxlbWVudGF0aW9uc0Zyb21QbHVnaW5zKHBsdWdpbnMpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRzID0ge307XG4gICAgaWYgKHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuV2ViU29ja2V0VHJhbnNwb3J0KSB7XG4gICAgICB0cmFuc3BvcnRzW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldF0gPSBwbHVnaW5zLldlYlNvY2tldFRyYW5zcG9ydDtcbiAgICB9XG4gICAgaWYgKHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuWEhSUG9sbGluZykge1xuICAgICAgdHJhbnNwb3J0c1tUcmFuc3BvcnROYW1lcy5YaHJQb2xsaW5nXSA9IHBsdWdpbnMuWEhSUG9sbGluZztcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gIH1cbiAgZ2V0IGNoYW5uZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFubmVscztcbiAgfVxuICBnZXQgY2xpZW50SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aC5jbGllbnRJZDtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lLmNvbm5lY3QoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lLmNsb3NlKClcIiwgXCJcIik7XG4gICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gIH1cbn07XG4vLyBpbnRlcm5hbCBBUEkgdG8gbWFrZSBFdmVudEVtaXR0ZXIgdXNhYmxlIGluIG90aGVyIFNES3Ncbl9CYXNlUmVhbHRpbWUuRXZlbnRFbWl0dGVyID0gZXZlbnRlbWl0dGVyX2RlZmF1bHQ7XG52YXIgQmFzZVJlYWx0aW1lID0gX0Jhc2VSZWFsdGltZTtcbnZhciBDaGFubmVsczIgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocmVhbHRpbWUpIHtcbiAgICBzdXBlcihyZWFsdGltZS5sb2dnZXIpO1xuICAgIHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICB0aGlzLmFsbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIub24oXCJ0cmFuc3BvcnQuYWN0aXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMub25UcmFuc3BvcnRBY3RpdmUoKTtcbiAgICB9KTtcbiAgfVxuICBjaGFubmVsU2VyaWFscygpIHtcbiAgICBsZXQgc2VyaWFscyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBrZXlzQXJyYXkodGhpcy5hbGwsIHRydWUpKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgICBpZiAoY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwpIHtcbiAgICAgICAgc2VyaWFsc1tuYW1lXSA9IGNoYW5uZWwucHJvcGVydGllcy5jaGFubmVsU2VyaWFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFscztcbiAgfVxuICAvLyByZWNvdmVyQ2hhbm5lbHMgZ2V0cyB0aGUgZ2l2ZW4gY2hhbm5lbHMgYW5kIHNldHMgdGhlaXIgY2hhbm5lbCBzZXJpYWxzLlxuICByZWNvdmVyQ2hhbm5lbHMoY2hhbm5lbFNlcmlhbHMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Yga2V5c0FycmF5KGNoYW5uZWxTZXJpYWxzLCB0cnVlKSkge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgPSBjaGFubmVsU2VyaWFsc1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgLy8gQWNjZXNzIHRvIHRoaXMgbWV0aG9kIGlzIHN5bmNocm9uaXNlZCBieSBDb25uZWN0aW9uTWFuYWdlciNwcm9jZXNzQ2hhbm5lbE1lc3NhZ2UuXG4gIGFzeW5jIHByb2Nlc3NDaGFubmVsTWVzc2FnZShtc2cpIHtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IG1zZy5jaGFubmVsO1xuICAgIGlmIChjaGFubmVsTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ2hhbm5lbHMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKClcIixcbiAgICAgICAgXCJyZWNlaXZlZCBldmVudCB1bnNwZWNpZmllZCBjaGFubmVsLCBhY3Rpb24gPSBcIiArIG1zZy5hY3Rpb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ2hhbm5lbHMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKClcIixcbiAgICAgICAgXCJyZWNlaXZlZCBldmVudCBmb3Igbm9uLWV4aXN0ZW50IGNoYW5uZWw6IFwiICsgY2hhbm5lbE5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGNoYW5uZWwucHJvY2Vzc01lc3NhZ2UobXNnKTtcbiAgfVxuICAvKiBjYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBiZWNvbWVzIGNvbm5lY3RlZDsgcmVhdHRlbXB0IGF0dGFjaC9kZXRhY2hcbiAgICogZm9yIGNoYW5uZWxzIHRoYXQgYXJlIGF0dGFjaGluZyBvciBkZXRhY2hpbmcuICovXG4gIG9uVHJhbnNwb3J0QWN0aXZlKCkge1xuICAgIGZvciAoY29uc3QgY2hhbm5lbE5hbWUgaW4gdGhpcy5hbGwpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG4gICAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIiB8fCBjaGFubmVsLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgIGNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgICBjaGFubmVsLl9hdHRhY2goZmFsc2UsIG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgY2hhbm5lbC5yZXF1ZXN0U3RhdGUoXCJhdHRhY2hpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIENvbm5lY3Rpb24gaW50ZXJydXB0aW9ucyAoaWUgd2hlbiB0aGUgY29ubmVjdGlvbiB3aWxsIG5vIGxvbmdlciBxdWV1ZVxuICAgKiBldmVudHMpIGltcGx5IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcyBmb3IgYW55IGNoYW5uZWwgd2hpY2ggaXMgZWl0aGVyXG4gICAqIGF0dGFjaGVkLCBwZW5kaW5nLCBvciB3aWxsIGF0dGVtcHQgdG8gYmVjb21lIGF0dGFjaGVkIGluIHRoZSBmdXR1cmUgKi9cbiAgcHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbihjb25uZWN0aW9uU3RhdGUsIHJlYXNvbikge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlID0ge1xuICAgICAgY2xvc2luZzogXCJkZXRhY2hlZFwiLFxuICAgICAgY2xvc2VkOiBcImRldGFjaGVkXCIsXG4gICAgICBmYWlsZWQ6IFwiZmFpbGVkXCIsXG4gICAgICBzdXNwZW5kZWQ6IFwic3VzcGVuZGVkXCJcbiAgICB9O1xuICAgIGNvbnN0IGZyb21DaGFubmVsU3RhdGVzID0gW1wiYXR0YWNoaW5nXCIsIFwiYXR0YWNoZWRcIiwgXCJkZXRhY2hpbmdcIiwgXCJzdXNwZW5kZWRcIl07XG4gICAgY29uc3QgdG9DaGFubmVsU3RhdGUgPSBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZVtjb25uZWN0aW9uU3RhdGVdO1xuICAgIGZvciAoY29uc3QgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcbiAgICAgIGlmIChmcm9tQ2hhbm5lbFN0YXRlcy5pbmNsdWRlcyhjaGFubmVsLnN0YXRlKSkge1xuICAgICAgICBjaGFubmVsLm5vdGlmeVN0YXRlKHRvQ2hhbm5lbFN0YXRlLCByZWFzb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQobmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIGxldCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV0gPSBuZXcgcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQodGhpcy5yZWFsdGltZSwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgIGlmIChjaGFubmVsLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucywgY2hhbm5lbC5jaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIkNoYW5uZWxzLmdldCgpIGNhbm5vdCBiZSB1c2VkIHRvIHNldCBjaGFubmVsIG9wdGlvbnMgdGhhdCB3b3VsZCBjYXVzZSB0aGUgY2hhbm5lbCB0byByZWF0dGFjaC4gUGxlYXNlLCB1c2UgUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKSBpbnN0ZWFkLlwiLFxuICAgICAgICAgIDRlNCxcbiAgICAgICAgICA0MDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsO1xuICB9XG4gIGdldERlcml2ZWQobmFtZSwgZGVyaXZlT3B0aW9ucywgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICBpZiAoZGVyaXZlT3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIGNvbnN0IGZpbHRlciA9IHRvQmFzZTY0KGRlcml2ZU9wdGlvbnMuZmlsdGVyKTtcbiAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hEZXJpdmVkQ2hhbm5lbChuYW1lKTtcbiAgICAgIG5hbWUgPSBgW2ZpbHRlcj0ke2ZpbHRlcn0ke21hdGNoLnF1YWxpZmllclBhcmFtfV0ke21hdGNoLmNoYW5uZWxOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gIH1cbiAgLyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG4gICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gIHJlbGVhc2UobmFtZSkge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWxlYXNlRXJyID0gY2hhbm5lbC5nZXRSZWxlYXNlRXJyKCk7XG4gICAgaWYgKHJlbGVhc2VFcnIpIHtcbiAgICAgIHRocm93IHJlbGVhc2VFcnI7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmFsbFtuYW1lXTtcbiAgfVxufTtcbnZhciBiYXNlcmVhbHRpbWVfZGVmYXVsdCA9IEJhc2VSZWFsdGltZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3ByZXNlbmNlbWFwLnRzXG5mdW5jdGlvbiBuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmcpIHtcbiAgaWYgKGl0ZW0uaXNTeW50aGVzaXplZCgpIHx8IGV4aXN0aW5nLmlzU3ludGhlc2l6ZWQoKSkge1xuICAgIHJldHVybiBpdGVtLnRpbWVzdGFtcCA+PSBleGlzdGluZy50aW1lc3RhbXA7XG4gIH1cbiAgY29uc3QgaXRlbU9yZGVyaW5ncyA9IGl0ZW0ucGFyc2VJZCgpLCBleGlzdGluZ09yZGVyaW5ncyA9IGV4aXN0aW5nLnBhcnNlSWQoKTtcbiAgaWYgKGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID09PSBleGlzdGluZ09yZGVyaW5ncy5tc2dTZXJpYWwpIHtcbiAgICByZXR1cm4gaXRlbU9yZGVyaW5ncy5pbmRleCA+IGV4aXN0aW5nT3JkZXJpbmdzLmluZGV4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpdGVtT3JkZXJpbmdzLm1zZ1NlcmlhbCA+IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbDtcbiAgfVxufVxudmFyIFByZXNlbmNlTWFwID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHByZXNlbmNlLCBtZW1iZXJLZXksIG5ld2VyID0gbmV3ZXJUaGFuKSB7XG4gICAgc3VwZXIocHJlc2VuY2UubG9nZ2VyKTtcbiAgICB0aGlzLnByZXNlbmNlID0gcHJlc2VuY2U7XG4gICAgdGhpcy5tYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN5bmNJblByb2dyZXNzID0gZmFsc2U7XG4gICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICAgIHRoaXMubWVtYmVyS2V5ID0gbWVtYmVyS2V5O1xuICAgIHRoaXMubmV3ZXJUaGFuID0gbmV3ZXI7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtrZXldO1xuICB9XG4gIGdldENsaWVudChjbGllbnRJZCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgIGlmIChpdGVtLmNsaWVudElkID09IGNsaWVudElkICYmIGl0ZW0uYWN0aW9uICE9IFwiYWJzZW50XCIpXG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxpc3QocGFyYW1zKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIGNsaWVudElkID0gcGFyYW1zICYmIHBhcmFtcy5jbGllbnRJZCwgY29ubmVjdGlvbklkID0gcGFyYW1zICYmIHBhcmFtcy5jb25uZWN0aW9uSWQsIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgY29uc3QgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgaWYgKGl0ZW0uYWN0aW9uID09PSBcImFic2VudFwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChjbGllbnRJZCAmJiBjbGllbnRJZCAhPSBpdGVtLmNsaWVudElkKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChjb25uZWN0aW9uSWQgJiYgY29ubmVjdGlvbklkICE9IGl0ZW0uY29ubmVjdGlvbklkKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHB1dChpdGVtKSB7XG4gICAgaWYgKGl0ZW0uYWN0aW9uID09PSBcImVudGVyXCIgfHwgaXRlbS5hY3Rpb24gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgIGl0ZW0gPSBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKGl0ZW0pO1xuICAgICAgaXRlbS5hY3Rpb24gPSBcInByZXNlbnRcIjtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIGtleSA9IHRoaXMubWVtYmVyS2V5KGl0ZW0pO1xuICAgIGlmICh0aGlzLnJlc2lkdWFsTWVtYmVycylcbiAgICAgIGRlbGV0ZSB0aGlzLnJlc2lkdWFsTWVtYmVyc1trZXldO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuICAgIGlmIChleGlzdGluZ0l0ZW0gJiYgIXRoaXMubmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nSXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFwW2tleV0gPSBpdGVtO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhbHVlcygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFwKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWFwW2tleV07XG4gICAgICBpZiAoaXRlbS5hY3Rpb24gIT0gXCJhYnNlbnRcIilcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwga2V5ID0gdGhpcy5tZW1iZXJLZXkoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAmJiAhdGhpcy5uZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgaXRlbSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoaXRlbSk7XG4gICAgICBpdGVtLmFjdGlvbiA9IFwiYWJzZW50XCI7XG4gICAgICBtYXBba2V5XSA9IGl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuICEhZXhpc3RpbmdJdGVtO1xuICB9XG4gIHN0YXJ0U3luYygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJQcmVzZW5jZU1hcC5zdGFydFN5bmMoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArIFwiOyBzeW5jSW5Qcm9ncmVzcyA9IFwiICsgc3luY0luUHJvZ3Jlc3NcbiAgICApO1xuICAgIGlmICghdGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBjb3B5KG1hcCk7XG4gICAgICB0aGlzLnNldEluUHJvZ3Jlc3ModHJ1ZSk7XG4gICAgfVxuICB9XG4gIGVuZFN5bmMoKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUHJlc2VuY2VNYXAuZW5kU3luYygpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgXCI7IHN5bmNJblByb2dyZXNzID0gXCIgKyBzeW5jSW5Qcm9ncmVzc1xuICAgICk7XG4gICAgaWYgKHN5bmNJblByb2dyZXNzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlcktleSBpbiBtYXApIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgaWYgKGVudHJ5LmFjdGlvbiA9PT0gXCJhYnNlbnRcIikge1xuICAgICAgICAgIGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wcmVzZW5jZS5fc3ludGhlc2l6ZUxlYXZlcyh2YWx1ZXNBcnJheSh0aGlzLnJlc2lkdWFsTWVtYmVycykpO1xuICAgICAgZm9yIChjb25zdCBtZW1iZXJLZXkgaW4gdGhpcy5yZXNpZHVhbE1lbWJlcnMpIHtcbiAgICAgICAgZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICAgICAgdGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwic3luY1wiKTtcbiAgfVxuICBhc3luYyB3YWl0U3luYygpIHtcbiAgICBjb25zdCBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlByZXNlbmNlTWFwLndhaXRTeW5jKClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyBcIjsgc3luY0luUHJvZ3Jlc3MgPSBcIiArIHN5bmNJblByb2dyZXNzXG4gICAgKTtcbiAgICBpZiAoIXN5bmNJblByb2dyZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMub25jZShcInN5bmNcIik7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgIHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcbiAgfVxuICBzZXRJblByb2dyZXNzKGluUHJvZ3Jlc3MpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJQcmVzZW5jZU1hcC5zZXRJblByb2dyZXNzKClcIiwgXCJpblByb2dyZXNzID0gXCIgKyBpblByb2dyZXNzKTtcbiAgICB0aGlzLnN5bmNJblByb2dyZXNzID0gaW5Qcm9ncmVzcztcbiAgICB0aGlzLnByZXNlbmNlLnN5bmNDb21wbGV0ZSA9ICFpblByb2dyZXNzO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWVwcmVzZW5jZS50c1xuZnVuY3Rpb24gZ2V0Q2xpZW50SWQocmVhbHRpbWVQcmVzZW5jZSkge1xuICByZXR1cm4gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLmNsaWVudC5hdXRoLmNsaWVudElkO1xufVxuZnVuY3Rpb24gaXNBbm9ueW1vdXNPcldpbGRjYXJkKHJlYWx0aW1lUHJlc2VuY2UpIHtcbiAgY29uc3QgcmVhbHRpbWUgPSByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwuY2xpZW50O1xuICBjb25zdCBjbGllbnRJZCA9IHJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG4gIHJldHVybiAoIWNsaWVudElkIHx8IGNsaWVudElkID09PSBcIipcIikgJiYgcmVhbHRpbWUuY29ubmVjdGlvbi5zdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIjtcbn1cbnZhciBSZWFsdGltZVByZXNlbmNlID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICBzdXBlcihjaGFubmVsLmxvZ2dlcik7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICB0aGlzLnN5bmNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMubWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzLCAoaXRlbSkgPT4gaXRlbS5jbGllbnRJZCArIFwiOlwiICsgaXRlbS5jb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX215TWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzLCAoaXRlbSkgPT4gaXRlbS5jbGllbnRJZCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcl9kZWZhdWx0KHRoaXMubG9nZ2VyKTtcbiAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICB9XG4gIGFzeW5jIGVudGVyKGRhdGEpIHtcbiAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gZW50ZXIgYSBwcmVzZW5jZSBjaGFubmVsXCIsIDQwMDEyLCA0MDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIHZvaWQgMCwgZGF0YSwgXCJlbnRlclwiKTtcbiAgfVxuICBhc3luYyB1cGRhdGUoZGF0YSkge1xuICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byB1cGRhdGUgcHJlc2VuY2UgZGF0YVwiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodm9pZCAwLCB2b2lkIDAsIGRhdGEsIFwidXBkYXRlXCIpO1xuICB9XG4gIGFzeW5jIGVudGVyQ2xpZW50KGNsaWVudElkLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodm9pZCAwLCBjbGllbnRJZCwgZGF0YSwgXCJlbnRlclwiKTtcbiAgfVxuICBhc3luYyB1cGRhdGVDbGllbnQoY2xpZW50SWQsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIGNsaWVudElkLCBkYXRhLCBcInVwZGF0ZVwiKTtcbiAgfVxuICBhc3luYyBfZW50ZXJPclVwZGF0ZUNsaWVudChpZCwgY2xpZW50SWQsIGRhdGEsIGFjdGlvbikge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2UuXCIgKyBhY3Rpb24gKyBcIkNsaWVudCgpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIGNoYW5uZWwubmFtZSArIFwiLCBpZCA9IFwiICsgaWQgKyBcIiwgY2xpZW50ID0gXCIgKyAoY2xpZW50SWQgfHwgXCIoaW1wbGljaXQpIFwiICsgZ2V0Q2xpZW50SWQodGhpcykpXG4gICAgKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21EYXRhKGRhdGEpO1xuICAgIHByZXNlbmNlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHByZXNlbmNlLmlkID0gaWQ7XG4gICAgfVxuICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgcHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICB9XG4gICAgY29uc3Qgd2lyZVByZXNNc2cgPSBhd2FpdCBwcmVzZW5jZS5lbmNvZGUoY2hhbm5lbC5jaGFubmVsT3B0aW9ucyk7XG4gICAgc3dpdGNoIChjaGFubmVsLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwuc2VuZFByZXNlbmNlKFt3aXJlUHJlc01zZ10pO1xuICAgICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgY2hhbm5lbC5hdHRhY2goKTtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcbiAgICAgICAgICAgIHByZXNlbmNlOiB3aXJlUHJlc01zZyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXG4gICAgICAgICAgXCJVbmFibGUgdG8gXCIgKyBhY3Rpb24gKyBcIiBwcmVzZW5jZSBjaGFubmVsIHdoaWxlIGluIFwiICsgY2hhbm5lbC5zdGF0ZSArIFwiIHN0YXRlXCIsXG4gICAgICAgICAgOTAwMDFcbiAgICAgICAgKTtcbiAgICAgICAgZXJyLmNvZGUgPSA5MDAwMTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBsZWF2ZShkYXRhKSB7XG4gICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgaGF2ZSBiZWVuIHNwZWNpZmllZCB0byBlbnRlciBvciBsZWF2ZSBhIHByZXNlbmNlIGNoYW5uZWxcIiwgNDAwMTIsIDQwMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlYXZlQ2xpZW50KHZvaWQgMCwgZGF0YSk7XG4gIH1cbiAgYXN5bmMgbGVhdmVDbGllbnQoY2xpZW50SWQsIGRhdGEpIHtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgIGlmICghY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyBjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZVByZXNlbmNlLmxlYXZlQ2xpZW50KClcIixcbiAgICAgIFwibGVhdmluZzsgY2hhbm5lbCA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUgKyBcIiwgY2xpZW50ID0gXCIgKyBjbGllbnRJZFxuICAgICk7XG4gICAgY29uc3QgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdC5mcm9tRGF0YShkYXRhKTtcbiAgICBwcmVzZW5jZS5hY3Rpb24gPSBcImxlYXZlXCI7XG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgIH1cbiAgICBjb25zdCB3aXJlUHJlc01zZyA9IGF3YWl0IHByZXNlbmNlLmVuY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zKTtcbiAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICByZXR1cm4gY2hhbm5lbC5zZW5kUHJlc2VuY2UoW3dpcmVQcmVzTXNnXSk7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG4gICAgICAgICAgICBwcmVzZW5jZTogd2lyZVByZXNNc2csXG4gICAgICAgICAgICBjYWxsYmFjazogKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZWRcIjpcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjoge1xuICAgICAgICB0aHJvdyBuZXcgUGFydGlhbEVycm9ySW5mbyhcIlVuYWJsZSB0byBsZWF2ZSBwcmVzZW5jZSBjaGFubmVsIChpbmNvbXBhdGlibGUgc3RhdGUpXCIsIDkwMDAxKTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGNvbnN0IHdhaXRGb3JTeW5jID0gIXBhcmFtcyB8fCAoXCJ3YWl0Rm9yU3luY1wiIGluIHBhcmFtcyA/IHBhcmFtcy53YWl0Rm9yU3luYyA6IHRydWUpO1xuICAgIGZ1bmN0aW9uIHRvTWVzc2FnZXMobWVtYmVyczIpIHtcbiAgICAgIHJldHVybiBwYXJhbXMgPyBtZW1iZXJzMi5saXN0KHBhcmFtcykgOiBtZW1iZXJzMi52YWx1ZXMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgaWYgKHdhaXRGb3JTeW5jKSB7XG4gICAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgY29kZTogOTEwMDUsXG4gICAgICAgICAgbWVzc2FnZTogXCJQcmVzZW5jZSBzdGF0ZSBpcyBvdXQgb2Ygc3luYyBkdWUgdG8gY2hhbm5lbCBiZWluZyBpbiB0aGUgU1VTUEVOREVEIHN0YXRlXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9NZXNzYWdlcyh0aGlzLm1lbWJlcnMpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmNoYW5uZWwuZW5zdXJlQXR0YWNoZWQoKTtcbiAgICBjb25zdCBtZW1iZXJzID0gdGhpcy5tZW1iZXJzO1xuICAgIGlmICh3YWl0Rm9yU3luYykge1xuICAgICAgYXdhaXQgbWVtYmVycy53YWl0U3luYygpO1xuICAgIH1cbiAgICByZXR1cm4gdG9NZXNzYWdlcyh0aGlzLm1lbWJlcnMpO1xuICB9XG4gIGFzeW5jIGhpc3RvcnkocGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVQcmVzZW5jZS5oaXN0b3J5KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHJlc3RNaXhpbiA9IHRoaXMuY2hhbm5lbC5jbGllbnQucmVzdC5wcmVzZW5jZU1peGluO1xuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG4gICAgICBpZiAodGhpcy5jaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcbiAgICAgICAgcGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5jaGFubmVsLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZCwgd2FzOiBcIiArIHRoaXMuY2hhbm5lbC5zdGF0ZSxcbiAgICAgICAgICA0ZTQsXG4gICAgICAgICAgNDAwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN0TWl4aW4uaGlzdG9yeSh0aGlzLCBwYXJhbXMpO1xuICB9XG4gIHNldFByZXNlbmNlKHByZXNlbmNlU2V0LCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2Uuc2V0UHJlc2VuY2UoKVwiLFxuICAgICAgXCJyZWNlaXZlZCBwcmVzZW5jZSBmb3IgXCIgKyBwcmVzZW5jZVNldC5sZW5ndGggKyBcIiBwYXJ0aWNpcGFudHM7IHN5bmNDaGFubmVsU2VyaWFsID0gXCIgKyBzeW5jQ2hhbm5lbFNlcmlhbFxuICAgICk7XG4gICAgbGV0IHN5bmNDdXJzb3IsIG1hdGNoO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycywgYnJvYWRjYXN0TWVzc2FnZXMgPSBbXSwgY29ubklkID0gdGhpcy5jaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZDtcbiAgICBpZiAoaXNTeW5jKSB7XG4gICAgICB0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG4gICAgICBpZiAoc3luY0NoYW5uZWxTZXJpYWwgJiYgKG1hdGNoID0gc3luY0NoYW5uZWxTZXJpYWwubWF0Y2goL15bXFx3LV0rOiguKikkLykpKSB7XG4gICAgICAgIHN5bmNDdXJzb3IgPSBtYXRjaFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgcHJlc2VuY2Ugb2YgcHJlc2VuY2VTZXQpIHtcbiAgICAgIHN3aXRjaCAocHJlc2VuY2UuYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJsZWF2ZVwiOlxuICAgICAgICAgIGlmIChtZW1iZXJzLnJlbW92ZShwcmVzZW5jZSkpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlc2VuY2UuY29ubmVjdGlvbklkID09PSBjb25uSWQgJiYgIXByZXNlbmNlLmlzU3ludGhlc2l6ZWQoKSkge1xuICAgICAgICAgICAgbXlNZW1iZXJzLnJlbW92ZShwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW50ZXJcIjpcbiAgICAgICAgY2FzZSBcInByZXNlbnRcIjpcbiAgICAgICAgY2FzZSBcInVwZGF0ZVwiOlxuICAgICAgICAgIGlmIChtZW1iZXJzLnB1dChwcmVzZW5jZSkpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlc2VuY2UuY29ubmVjdGlvbklkID09PSBjb25uSWQpIHtcbiAgICAgICAgICAgIG15TWVtYmVycy5wdXQocHJlc2VuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU3luYyAmJiAhc3luY0N1cnNvcikge1xuICAgICAgbWVtYmVycy5lbmRTeW5jKCk7XG4gICAgICB0aGlzLmNoYW5uZWwuc3luY0NoYW5uZWxTZXJpYWwgPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJyb2FkY2FzdE1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwcmVzZW5jZSA9IGJyb2FkY2FzdE1lc3NhZ2VzW2ldO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmVtaXQocHJlc2VuY2UuYWN0aW9uLCBwcmVzZW5jZSk7XG4gICAgfVxuICB9XG4gIG9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5vbkF0dGFjaGVkKClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUgKyBcIiwgaGFzUHJlc2VuY2UgPSBcIiArIGhhc1ByZXNlbmNlXG4gICAgKTtcbiAgICBpZiAoaGFzUHJlc2VuY2UpIHtcbiAgICAgIHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3ludGhlc2l6ZUxlYXZlcyh0aGlzLm1lbWJlcnMudmFsdWVzKCkpO1xuICAgICAgdGhpcy5tZW1iZXJzLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKTtcbiAgICBjb25zdCBwZW5kaW5nUHJlc2VuY2UgPSB0aGlzLnBlbmRpbmdQcmVzZW5jZSwgcGVuZGluZ1ByZXNDb3VudCA9IHBlbmRpbmdQcmVzZW5jZS5sZW5ndGg7XG4gICAgaWYgKHBlbmRpbmdQcmVzQ291bnQpIHtcbiAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gICAgICBjb25zdCBwcmVzZW5jZUFycmF5ID0gW107XG4gICAgICBjb25zdCBtdWx0aWNhc3RlciA9IG11bHRpY2FzdGVyX2RlZmF1bHQuY3JlYXRlKHRoaXMubG9nZ2VyKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWRcIixcbiAgICAgICAgXCJzZW5kaW5nIFwiICsgcGVuZGluZ1ByZXNDb3VudCArIFwiIHF1ZXVlZCBwcmVzZW5jZSBtZXNzYWdlc1wiXG4gICAgICApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZW5kaW5nUHJlc0NvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBwZW5kaW5nUHJlc2VuY2VbaV07XG4gICAgICAgIHByZXNlbmNlQXJyYXkucHVzaChldmVudC5wcmVzZW5jZSk7XG4gICAgICAgIG11bHRpY2FzdGVyLnB1c2goZXZlbnQuY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZUFycmF5KS50aGVuKCgpID0+IG11bHRpY2FzdGVyKCkpLmNhdGNoKChlcnIpID0+IG11bHRpY2FzdGVyKGVycikpO1xuICAgIH1cbiAgfVxuICBhY3RPbkNoYW5uZWxTdGF0ZShzdGF0ZSwgaGFzUHJlc2VuY2UsIGVycikge1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICB0aGlzLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICB0aGlzLl9jbGVhck15TWVtYmVycygpO1xuICAgICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgdGhpcy5mYWlsUGVuZGluZ1ByZXNlbmNlKGVycik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmYWlsUGVuZGluZ1ByZXNlbmNlKGVycikge1xuICAgIGlmICh0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwuZmFpbFBlbmRpbmdQcmVzZW5jZVwiLFxuICAgICAgICBcImNoYW5uZWw7IG5hbWUgPSBcIiArIHRoaXMuY2hhbm5lbC5uYW1lICsgXCIsIGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aDsgaSsrKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlW2ldLmNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICB9XG4gIH1cbiAgX2NsZWFyTXlNZW1iZXJzKCkge1xuICAgIHRoaXMuX215TWVtYmVycy5jbGVhcigpO1xuICB9XG4gIF9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCkge1xuICAgIGNvbnN0IG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycztcbiAgICBjb25zdCBjb25uSWQgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkO1xuICAgIGZvciAoY29uc3QgbWVtYmVyS2V5IGluIG15TWVtYmVycy5tYXApIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlJlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKVwiLFxuICAgICAgICAnQXV0by1yZWVudGVyaW5nIGNsaWVudElkIFwiJyArIGVudHJ5LmNsaWVudElkICsgJ1wiIGludG8gdGhlIHByZXNlbmNlIHNldCdcbiAgICAgICk7XG4gICAgICBjb25zdCBpZCA9IGVudHJ5LmNvbm5lY3Rpb25JZCA9PT0gY29ubklkID8gZW50cnkuaWQgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGlkLCBlbnRyeS5jbGllbnRJZCwgZW50cnkuZGF0YSwgXCJlbnRlclwiKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRFcnIgPSBuZXcgRXJyb3JJbmZvKFwiUHJlc2VuY2UgYXV0byByZS1lbnRlciBmYWlsZWRcIiwgOTEwMDQsIDQwMCwgZXJyKTtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIlJlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKVwiLFxuICAgICAgICAgIFwiUHJlc2VuY2UgYXV0byByZS1lbnRlciBmYWlsZWQ7IHJlYXNvbiA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuY2hhbm5lbC5zdGF0ZSwgdGhpcy5jaGFubmVsLnN0YXRlLCB0cnVlLCBmYWxzZSwgd3JhcHBlZEVycik7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5lbWl0KFwidXBkYXRlXCIsIGNoYW5nZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3N5bnRoZXNpemVMZWF2ZXMoaXRlbXMpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgY29uc3QgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgYWN0aW9uOiBcImxlYXZlXCIsXG4gICAgICAgIGNvbm5lY3Rpb25JZDogaXRlbS5jb25uZWN0aW9uSWQsXG4gICAgICAgIGNsaWVudElkOiBpdGVtLmNsaWVudElkLFxuICAgICAgICBkYXRhOiBpdGVtLmRhdGEsXG4gICAgICAgIGVuY29kaW5nOiBpdGVtLmVuY29kaW5nLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgICAgc3Vic2NyaXB0aW9ucy5lbWl0KFwibGVhdmVcIiwgcHJlc2VuY2UpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIGlmIChjaGFubmVsLmNoYW5uZWxPcHRpb25zLmF0dGFjaE9uU3Vic2NyaWJlICE9PSBmYWxzZSkge1xuICAgICAgYXdhaXQgY2hhbm5lbC5hdHRhY2goKTtcbiAgICB9XG4gIH1cbiAgdW5zdWJzY3JpYmUoLi4uX2FyZ3MpIHtcbiAgICBjb25zdCBhcmdzID0gcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn07XG52YXIgcmVhbHRpbWVwcmVzZW5jZV9kZWZhdWx0ID0gUmVhbHRpbWVQcmVzZW5jZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L3dlYnNvY2tldHRyYW5zcG9ydC50c1xudmFyIHNob3J0TmFtZSA9IFRyYW5zcG9ydE5hbWVzLldlYlNvY2tldDtcbmZ1bmN0aW9uIGlzTm9kZVdlYlNvY2tldCh3cykge1xuICByZXR1cm4gISF3cy5vbjtcbn1cbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIHRyYW5zcG9ydF9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgIHN1cGVyKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICAgIHBhcmFtcy5oZWFydGJlYXRzID0gUGxhdGZvcm0uQ29uZmlnLnVzZVByb3RvY29sSGVhcnRiZWF0cztcbiAgICB0aGlzLndzSG9zdCA9IHBhcmFtcy5ob3N0O1xuICB9XG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gISFQbGF0Zm9ybS5Db25maWcuV2ViU29ja2V0O1xuICB9XG4gIGNyZWF0ZVdlYlNvY2tldCh1cmksIGNvbm5lY3RQYXJhbXMpIHtcbiAgICB0aGlzLnVyaSA9IHVyaSArIHRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBQbGF0Zm9ybS5Db25maWcuV2ViU29ja2V0KHRoaXMudXJpKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJXZWJTb2NrZXRUcmFuc3BvcnQ7IHVyaT1cIiArIHRoaXMudXJpO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLCBcInN0YXJ0aW5nXCIpO1xuICAgIHRyYW5zcG9ydF9kZWZhdWx0LnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XG4gICAgY29uc3Qgc2VsZjIgPSB0aGlzLCBwYXJhbXMgPSB0aGlzLnBhcmFtcywgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuICAgIGNvbnN0IHdzU2NoZW1lID0gb3B0aW9ucy50bHMgPyBcIndzczovL1wiIDogXCJ3czovL1wiO1xuICAgIGNvbnN0IHdzVXJpID0gd3NTY2hlbWUgKyB0aGlzLndzSG9zdCArIFwiOlwiICsgZGVmYXVsdHNfZGVmYXVsdC5nZXRQb3J0KG9wdGlvbnMpICsgXCIvXCI7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLCBcInVyaTogXCIgKyB3c1VyaSk7XG4gICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgdGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoKSxcbiAgICAgIGZ1bmN0aW9uKGVyciwgYXV0aFBhcmFtcykge1xuICAgICAgICBpZiAoc2VsZjIuaXNEaXNwb3NlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyYW1TdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIGluIGF1dGhQYXJhbXMpXG4gICAgICAgICAgcGFyYW1TdHIgKz0gXCIgXCIgKyBwYXJhbSArIFwiOiBcIiArIGF1dGhQYXJhbXNbcGFyYW1dICsgXCI7XCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICBzZWxmMi5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLFxuICAgICAgICAgIFwiYXV0aFBhcmFtczpcIiArIHBhcmFtU3RyICsgXCIgZXJyOiBcIiArIGVyclxuICAgICAgICApO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgc2VsZjIuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0gcGFyYW1zLmdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgd3NDb25uZWN0aW9uID0gc2VsZjIud3NDb25uZWN0aW9uID0gc2VsZjIuY3JlYXRlV2ViU29ja2V0KHdzVXJpLCBjb25uZWN0UGFyYW1zKTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24uYmluYXJ5VHlwZSA9IFBsYXRmb3JtLkNvbmZpZy5iaW5hcnlUeXBlO1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NPcGVuKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25jbG9zZSA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBzZWxmMi5vbldzQ2xvc2UoZXYpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBzZWxmMi5vbldzRGF0YShldi5kYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NFcnJvcihldik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaXNOb2RlV2ViU29ja2V0KHdzQ29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbihcInBpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYyLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHNlbGYyLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLFxuICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBjcmVhdGluZyB3ZWJzb2NrZXQ6IGVyciA9IFwiICsgKGUuc3RhY2sgfHwgZS5tZXNzYWdlKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc2VsZjIuZGlzY29ubmVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgc2VuZChtZXNzYWdlKSB7XG4gICAgY29uc3Qgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgaWYgKCF3c0Nvbm5lY3Rpb24pIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5zZW5kKClcIiwgXCJObyBzb2NrZXQgY29ubmVjdGlvblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHdzQ29ubmVjdGlvbi5zZW5kKFxuICAgICAgICBzZXJpYWxpemUyKG1lc3NhZ2UsIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX01zZ1BhY2ssIHRoaXMucGFyYW1zLmZvcm1hdClcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgbXNnID0gXCJFeGNlcHRpb24gZnJvbSB3cyBjb25uZWN0aW9uIHdoZW4gdHJ5aW5nIHRvIHNlbmQ6IFwiICsgaW5zcGVjdEVycm9yKGUpO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgbmV3IEVycm9ySW5mbyhtc2csIDVlNCwgNTAwKSk7XG4gICAgfVxuICB9XG4gIG9uV3NEYXRhKGRhdGEpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKClcIixcbiAgICAgIFwiZGF0YSByZWNlaXZlZDsgbGVuZ3RoID0gXCIgKyBkYXRhLmxlbmd0aCArIFwiOyB0eXBlID0gXCIgKyB0eXBlb2YgZGF0YVxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoXG4gICAgICAgIGRlc2VyaWFsaXplKFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fTXNnUGFjayxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX0Fubm90YXRpb25zLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX2xpdmVPYmplY3RzUGx1Z2luLFxuICAgICAgICAgIHRoaXMuZm9ybWF0XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIG1lc3NhZ2U6IFwiICsgZS5zdGFja1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgb25Xc09wZW4oKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NPcGVuKClcIiwgXCJvcGVuZWQgV2ViU29ja2V0XCIpO1xuICAgIHRoaXMuZW1pdChcInByZWNvbm5lY3RcIik7XG4gIH1cbiAgb25Xc0Nsb3NlKGV2KSB7XG4gICAgbGV0IHdhc0NsZWFuLCBjb2RlO1xuICAgIGlmICh0eXBlb2YgZXYgPT0gXCJvYmplY3RcIikge1xuICAgICAgY29kZSA9IGV2LmNvZGU7XG4gICAgICB3YXNDbGVhbiA9IGV2Lndhc0NsZWFuIHx8IGNvZGUgPT09IDFlMztcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IGV2O1xuICAgICAgd2FzQ2xlYW4gPSBjb2RlID09IDFlMztcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuICAgIGlmICh3YXNDbGVhbikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpXCIsIFwiQ2xlYW5seSBjbG9zZWQgV2ViU29ja2V0XCIpO1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhcIldlYnNvY2tldCBjbG9zZWRcIiwgODAwMDMsIDQwMCk7XG4gICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBcIlVuY2xlYW4gZGlzY29ubmVjdGlvbiBvZiBXZWJTb2NrZXQgOyBjb2RlID0gXCIgKyBjb2RlLCBlcnIgPSBuZXcgRXJyb3JJbmZvKG1zZywgODAwMDMsIDQwMCk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKClcIiwgbXNnKTtcbiAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImRpc3Bvc2VkXCIpO1xuICB9XG4gIG9uV3NFcnJvcihlcnIpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uRXJyb3IoKVwiLFxuICAgICAgXCJFcnJvciBmcm9tIFdlYlNvY2tldDogXCIgKyBlcnIubWVzc2FnZVxuICAgICk7XG4gICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdChFcnJvcihlcnIubWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIGNvbnN0IHdzQ29ubmVjdGlvbiA9IHRoaXMud3NDb25uZWN0aW9uO1xuICAgIGlmICh3c0Nvbm5lY3Rpb24pIHtcbiAgICAgIHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgICBkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiY2xvc2luZyB3ZWJzb2NrZXRcIik7XG4gICAgICAgIGlmICghd3NDb25uZWN0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKTogd3NDb25uZWN0aW9uIGlzIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHdzQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xudmFyIHdlYnNvY2tldHRyYW5zcG9ydF9kZWZhdWx0ID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvZmlsdGVyZWRzdWJzY3JpcHRpb25zLnRzXG52YXIgRmlsdGVyZWRTdWJzY3JpcHRpb25zID0gY2xhc3Mge1xuICBzdGF0aWMgc3Vic2NyaWJlRmlsdGVyKGNoYW5uZWwsIGZpbHRlciwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBmaWx0ZXJlZExpc3RlbmVyID0gKG0pID0+IHtcbiAgICAgIHZhciBfYTIsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIGNvbnN0IG1hcHBpbmcgPSB7XG4gICAgICAgIG5hbWU6IG0ubmFtZSxcbiAgICAgICAgcmVmVGltZXNlcmlhbDogKF9iID0gKF9hMiA9IG0uZXh0cmFzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRpbWVzZXJpYWwsXG4gICAgICAgIHJlZlR5cGU6IChfZCA9IChfYyA9IG0uZXh0cmFzKSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2QudHlwZSxcbiAgICAgICAgaXNSZWY6ICEhKChfZiA9IChfZSA9IG0uZXh0cmFzKSA9PSBudWxsID8gdm9pZCAwIDogX2UucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2YudGltZXNlcmlhbCksXG4gICAgICAgIGNsaWVudElkOiBtLmNsaWVudElkXG4gICAgICB9O1xuICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZmluZChcbiAgICAgICAgKFtrZXksIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMCA/IG1hcHBpbmdba2V5XSAhPT0gdmFsdWUgOiBmYWxzZVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihtKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkRmlsdGVyZWRTdWJzY3JpcHRpb24oY2hhbm5lbCwgZmlsdGVyLCBsaXN0ZW5lciwgZmlsdGVyZWRMaXN0ZW5lcik7XG4gICAgY2hhbm5lbC5zdWJzY3JpcHRpb25zLm9uKGZpbHRlcmVkTGlzdGVuZXIpO1xuICB9XG4gIC8vIEFkZHMgYSBuZXcgZmlsdGVyZWQgc3Vic2NyaXB0aW9uXG4gIHN0YXRpYyBhZGRGaWx0ZXJlZFN1YnNjcmlwdGlvbihjaGFubmVsLCBmaWx0ZXIsIHJlYWxMaXN0ZW5lciwgZmlsdGVyZWRMaXN0ZW5lcikge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKCFjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykge1xuICAgICAgY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBpZiAoY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuaGFzKHJlYWxMaXN0ZW5lcikpIHtcbiAgICAgIGNvbnN0IHJlYWxMaXN0ZW5lck1hcCA9IGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmdldChyZWFsTGlzdGVuZXIpO1xuICAgICAgcmVhbExpc3RlbmVyTWFwLnNldChmaWx0ZXIsICgoX2EyID0gcmVhbExpc3RlbmVyTWFwID09IG51bGwgPyB2b2lkIDAgOiByZWFsTGlzdGVuZXJNYXAuZ2V0KGZpbHRlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY29uY2F0KGZpbHRlcmVkTGlzdGVuZXIpKSB8fCBbZmlsdGVyZWRMaXN0ZW5lcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5zZXQoXG4gICAgICAgIHJlYWxMaXN0ZW5lcixcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1tmaWx0ZXIsIFtmaWx0ZXJlZExpc3RlbmVyXV1dKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldEFuZERlbGV0ZUZpbHRlcmVkU3Vic2NyaXB0aW9ucyhjaGFubmVsLCBmaWx0ZXIsIHJlYWxMaXN0ZW5lcikge1xuICAgIGlmICghY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFyZWFsTGlzdGVuZXIgJiYgZmlsdGVyKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5lbnRyaWVzKCkpLm1hcCgoW2tleSwgZmlsdGVyTWFwc10pID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgbGV0IGxpc3RlbmVyTWFwcyA9IGZpbHRlck1hcHMuZ2V0KGZpbHRlcik7XG4gICAgICAgIGZpbHRlck1hcHMuZGVsZXRlKGZpbHRlcik7XG4gICAgICAgIGlmIChmaWx0ZXJNYXBzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAoX2EyID0gY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyTWFwcztcbiAgICAgIH0pLnJlZHVjZShcbiAgICAgICAgKHByZXYsIGN1cikgPT4gY3VyID8gcHJldi5jb25jYXQoLi4uY3VyKSA6IHByZXYsXG4gICAgICAgIFtdXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlYWxMaXN0ZW5lciB8fCAhY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuaGFzKHJlYWxMaXN0ZW5lcikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcmVhbExpc3RlbmVyTWFwID0gY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0KHJlYWxMaXN0ZW5lcik7XG4gICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyczIgPSBBcnJheS5mcm9tKHJlYWxMaXN0ZW5lck1hcC52YWx1ZXMoKSkucmVkdWNlKChwcmV2LCBjdXIpID0+IHByZXYuY29uY2F0KC4uLmN1ciksIFtdKTtcbiAgICAgIGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmRlbGV0ZShyZWFsTGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIGxpc3RlbmVyczI7XG4gICAgfVxuICAgIGxldCBsaXN0ZW5lcnMgPSByZWFsTGlzdGVuZXJNYXAuZ2V0KGZpbHRlcik7XG4gICAgcmVhbExpc3RlbmVyTWFwLmRlbGV0ZShmaWx0ZXIpO1xuICAgIHJldHVybiBsaXN0ZW5lcnMgfHwgW107XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9kZWZhdWx0cmVhbHRpbWUudHNcbnZhciBfRGVmYXVsdFJlYWx0aW1lID0gY2xhc3MgX0RlZmF1bHRSZWFsdGltZSBleHRlbmRzIGJhc2VyZWFsdGltZV9kZWZhdWx0IHtcbiAgLy8gVGhlIHB1YmxpYyB0eXBpbmdzIGRlY2xhcmUgdGhhdCB0aGlzIHJlcXVpcmVzIGFuIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCwgYnV0IHNpbmNlIHdlIHdhbnQgdG8gZW1pdCBhIGdvb2QgZXJyb3IgbWVzc2FnZSBpbiB0aGUgY2FzZSB3aGVyZSBhIG5vbi1UeXBlU2NyaXB0IHVzZXIgZG9lcyBub3QgcGFzcyBhbiBhcmd1bWVudCwgdGVsbCB0aGUgY29tcGlsZXIgdGhhdCB0aGlzIGlzIHBvc3NpYmxlIHNvIHRoYXQgaXQgZm9yY2VzIHVzIHRvIGhhbmRsZSBpdC5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3QgTXNnUGFjayA9IF9EZWZhdWx0UmVhbHRpbWUuX01zZ1BhY2s7XG4gICAgaWYgKCFNc2dQYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEZWZhdWx0UmVhbHRpbWUuX01zZ1BhY2sgdG8gaGF2ZSBiZWVuIHNldFwiKTtcbiAgICB9XG4gICAgc3VwZXIoXG4gICAgICBkZWZhdWx0c19kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucywgdHJ1ZSwgXCJSZWFsdGltZVwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhbGxDb21tb25Nb2R1bGFyUGx1Z2lucyksIHtcbiAgICAgICAgQ3J5cHRvOiAoX2EyID0gX0RlZmF1bHRSZWFsdGltZS5DcnlwdG8pICE9IG51bGwgPyBfYTIgOiB2b2lkIDAsXG4gICAgICAgIE1zZ1BhY2ssXG4gICAgICAgIFJlYWx0aW1lUHJlc2VuY2U6IHtcbiAgICAgICAgICBSZWFsdGltZVByZXNlbmNlOiByZWFsdGltZXByZXNlbmNlX2RlZmF1bHQsXG4gICAgICAgICAgUHJlc2VuY2VNZXNzYWdlOiBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdCxcbiAgICAgICAgICBXaXJlUHJlc2VuY2VNZXNzYWdlXG4gICAgICAgIH0sXG4gICAgICAgIEFubm90YXRpb25zOiB7XG4gICAgICAgICAgQW5ub3RhdGlvbjogYW5ub3RhdGlvbl9kZWZhdWx0LFxuICAgICAgICAgIFdpcmVBbm5vdGF0aW9uLFxuICAgICAgICAgIFJlYWx0aW1lQW5ub3RhdGlvbnM6IHJlYWx0aW1lYW5ub3RhdGlvbnNfZGVmYXVsdCxcbiAgICAgICAgICBSZXN0QW5ub3RhdGlvbnM6IHJlc3Rhbm5vdGF0aW9uc19kZWZhdWx0XG4gICAgICAgIH0sXG4gICAgICAgIFdlYlNvY2tldFRyYW5zcG9ydDogd2Vic29ja2V0dHJhbnNwb3J0X2RlZmF1bHQsXG4gICAgICAgIE1lc3NhZ2VJbnRlcmFjdGlvbnM6IEZpbHRlcmVkU3Vic2NyaXB0aW9uc1xuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IENyeXB0bygpIHtcbiAgICBpZiAodGhpcy5fQ3J5cHRvID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9DcnlwdG87XG4gIH1cbiAgc3RhdGljIHNldCBDcnlwdG8obmV3VmFsdWUpIHtcbiAgICB0aGlzLl9DcnlwdG8gPSBuZXdWYWx1ZTtcbiAgfVxufTtcbl9EZWZhdWx0UmVhbHRpbWUuVXRpbHMgPSB1dGlsc19leHBvcnRzO1xuX0RlZmF1bHRSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25tYW5hZ2VyX2RlZmF1bHQ7XG5fRGVmYXVsdFJlYWx0aW1lLlByb3RvY29sTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZV9kZWZhdWx0O1xuX0RlZmF1bHRSZWFsdGltZS5fQ3J5cHRvID0gbnVsbDtcbl9EZWZhdWx0UmVhbHRpbWUuTWVzc2FnZSA9IERlZmF1bHRNZXNzYWdlO1xuX0RlZmF1bHRSZWFsdGltZS5QcmVzZW5jZU1lc3NhZ2UgPSBEZWZhdWx0UHJlc2VuY2VNZXNzYWdlO1xuX0RlZmF1bHRSZWFsdGltZS5Bbm5vdGF0aW9uID0gRGVmYXVsdEFubm90YXRpb247XG5fRGVmYXVsdFJlYWx0aW1lLl9Nc2dQYWNrID0gbnVsbDtcbi8vIFVzZWQgYnkgdGVzdHNcbl9EZWZhdWx0UmVhbHRpbWUuX0h0dHAgPSBIdHRwO1xuX0RlZmF1bHRSZWFsdGltZS5fUHJlc2VuY2VNYXAgPSBQcmVzZW5jZU1hcDtcbl9EZWZhdWx0UmVhbHRpbWUuX01lc3NhZ2VFbmNvZGluZyA9IE1lc3NhZ2VFbmNvZGluZztcbnZhciBEZWZhdWx0UmVhbHRpbWUgPSBfRGVmYXVsdFJlYWx0aW1lO1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi91dGlsL2htYWMtc2hhMjU2LnRzXG52YXIgdWludDhBcnJheSA9IFVpbnQ4QXJyYXk7XG52YXIgdWludDMyQXJyYXkgPSBVaW50MzJBcnJheTtcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBERUZBVUxUX1NUQVRFID0gbmV3IHVpbnQzMkFycmF5KDgpO1xudmFyIFJPVU5EX0NPTlNUQU5UUyA9IFtdO1xudmFyIE0gPSBuZXcgdWludDMyQXJyYXkoNjQpO1xuZnVuY3Rpb24gZ2V0RnJhY3Rpb25hbEJpdHMobjIpIHtcbiAgcmV0dXJuIChuMiAtIChuMiB8IDApKSAqIHBvdygyLCAzMikgfCAwO1xufVxudmFyIG4gPSAyO1xudmFyIG5QcmltZSA9IDA7XG53aGlsZSAoblByaW1lIDwgNjQpIHtcbiAgaXNQcmltZSA9IHRydWU7XG4gIGZvciAoZmFjdG9yID0gMjsgZmFjdG9yIDw9IG4gLyAyOyBmYWN0b3IrKykge1xuICAgIGlmIChuICUgZmFjdG9yID09PSAwKSB7XG4gICAgICBpc1ByaW1lID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc1ByaW1lKSB7XG4gICAgaWYgKG5QcmltZSA8IDgpIHtcbiAgICAgIERFRkFVTFRfU1RBVEVbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKHBvdyhuLCAxIC8gMikpO1xuICAgIH1cbiAgICBST1VORF9DT05TVEFOVFNbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKHBvdyhuLCAxIC8gMykpO1xuICAgIG5QcmltZSsrO1xuICB9XG4gIG4rKztcbn1cbnZhciBpc1ByaW1lO1xudmFyIGZhY3RvcjtcbnZhciBMaXR0bGVFbmRpYW4gPSAhIW5ldyB1aW50OEFycmF5KG5ldyB1aW50MzJBcnJheShbMV0pLmJ1ZmZlcilbMF07XG5mdW5jdGlvbiBjb252ZXJ0RW5kaWFuKHdvcmQpIHtcbiAgaWYgKExpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBieXRlIDEgLT4gYnl0ZSA0XG4gICAgICB3b3JkID4+PiAyNCB8IC8vIGJ5dGUgMiAtPiBieXRlIDNcbiAgICAgICh3b3JkID4+PiAxNiAmIDI1NSkgPDwgOCB8IC8vIGJ5dGUgMyAtPiBieXRlIDJcbiAgICAgICh3b3JkICYgNjUyODApIDw8IDggfCAvLyBieXRlIDQgLT4gYnl0ZSAxXG4gICAgICB3b3JkIDw8IDI0XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd29yZDtcbiAgfVxufVxuZnVuY3Rpb24gcmlnaHRSb3RhdGUod29yZCwgYml0cykge1xuICByZXR1cm4gd29yZCA+Pj4gYml0cyB8IHdvcmQgPDwgMzIgLSBiaXRzO1xufVxuZnVuY3Rpb24gc2hhMjU2KGRhdGEpIHtcbiAgdmFyIFNUQVRFID0gREVGQVVMVF9TVEFURS5zbGljZSgpO1xuICB2YXIgbGVndGggPSBkYXRhLmxlbmd0aDtcbiAgdmFyIGJpdExlbmd0aCA9IGxlZ3RoICogODtcbiAgdmFyIG5ld0JpdExlbmd0aCA9IDUxMiAtIChiaXRMZW5ndGggKyA2NCkgJSA1MTIgLSAxICsgYml0TGVuZ3RoICsgNjU7XG4gIHZhciBieXRlcyA9IG5ldyB1aW50OEFycmF5KG5ld0JpdExlbmd0aCAvIDgpO1xuICB2YXIgd29yZHMgPSBuZXcgdWludDMyQXJyYXkoYnl0ZXMuYnVmZmVyKTtcbiAgYnl0ZXMuc2V0KGRhdGEsIDApO1xuICBieXRlc1tsZWd0aF0gPSAxMjg7XG4gIHdvcmRzW3dvcmRzLmxlbmd0aCAtIDFdID0gY29udmVydEVuZGlhbihiaXRMZW5ndGgpO1xuICB2YXIgcm91bmQ7XG4gIGZvciAodmFyIGJsb2NrID0gMDsgYmxvY2sgPCBuZXdCaXRMZW5ndGggLyAzMjsgYmxvY2sgKz0gMTYpIHtcbiAgICB2YXIgd29ya2luZ1N0YXRlID0gU1RBVEUuc2xpY2UoKTtcbiAgICBmb3IgKHJvdW5kID0gMDsgcm91bmQgPCA2NDsgcm91bmQrKykge1xuICAgICAgdmFyIE1Sb3VuZDtcbiAgICAgIGlmIChyb3VuZCA8IDE2KSB7XG4gICAgICAgIE1Sb3VuZCA9IGNvbnZlcnRFbmRpYW4od29yZHNbYmxvY2sgKyByb3VuZF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGdhbW1hMHggPSBNW3JvdW5kIC0gMTVdO1xuICAgICAgICB2YXIgZ2FtbWExeCA9IE1bcm91bmQgLSAyXTtcbiAgICAgICAgTVJvdW5kID0gTVtyb3VuZCAtIDddICsgTVtyb3VuZCAtIDE2XSArIChyaWdodFJvdGF0ZShnYW1tYTB4LCA3KSBeIHJpZ2h0Um90YXRlKGdhbW1hMHgsIDE4KSBeIGdhbW1hMHggPj4+IDMpICsgKHJpZ2h0Um90YXRlKGdhbW1hMXgsIDE3KSBeIHJpZ2h0Um90YXRlKGdhbW1hMXgsIDE5KSBeIGdhbW1hMXggPj4+IDEwKTtcbiAgICAgIH1cbiAgICAgIE1bcm91bmRdID0gTVJvdW5kIHw9IDA7XG4gICAgICB2YXIgdDEgPSAocmlnaHRSb3RhdGUod29ya2luZ1N0YXRlWzRdLCA2KSBeIHJpZ2h0Um90YXRlKHdvcmtpbmdTdGF0ZVs0XSwgMTEpIF4gcmlnaHRSb3RhdGUod29ya2luZ1N0YXRlWzRdLCAyNSkpICsgKHdvcmtpbmdTdGF0ZVs0XSAmIHdvcmtpbmdTdGF0ZVs1XSBeIH53b3JraW5nU3RhdGVbNF0gJiB3b3JraW5nU3RhdGVbNl0pICsgd29ya2luZ1N0YXRlWzddICsgTVJvdW5kICsgUk9VTkRfQ09OU1RBTlRTW3JvdW5kXTtcbiAgICAgIHZhciB0MiA9IChyaWdodFJvdGF0ZSh3b3JraW5nU3RhdGVbMF0sIDIpIF4gcmlnaHRSb3RhdGUod29ya2luZ1N0YXRlWzBdLCAxMykgXiByaWdodFJvdGF0ZSh3b3JraW5nU3RhdGVbMF0sIDIyKSkgKyAod29ya2luZ1N0YXRlWzBdICYgd29ya2luZ1N0YXRlWzFdIF4gd29ya2luZ1N0YXRlWzJdICYgKHdvcmtpbmdTdGF0ZVswXSBeIHdvcmtpbmdTdGF0ZVsxXSkpO1xuICAgICAgZm9yICh2YXIgaSA9IDc7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgd29ya2luZ1N0YXRlW2ldID0gd29ya2luZ1N0YXRlW2kgLSAxXTtcbiAgICAgIH1cbiAgICAgIHdvcmtpbmdTdGF0ZVswXSA9IHQxICsgdDIgfCAwO1xuICAgICAgd29ya2luZ1N0YXRlWzRdID0gd29ya2luZ1N0YXRlWzRdICsgdDEgfCAwO1xuICAgIH1cbiAgICBmb3IgKHJvdW5kID0gMDsgcm91bmQgPCA4OyByb3VuZCsrKSB7XG4gICAgICBTVEFURVtyb3VuZF0gPSBTVEFURVtyb3VuZF0gKyB3b3JraW5nU3RhdGVbcm91bmRdIHwgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyB1aW50OEFycmF5KFxuICAgIG5ldyB1aW50MzJBcnJheShcbiAgICAgIFNUQVRFLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRFbmRpYW4odmFsKTtcbiAgICAgIH0pXG4gICAgKS5idWZmZXJcbiAgKTtcbn1cbmZ1bmN0aW9uIGhtYWMyKGtleSwgZGF0YSkge1xuICBpZiAoa2V5Lmxlbmd0aCA+IDY0KVxuICAgIGtleSA9IHNoYTI1NihrZXkpO1xuICBpZiAoa2V5Lmxlbmd0aCA8IDY0KSB7XG4gICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIHRtcC5zZXQoa2V5LCAwKTtcbiAgICBrZXkgPSB0bXA7XG4gIH1cbiAgdmFyIGlubmVyS2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgb3V0ZXJLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIGlubmVyS2V5W2ldID0gNTQgXiBrZXlbaV07XG4gICAgb3V0ZXJLZXlbaV0gPSA5MiBeIGtleVtpXTtcbiAgfVxuICB2YXIgbXNnID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyA2NCk7XG4gIG1zZy5zZXQoaW5uZXJLZXksIDApO1xuICBtc2cuc2V0KGRhdGEsIDY0KTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KDY0ICsgMzIpO1xuICByZXN1bHQuc2V0KG91dGVyS2V5LCAwKTtcbiAgcmVzdWx0LnNldChzaGEyNTYobXNnKSwgNjQpO1xuICByZXR1cm4gc2hhMjU2KHJlc3VsdCk7XG59XG5cbi8vIHNyYy9wbGF0Zm9ybS93ZWIvbGliL3V0aWwvYnVmZmVydXRpbHMudHNcbnZhciBCdWZmZXJVdGlscyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5iYXNlNjRDaGFyU2V0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gICAgdGhpcy5oZXhDaGFyU2V0ID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIH1cbiAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qb25sZWlnaHRvbi85NTg4NDEvcmF3L2YyMDBlMzBkZmU5NTIxMmMwMTY1Y2NmMWFlMDAwY2E1MWU5ZGU4MDMvZ2lzdGZpbGUxLmpzXG4gIHVpbnQ4Vmlld1RvQmFzZTY0KGJ5dGVzKSB7XG4gICAgbGV0IGJhc2U2NCA9IFwiXCI7XG4gICAgY29uc3QgZW5jb2RpbmdzID0gdGhpcy5iYXNlNjRDaGFyU2V0O1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGJ5dGVSZW1haW5kZXIgPSBieXRlTGVuZ3RoICUgMztcbiAgICBjb25zdCBtYWluTGVuZ3RoID0gYnl0ZUxlbmd0aCAtIGJ5dGVSZW1haW5kZXI7XG4gICAgbGV0IGEsIGIsIGMsIGQ7XG4gICAgbGV0IGNodW5rO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFpbkxlbmd0aDsgaSA9IGkgKyAzKSB7XG4gICAgICBjaHVuayA9IGJ5dGVzW2ldIDw8IDE2IHwgYnl0ZXNbaSArIDFdIDw8IDggfCBieXRlc1tpICsgMl07XG4gICAgICBhID0gKGNodW5rICYgMTY1MTUwNzIpID4+IDE4O1xuICAgICAgYiA9IChjaHVuayAmIDI1ODA0OCkgPj4gMTI7XG4gICAgICBjID0gKGNodW5rICYgNDAzMikgPj4gNjtcbiAgICAgIGQgPSBjaHVuayAmIDYzO1xuICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArIGVuY29kaW5nc1tkXTtcbiAgICB9XG4gICAgaWYgKGJ5dGVSZW1haW5kZXIgPT0gMSkge1xuICAgICAgY2h1bmsgPSBieXRlc1ttYWluTGVuZ3RoXTtcbiAgICAgIGEgPSAoY2h1bmsgJiAyNTIpID4+IDI7XG4gICAgICBiID0gKGNodW5rICYgMykgPDwgNDtcbiAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBcIj09XCI7XG4gICAgfSBlbHNlIGlmIChieXRlUmVtYWluZGVyID09IDIpIHtcbiAgICAgIGNodW5rID0gYnl0ZXNbbWFpbkxlbmd0aF0gPDwgOCB8IGJ5dGVzW21haW5MZW5ndGggKyAxXTtcbiAgICAgIGEgPSAoY2h1bmsgJiA2NDUxMikgPj4gMTA7XG4gICAgICBiID0gKGNodW5rICYgMTAwOCkgPj4gNDtcbiAgICAgIGMgPSAoY2h1bmsgJiAxNSkgPDwgMjtcbiAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBlbmNvZGluZ3NbY10gKyBcIj1cIjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfVxuICBiYXNlNjRUb0FycmF5QnVmZmVyKGJhc2U2NCkge1xuICAgIGNvbnN0IGJpbmFyeV9zdHJpbmcgPSBhdG9iID09IG51bGwgPyB2b2lkIDAgOiBhdG9iKGJhc2U2NCk7XG4gICAgY29uc3QgbGVuID0gYmluYXJ5X3N0cmluZy5sZW5ndGg7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGFzY2lpID0gYmluYXJ5X3N0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgYnl0ZXNbaV0gPSBhc2NpaTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcihieXRlcyk7XG4gIH1cbiAgaXNCdWZmZXIoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpO1xuICB9XG4gIHRvQnVmZmVyKGJ1ZmZlcikge1xuICAgIGlmICghQXJyYXlCdWZmZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgdG8gQnVmZmVyOiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIG5lY2Vzc2FyeSB0eXBlc1wiKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy50b0FycmF5QnVmZmVyKGJ1ZmZlcikpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXJVdGlscy50b0J1ZmZlciBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlciBvciBhIHZpZXcgb250byBvbmVcIik7XG4gIH1cbiAgdG9BcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgICBpZiAoIUFycmF5QnVmZmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0IHRvIEFycmF5QnVmZmVyOiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIG5lY2Vzc2FyeSB0eXBlc1wiKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuYnVmZmVyLnNsaWNlKGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZU9mZnNldCArIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlciBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlciBvciBhIHZpZXcgb250byBvbmVcIik7XG4gIH1cbiAgYmFzZTY0RW5jb2RlKGJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLnVpbnQ4Vmlld1RvQmFzZTY0KHRoaXMudG9CdWZmZXIoYnVmZmVyKSk7XG4gIH1cbiAgYmFzZTY0VXJsRW5jb2RlKGJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLmJhc2U2NEVuY29kZShidWZmZXIpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbiAgfVxuICBiYXNlNjREZWNvZGUoc3RyKSB7XG4gICAgaWYgKEFycmF5QnVmZmVyICYmIFBsYXRmb3JtLkNvbmZpZy5hdG9iKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRUb0FycmF5QnVmZmVyKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIEFycmF5QnVmZmVyIHRvIGV4aXN0IGFuZCBQbGF0Zm9ybS5Db25maWcuYXRvYiB0byBiZSBjb25maWd1cmVkXCIpO1xuICAgIH1cbiAgfVxuICBoZXhFbmNvZGUoYnVmZmVyKSB7XG4gICAgY29uc3QgdWludDhBcnJheTIgPSB0aGlzLnRvQnVmZmVyKGJ1ZmZlcik7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXkyLnJlZHVjZSgoYWNjdW0sIGJ5dGUpID0+IGFjY3VtICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbiAgfVxuICBoZXhEZWNvZGUoaGV4RW5jb2RlZEJ5dGVzKSB7XG4gICAgaWYgKGhleEVuY29kZWRCeXRlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjcmVhdGUgYSBieXRlIGFycmF5IGZyb20gYSBoZXggc3RyaW5nIG9mIG9kZCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGNvbnN0IHVpbnQ4QXJyYXkyID0gbmV3IFVpbnQ4QXJyYXkoaGV4RW5jb2RlZEJ5dGVzLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhBcnJheTIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVpbnQ4QXJyYXkyW2ldID0gcGFyc2VJbnQoaGV4RW5jb2RlZEJ5dGVzLnNsaWNlKDIgKiBpLCAyICogKGkgKyAxKSksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcih1aW50OEFycmF5Mik7XG4gIH1cbiAgdXRmOEVuY29kZShzdHJpbmcpIHtcbiAgICBpZiAoUGxhdGZvcm0uQ29uZmlnLlRleHRFbmNvZGVyKSB7XG4gICAgICBjb25zdCBlbmNvZGVkQnl0ZUFycmF5ID0gbmV3IFBsYXRmb3JtLkNvbmZpZy5UZXh0RW5jb2RlcigpLmVuY29kZShzdHJpbmcpO1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcihlbmNvZGVkQnl0ZUFycmF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgVGV4dEVuY29kZXIgdG8gYmUgY29uZmlndXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgLyogRm9yIHV0ZjggZGVjb2Rpbmcgd2UgYXBwbHkgc2xpZ2h0bHkgc3RyaWN0ZXIgaW5wdXQgdmFsaWRhdGlvbiB0aGFuIHRvXG4gICAqIGhleEVuY29kZS9iYXNlNjRFbmNvZGUvZXRjOiBpbiB0aG9zZSB3ZSBhY2NlcHQgYW55dGhpbmcgdGhhdCBCdWZmZXIuZnJvbVxuICAgKiBjYW4gdGFrZSAoaW4gcGFydGljdWxhciBhbGxvd2luZyBzdHJpbmdzLCB3aGljaCBhcmUganVzdCBpbnRlcnByZXRlZCBhc1xuICAgKiBiaW5hcnkpOyBoZXJlIHdlIGVuc3VyZSB0aGF0IHRoZSBpbnB1dCBpcyBhY3R1YWxseSBhIGJ1ZmZlciBzaW5jZSB0cnlpbmdcbiAgICogdG8gdXRmOC1kZWNvZGUgYSBzdHJpbmcgdG8gYW5vdGhlciBzdHJpbmcgaXMgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UgKi9cbiAgdXRmOERlY29kZShidWZmZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgb2YgdXRmOGRlY29kZSB0byBiZSBhbiBhcnJheWJ1ZmZlciBvciB0eXBlZCBhcnJheVwiKTtcbiAgICB9XG4gICAgaWYgKFRleHREZWNvZGVyKSB7XG4gICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFRleHREZWNvZGVyIHRvIGJlIGNvbmZpZ3VyZWRcIik7XG4gICAgfVxuICB9XG4gIGFyZUJ1ZmZlcnNFcXVhbChidWZmZXIxLCBidWZmZXIyKSB7XG4gICAgaWYgKCFidWZmZXIxIHx8ICFidWZmZXIyKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFycmF5QnVmZmVyMSA9IHRoaXMudG9BcnJheUJ1ZmZlcihidWZmZXIxKTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlcjIgPSB0aGlzLnRvQXJyYXlCdWZmZXIoYnVmZmVyMik7XG4gICAgaWYgKGFycmF5QnVmZmVyMS5ieXRlTGVuZ3RoICE9IGFycmF5QnVmZmVyMi5ieXRlTGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGJ5dGVzMSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyMSk7XG4gICAgY29uc3QgYnl0ZXMyID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJ5dGVzMVtpXSAhPSBieXRlczJbaV0pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYnl0ZUxlbmd0aChidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGFycmF5QnVmZmVyVmlld1RvQnVmZmVyKGFycmF5QnVmZmVyVmlldykge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXJWaWV3KTtcbiAgfVxuICBjb25jYXQoYnVmZmVycykge1xuICAgIGNvbnN0IHN1bUxlbmd0aCA9IGJ1ZmZlcnMucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYuYnl0ZUxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc3VtTGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICBjb25zdCB1aW50OEFycmF5MiA9IHRoaXMudG9CdWZmZXIoYnVmZmVyKTtcbiAgICAgIHJlc3VsdC5zZXQodWludDhBcnJheTIsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gdWludDhBcnJheTIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG4gIH1cbiAgc2hhMjU2KG1lc3NhZ2UpIHtcbiAgICBjb25zdCBoYXNoID0gc2hhMjU2KHRoaXMudG9CdWZmZXIobWVzc2FnZSkpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIoaGFzaCk7XG4gIH1cbiAgaG1hY1NoYTI1NihtZXNzYWdlLCBrZXkpIHtcbiAgICBjb25zdCBoYXNoID0gaG1hYzIodGhpcy50b0J1ZmZlcihrZXkpLCB0aGlzLnRvQnVmZmVyKG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5QnVmZmVyKGhhc2gpO1xuICB9XG59O1xudmFyIGJ1ZmZlcnV0aWxzX2RlZmF1bHQgPSBuZXcgQnVmZmVyVXRpbHMoKTtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC9jcnlwdG8udHNcbnZhciBjcmVhdGVDcnlwdG9DbGFzcyA9IGZ1bmN0aW9uKGNvbmZpZywgYnVmZmVyVXRpbHMpIHtcbiAgdmFyIERFRkFVTFRfQUxHT1JJVEhNID0gXCJhZXNcIjtcbiAgdmFyIERFRkFVTFRfS0VZTEVOR1RIID0gMjU2O1xuICB2YXIgREVGQVVMVF9NT0RFID0gXCJjYmNcIjtcbiAgdmFyIERFRkFVTFRfQkxPQ0tMRU5HVEggPSAxNjtcbiAgZnVuY3Rpb24gdmFsaWRhdGVDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5hbGdvcml0aG0gPT09IFwiYWVzXCIgJiYgcGFyYW1zLm1vZGUgPT09IFwiY2JjXCIpIHtcbiAgICAgIGlmIChwYXJhbXMua2V5TGVuZ3RoID09PSAxMjggfHwgcGFyYW1zLmtleUxlbmd0aCA9PT0gMjU2KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJVbnN1cHBvcnRlZCBrZXkgbGVuZ3RoIFwiICsgcGFyYW1zLmtleUxlbmd0aCArIFwiIGZvciBhZXMtY2JjIGVuY3J5cHRpb24uIEVuY3J5cHRpb24ga2V5IG11c3QgYmUgMTI4IG9yIDI1NiBiaXRzICgxNiBvciAzMiBBU0NJSSBjaGFyYWN0ZXJzKVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpc2VCYXNlNjQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKFwiX1wiLCBcIi9cIikucmVwbGFjZShcIi1cIiwgXCIrXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2lwaGVyUGFyYW1zKHBhcmFtcykge1xuICAgIHJldHVybiBwYXJhbXMgaW5zdGFuY2VvZiBDaXBoZXJQYXJhbXM7XG4gIH1cbiAgY2xhc3MgQ2lwaGVyUGFyYW1zIHtcbiAgICBjb25zdHJ1Y3RvcihhbGdvcml0aG0sIGtleUxlbmd0aCwgbW9kZSwga2V5KSB7XG4gICAgICB0aGlzLmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgIHRoaXMua2V5TGVuZ3RoID0ga2V5TGVuZ3RoO1xuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgfVxuICBjbGFzcyBDcnlwdG8yIHtcbiAgICAvKipcbiAgICAgKiBPYnRhaW4gYSBjb21wbGV0ZSBDaXBoZXJQYXJhbXMgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQgcGFyYW1zLCBmaWxsaW5nXG4gICAgICogaW4gYW55IG5vdCBwcm92aWRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzLCBjYWxjdWxhdGluZyBhIGtleUxlbmd0aCBmcm9tXG4gICAgICogdGhlIHN1cHBsaWVkIGtleSwgYW5kIHZhbGlkYXRpbmcgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIGFuIG9iamVjdCBjb250YWluaW5nIGF0IGEgbWluaW11bSBhIGBrZXlgIGtleSB3aXRoIHZhbHVlIHRoZVxuICAgICAqIGtleSwgYXMgZWl0aGVyIGEgYmluYXJ5IG9yIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqIE1heSBvcHRpb25hbGx5IGFsc28gY29udGFpbjogYWxnb3JpdGhtIChkZWZhdWx0cyB0byBBRVMpLFxuICAgICAqIG1vZGUgKGRlZmF1bHRzIHRvICdjYmMnKVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREZWZhdWx0UGFyYW1zKHBhcmFtcykge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGlmICghcGFyYW1zLmtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXkgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5rZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAga2V5ID0gYnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcihidWZmZXJVdGlscy5iYXNlNjREZWNvZGUobm9ybWFsaXNlQmFzZTY0KHBhcmFtcy5rZXkpKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5rZXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBrZXkgPSBwYXJhbXMua2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gYnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcihwYXJhbXMua2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBhbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtIHx8IERFRkFVTFRfQUxHT1JJVEhNO1xuICAgICAgdmFyIGtleUxlbmd0aCA9IGtleS5ieXRlTGVuZ3RoICogODtcbiAgICAgIHZhciBtb2RlID0gcGFyYW1zLm1vZGUgfHwgREVGQVVMVF9NT0RFO1xuICAgICAgdmFyIGNpcGhlclBhcmFtcyA9IG5ldyBDaXBoZXJQYXJhbXMoYWxnb3JpdGhtLCBrZXlMZW5ndGgsIG1vZGUsIGtleSk7XG4gICAgICBpZiAocGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMua2V5TGVuZ3RoICE9PSBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleUxlbmd0aCBvZiBcIiArIHBhcmFtcy5rZXlMZW5ndGggKyBcIiB3YXMgc3BlY2lmaWVkLCBidXQgdGhlIGtleSBhY3R1YWxseSBoYXMgbGVuZ3RoIFwiICsgY2lwaGVyUGFyYW1zLmtleUxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVDaXBoZXJQYXJhbXMoY2lwaGVyUGFyYW1zKTtcbiAgICAgIHJldHVybiBjaXBoZXJQYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgcmFuZG9tIGVuY3J5cHRpb24ga2V5IGZyb20gdGhlIHN1cHBsaWVkIGtleWxlbmd0aCAob3IgdGhlXG4gICAgICogZGVmYXVsdCBrZXlMZW5ndGggaWYgbm9uZSBzdXBwbGllZCkgYXMgYW4gQXJyYXlCdWZmZXJcbiAgICAgKiBAcGFyYW0ga2V5TGVuZ3RoIChvcHRpb25hbCkgdGhlIHJlcXVpcmVkIGtleUxlbmd0aCBpbiBiaXRzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlUmFuZG9tS2V5KGtleUxlbmd0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5nZXRSYW5kb21BcnJheUJ1ZmZlcigoa2V5TGVuZ3RoIHx8IERFRkFVTFRfS0VZTEVOR1RIKSAvIDgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmFuZG9tIGtleTogXCIgKyBlcnIubWVzc2FnZSwgNDAwLCA1ZTQsIGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsOyBnZXQgYSBDaGFubmVsQ2lwaGVyIGluc3RhbmNlIGJhc2VkIG9uIHRoZSBnaXZlbiBjaXBoZXJQYXJhbXNcbiAgICAgKiBAcGFyYW0gcGFyYW1zIGVpdGhlciBhIENpcGhlclBhcmFtcyBpbnN0YW5jZSBvciBzb21lIHN1YnNldCBvZiBpdHNcbiAgICAgKiBmaWVsZHMgdGhhdCBpbmNsdWRlcyBhIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaXBoZXIocGFyYW1zLCBsb2dnZXIpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICB2YXIgY2lwaGVyUGFyYW1zID0gaXNDaXBoZXJQYXJhbXMocGFyYW1zKSA/IHBhcmFtcyA6IHRoaXMuZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2lwaGVyUGFyYW1zLFxuICAgICAgICBjaXBoZXI6IG5ldyBDQkNDaXBoZXIoY2lwaGVyUGFyYW1zLCAoX2EyID0gcGFyYW1zLml2KSAhPSBudWxsID8gX2EyIDogbnVsbCwgbG9nZ2VyKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgQ3J5cHRvMi5DaXBoZXJQYXJhbXMgPSBDaXBoZXJQYXJhbXM7XG4gIENyeXB0bzI7XG4gIGNsYXNzIENCQ0NpcGhlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCBpdiwgbG9nZ2VyKSB7XG4gICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgIGlmICghY3J5cHRvLnN1YnRsZSkge1xuICAgICAgICBpZiAoaXNTZWN1cmVDb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJDcnlwdG8gb3BlcmF0aW9ucyBhcmUgbm90IHBvc3NpYmxlIHNpbmNlIHRoZSBicm93c2VyXFx1MjAxOXMgU3VidGxlQ3J5cHRvIGNsYXNzIGlzIHVuYXZhaWxhYmxlIChyZWFzb24gdW5rbm93bikuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQ3J5cHRvIG9wZXJhdGlvbnMgYXJlIGlzIG5vdCBwb3NzaWJsZSBzaW5jZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBhIG5vbi1zZWN1cmUgY29udGV4dCBhbmQgaGVuY2UgdGhlIGJyb3dzZXJcXHUyMDE5cyBTdWJ0bGVDcnlwdG8gY2xhc3MgaXMgbm90IGF2YWlsYWJsZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSArIFwiLVwiICsgU3RyaW5nKHBhcmFtcy5rZXlMZW5ndGgpICsgXCItXCIgKyBwYXJhbXMubW9kZTtcbiAgICAgIHRoaXMud2ViQ3J5cHRvQWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSArIFwiLVwiICsgcGFyYW1zLm1vZGU7XG4gICAgICB0aGlzLmtleSA9IGJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIocGFyYW1zLmtleSk7XG4gICAgICB0aGlzLml2ID0gaXYgPyBidWZmZXJVdGlscy50b0FycmF5QnVmZmVyKGl2KSA6IG51bGw7XG4gICAgfVxuICAgIGNvbmNhdChidWZmZXIxLCBidWZmZXIyKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcbiAgICAgIGNvbnN0IG91dHB1dFZpZXcgPSBuZXcgRGF0YVZpZXcob3V0cHV0KTtcbiAgICAgIGNvbnN0IGJ1ZmZlcjFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIoYnVmZmVyMSkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIxVmlldy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0Vmlldy5zZXRJbnQ4KGksIGJ1ZmZlcjFWaWV3LmdldEludDgoaSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVyMlZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcihidWZmZXIyKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcjJWaWV3LmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRwdXRWaWV3LnNldEludDgoYnVmZmVyMVZpZXcuYnl0ZUxlbmd0aCArIGksIGJ1ZmZlcjJWaWV3LmdldEludDgoaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNCQ0NpcGhlci5lbmNyeXB0KClcIiwgXCJcIik7XG4gICAgICBjb25zdCBpdiA9IGF3YWl0IHRoaXMuZ2V0SXYoKTtcbiAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIHRoaXMua2V5LCB0aGlzLndlYkNyeXB0b0FsZ29yaXRobSwgZmFsc2UsIFtcImVuY3J5cHRcIl0pO1xuICAgICAgY29uc3QgY2lwaGVydGV4dCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZW5jcnlwdCh7IG5hbWU6IHRoaXMud2ViQ3J5cHRvQWxnb3JpdGhtLCBpdiB9LCBjcnlwdG9LZXksIHBsYWludGV4dCk7XG4gICAgICByZXR1cm4gdGhpcy5jb25jYXQoaXYsIGNpcGhlcnRleHQpO1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNCQ0NpcGhlci5kZWNyeXB0KClcIiwgXCJcIik7XG4gICAgICBjb25zdCBjaXBoZXJ0ZXh0QXJyYXlCdWZmZXIgPSBidWZmZXJVdGlscy50b0FycmF5QnVmZmVyKGNpcGhlcnRleHQpO1xuICAgICAgY29uc3QgaXYgPSBjaXBoZXJ0ZXh0QXJyYXlCdWZmZXIuc2xpY2UoMCwgREVGQVVMVF9CTE9DS0xFTkdUSCk7XG4gICAgICBjb25zdCBjaXBoZXJ0ZXh0Qm9keSA9IGNpcGhlcnRleHRBcnJheUJ1ZmZlci5zbGljZShERUZBVUxUX0JMT0NLTEVOR1RIKTtcbiAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIHRoaXMua2V5LCB0aGlzLndlYkNyeXB0b0FsZ29yaXRobSwgZmFsc2UsIFtcImRlY3J5cHRcIl0pO1xuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGVjcnlwdCh7IG5hbWU6IHRoaXMud2ViQ3J5cHRvQWxnb3JpdGhtLCBpdiB9LCBjcnlwdG9LZXksIGNpcGhlcnRleHRCb2R5KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SXYoKSB7XG4gICAgICBpZiAodGhpcy5pdikge1xuICAgICAgICB2YXIgaXYgPSB0aGlzLml2O1xuICAgICAgICB0aGlzLml2ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGl2O1xuICAgICAgfVxuICAgICAgY29uc3QgcmFuZG9tQmxvY2sgPSBhd2FpdCBjb25maWcuZ2V0UmFuZG9tQXJyYXlCdWZmZXIoREVGQVVMVF9CTE9DS0xFTkdUSCk7XG4gICAgICByZXR1cm4gYnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcihyYW5kb21CbG9jayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBDcnlwdG8yO1xufTtcblxuLy8gc3JjL2NvbW1vbi9jb25zdGFudHMvWEhSU3RhdGVzLnRzXG52YXIgWEhSU3RhdGVzID0gLyogQF9fUFVSRV9fICovICgoWEhSU3RhdGVzMikgPT4ge1xuICBYSFJTdGF0ZXMyW1hIUlN0YXRlczJbXCJSRVFfU0VORFwiXSA9IDBdID0gXCJSRVFfU0VORFwiO1xuICBYSFJTdGF0ZXMyW1hIUlN0YXRlczJbXCJSRVFfUkVDVlwiXSA9IDFdID0gXCJSRVFfUkVDVlwiO1xuICBYSFJTdGF0ZXMyW1hIUlN0YXRlczJbXCJSRVFfUkVDVl9QT0xMXCJdID0gMl0gPSBcIlJFUV9SRUNWX1BPTExcIjtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1JFQ1ZfU1RSRUFNXCJdID0gM10gPSBcIlJFUV9SRUNWX1NUUkVBTVwiO1xuICByZXR1cm4gWEhSU3RhdGVzMjtcbn0pKFhIUlN0YXRlcyB8fCB7fSk7XG52YXIgWEhSU3RhdGVzX2RlZmF1bHQgPSBYSFJTdGF0ZXM7XG5cbi8vIHNyYy9wbGF0Zm9ybS93ZWIvbGliL2h0dHAvaHR0cC50c1xuZnVuY3Rpb24gY3JlYXRlTWlzc2luZ0ltcGxlbWVudGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3JJbmZvKFxuICAgIFwiTm8gSFRUUCByZXF1ZXN0IHBsdWdpbiBwcm92aWRlZC4gUHJvdmlkZSBhdCBsZWFzdCBvbmUgb2YgdGhlIEZldGNoUmVxdWVzdCBvciBYSFJSZXF1ZXN0IHBsdWdpbnMuXCIsXG4gICAgNDAwLFxuICAgIDRlNFxuICApO1xufVxudmFyIF9hO1xudmFyIEh0dHAyID0gKF9hID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNoZWNrc0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdXBwb3J0c0F1dGhIZWFkZXJzID0gZmFsc2U7XG4gICAgdGhpcy5zdXBwb3J0c0xpbmtIZWFkZXJzID0gZmFsc2U7XG4gICAgdmFyIF9hMjtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudCAhPSBudWxsID8gY2xpZW50IDogbnVsbDtcbiAgICBjb25zdCBjb25uZWN0aXZpdHlDaGVja1VybCA9IChjbGllbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNsaWVudC5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsKSB8fCBkZWZhdWx0c19kZWZhdWx0LmNvbm5lY3Rpdml0eUNoZWNrVXJsO1xuICAgIGNvbnN0IGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gKF9hMiA9IGNsaWVudCA9PSBudWxsID8gdm9pZCAwIDogY2xpZW50Lm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMpICE9IG51bGwgPyBfYTIgOiBudWxsO1xuICAgIGNvbnN0IGNvbm5lY3Rpdml0eVVybElzRGVmYXVsdCA9ICEoY2xpZW50ID09IG51bGwgPyB2b2lkIDAgOiBjbGllbnQub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybCk7XG4gICAgY29uc3QgcmVxdWVzdEltcGxlbWVudGF0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBIdHRwMi5idW5kbGVkUmVxdWVzdEltcGxlbWVudGF0aW9ucyksIGNsaWVudCA9PSBudWxsID8gdm9pZCAwIDogY2xpZW50Ll9hZGRpdGlvbmFsSFRUUFJlcXVlc3RJbXBsZW1lbnRhdGlvbnMpO1xuICAgIGNvbnN0IHhoclJlcXVlc3RJbXBsZW1lbnRhdGlvbiA9IHJlcXVlc3RJbXBsZW1lbnRhdGlvbnMuWEhSUmVxdWVzdDtcbiAgICBjb25zdCBmZXRjaFJlcXVlc3RJbXBsZW1lbnRhdGlvbiA9IHJlcXVlc3RJbXBsZW1lbnRhdGlvbnMuRmV0Y2hSZXF1ZXN0O1xuICAgIGNvbnN0IGhhc0ltcGxlbWVudGF0aW9uID0gISEoeGhyUmVxdWVzdEltcGxlbWVudGF0aW9uIHx8IGZldGNoUmVxdWVzdEltcGxlbWVudGF0aW9uKTtcbiAgICBpZiAoIWhhc0ltcGxlbWVudGF0aW9uKSB7XG4gICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nSW1wbGVtZW50YXRpb25FcnJvcigpO1xuICAgIH1cbiAgICBpZiAoUGxhdGZvcm0uQ29uZmlnLnhoclN1cHBvcnRlZCAmJiB4aHJSZXF1ZXN0SW1wbGVtZW50YXRpb24pIHtcbiAgICAgIHRoaXMuc3VwcG9ydHNBdXRoSGVhZGVycyA9IHRydWU7XG4gICAgICB0aGlzLlJlcXVlc3QgPSBhc3luYyBmdW5jdGlvbihtZXRob2QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgY29uc3QgcmVxID0geGhyUmVxdWVzdEltcGxlbWVudGF0aW9uLmNyZWF0ZVJlcXVlc3QoXG4gICAgICAgICAgICB1cmksXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5ELFxuICAgICAgICAgICAgKF9hMyA9IGNsaWVudCAmJiBjbGllbnQub3B0aW9ucy50aW1lb3V0cykgIT0gbnVsbCA/IF9hMyA6IG51bGwsXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIG1ldGhvZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVxLm9uY2UoXG4gICAgICAgICAgICBcImNvbXBsZXRlXCIsXG4gICAgICAgICAgICAoZXJyb3IsIGJvZHkyLCBoZWFkZXJzMiwgdW5wYWNrZWQsIHN0YXR1c0NvZGUpID0+IHJlc29sdmUoeyBlcnJvciwgYm9keTogYm9keTIsIGhlYWRlcnM6IGhlYWRlcnMyLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVxLmV4ZWMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKGNsaWVudCA9PSBudWxsID8gdm9pZCAwIDogY2xpZW50Lm9wdGlvbnMuZGlzYWJsZUNvbm5lY3Rpdml0eUNoZWNrKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgICAgXCIoWEhSUmVxdWVzdClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KClcIixcbiAgICAgICAgICAgIFwiU2VuZGluZzsgXCIgKyBjb25uZWN0aXZpdHlDaGVja1VybFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdFJlc3VsdCA9IGF3YWl0IHRoaXMuZG9VcmkoXG4gICAgICAgICAgICBIdHRwTWV0aG9kc19kZWZhdWx0LkdldCxcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eUNoZWNrVXJsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlDaGVja1BhcmFtc1xuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghY29ubmVjdGl2aXR5VXJsSXNEZWZhdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSAhcmVxdWVzdFJlc3VsdC5lcnJvciAmJiBpc1N1Y2Nlc3NDb2RlKHJlcXVlc3RSZXN1bHQuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICFyZXF1ZXN0UmVzdWx0LmVycm9yICYmICgoX2EzID0gcmVxdWVzdFJlc3VsdC5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnJlcGxhY2UoL1xcbi8sIFwiXCIpKSA9PSBcInllc1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCIoWEhSUmVxdWVzdClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KClcIiwgXCJSZXN1bHQ6IFwiICsgcmVzdWx0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUGxhdGZvcm0uQ29uZmlnLmZldGNoU3VwcG9ydGVkICYmIGZldGNoUmVxdWVzdEltcGxlbWVudGF0aW9uKSB7XG4gICAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuICAgICAgdGhpcy5SZXF1ZXN0ID0gYXN5bmMgKG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHkpID0+IHtcbiAgICAgICAgcmV0dXJuIGZldGNoUmVxdWVzdEltcGxlbWVudGF0aW9uKG1ldGhvZCwgY2xpZW50ICE9IG51bGwgPyBjbGllbnQgOiBudWxsLCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSk7XG4gICAgICB9O1xuICAgICAgaWYgKGNsaWVudCA9PSBudWxsID8gdm9pZCAwIDogY2xpZW50Lm9wdGlvbnMuZGlzYWJsZUNvbm5lY3Rpdml0eUNoZWNrKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgICAgXCIoRmV0Y2gpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpXCIsXG4gICAgICAgICAgICBcIlNlbmRpbmc7IFwiICsgY29ubmVjdGl2aXR5Q2hlY2tVcmxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3RSZXN1bHQgPSBhd2FpdCB0aGlzLmRvVXJpKEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBjb25uZWN0aXZpdHlDaGVja1VybCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gIXJlcXVlc3RSZXN1bHQuZXJyb3IgJiYgKChfYTMgPSByZXF1ZXN0UmVzdWx0LmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYTMucmVwbGFjZSgvXFxuLywgXCJcIikpID09IFwieWVzXCI7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiKEZldGNoKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKVwiLCBcIlJlc3VsdDogXCIgKyByZXN1bHQpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuUmVxdWVzdCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBoYXNJbXBsZW1lbnRhdGlvbiA/IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwibm8gc3VwcG9ydGVkIEhUVFAgdHJhbnNwb3J0cyBhdmFpbGFibGVcIiwgbnVsbCwgNDAwKSA6IGNyZWF0ZU1pc3NpbmdJbXBsZW1lbnRhdGlvbkVycm9yKCk7XG4gICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EyID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9nZ2VyKSAhPSBudWxsID8gX2IgOiBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyO1xuICB9XG4gIGFzeW5jIGRvVXJpKG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuUmVxdWVzdCkge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiUmVxdWVzdCBpbnZva2VkIGJlZm9yZSBhc3NpZ25lZCB0b1wiLCBudWxsLCA1MDApIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLlJlcXVlc3QobWV0aG9kLCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSk7XG4gIH1cbiAgc2hvdWxkRmFsbGJhY2soZXJyb3JJbmZvKSB7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IGVycm9ySW5mby5zdGF0dXNDb2RlO1xuICAgIHJldHVybiBzdGF0dXNDb2RlID09PSA0MDggJiYgIWVycm9ySW5mby5jb2RlIHx8IHN0YXR1c0NvZGUgPT09IDQwMCAmJiAhZXJyb3JJbmZvLmNvZGUgfHwgc3RhdHVzQ29kZSA+PSA1MDAgJiYgc3RhdHVzQ29kZSA8PSA1MDQ7XG4gIH1cbn0sIF9hLm1ldGhvZHMgPSBbSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsIEh0dHBNZXRob2RzX2RlZmF1bHQuRGVsZXRlLCBIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIEh0dHBNZXRob2RzX2RlZmF1bHQuUHV0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlBhdGNoXSwgX2EubWV0aG9kc1dpdGhvdXRCb2R5ID0gW0h0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBIdHRwTWV0aG9kc19kZWZhdWx0LkRlbGV0ZV0sIF9hLm1ldGhvZHNXaXRoQm9keSA9IFtIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIEh0dHBNZXRob2RzX2RlZmF1bHQuUHV0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlBhdGNoXSwgX2EpO1xudmFyIGh0dHBfZGVmYXVsdCA9IEh0dHAyO1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi91dGlsL3dlYnN0b3JhZ2UudHNcbnZhciB0ZXN0ID0gXCJhYmx5anMtc3RvcmFnZS10ZXN0XCI7XG52YXIgZ2xvYmFsT2JqZWN0MyA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogc2VsZjtcbnZhciBXZWJzdG9yYWdlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqZWN0My5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuICAgICAgZ2xvYmFsT2JqZWN0My5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3QpO1xuICAgICAgdGhpcy5zZXNzaW9uU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbE9iamVjdDMubG9jYWxTdG9yYWdlLnNldEl0ZW0odGVzdCwgdGVzdCk7XG4gICAgICBnbG9iYWxPYmplY3QzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3QpO1xuICAgICAgdGhpcy5sb2NhbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2NhbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXQobmFtZSwgZmFsc2UpO1xuICB9XG4gIGdldFNlc3Npb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXQobmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmVtb3ZlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKG5hbWUsIGZhbHNlKTtcbiAgfVxuICByZW1vdmVTZXNzaW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKG5hbWUsIHRydWUpO1xuICB9XG4gIHNldChuYW1lLCB2YWx1ZSwgdHRsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldChuYW1lLCB2YWx1ZSwgdHRsLCBmYWxzZSk7XG4gIH1cbiAgc2V0U2Vzc2lvbihuYW1lLCB2YWx1ZSwgdHRsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldChuYW1lLCB2YWx1ZSwgdHRsLCB0cnVlKTtcbiAgfVxuICBfc2V0KG5hbWUsIHZhbHVlLCB0dGwsIHNlc3Npb24pIHtcbiAgICBjb25zdCB3cmFwcGVkVmFsdWUgPSB7IHZhbHVlIH07XG4gICAgaWYgKHR0bCkge1xuICAgICAgd3JhcHBlZFZhbHVlLmV4cGlyZXMgPSBEYXRlLm5vdygpICsgdHRsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkod3JhcHBlZFZhbHVlKSk7XG4gIH1cbiAgX2dldChuYW1lLCBzZXNzaW9uKSB7XG4gICAgaWYgKHNlc3Npb24gJiYgIXRoaXMuc2Vzc2lvblN1cHBvcnRlZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gU3RvcmFnZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIGlmICghc2Vzc2lvbiAmJiAhdGhpcy5sb2NhbFN1cHBvcnRlZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvY2FsIFN0b3JhZ2Ugbm90IHN1cHBvcnRlZFwiKTtcbiAgICBjb25zdCByYXdJdGVtID0gdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLmdldEl0ZW0obmFtZSk7XG4gICAgaWYgKCFyYXdJdGVtKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgd3JhcHBlZFZhbHVlID0gSlNPTi5wYXJzZShyYXdJdGVtKTtcbiAgICBpZiAod3JhcHBlZFZhbHVlLmV4cGlyZXMgJiYgd3JhcHBlZFZhbHVlLmV4cGlyZXMgPCBEYXRlLm5vdygpKSB7XG4gICAgICB0aGlzLnN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikucmVtb3ZlSXRlbShuYW1lKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlZFZhbHVlLnZhbHVlO1xuICB9XG4gIF9yZW1vdmUobmFtZSwgc2Vzc2lvbikge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikucmVtb3ZlSXRlbShuYW1lKTtcbiAgfVxuICBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pIHtcbiAgICByZXR1cm4gc2Vzc2lvbiA/IGdsb2JhbE9iamVjdDMuc2Vzc2lvblN0b3JhZ2UgOiBnbG9iYWxPYmplY3QzLmxvY2FsU3RvcmFnZTtcbiAgfVxufTtcbnZhciB3ZWJzdG9yYWdlX2RlZmF1bHQgPSBuZXcgV2Vic3RvcmFnZSgpO1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2NvbmZpZy50c1xudmFyIGdsb2JhbE9iamVjdDQgPSBnZXRHbG9iYWxPYmplY3QoKTtcbnZhciBpc1ZlcmNlbEVkZ2VSdW50aW1lID0gdHlwZW9mIEVkZ2VSdW50aW1lID09PSBcInN0cmluZ1wiO1xuaWYgKHR5cGVvZiBXaW5kb3cgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSBcInVuZGVmaW5lZFwiICYmICFpc1ZlcmNlbEVkZ2VSdW50aW1lKSB7XG4gIGNvbnNvbGUubG9nKFxuICAgIFwiV2FybmluZzogdGhpcyBkaXN0cmlidXRpb24gb2YgQWJseSBpcyBpbnRlbmRlZCBmb3IgYnJvd3NlcnMuIE9uIG5vZGVqcywgcGxlYXNlIHVzZSB0aGUgJ2FibHknIHBhY2thZ2Ugb24gbnBtXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIGFsbG93Q29tZXQoKSB7XG4gIGNvbnN0IGxvYyA9IGdsb2JhbE9iamVjdDQubG9jYXRpb247XG4gIHJldHVybiAhZ2xvYmFsT2JqZWN0NC5XZWJTb2NrZXQgfHwgIWxvYyB8fCAhbG9jLm9yaWdpbiB8fCBsb2Mub3JpZ2luLmluZGV4T2YoXCJodHRwXCIpID4gLTE7XG59XG5mdW5jdGlvbiBpc1dlYldvcmtlckNvbnRleHQoKSB7XG4gIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG52YXIgdXNlckFnZW50ID0gZ2xvYmFsT2JqZWN0NC5uYXZpZ2F0b3IgJiYgZ2xvYmFsT2JqZWN0NC5uYXZpZ2F0b3IudXNlckFnZW50LnRvU3RyaW5nKCk7XG52YXIgY3VycmVudFVybCA9IGdsb2JhbE9iamVjdDQubG9jYXRpb24gJiYgZ2xvYmFsT2JqZWN0NC5sb2NhdGlvbi5ocmVmO1xudmFyIENvbmZpZyA9IHtcbiAgYWdlbnQ6IFwiYnJvd3NlclwiLFxuICBsb2dUaW1lc3RhbXBzOiB0cnVlLFxuICB1c2VyQWdlbnQsXG4gIGN1cnJlbnRVcmwsXG4gIGJpbmFyeVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgV2ViU29ja2V0OiBnbG9iYWxPYmplY3Q0LldlYlNvY2tldCxcbiAgZmV0Y2hTdXBwb3J0ZWQ6ICEhZ2xvYmFsT2JqZWN0NC5mZXRjaCxcbiAgeGhyU3VwcG9ydGVkOiBnbG9iYWxPYmplY3Q0LlhNTEh0dHBSZXF1ZXN0ICYmIFwid2l0aENyZWRlbnRpYWxzXCIgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gIGFsbG93Q29tZXQ6IGFsbG93Q29tZXQoKSxcbiAgdXNlUHJvdG9jb2xIZWFydGJlYXRzOiB0cnVlLFxuICBzdXBwb3J0c0JpbmFyeTogISFnbG9iYWxPYmplY3Q0LlRleHREZWNvZGVyLFxuICAvKiBQZXIgUGFkZHkgKGh0dHBzOi8vYWJseS1yZWFsLXRpbWUuc2xhY2suY29tL2FyY2hpdmVzL0NVUkw0VTJGUC9wMTcwNTY3NDUzNzc2MzQ3OSkgd2ViIGludGVudGlvbmFsbHkgcHJlZmVycyBKU09OIHRvIE1lc3NhZ2VQYWNrOlxuICAgKlxuICAgKiA+IGJyb3dzZXJzJyBzdXBwb3J0IGZvciBiaW5hcnkgdHlwZXMgaW4gZ2VuZXJhbCB3YXMgaGlzdG9yaWNhbGx5IHBvb3IsIGFuZCBKU09OIHRyYW5zcG9ydCBwZXJmb3JtYW5jZSBpcyBzaWduaWZpY2FudGx5IGJldHRlciBpbiBhIGJyb3dzZXIgdGhhbiBtc2dwYWNrLiBJbiBtb2Rlcm4gYnJvd3NlcnMgdGhlbiBiaW5hcnkgaXMgc3VwcG9ydGVkIGNvbnNpc3RlbnRseSwgYnV0IEknZCBzdGlsbCBleHBlY3QgdGhhdCBKU09OIGVuY29kZS9kZWNvZGUgcGVyZm9ybWFuY2UgaXMgZHJhbWF0aWNhbGx5IGJldHRlciB0aGFuIG1zZ3BhY2sgaW4gYSBicm93c2VyLlxuICAgKi9cbiAgcHJlZmVyQmluYXJ5OiBmYWxzZSxcbiAgQXJyYXlCdWZmZXI6IGdsb2JhbE9iamVjdDQuQXJyYXlCdWZmZXIsXG4gIGF0b2I6IGdsb2JhbE9iamVjdDQuYXRvYixcbiAgbmV4dFRpY2s6IHR5cGVvZiBnbG9iYWxPYmplY3Q0LnF1ZXVlTWljcm90YXNrID09PSBcImZ1bmN0aW9uXCIgPyAoZikgPT4gZ2xvYmFsT2JqZWN0NC5xdWV1ZU1pY3JvdGFzayhmKSA6IChmKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGYpLFxuICBhZGRFdmVudExpc3RlbmVyOiBnbG9iYWxPYmplY3Q0LmFkZEV2ZW50TGlzdGVuZXIsXG4gIGluc3BlY3Q6IEpTT04uc3RyaW5naWZ5LFxuICBzdHJpbmdCeXRlU2l6ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIGdsb2JhbE9iamVjdDQuVGV4dERlY29kZXIgJiYgbmV3IGdsb2JhbE9iamVjdDQuVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKS5sZW5ndGggfHwgc3RyLmxlbmd0aDtcbiAgfSxcbiAgVGV4dEVuY29kZXI6IGdsb2JhbE9iamVjdDQuVGV4dEVuY29kZXIsXG4gIFRleHREZWNvZGVyOiBnbG9iYWxPYmplY3Q0LlRleHREZWNvZGVyLFxuICBnZXRSYW5kb21BcnJheUJ1ZmZlcjogYXN5bmMgZnVuY3Rpb24oYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGdsb2JhbE9iamVjdDQuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlQXJyYXkpO1xuICAgIHJldHVybiBieXRlQXJyYXkuYnVmZmVyO1xuICB9LFxuICBpc1dlYndvcmtlcjogaXNXZWJXb3JrZXJDb250ZXh0KCksXG4gIHB1c2g6IHtcbiAgICBwbGF0Zm9ybTogXCJicm93c2VyXCIgLyogQnJvd3NlciAqLyxcbiAgICBmb3JtRmFjdG9yOiBcImRlc2t0b3BcIiAvKiBEZXNrdG9wICovLFxuICAgIHN0b3JhZ2U6IHdlYnN0b3JhZ2VfZGVmYXVsdFxuICB9XG59O1xudmFyIGNvbmZpZ19kZWZhdWx0ID0gQ29uZmlnO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29tZXR0cmFuc3BvcnQudHNcbmZ1bmN0aW9uIHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSB7XG4gIGNvbnN0IFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUyA9IFs4MDAxNSwgODAwMTcsIDgwMDMwXTtcbiAgaWYgKGVyci5jb2RlKSB7XG4gICAgaWYgKGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKGVycikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUy5pbmNsdWRlcyhlcnIuY29kZSkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZXJyLmNvZGUgPj0gNGU0ICYmIGVyci5jb2RlIDwgNWU0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikge1xuICBpZiAoc2hvdWxkQmVFcnJvckFjdGlvbihlcnIpKSB7XG4gICAgcmV0dXJuIFtmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkVSUk9SLCBlcnJvcjogZXJyIH0pXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2Zyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuRElTQ09OTkVDVEVELCBlcnJvcjogZXJyIH0pXTtcbiAgfVxufVxudmFyIENvbWV0VHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyB0cmFuc3BvcnRfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICBzdXBlcihcbiAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLFxuICAgICAgYXV0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIC8qIGJpbmFyeSBub3Qgc3VwcG9ydGVkIGZvciBjb21ldCBzbyBmb3JjZSBKU09OIHByb3RvY29sICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICAvKiBIaXN0b3JpY2FsIGNvbW1lbnQsIGJhY2sgZnJvbSB3aGVuIHdlIHN1cHBvcnRlZCBKU09OUDpcbiAgICAgKlxuICAgICAqID4gRm9yIGNvbWV0LCB3ZSBjb3VsZCBkbyB0aGUgYXV0aCB1cGRhdGUgYnkgYWJvcnRpbmcgdGhlIGN1cnJlbnQgcmVjdiBhbmRcbiAgICAgKiA+IHN0YXJ0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRoYXQnZCBiZSBzdWZmaWNpZW50IGZvciByZWFsdGltZS5cbiAgICAgKiA+IFByb2JsZW0gaXMgSlNPTlAgLSB5b3UgY2FuJ3QgY2FuY2VsIHRydWx5IGFib3J0IGEgcmVjdiBvbmNlIHN0YXJ0ZWQuIFNvXG4gICAgICogPiB3ZSBuZWVkIHRvIHNlbmQgYW4gQVVUSCBmb3IganNvbnAuIEluIHdoaWNoIGNhc2UgaXQncyBzaW1wbGVyIHRvIGtlZXAgYWxsXG4gICAgICogPiBjb21ldCB0cmFuc3BvcnRzIHRoZSBzYW1lIGFuZCBkbyBpdCBmb3IgYWxsIG9mIHRoZW0uIFNvIHdlIHNlbmQgdGhlIEFVVEhcbiAgICAgKiA+IGluc3RlYWQsIGFuZCBkb24ndCBuZWVkIHRvIGFib3J0IHRoZSByZWN2XG4gICAgICpcbiAgICAgKiBOb3cgdGhhdCB3ZeKAmXZlIGRyb3BwZWQgSlNPTlAgc3VwcG9ydCwgd2UgbWF5IGJlIGFibGUgdG8gcmV2aXNpdCB0aGUgYWJvdmU7XG4gICAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzEyMTQuXG4gICAgICovXG4gICAgdGhpcy5vbkF1dGhVcGRhdGVkID0gKHRva2VuRGV0YWlscykgPT4ge1xuICAgICAgdGhpcy5hdXRoUGFyYW1zID0geyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9O1xuICAgIH07XG4gICAgdGhpcy5zdHJlYW0gPSBcInN0cmVhbVwiIGluIHBhcmFtcyA/IHBhcmFtcy5zdHJlYW0gOiB0cnVlO1xuICAgIHRoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJzdGFydGluZ1wiKTtcbiAgICB0cmFuc3BvcnRfZGVmYXVsdC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcbiAgICBjb25zdCBob3N0ID0gcGFyYW1zLmhvc3QgfHwgb3B0aW9ucy5wcmltYXJ5RG9tYWluO1xuICAgIGNvbnN0IHBvcnQgPSBkZWZhdWx0c19kZWZhdWx0LmdldFBvcnQob3B0aW9ucyk7XG4gICAgY29uc3QgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/IFwiaHR0cHM6Ly9cIiA6IFwiaHR0cDovL1wiO1xuICAgIHRoaXMuYmFzZVVyaSA9IGNvbWV0U2NoZW1lICsgaG9zdCArIFwiOlwiICsgcG9ydCArIFwiL2NvbWV0L1wiO1xuICAgIGNvbnN0IGNvbm5lY3RVcmkgPSB0aGlzLmJhc2VVcmkgKyBcImNvbm5lY3RcIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJ1cmk6IFwiICsgY29ubmVjdFVyaSk7XG4gICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKCksIChlcnIsIGF1dGhQYXJhbXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRoUGFyYW1zID0gYXV0aFBhcmFtcztcbiAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSB0aGlzLnBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuICAgICAgaWYgKFwic3RyZWFtXCIgaW4gY29ubmVjdFBhcmFtcylcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBjb25uZWN0UGFyYW1zLnN0cmVhbTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIixcbiAgICAgICAgXCJjb25uZWN0UGFyYW1zOlwiICsgdG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKVxuICAgICAgKTtcbiAgICAgIGxldCBwcmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbm5lY3RSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgICAgY29ubmVjdFVyaSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY29ubmVjdFBhcmFtcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVlxuICAgICAgKTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmVjb25uZWN0ZWQpIHtcbiAgICAgICAgICBwcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZW1pdChcInByZWNvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycjIpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgZXJyMiA9IGVycjIgfHwgbmV3IEVycm9ySW5mbyhcIlJlcXVlc3QgY2FuY2VsbGVkXCIsIDgwMDAzLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgICBpZiAoIXByZWNvbm5lY3RlZCAmJiAhZXJyMikge1xuICAgICAgICAgIHByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicHJlY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICBpZiAoZXJyMi5jb2RlKSB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyMikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVjdigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29ubmVjdFJlcXVlc3QuZXhlYygpO1xuICAgIH0pO1xuICB9XG4gIHJlcXVlc3RDbG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKVwiKTtcbiAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QodHJ1ZSk7XG4gIH1cbiAgcmVxdWVzdERpc2Nvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKVwiKTtcbiAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoZmFsc2UpO1xuICB9XG4gIF9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoY2xvc2luZykge1xuICAgIGNvbnN0IGNsb3NlT3JEaXNjb25uZWN0VXJpID0gY2xvc2luZyA/IHRoaXMuY2xvc2VVcmkgOiB0aGlzLmRpc2Nvbm5lY3RVcmk7XG4gICAgaWYgKGNsb3NlT3JEaXNjb25uZWN0VXJpKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KGNsb3NlT3JEaXNjb25uZWN0VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5EKTtcbiAgICAgIHJlcXVlc3Qub24oXCJjb21wbGV0ZVwiLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdFwiICsgKGNsb3NpbmcgPyBcIkNsb3NlKClcIiA6IFwiRGlzY29ubmVjdCgpXCIpLFxuICAgICAgICAgICAgXCJyZXF1ZXN0IHJldHVybmVkIGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVxdWVzdC5leGVjKCk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiXCIpO1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiYWJvcnRpbmcgcmVjdiByZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcImRpc3Bvc2VkXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uQ29ubmVjdChtZXNzYWdlKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25TdHIgPSAoX2EyID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb25uZWN0aW9uS2V5O1xuICAgIHRyYW5zcG9ydF9kZWZhdWx0LnByb3RvdHlwZS5vbkNvbm5lY3QuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBjb25zdCBiYXNlQ29ubmVjdGlvblVyaSA9IHRoaXMuYmFzZVVyaSArIGNvbm5lY3Rpb25TdHI7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29tZXRUcmFuc3BvcnQub25Db25uZWN0KClcIiwgXCJiYXNlVXJpID0gXCIgKyBiYXNlQ29ubmVjdGlvblVyaSk7XG4gICAgdGhpcy5zZW5kVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9zZW5kXCI7XG4gICAgdGhpcy5yZWN2VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9yZWN2XCI7XG4gICAgdGhpcy5jbG9zZVVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgXCIvY2xvc2VcIjtcbiAgICB0aGlzLmRpc2Nvbm5lY3RVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArIFwiL2Rpc2Nvbm5lY3RcIjtcbiAgfVxuICBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcbiAgICAgIHRoaXMucGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuICAgIHBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICB9XG4gIHNlbmRBbnlQZW5kaW5nKCkge1xuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zO1xuICAgIGlmICghcGVuZGluZ0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICB9XG4gIHNlbmRJdGVtcyhpdGVtcykge1xuICAgIGNvbnN0IHNlbmRSZXF1ZXN0ID0gdGhpcy5zZW5kUmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHRoaXMuc2VuZFVyaSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmF1dGhQYXJhbXMsXG4gICAgICB0aGlzLmVuY29kZVJlcXVlc3QoaXRlbXMpLFxuICAgICAgWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1NFTkRcbiAgICApO1xuICAgIHNlbmRSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycilcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkNvbWV0VHJhbnNwb3J0LnNlbmRJdGVtcygpXCIsXG4gICAgICAgICAgXCJvbiBjb21wbGV0ZTogZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICApO1xuICAgICAgdGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgIHRoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdJdGVtcykge1xuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kQW55UGVuZGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VuZFJlcXVlc3QuZXhlYygpO1xuICB9XG4gIHJlY3YoKSB7XG4gICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJlY3ZSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHRoaXMucmVjdlVyaSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmF1dGhQYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9QT0xMXG4gICAgKTtcbiAgICByZWN2UmVxdWVzdC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgIH0pO1xuICAgIHJlY3ZSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycikgPT4ge1xuICAgICAgdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMucmVjdigpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmVjdlJlcXVlc3QuZXhlYygpO1xuICB9XG4gIG9uRGF0YShyZXNwb25zZURhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmRlY29kZVJlc3BvbnNlKHJlc3BvbnNlRGF0YSk7XG4gICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoXG4gICAgICAgICAgICBmcm9tRGVzZXJpYWxpemVkKFxuICAgICAgICAgICAgICBpdGVtc1tpXSxcbiAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fQW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX2xpdmVPYmplY3RzUGx1Z2luXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29tZXRUcmFuc3BvcnQub25EYXRhKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgZXZlbnQ6IFwiICsgZS5zdGFja1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlUmVxdWVzdChyZXF1ZXN0SXRlbXMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVxdWVzdEl0ZW1zKTtcbiAgfVxuICBkZWNvZGVSZXNwb25zZShyZXNwb25zZURhdGEpIHtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlRGF0YSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2VEYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2VEYXRhO1xuICB9XG59O1xudmFyIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQgPSBDb21ldFRyYW5zcG9ydDtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvaHR0cC9yZXF1ZXN0L3hocnJlcXVlc3QudHNcbmZ1bmN0aW9uIGlzQWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykge1xuICByZXR1cm4gYWxsVG9Mb3dlckNhc2Uoa2V5c0FycmF5KGhlYWRlcnMpKS5pbmNsdWRlcyhcIngtYWJseS1lcnJvcmNvZGVcIik7XG59XG5mdW5jdGlvbiBnZXRBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gIGlmIChpc0FibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlQm9keS5lcnJvciAmJiBFcnJvckluZm8uZnJvbVZhbHVlcyhyZXNwb25zZUJvZHkuZXJyb3IpO1xuICB9XG59XG52YXIgbm9vcDMgPSBmdW5jdGlvbigpIHtcbn07XG52YXIgaWRDb3VudGVyID0gMDtcbnZhciBwZW5kaW5nUmVxdWVzdHMgPSB7fTtcbmZ1bmN0aW9uIGdldEhlYWRlcih4aHIsIGhlYWRlcikge1xuICByZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyICYmIHhoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xufVxuZnVuY3Rpb24gaXNFbmNvZGluZ0NodW5rZWQoeGhyKSB7XG4gIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgKHhoci5nZXRSZXNwb25zZUhlYWRlcihcInRyYW5zZmVyLWVuY29kaW5nXCIpIHx8ICF4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LWxlbmd0aFwiKSk7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKSB7XG4gIGNvbnN0IGhlYWRlclBhaXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdChcIlxcclxcblwiKTtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlclBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGFydHMgPSBoZWFkZXJQYWlyc1tpXS5zcGxpdChcIjpcIikubWFwKCh4KSA9PiB4LnRyaW0oKSk7XG4gICAgaGVhZGVyc1twYXJ0c1swXS50b0xvd2VyQ2FzZSgpXSA9IHBhcnRzWzFdO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxudmFyIFhIUlJlcXVlc3QgPSBjbGFzcyBfWEhSUmVxdWVzdCBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbG9nZ2VyLCBtZXRob2QpIHtcbiAgICBzdXBlcihsb2dnZXIpO1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBwYXJhbXMucm5kID0gY2hlYXBSYW5kU3RyKCk7XG4gICAgdGhpcy51cmkgPSB1cmkgKyB0b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBpc05pbChib2R5KSA/IFwiR0VUXCIgOiBcIlBPU1RcIjtcbiAgICB0aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG4gICAgdGhpcy50aW1lb3V0cyA9IHRpbWVvdXRzO1xuICAgIHRoaXMudGltZWRPdXQgPSBmYWxzZTtcbiAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMuaWQgPSBTdHJpbmcoKytpZENvdW50ZXIpO1xuICAgIHBlbmRpbmdSZXF1ZXN0c1t0aGlzLmlkXSA9IHRoaXM7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbG9nZ2VyLCBtZXRob2QpIHtcbiAgICBjb25zdCBfdGltZW91dHMgPSB0aW1lb3V0cyB8fCBkZWZhdWx0c19kZWZhdWx0LlRJTUVPVVRTO1xuICAgIHJldHVybiBuZXcgX1hIUlJlcXVlc3QoXG4gICAgICB1cmksXG4gICAgICBoZWFkZXJzLFxuICAgICAgY29weShwYXJhbXMpLFxuICAgICAgYm9keSxcbiAgICAgIHJlcXVlc3RNb2RlLFxuICAgICAgX3RpbWVvdXRzLFxuICAgICAgbG9nZ2VyLFxuICAgICAgbWV0aG9kXG4gICAgKTtcbiAgfVxuICBjb21wbGV0ZShlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgaWYgKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSkge1xuICAgICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUgPSB0cnVlO1xuICAgICAgaWYgKCFlcnIgJiYgYm9keSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGJvZHkpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gIH1cbiAgZXhlYygpIHtcbiAgICBsZXQgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5yZXF1ZXN0TW9kZSA9PSBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfU0VORCA/IHRoaXMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogdGhpcy50aW1lb3V0cy5yZWN2VGltZW91dCwgdGltZXIgPSB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgIHhoci5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpLCBtZXRob2QgPSB0aGlzLm1ldGhvZCwgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSwgYWNjZXB0ID0gaGVhZGVyc1tcImFjY2VwdFwiXTtcbiAgICBsZXQgYm9keSA9IHRoaXMuYm9keTtcbiAgICBsZXQgcmVzcG9uc2VUeXBlID0gXCJ0ZXh0XCI7XG4gICAgaWYgKCFhY2NlcHQpIHtcbiAgICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICB9IGVsc2UgaWYgKGFjY2VwdC5pbmRleE9mKFwiYXBwbGljYXRpb24veC1tc2dwYWNrXCIpID09PSAwKSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgPiAtMSAmJiB0eXBlb2YgYm9keSAhPSBcInN0cmluZ1wiKVxuICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgfVxuICAgIHhoci5vcGVuKG1ldGhvZCwgdGhpcy51cmksIHRydWUpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgaWYgKFwiYXV0aG9yaXphdGlvblwiIGluIGhlYWRlcnMpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGggaW4gaGVhZGVycylcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pO1xuICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChlcnJvckV2ZW50LCBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlMikgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlICsgXCIgKGV2ZW50IHR5cGU6IFwiICsgZXJyb3JFdmVudC50eXBlICsgXCIpXCI7XG4gICAgICBpZiAoKF9hMiA9IHRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IHRoaXMueGhyKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnN0YXR1c1RleHQpXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSBcIiwgY3VycmVudCBzdGF0dXNUZXh0IGlzIFwiICsgdGhpcy54aHIuc3RhdHVzVGV4dDtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIlJlcXVlc3Qub25cIiArIGVycm9yRXZlbnQudHlwZSArIFwiKClcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgIHRoaXMuY29tcGxldGUobmV3IFBhcnRpYWxFcnJvckluZm8oZXJyb3JNZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlMikpO1xuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSAoZXJyb3JFdmVudCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsIFwiWEhSIGVycm9yIG9jY3VycmVkXCIsIG51bGwsIDQwMCk7XG4gICAgfTtcbiAgICB4aHIub25hYm9ydCA9IChlcnJvckV2ZW50KSA9PiB7XG4gICAgICBpZiAodGhpcy50aW1lZE91dCkge1xuICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgXCJSZXF1ZXN0IGFib3J0ZWQgZHVlIHRvIHJlcXVlc3QgdGltZW91dCBleHBpcmluZ1wiLCBudWxsLCA0MDgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsIFwiUmVxdWVzdCBjYW5jZWxsZWRcIiwgbnVsbCwgNDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vbnRpbWVvdXQgPSAoZXJyb3JFdmVudCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsIFwiUmVxdWVzdCB0aW1lZCBvdXRcIiwgbnVsbCwgNDA4KTtcbiAgICB9O1xuICAgIGxldCBzdHJlYW1pbmc7XG4gICAgbGV0IHN0YXR1c0NvZGU7XG4gICAgbGV0IHN1Y2Nlc3NSZXNwb25zZTtcbiAgICBsZXQgc3RyZWFtUG9zID0gMDtcbiAgICBsZXQgdW5wYWNrZWQgPSBmYWxzZTtcbiAgICBjb25zdCBvblJlc3BvbnNlID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHN1Y2Nlc3NSZXNwb25zZSA9IHN0YXR1c0NvZGUgPCA0MDA7XG4gICAgICBpZiAoc3RhdHVzQ29kZSA9PSAyMDQpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBudWxsLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RyZWFtaW5nID0gdGhpcy5yZXF1ZXN0TW9kZSA9PSBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gJiYgc3VjY2Vzc1Jlc3BvbnNlICYmIGlzRW5jb2RpbmdDaHVua2VkKHhocik7XG4gICAgfTtcbiAgICBjb25zdCBvbkVuZCA9ICgpID0+IHtcbiAgICAgIGxldCBwYXJzZWRSZXNwb25zZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gZ2V0SGVhZGVyKHhociwgXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgIGNvbnN0IGpzb24gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID49IDAgOiB4aHIucmVzcG9uc2VUeXBlID09IFwidGV4dFwiO1xuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgIGNvbnN0IGpzb25SZXNwb25zZUJvZHkgPSB4aHIucmVzcG9uc2VUeXBlID09PSBcImFycmF5YnVmZmVyXCIgPyBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RGVjb2RlKHhoci5yZXNwb25zZSkgOiBTdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgaWYgKGpzb25SZXNwb25zZUJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IEpTT04ucGFyc2UoanNvblJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0ganNvblJlc3BvbnNlQm9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5wYWNrZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0geGhyLnJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5yZXNwb25zZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3RhdHVzQ29kZSA9IHBhcnNlZFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgc3VjY2Vzc1Jlc3BvbnNlID0gc3RhdHVzQ29kZSA8IDQwMDtcbiAgICAgICAgICBoZWFkZXJzID0gcGFyc2VkUmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IHBhcnNlZFJlc3BvbnNlLnJlc3BvbnNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRlcnMgPSBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiTWFsZm9ybWVkIHJlc3BvbnNlIGJvZHkgZnJvbSBzZXJ2ZXI6IFwiICsgZS5tZXNzYWdlLCBudWxsLCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHN1Y2Nlc3NSZXNwb25zZSB8fCBBcnJheS5pc0FycmF5KHBhcnNlZFJlc3BvbnNlKSkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKG51bGwsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBlcnIgPSBnZXRBYmx5RXJyb3IocGFyc2VkUmVzcG9uc2UsIGhlYWRlcnMpO1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXG4gICAgICAgICAgXCJFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogXCIgKyBzdGF0dXNDb2RlICsgXCIgYm9keSB3YXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QocGFyc2VkUmVzcG9uc2UpLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgc3RhdHVzQ29kZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21wbGV0ZShlcnIsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBvblByb2dyZXNzKCkge1xuICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIGNvbnN0IGJvZHlFbmQgPSByZXNwb25zZVRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBpZHgsIGNodW5rO1xuICAgICAgd2hpbGUgKHN0cmVhbVBvcyA8IGJvZHlFbmQgJiYgKGlkeCA9IHJlc3BvbnNlVGV4dC5pbmRleE9mKFwiXFxuXCIsIHN0cmVhbVBvcykpID4gLTEpIHtcbiAgICAgICAgY2h1bmsgPSByZXNwb25zZVRleHQuc2xpY2Uoc3RyZWFtUG9zLCBpZHgpO1xuICAgICAgICBzdHJlYW1Qb3MgPSBpZHggKyAxO1xuICAgICAgICBvbkNodW5rKGNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb25DaHVuayA9IChjaHVuaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2h1bmsgPSBKU09OLnBhcnNlKGNodW5rKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShuZXcgUGFydGlhbEVycm9ySW5mbyhcIk1hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiBcIiArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH07XG4gICAgY29uc3Qgb25TdHJlYW1FbmQgPSAoKSA9PiB7XG4gICAgICBvblByb2dyZXNzKCk7XG4gICAgICB0aGlzLnN0cmVhbUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICAgIGlmIChyZWFkeVN0YXRlIDwgMylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDApIHtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzO1xuICAgICAgICAgIG9uUmVzcG9uc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZHlTdGF0ZSA9PSAzICYmIHN0cmVhbWluZykge1xuICAgICAgICAgIG9uUHJvZ3Jlc3MoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtaW5nKVxuICAgICAgICAgICAgb25TdHJlYW1FbmQoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBvbkVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChib2R5KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHhociA9IHRoaXMueGhyO1xuICAgIGlmICh4aHIpIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9IG5vb3AzO1xuICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgICAgY29uc3QgdGltZXIgPSB0aGlzLnRpbWVyO1xuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSlcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgfVxuICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNbdGhpcy5pZF07XG4gIH1cbn07XG52YXIgeGhycmVxdWVzdF9kZWZhdWx0ID0gWEhSUmVxdWVzdDtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L3hocnBvbGxpbmd0cmFuc3BvcnQudHNcbnZhciBzaG9ydE5hbWUyID0gVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZztcbnZhciBYSFJQb2xsaW5nVHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyBjb21ldHRyYW5zcG9ydF9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgIHN1cGVyKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lMjtcbiAgICBwYXJhbXMuc3RyZWFtID0gZmFsc2U7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWUyO1xuICB9XG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gISEoUGxhdGZvcm0uQ29uZmlnLnhoclN1cHBvcnRlZCAmJiBQbGF0Zm9ybS5Db25maWcuYWxsb3dDb21ldCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiWEhSUG9sbGluZ1RyYW5zcG9ydDsgdXJpPVwiICsgdGhpcy5iYXNlVXJpICsgXCI7IGlzQ29ubmVjdGVkPVwiICsgdGhpcy5pc0Nvbm5lY3RlZDtcbiAgfVxuICBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSkge1xuICAgIHJldHVybiB4aHJyZXF1ZXN0X2RlZmF1bHQuY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMudGltZW91dHMsIHRoaXMubG9nZ2VyKTtcbiAgfVxufTtcbnZhciB4aHJwb2xsaW5ndHJhbnNwb3J0X2RlZmF1bHQgPSBYSFJQb2xsaW5nVHJhbnNwb3J0O1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQvaW5kZXgudHNcbnZhciBvcmRlciA9IFtcInhocl9wb2xsaW5nXCJdO1xudmFyIGRlZmF1bHRUcmFuc3BvcnRzID0ge1xuICBvcmRlcixcbiAgYnVuZGxlZEltcGxlbWVudGF0aW9uczoge1xuICAgIHdlYl9zb2NrZXQ6IHdlYnNvY2tldHRyYW5zcG9ydF9kZWZhdWx0LFxuICAgIHhocl9wb2xsaW5nOiB4aHJwb2xsaW5ndHJhbnNwb3J0X2RlZmF1bHRcbiAgfVxufTtcbnZhciB0cmFuc3BvcnRfZGVmYXVsdDIgPSBkZWZhdWx0VHJhbnNwb3J0cztcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC9kZWZhdWx0cy50c1xudmFyIERlZmF1bHRzMiA9IHtcbiAgY29ubmVjdGl2aXR5Q2hlY2tVcmw6IFwiaHR0cHM6Ly9pbnRlcm5ldC11cC5hYmx5LXJlYWx0aW1lLmNvbS9pcy10aGUtaW50ZXJuZXQtdXAudHh0XCIsXG4gIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmw6IFwid3NzOi8vd3MtdXAuYWJseS1yZWFsdGltZS5jb21cIixcbiAgLyogT3JkZXIgbWF0dGVycyBoZXJlOiB0aGUgYmFzZSB0cmFuc3BvcnQgaXMgdGhlIGxlZnRtb3N0IG9uZSBpbiB0aGVcbiAgICogaW50ZXJzZWN0aW9uIG9mIGJhc2VUcmFuc3BvcnRPcmRlciBhbmQgdGhlIHRyYW5zcG9ydHMgY2xpZW50T3B0aW9uIHRoYXQnc1xuICAgKiBzdXBwb3J0ZWQuICovXG4gIGRlZmF1bHRUcmFuc3BvcnRzOiBbVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZywgVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0XVxufTtcbnZhciBkZWZhdWx0c19kZWZhdWx0MiA9IERlZmF1bHRzMjtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC9tc2dwYWNrLnRzXG5mdW5jdGlvbiBpbnNwZWN0KGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyID09PSB2b2lkIDApXG4gICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gIGxldCB2aWV3O1xuICBsZXQgdHlwZTtcbiAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdHlwZSA9IFwiQXJyYXlCdWZmZXJcIjtcbiAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICB0eXBlID0gXCJEYXRhVmlld1wiO1xuICAgIHZpZXcgPSBidWZmZXI7XG4gIH1cbiAgaWYgKCF2aWV3KVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShidWZmZXIpO1xuICBjb25zdCBieXRlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA+IDIwKSB7XG4gICAgICBieXRlcy5wdXNoKFwiLi4uXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSkudG9TdHJpbmcoMTYpO1xuICAgIGlmIChieXRlXy5sZW5ndGggPT09IDEpXG4gICAgICBieXRlXyA9IFwiMFwiICsgYnl0ZV87XG4gICAgYnl0ZXMucHVzaChieXRlXyk7XG4gIH1cbiAgcmV0dXJuIFwiPFwiICsgdHlwZSArIFwiIFwiICsgYnl0ZXMuam9pbihcIiBcIikgKyBcIj5cIjtcbn1cbmZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIHN0cmluZykge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVyLmVuY29kZShzdHJpbmcpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGksIGVuY29kZWRbaV0pO1xuICB9XG59XG5mdW5jdGlvbiB1dGY4UmVhZCh2aWV3LCBvZmZzZXQsIGxlbmd0aCkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBkZWNvZGVyLmRlY29kZSh2aWV3LmJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xufVxuZnVuY3Rpb24gdXRmOEJ5dGVDb3VudChzdHJpbmcpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyaW5nKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBlbmNvZGUyKHZhbHVlLCBzcGFyc2UpIHtcbiAgY29uc3Qgc2l6ZSA9IHNpemVvZih2YWx1ZSwgc3BhcnNlKTtcbiAgaWYgKHNpemUgPT09IDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gIF9lbmNvZGUodmFsdWUsIHZpZXcsIDAsIHNwYXJzZSk7XG4gIHJldHVybiBidWZmZXI7XG59XG52YXIgU0hfTF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KTtcbnZhciBTSF9SXzMyID0gMSAvIFNIX0xfMzI7XG5mdW5jdGlvbiBnZXRJbnQ2NCh2aWV3LCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHJldHVybiB2aWV3LmdldEludDMyKG9mZnNldCkgKiBTSF9MXzMyICsgdmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCk7XG59XG5mdW5jdGlvbiBnZXRVaW50NjQodmlldywgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICByZXR1cm4gdmlldy5nZXRVaW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcbn1cbmZ1bmN0aW9uIHNldEludDY0KHZpZXcsIG9mZnNldCwgdmFsKSB7XG4gIGlmICh2YWwgPCA5MjIzMzcyMDM2ODU0Nzc2ZTMpIHtcbiAgICB2aWV3LnNldEludDMyKG9mZnNldCwgTWF0aC5mbG9vcih2YWwgKiBTSF9SXzMyKSk7XG4gICAgdmlldy5zZXRJbnQzMihvZmZzZXQgKyA0LCB2YWwgJiAtMSk7XG4gIH0gZWxzZSB7XG4gICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAyMTQ3NDgzNjQ3KTtcbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyA0LCAyMTQ3NDgzNjQ3KTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0VWludDY0KHZpZXcsIG9mZnNldCwgdmFsKSB7XG4gIGlmICh2YWwgPCAxODQ0Njc0NDA3MzcwOTU1MmUzKSB7XG4gICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcbiAgICB2aWV3LnNldEludDMyKG9mZnNldCArIDQsIHZhbCAmIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDQyOTQ5NjcyOTUpO1xuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIDQyOTQ5NjcyOTUpO1xuICB9XG59XG52YXIgRGVjb2RlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iodmlldywgb2Zmc2V0KSB7XG4gICAgdGhpcy5tYXAgPSAobGVuZ3RoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlKCk7XG4gICAgICAgIHZhbHVlW2tleV0gPSB0aGlzLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICB0aGlzLmJpbiA9IChsZW5ndGgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheSh2YWx1ZSkuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMudmlldy5idWZmZXIsIHRoaXMub2Zmc2V0LCBsZW5ndGgpLCAwKTtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHRoaXMuYnVmID0gdGhpcy5iaW47XG4gICAgdGhpcy5zdHIgPSAobGVuZ3RoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHV0ZjhSZWFkKHRoaXMudmlldywgdGhpcy5vZmZzZXQsIGxlbmd0aCk7XG4gICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICB0aGlzLmFycmF5ID0gKGxlbmd0aCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSB0aGlzLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICB0aGlzLmV4dCA9IChsZW5ndGgpID0+IHtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0KSxcbiAgICAgICAgZGF0YTogdGhpcy5idWYobGVuZ3RoKVxuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMucGFyc2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0KTtcbiAgICAgIGxldCB2YWx1ZSwgbGVuZ3RoO1xuICAgICAgaWYgKCh0eXBlICYgMTI4KSA9PT0gMCkge1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZSAmIDI0MCkgPT09IDEyOCkge1xuICAgICAgICBsZW5ndGggPSB0eXBlICYgMTU7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjQwKSA9PT0gMTQ0KSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAxNTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZSAmIDIyNCkgPT09IDE2MCkge1xuICAgICAgICBsZW5ndGggPSB0eXBlICYgMzE7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjI0KSA9PT0gMjI0KSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAxOTI6XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAxOTM6XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICBjYXNlIDE5NDpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAxOTU6XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAxOTY6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTc6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmluKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMTk4OlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICBjYXNlIDE5OTpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMDE6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjAyOlxuICAgICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldEZsb2F0MzIodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMDM6XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwNTpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMDY6XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA3OlxuICAgICAgICAgIHZhbHVlID0gZ2V0VWludDY0KHRoaXMudmlldywgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA5O1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMDg6XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwOTpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQxNih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMDpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQzMih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMTpcbiAgICAgICAgICB2YWx1ZSA9IGdldEludDY0KHRoaXMudmlldywgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA5O1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMTI6XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxMzpcbiAgICAgICAgICBsZW5ndGggPSAyO1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjE0OlxuICAgICAgICAgIGxlbmd0aCA9IDQ7XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMTU6XG4gICAgICAgICAgbGVuZ3RoID0gODtcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxNjpcbiAgICAgICAgICBsZW5ndGggPSAxNjtcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxNzpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxODpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMTk6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjIwOlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjIxOlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjIyOlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIyMzpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSAweFwiICsgdHlwZS50b1N0cmluZygxNikpO1xuICAgIH07XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICB9XG59O1xuZnVuY3Rpb24gZGVjb2RlMihidWZmZXIpIHtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IERlY29kZXIodmlldyk7XG4gIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5wYXJzZSgpO1xuICBpZiAoZGVjb2Rlci5vZmZzZXQgIT09IGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcihidWZmZXIuYnl0ZUxlbmd0aCAtIGRlY29kZXIub2Zmc2V0ICsgXCIgdHJhaWxpbmcgYnl0ZXNcIik7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoZnVuY3Rpb24oZSkge1xuICAgIGNvbnN0IHZhbCA9IHZhbHVlW2VdLCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICByZXR1cm4gKCFzcGFyc2UgfHwgdmFsICE9PSB2b2lkIDAgJiYgdmFsICE9PSBudWxsKSAmJiAoXCJmdW5jdGlvblwiICE9PSB0eXBlIHx8ICEhdmFsLnRvSlNPTik7XG4gIH0pO1xufVxuZnVuY3Rpb24gX2VuY29kZSh2YWx1ZSwgdmlldywgb2Zmc2V0LCBzcGFyc2UpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHV0ZjhCeXRlQ291bnQodmFsdWUpO1xuICAgIGlmIChsZW5ndGggPCAzMikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGxlbmd0aCB8IDE2MCk7XG4gICAgICB1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDEgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMTcpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDIsIHZhbHVlKTtcbiAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMTgpO1xuICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAzLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMTkpO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyA1LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gNSArIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5idWZmZXI7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAxOTYpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDIpO1xuICAgICAgcmV0dXJuIDIgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDE5Nyk7XG4gICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDMpO1xuICAgICAgcmV0dXJuIDMgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMTk4KTtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgNSk7XG4gICAgICByZXR1cm4gNSArIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMDMpO1xuICAgICAgdmlldy5zZXRGbG9hdDY0KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgIHJldHVybiA5O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgaWYgKHZhbHVlIDwgMTI4KSB7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIDwgMjU2KSB7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMDQpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPCA2NTUzNikge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMjA1KTtcbiAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gMztcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIwNik7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPCAxODQ0Njc0NDA3MzcwOTU1MmUzKSB7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMDcpO1xuICAgICAgICBzZXRVaW50NjQodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gOTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnIDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gLTMyKSB7XG4gICAgICB2aWV3LnNldEludDgob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID49IC0xMjgpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMDgpO1xuICAgICAgdmlldy5zZXRJbnQ4KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gLTMyNzY4KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMjA5KTtcbiAgICAgIHZpZXcuc2V0SW50MTYob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSAtMjE0NzQ4MzY0OCkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxMCk7XG4gICAgICB2aWV3LnNldEludDMyKG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gLTkyMjMzNzIwMzY4NTQ3NzZlMykge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxMSk7XG4gICAgICBzZXRJbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gOTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArICgtdmFsdWUpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICB9XG4gIGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHNwYXJzZSlcbiAgICAgIHJldHVybiAwO1xuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMTIpO1xuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgMCk7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAyLCAwKTtcbiAgICByZXR1cm4gMztcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICBpZiAoc3BhcnNlKVxuICAgICAgcmV0dXJuIDA7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDE5Mik7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQsIHZhbHVlID8gMTk1IDogMTk0KTtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUudG9KU09OKVxuICAgIHJldHVybiBfZW5jb2RlKHZhbHVlLnRvSlNPTigpLCB2aWV3LCBvZmZzZXQsIHNwYXJzZSk7XG4gIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgbGV0IGxlbmd0aCwgc2l6ZSA9IDA7XG4gICAgbGV0IGtleXM7XG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgMTYpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCBsZW5ndGggfCAoaXNBcnJheSA/IDE0NCA6IDEyOCkpO1xuICAgICAgc2l6ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGlzQXJyYXkgPyAyMjAgOiAyMjIpO1xuICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICAgIHNpemUgPSAzO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGlzQXJyYXkgPyAyMjEgOiAyMjMpO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICAgIHNpemUgPSA1O1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzaXplICs9IF9lbmNvZGUodmFsdWVbaV0sIHZpZXcsIG9mZnNldCArIHNpemUsIHNwYXJzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXlzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIHNpemUgKz0gX2VuY29kZShrZXksIHZpZXcsIG9mZnNldCArIHNpemUpO1xuICAgICAgICBzaXplICs9IF9lbmNvZGUodmFsdWVba2V5XSwgdmlldywgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMDtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgdHlwZSk7XG59XG5mdW5jdGlvbiBzaXplb2YodmFsdWUsIHNwYXJzZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHV0ZjhCeXRlQ291bnQodmFsdWUpO1xuICAgIGlmIChsZW5ndGggPCAzMikge1xuICAgICAgcmV0dXJuIDEgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUuYnVmZmVyO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMjU2KSB7XG4gICAgICByZXR1cm4gMiArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcbiAgICAgIHJldHVybiA5O1xuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICBpZiAodmFsdWUgPCAxMjgpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHZhbHVlIDwgMjU2KVxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGlmICh2YWx1ZSA8IDY1NTM2KVxuICAgICAgICByZXR1cm4gMztcbiAgICAgIGlmICh2YWx1ZSA8IDQyOTQ5NjcyOTYpXG4gICAgICAgIHJldHVybiA1O1xuICAgICAgaWYgKHZhbHVlIDwgMTg0NDY3NDQwNzM3MDk1NTJlMylcbiAgICAgICAgcmV0dXJuIDk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZyAweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID49IC0zMilcbiAgICAgIHJldHVybiAxO1xuICAgIGlmICh2YWx1ZSA+PSAtMTI4KVxuICAgICAgcmV0dXJuIDI7XG4gICAgaWYgKHZhbHVlID49IC0zMjc2OClcbiAgICAgIHJldHVybiAzO1xuICAgIGlmICh2YWx1ZSA+PSAtMjE0NzQ4MzY0OClcbiAgICAgIHJldHVybiA1O1xuICAgIGlmICh2YWx1ZSA+PSAtOTIyMzM3MjAzNjg1NDc3NmUzKVxuICAgICAgcmV0dXJuIDk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICB9XG4gIGlmICh0eXBlID09PSBcImJvb2xlYW5cIilcbiAgICByZXR1cm4gMTtcbiAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiBzcGFyc2UgPyAwIDogMTtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHNwYXJzZSA/IDAgOiAzO1xuICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUudG9KU09OKVxuICAgIHJldHVybiBzaXplb2YodmFsdWUudG9KU09OKCksIHNwYXJzZSk7XG4gIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgbGV0IGxlbmd0aCwgc2l6ZSA9IDA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpemUgKz0gc2l6ZW9mKHZhbHVlW2ldLCBzcGFyc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgc2l6ZSArPSBzaXplb2Yoa2V5KSArIHNpemVvZih2YWx1ZVtrZXldLCBzcGFyc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgMTYpIHtcbiAgICAgIHJldHVybiAxICsgc2l6ZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICByZXR1cm4gMyArIHNpemU7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICByZXR1cm4gNSArIHNpemU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5IG9yIG9iamVjdCB0b28gbG9uZyAweFwiICsgbGVuZ3RoLnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMDtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgdHlwZSk7XG59XG52YXIgbXNncGFja19kZWZhdWx0ID0ge1xuICBlbmNvZGU6IGVuY29kZTIsXG4gIGRlY29kZTogZGVjb2RlMixcbiAgaW5zcGVjdCxcbiAgdXRmOFdyaXRlLFxuICB1dGY4UmVhZCxcbiAgdXRmOEJ5dGVDb3VudFxufTtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvaHR0cC9yZXF1ZXN0L2ZldGNocmVxdWVzdC50c1xuZnVuY3Rpb24gaXNBYmx5RXJyb3IyKHJlc3BvbnNlQm9keSwgaGVhZGVycykge1xuICByZXR1cm4gISFoZWFkZXJzLmdldChcIngtYWJseS1lcnJvcmNvZGVcIik7XG59XG5mdW5jdGlvbiBnZXRBYmx5RXJyb3IyKHJlc3BvbnNlQm9keSwgaGVhZGVycykge1xuICBpZiAoaXNBYmx5RXJyb3IyKHJlc3BvbnNlQm9keSwgaGVhZGVycykpIHtcbiAgICByZXR1cm4gcmVzcG9uc2VCb2R5LmVycm9yICYmIEVycm9ySW5mby5mcm9tVmFsdWVzKHJlc3BvbnNlQm9keS5lcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRIZWFkZXJzKGhlYWRlcnMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXF1ZXN0KG1ldGhvZCwgY2xpZW50LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSkge1xuICBjb25zdCBmZXRjaEhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzIHx8IHt9KTtcbiAgY29uc3QgX21ldGhvZCA9IG1ldGhvZCA/IG1ldGhvZC50b1VwcGVyQ2FzZSgpIDogaXNOaWwoYm9keSkgPyBcIkdFVFwiIDogXCJQT1NUXCI7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGxldCB0aW1lb3V0O1xuICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgcmVzb2x2ZSh7IGVycm9yOiBuZXcgUGFydGlhbEVycm9ySW5mbyhcIlJlcXVlc3QgdGltZWQgb3V0XCIsIG51bGwsIDQwOCkgfSk7XG4gICAgICB9LFxuICAgICAgY2xpZW50ID8gY2xpZW50Lm9wdGlvbnMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogZGVmYXVsdHNfZGVmYXVsdC5USU1FT1VUUy5odHRwUmVxdWVzdFRpbWVvdXRcbiAgICApO1xuICB9KTtcbiAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgbWV0aG9kOiBfbWV0aG9kLFxuICAgIGhlYWRlcnM6IGZldGNoSGVhZGVycyxcbiAgICBib2R5LFxuICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgfTtcbiAgaWYgKCFQbGF0Zm9ybS5Db25maWcuaXNXZWJ3b3JrZXIpIHtcbiAgICByZXF1ZXN0SW5pdC5jcmVkZW50aWFscyA9IGZldGNoSGVhZGVycy5oYXMoXCJhdXRob3JpemF0aW9uXCIpID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCI7XG4gIH1cbiAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zIHx8IHt9KTtcbiAgICAgIHVybFBhcmFtcy5zZXQoXCJybmRcIiwgY2hlYXBSYW5kU3RyKCkpO1xuICAgICAgY29uc3QgcHJlcGFyZWRVUkkgPSB1cmkgKyBcIj9cIiArIHVybFBhcmFtcztcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGdldEdsb2JhbE9iamVjdCgpLmZldGNoKHByZXBhcmVkVVJJLCByZXF1ZXN0SW5pdCk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBpZiAocmVzLnN0YXR1cyA9PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwsIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXMgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgbGV0IGJvZHkyO1xuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LW1zZ3BhY2tcIikgPiAtMSkge1xuICAgICAgICBib2R5MiA9IGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgICAgfSBlbHNlIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSA+IC0xKSB7XG4gICAgICAgIGJvZHkyID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkyID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVucGFja2VkID0gISFjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24veC1tc2dwYWNrXCIpID09PSAtMTtcbiAgICAgIGNvbnN0IGhlYWRlcnMyID0gY29udmVydEhlYWRlcnMocmVzLmhlYWRlcnMpO1xuICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBnZXRBYmx5RXJyb3IyKGJvZHkyLCByZXMuaGVhZGVycykgfHwgbmV3IFBhcnRpYWxFcnJvckluZm8oXG4gICAgICAgICAgXCJFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogXCIgKyByZXMuc3RhdHVzICsgXCIgYm9keSB3YXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYm9keTIpLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcmVzLnN0YXR1c1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4geyBlcnJvciwgYm9keTogYm9keTIsIGhlYWRlcnM6IGhlYWRlcnMyLCB1bnBhY2tlZCwgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwsIGJvZHk6IGJvZHkyLCBoZWFkZXJzOiBoZWFkZXJzMiwgdW5wYWNrZWQsIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXMgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICB9XG4gIH0pKCk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3RpbWVvdXRQcm9taXNlLCByZXN1bHRQcm9taXNlXSk7XG59XG5cbi8vIHNyYy9wbGF0Zm9ybS93ZWIvbGliL2h0dHAvcmVxdWVzdC9pbmRleC50c1xudmFyIGRlZmF1bHRCdW5kbGVkUmVxdWVzdEltcGxlbWVudGF0aW9ucyA9IHtcbiAgWEhSUmVxdWVzdDogeGhycmVxdWVzdF9kZWZhdWx0LFxuICBGZXRjaFJlcXVlc3Q6IGZldGNoUmVxdWVzdFxufTtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9pbmRleC50c1xudmFyIENyeXB0byA9IGNyZWF0ZUNyeXB0b0NsYXNzKGNvbmZpZ19kZWZhdWx0LCBidWZmZXJ1dGlsc19kZWZhdWx0KTtcblBsYXRmb3JtLkNyeXB0byA9IENyeXB0bztcblBsYXRmb3JtLkJ1ZmZlclV0aWxzID0gYnVmZmVydXRpbHNfZGVmYXVsdDtcblBsYXRmb3JtLkh0dHAgPSBodHRwX2RlZmF1bHQ7XG5QbGF0Zm9ybS5Db25maWcgPSBjb25maWdfZGVmYXVsdDtcblBsYXRmb3JtLlRyYW5zcG9ydHMgPSB0cmFuc3BvcnRfZGVmYXVsdDI7XG5QbGF0Zm9ybS5XZWJTdG9yYWdlID0gd2Vic3RvcmFnZV9kZWZhdWx0O1xuZm9yIChjb25zdCBjbGllbnRDbGFzcyBvZiBbRGVmYXVsdFJlc3QsIERlZmF1bHRSZWFsdGltZV0pIHtcbiAgY2xpZW50Q2xhc3MuQ3J5cHRvID0gQ3J5cHRvO1xuICBjbGllbnRDbGFzcy5fTXNnUGFjayA9IG1zZ3BhY2tfZGVmYXVsdDtcbn1cbmh0dHBfZGVmYXVsdC5idW5kbGVkUmVxdWVzdEltcGxlbWVudGF0aW9ucyA9IGRlZmF1bHRCdW5kbGVkUmVxdWVzdEltcGxlbWVudGF0aW9ucztcbmxvZ2dlcl9kZWZhdWx0LmluaXRMb2dIYW5kbGVycygpO1xuUGxhdGZvcm0uRGVmYXVsdHMgPSBnZXREZWZhdWx0cyhkZWZhdWx0c19kZWZhdWx0Mik7XG5pZiAoUGxhdGZvcm0uQ29uZmlnLmFnZW50KSB7XG4gIFBsYXRmb3JtLkRlZmF1bHRzLmFnZW50ICs9IFwiIFwiICsgUGxhdGZvcm0uQ29uZmlnLmFnZW50O1xufVxudmFyIHdlYl9kZWZhdWx0ID0ge1xuICBFcnJvckluZm8sXG4gIFJlc3Q6IERlZmF1bHRSZXN0LFxuICBSZWFsdGltZTogRGVmYXVsdFJlYWx0aW1lLFxuICBtc2dwYWNrOiBtc2dwYWNrX2RlZmF1bHQsXG4gIG1ha2VQcm90b2NvbE1lc3NhZ2VGcm9tRGVzZXJpYWxpemVkOiBtYWtlRnJvbURlc2VyaWFsaXplZFdpdGhEZXBlbmRlbmNpZXNcbn07XG5pZiAodHlwZW9mIG1vZHVsZS5leHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIikge1xuICB2YXIgX19jcCA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gICAgaWYgKChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiKSB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZnJvbSkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywga2V5LCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiBmcm9tW2tleV0sXG4gICAgICAgICAgZW51bWVyYWJsZTogIShkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG4gIH07XG4gIG1vZHVsZS5leHBvcnRzID0gX19jcChtb2R1bGUuZXhwb3J0cywgZXhwb3J0cyk7XG59XG5yZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59KSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFibHkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/game-view.tsx":
/*!**********************************!*\
  !*** ./components/game-view.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameView: function() { return /* binding */ GameView; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chess.js */ \"(app-pages-browser)/./node_modules/.pnpm/chess.js@1.4.0/node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var ably__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ably */ \"(app-pages-browser)/./node_modules/.pnpm/ably@2.17.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/ably/build/ably.js\");\n/* harmony import */ var ably__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ably__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/mcp-client */ \"(app-pages-browser)/./lib/mcp-client.ts\");\n/* harmony import */ var _components_chess_board__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/chess-board */ \"(app-pages-browser)/./components/chess-board.tsx\");\n/* harmony import */ var _components_chat_panel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/chat-panel */ \"(app-pages-browser)/./components/chat-panel.tsx\");\n/* __next_internal_client_entry_do_not_use__ GameView auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction GameView(param) {\n    let { gameId, currentUserId } = param;\n    _s();\n    const [game, setGame] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [history, setHistory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedFrom, setSelectedFrom] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [snapshotUrl, setSnapshotUrl] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [toasts, setToasts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [activeTab, setActiveTab] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"board\");\n    const [unreadCount, setUnreadCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const toastIdRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const activeTabRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(\"board\");\n    const load = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const [g, s, h, c] = await Promise.all([\n                (0,_lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__.callMcpTool)(\"get_game\", {\n                    gameId\n                }),\n                (0,_lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__.callMcpTool)(\"status\", {\n                    gameId\n                }),\n                (0,_lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__.callMcpTool)(\"history\", {\n                    gameId\n                }),\n                (0,_lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__.callMcpTool)(\"get_chat_messages\", {\n                    gameId,\n                    limit: 80\n                })\n            ]);\n            setGame(g.game);\n            setStatus(s);\n            setHistory(h.moves);\n            setMessages(c.messages);\n            setUnreadCount(0);\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Failed to load game\");\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        gameId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        void load();\n    }, [\n        load\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        activeTabRef.current = activeTab;\n        if (activeTab === \"chat\") {\n            setUnreadCount(0);\n        }\n    }, [\n        activeTab\n    ]);\n    const refreshChat = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        const chat = await (0,_lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__.callMcpTool)(\"get_chat_messages\", {\n            gameId,\n            limit: 80\n        });\n        setMessages(chat.messages);\n    }, [\n        gameId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const client = new ably__WEBPACK_IMPORTED_MODULE_3__.Realtime({\n            authUrl: \"/api/ably/token\",\n            autoConnect: true,\n            closeOnUnload: true\n        });\n        const channel = client.channels.get(\"game:\".concat(gameId));\n        const onMessage = (message)=>{\n            if (message.name === \"chat.created\") {\n                if (activeTabRef.current === \"chat\") {\n                    void refreshChat();\n                } else {\n                    const byCurrentUser = typeof message.data === \"object\" && message.data !== null && \"userId\" in message.data && message.data.userId === currentUserId;\n                    if (!byCurrentUser) {\n                        setUnreadCount((count)=>count + 1);\n                    }\n                }\n                return;\n            }\n            if (message.name === \"move.created\" || message.name === \"game.finished\" || message.name === \"game.created\") {\n                void load();\n            }\n        };\n        channel.subscribe(onMessage);\n        return ()=>{\n            channel.unsubscribe(onMessage);\n            client.close();\n        };\n    }, [\n        gameId,\n        currentUserId,\n        load,\n        refreshChat\n    ]);\n    const piecesBySquare = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const map = new Map();\n        var _status_pieces;\n        for (const p of (_status_pieces = status === null || status === void 0 ? void 0 : status.pieces) !== null && _status_pieces !== void 0 ? _status_pieces : []){\n            map.set(p.square, p);\n        }\n        return map;\n    }, [\n        status === null || status === void 0 ? void 0 : status.pieces\n    ]);\n    const myColor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!game || !currentUserId) return null;\n        if (game.white.id === currentUserId) return \"w\";\n        if (game.black.id === currentUserId) return \"b\";\n        return null;\n    }, [\n        game,\n        currentUserId\n    ]);\n    const isGameActive = (status === null || status === void 0 ? void 0 : status.gameStatus) === \"ACTIVE\";\n    const canPlay = Boolean((game === null || game === void 0 ? void 0 : game.canMove) && myColor && isGameActive);\n    const isMyTurn = Boolean(canPlay && (status === null || status === void 0 ? void 0 : status.turn) === myColor);\n    const gameResultMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!status || isGameActive) return null;\n        if (status.isCheckmate) {\n            const winner = status.turn === \"w\" ? game === null || game === void 0 ? void 0 : game.black : game === null || game === void 0 ? void 0 : game.white;\n            var _winner_email, _ref;\n            return \"Checkmate. Winner: \".concat((_ref = (_winner_email = winner === null || winner === void 0 ? void 0 : winner.email) !== null && _winner_email !== void 0 ? _winner_email : winner === null || winner === void 0 ? void 0 : winner.id) !== null && _ref !== void 0 ? _ref : \"Unknown player\", \".\");\n        }\n        if (status.isDraw || status.isStalemate) {\n            return \"Game over: Draw.\";\n        }\n        return \"Game finished.\";\n    }, [\n        status,\n        isGameActive,\n        game\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isMyTurn || activeTab !== \"board\") {\n            setSelectedFrom(null);\n        }\n    }, [\n        isMyTurn,\n        activeTab\n    ]);\n    function pushToast(level, message) {\n        const id = toastIdRef.current + 1;\n        toastIdRef.current = id;\n        setToasts((prev)=>[\n                ...prev,\n                {\n                    id,\n                    level,\n                    message\n                }\n            ]);\n        setTimeout(()=>{\n            setToasts((prev)=>prev.filter((t)=>t.id !== id));\n        }, 3200);\n    }\n    async function handleSquareClick(square) {\n        if (!status || !(game === null || game === void 0 ? void 0 : game.canMove) || !myColor) return;\n        if (status.turn !== myColor) {\n            pushToast(\"warning\", \"Not your turn.\");\n            return;\n        }\n        if (!selectedFrom) {\n            const piece = piecesBySquare.get(square);\n            if (!piece || piece.color !== myColor) {\n                pushToast(\"warning\", \"Select one of your pieces first.\");\n                return;\n            }\n            setSelectedFrom(square);\n            return;\n        }\n        if (selectedFrom === square) {\n            setSelectedFrom(null);\n            return;\n        }\n        const targetPiece = piecesBySquare.get(square);\n        if ((targetPiece === null || targetPiece === void 0 ? void 0 : targetPiece.color) === myColor) {\n            setSelectedFrom(square);\n            return;\n        }\n        const chess = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess(status.fen);\n        const legalTargets = chess.moves({\n            square: selectedFrom,\n            verbose: true\n        }).map((m)=>m.to);\n        if (!legalTargets.includes(square)) {\n            pushToast(\"warning\", \"That destination is not legal for the selected piece.\");\n            return;\n        }\n        setError(null);\n        try {\n            await (0,_lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__.callMcpTool)(\"move_piece\", {\n                gameId,\n                from: selectedFrom,\n                to: square,\n                promotion: \"q\"\n            });\n            setSelectedFrom(null);\n            await load();\n        } catch (err) {\n            const message = err instanceof Error ? err.message : \"Move failed\";\n            setError(message);\n            if (message.includes(\"Illegal move\")) {\n                pushToast(\"error\", \"Illegal move. This move would break chess rules (for example, exposing your king).\");\n            } else if (message.includes(\"not your turn\")) {\n                pushToast(\"warning\", \"Not your turn.\");\n            }\n            setSelectedFrom(null);\n        }\n    }\n    async function sendMessage(body) {\n        await (0,_lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__.callMcpTool)(\"post_chat_message\", {\n            gameId,\n            body\n        });\n        const chat = await (0,_lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__.callMcpTool)(\"get_chat_messages\", {\n            gameId,\n            limit: 80\n        });\n        setMessages(chat.messages);\n        setUnreadCount(0);\n    }\n    async function loadSnapshot() {\n        setError(null);\n        try {\n            const snap = await (0,_lib_mcp_client__WEBPACK_IMPORTED_MODULE_4__.callMcpTool)(\"snapshot\", {\n                gameId,\n                size: 560\n            });\n            setSnapshotUrl(snap.dataUrl);\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Snapshot failed\");\n        }\n    }\n    if (loading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n            className: \"muted\",\n            children: \"Loading game...\"\n        }, void 0, false, {\n            fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n            lineNumber: 314,\n            columnNumber: 12\n        }, this);\n    }\n    if (!game || !status) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n            className: \"error\",\n            children: \"Game unavailable.\"\n        }, void 0, false, {\n            fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n            lineNumber: 318,\n            columnNumber: 12\n        }, this);\n    }\n    var _game_white_email, _game_black_email;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"stack\",\n        style: {\n            marginTop: \"1rem\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"toast-stack\",\n                \"aria-live\": \"polite\",\n                children: toasts.map((toast)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"toast \".concat(toast.level === \"error\" ? \"toast-error\" : \"toast-warning\"),\n                        children: toast.message\n                    }, toast.id, false, {\n                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                        lineNumber: 325,\n                        columnNumber: 11\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                lineNumber: 323,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"panel stack\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"row\",\n                        style: {\n                            justifyContent: \"space-between\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                style: {\n                                    margin: 0\n                                },\n                                children: [\n                                    (_game_white_email = game.white.email) !== null && _game_white_email !== void 0 ? _game_white_email : game.white.id,\n                                    \" vs \",\n                                    (_game_black_email = game.black.email) !== null && _game_black_email !== void 0 ? _game_black_email : game.black.id\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 336,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                children: status.gameStatus\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 339,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                        lineNumber: 335,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"muted\",\n                        children: [\n                            \"Turn: \",\n                            status.turn === \"w\" ? \"White\" : \"Black\",\n                            \" â€¢ Moves: \",\n                            game.moveCount\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                        lineNumber: 342,\n                        columnNumber: 9\n                    }, this),\n                    gameResultMessage && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"game-result-banner\",\n                        children: gameResultMessage\n                    }, void 0, false, {\n                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                        lineNumber: 346,\n                        columnNumber: 31\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"tabs\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                className: \"tab \".concat(activeTab === \"board\" ? \"active\" : \"\"),\n                                type: \"button\",\n                                onClick: ()=>setActiveTab(\"board\"),\n                                children: \"Board\"\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 349,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                className: \"tab \".concat(activeTab === \"history\" ? \"active\" : \"\"),\n                                type: \"button\",\n                                onClick: ()=>setActiveTab(\"history\"),\n                                children: \"Move History\"\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 356,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                className: \"tab \".concat(activeTab === \"chat\" ? \"active\" : \"\"),\n                                type: \"button\",\n                                onClick: ()=>setActiveTab(\"chat\"),\n                                children: [\n                                    \"Chat\",\n                                    unreadCount > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"tab-badge\",\n                                        children: unreadCount\n                                    }, void 0, false, {\n                                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                        lineNumber: 369,\n                                        columnNumber: 33\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 363,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                        lineNumber: 348,\n                        columnNumber: 9\n                    }, this),\n                    activeTab === \"board\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            canPlay ? isMyTurn ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"turn-banner my-turn\",\n                                children: \"Your turn to move\"\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 377,\n                                columnNumber: 17\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"turn-banner waiting-turn\",\n                                children: \"Not your turn. Waiting for opponent.\"\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 379,\n                                columnNumber: 17\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"turn-banner spectator-turn\",\n                                children: \"You can view this game, but only the two players can move.\"\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 384,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"row\",\n                                children: [\n                                    status.isCheck && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"Check\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                        lineNumber: 390,\n                                        columnNumber: 34\n                                    }, this),\n                                    status.isCheckmate && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"Checkmate\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                        lineNumber: 391,\n                                        columnNumber: 38\n                                    }, this),\n                                    status.isStalemate && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"Stalemate\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                        lineNumber: 392,\n                                        columnNumber: 38\n                                    }, this),\n                                    status.isDraw && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"Draw\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                        lineNumber: 393,\n                                        columnNumber: 33\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 389,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_chess_board__WEBPACK_IMPORTED_MODULE_5__.ChessBoard, {\n                                pieces: status.pieces,\n                                selectedSquare: selectedFrom,\n                                onSquareClick: (sq)=>void handleSquareClick(sq),\n                                interactive: isMyTurn,\n                                orientation: myColor === \"b\" ? \"black\" : \"white\"\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 396,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"muted\",\n                                children: isMyTurn ? \"Select one of your pieces, then a destination square.\" : \"Board is locked until your turn.\"\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 404,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true),\n                    activeTab === \"history\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"row\",\n                                style: {\n                                    justifyContent: \"space-between\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        style: {\n                                            margin: 0\n                                        },\n                                        children: \"History\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                        lineNumber: 415,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        type: \"button\",\n                                        className: \"primary\",\n                                        onClick: ()=>void loadSnapshot(),\n                                        children: \"Snapshot\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                        lineNumber: 416,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 414,\n                                columnNumber: 13\n                            }, this),\n                            history.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"muted\",\n                                children: \"No moves yet.\"\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 422,\n                                columnNumber: 15\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                className: \"game-list\",\n                                children: history.map((m)=>/*#__PURE__*/ {\n                                    var _m_byUser_email;\n                                    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                children: [\n                                                    m.ply,\n                                                    \". \",\n                                                    m.san\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                                lineNumber: 427,\n                                                columnNumber: 21\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"muted\",\n                                                children: [\n                                                    (_m_byUser_email = m.byUser.email) !== null && _m_byUser_email !== void 0 ? _m_byUser_email : m.byUser.id,\n                                                    \" â€¢ \",\n                                                    new Date(m.createdAt).toLocaleString()\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                                lineNumber: 430,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, m.id, true, {\n                                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                        lineNumber: 426,\n                                        columnNumber: 19\n                                    }, this);\n                                })\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 424,\n                                columnNumber: 15\n                            }, this),\n                            snapshotUrl && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                src: snapshotUrl,\n                                alt: \"Chess board snapshot\",\n                                className: \"snapshot\"\n                            }, void 0, false, {\n                                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                                lineNumber: 439,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true),\n                    activeTab === \"chat\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_chat_panel__WEBPACK_IMPORTED_MODULE_6__.ChatPanel, {\n                        messages: messages,\n                        canSend: Boolean(game.canMove && currentUserId),\n                        onSend: sendMessage\n                    }, void 0, false, {\n                        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                        lineNumber: 445,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                lineNumber: 334,\n                columnNumber: 7\n            }, this),\n            error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"error\",\n                children: error\n            }, void 0, false, {\n                fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n                lineNumber: 453,\n                columnNumber: 17\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/samuelbourque/codex/mcp-chess/components/game-view.tsx\",\n        lineNumber: 322,\n        columnNumber: 5\n    }, this);\n}\n_s(GameView, \"6MS+PhAOGLEYNDvnsI2Ys+P69ps=\");\n_c = GameView;\nvar _c;\n$RefreshReg$(_c, \"GameView\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvZ2FtZS12aWV3LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFMEU7QUFDekM7QUFFSjtBQUVrQjtBQUNPO0FBQ0Y7QUErRDdDLFNBQVNVLFNBQVMsS0FNeEI7UUFOd0IsRUFDdkJDLE1BQU0sRUFDTkMsYUFBYSxFQUlkLEdBTndCOztJQU92QixNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FBR1YsK0NBQVFBLENBQTBCO0lBQzFELE1BQU0sQ0FBQ1csUUFBUUMsVUFBVSxHQUFHWiwrQ0FBUUEsQ0FBb0I7SUFDeEQsTUFBTSxDQUFDYSxTQUFTQyxXQUFXLEdBQUdkLCtDQUFRQSxDQUF1QixFQUFFO0lBQy9ELE1BQU0sQ0FBQ2UsVUFBVUMsWUFBWSxHQUFHaEIsK0NBQVFBLENBQXVCLEVBQUU7SUFDakUsTUFBTSxDQUFDaUIsY0FBY0MsZ0JBQWdCLEdBQUdsQiwrQ0FBUUEsQ0FBZ0I7SUFDaEUsTUFBTSxDQUFDbUIsYUFBYUMsZUFBZSxHQUFHcEIsK0NBQVFBLENBQWdCO0lBQzlELE1BQU0sQ0FBQ3FCLE9BQU9DLFNBQVMsR0FBR3RCLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUN1QixTQUFTQyxXQUFXLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUN5QixRQUFRQyxVQUFVLEdBQUcxQiwrQ0FBUUEsQ0FBVSxFQUFFO0lBQ2hELE1BQU0sQ0FBQzJCLFdBQVdDLGFBQWEsR0FBRzVCLCtDQUFRQSxDQUFVO0lBQ3BELE1BQU0sQ0FBQzZCLGFBQWFDLGVBQWUsR0FBRzlCLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0rQixhQUFhaEMsNkNBQU1BLENBQUM7SUFDMUIsTUFBTWlDLGVBQWVqQyw2Q0FBTUEsQ0FBVTtJQUVyQyxNQUFNa0MsT0FBT3JDLGtEQUFXQSxDQUFDO1FBQ3ZCNEIsV0FBVztRQUNYRixTQUFTO1FBRVQsSUFBSTtZQUNGLE1BQU0sQ0FBQ1ksR0FBR0MsR0FBR0MsR0FB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Ozs7Ozs7Ozs7Ozs7QUFHdEM7R0EvWGdCZjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2dhbWUtdmlldy50c3g/NWU3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQ2hlc3MgfSBmcm9tIFwiY2hlc3MuanNcIjtcbmltcG9ydCB0eXBlIHsgU3F1YXJlIH0gZnJvbSBcImNoZXNzLmpzXCI7XG5pbXBvcnQgKiBhcyBBYmx5IGZyb20gXCJhYmx5XCI7XG5cbmltcG9ydCB7IGNhbGxNY3BUb29sIH0gZnJvbSBcIkAvbGliL21jcC1jbGllbnRcIjtcbmltcG9ydCB7IENoZXNzQm9hcmQgfSBmcm9tIFwiQC9jb21wb25lbnRzL2NoZXNzLWJvYXJkXCI7XG5pbXBvcnQgeyBDaGF0UGFuZWwgfSBmcm9tIFwiQC9jb21wb25lbnRzL2NoYXQtcGFuZWxcIjtcblxudHlwZSBQaWVjZSA9IHtcbiAgc3F1YXJlOiBzdHJpbmc7XG4gIHR5cGU6IFwicFwiIHwgXCJyXCIgfCBcIm5cIiB8IFwiYlwiIHwgXCJxXCIgfCBcImtcIjtcbiAgY29sb3I6IFwid1wiIHwgXCJiXCI7XG59O1xuXG50eXBlIEdhbWVEYXRhID0ge1xuICBnYW1lOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB3aGl0ZTogeyBpZDogc3RyaW5nOyBlbWFpbDogc3RyaW5nIHwgbnVsbCB9O1xuICAgIGJsYWNrOiB7IGlkOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmcgfCBudWxsIH07XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgbW92ZUNvdW50OiBudW1iZXI7XG4gICAgY2hhdENvdW50OiBudW1iZXI7XG4gICAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gICAgdXBkYXRlZEF0OiBzdHJpbmc7XG4gICAgY2FuTW92ZTogYm9vbGVhbjtcbiAgfTtcbn07XG5cbnR5cGUgU3RhdHVzRGF0YSA9IHtcbiAgZ2FtZUlkOiBzdHJpbmc7XG4gIGZlbjogc3RyaW5nO1xuICB0dXJuOiBcIndcIiB8IFwiYlwiO1xuICBpc0NoZWNrOiBib29sZWFuO1xuICBpc0NoZWNrbWF0ZTogYm9vbGVhbjtcbiAgaXNTdGFsZW1hdGU6IGJvb2xlYW47XG4gIGlzRHJhdzogYm9vbGVhbjtcbiAgZ2FtZVN0YXR1czogc3RyaW5nO1xuICBwaWVjZXM6IFBpZWNlW107XG59O1xuXG50eXBlIEhpc3RvcnlEYXRhID0ge1xuICBtb3ZlczogQXJyYXk8e1xuICAgIGlkOiBzdHJpbmc7XG4gICAgcGx5OiBudW1iZXI7XG4gICAgc2FuOiBzdHJpbmc7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHRvOiBzdHJpbmc7XG4gICAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gICAgYnlVc2VyOiB7IGlkOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmcgfCBudWxsIH07XG4gIH0+O1xufTtcblxudHlwZSBDaGF0RGF0YSA9IHtcbiAgbWVzc2FnZXM6IEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGJvZHk6IHN0cmluZztcbiAgICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgICB1c2VyOiB7IGlkOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmcgfCBudWxsIH07XG4gIH0+O1xufTtcblxudHlwZSBUb2FzdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgbGV2ZWw6IFwid2FybmluZ1wiIHwgXCJlcnJvclwiO1xuICBtZXNzYWdlOiBzdHJpbmc7XG59O1xuXG50eXBlIEdhbWVUYWIgPSBcImJvYXJkXCIgfCBcImhpc3RvcnlcIiB8IFwiY2hhdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gR2FtZVZpZXcoe1xuICBnYW1lSWQsXG4gIGN1cnJlbnRVc2VySWRcbn06IHtcbiAgZ2FtZUlkOiBzdHJpbmc7XG4gIGN1cnJlbnRVc2VySWQ6IHN0cmluZyB8IG51bGw7XG59KSB7XG4gIGNvbnN0IFtnYW1lLCBzZXRHYW1lXSA9IHVzZVN0YXRlPEdhbWVEYXRhW1wiZ2FtZVwiXSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGU8U3RhdHVzRGF0YSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaGlzdG9yeSwgc2V0SGlzdG9yeV0gPSB1c2VTdGF0ZTxIaXN0b3J5RGF0YVtcIm1vdmVzXCJdPihbXSk7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8Q2hhdERhdGFbXCJtZXNzYWdlc1wiXT4oW10pO1xuICBjb25zdCBbc2VsZWN0ZWRGcm9tLCBzZXRTZWxlY3RlZEZyb21dID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzbmFwc2hvdFVybCwgc2V0U25hcHNob3RVcmxdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbdG9hc3RzLCBzZXRUb2FzdHNdID0gdXNlU3RhdGU8VG9hc3RbXT4oW10pO1xuICBjb25zdCBbYWN0aXZlVGFiLCBzZXRBY3RpdmVUYWJdID0gdXNlU3RhdGU8R2FtZVRhYj4oXCJib2FyZFwiKTtcbiAgY29uc3QgW3VucmVhZENvdW50LCBzZXRVbnJlYWRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgdG9hc3RJZFJlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgYWN0aXZlVGFiUmVmID0gdXNlUmVmPEdhbWVUYWI+KFwiYm9hcmRcIik7XG5cbiAgY29uc3QgbG9hZCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFtnLCBzLCBoLCBjXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgY2FsbE1jcFRvb2w8R2FtZURhdGE+KFwiZ2V0X2dhbWVcIiwgeyBnYW1lSWQgfSksXG4gICAgICAgIGNhbGxNY3BUb29sPFN0YXR1c0RhdGE+KFwic3RhdHVzXCIsIHsgZ2FtZUlkIH0pLFxuICAgICAgICBjYWxsTWNwVG9vbDxIaXN0b3J5RGF0YT4oXCJoaXN0b3J5XCIsIHsgZ2FtZUlkIH0pLFxuICAgICAgICBjYWxsTWNwVG9vbDxDaGF0RGF0YT4oXCJnZXRfY2hhdF9tZXNzYWdlc1wiLCB7IGdhbWVJZCwgbGltaXQ6IDgwIH0pXG4gICAgICBdKTtcblxuICAgICAgc2V0R2FtZShnLmdhbWUpO1xuICAgICAgc2V0U3RhdHVzKHMpO1xuICAgICAgc2V0SGlzdG9yeShoLm1vdmVzKTtcbiAgICAgIHNldE1lc3NhZ2VzKGMubWVzc2FnZXMpO1xuICAgICAgc2V0VW5yZWFkQ291bnQoMCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gbG9hZCBnYW1lXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtnYW1lSWRdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZvaWQgbG9hZCgpO1xuICB9LCBbbG9hZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlVGFiUmVmLmN1cnJlbnQgPSBhY3RpdmVUYWI7XG4gICAgaWYgKGFjdGl2ZVRhYiA9PT0gXCJjaGF0XCIpIHtcbiAgICAgIHNldFVucmVhZENvdW50KDApO1xuICAgIH1cbiAgfSwgW2FjdGl2ZVRhYl0pO1xuXG4gIGNvbnN0IHJlZnJlc2hDaGF0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNoYXQgPSBhd2FpdCBjYWxsTWNwVG9vbDxDaGF0RGF0YT4oXCJnZXRfY2hhdF9tZXNzYWdlc1wiLCB7XG4gICAgICBnYW1lSWQsXG4gICAgICBsaW1pdDogODBcbiAgICB9KTtcbiAgICBzZXRNZXNzYWdlcyhjaGF0Lm1lc3NhZ2VzKTtcbiAgfSwgW2dhbWVJZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IEFibHkuUmVhbHRpbWUoe1xuICAgICAgYXV0aFVybDogXCIvYXBpL2FibHkvdG9rZW5cIixcbiAgICAgIGF1dG9Db25uZWN0OiB0cnVlLFxuICAgICAgY2xvc2VPblVubG9hZDogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5uZWwgPSBjbGllbnQuY2hhbm5lbHMuZ2V0KGBnYW1lOiR7Z2FtZUlkfWApO1xuXG4gICAgY29uc3Qgb25NZXNzYWdlID0gKG1lc3NhZ2U6IEFibHkuVHlwZXMuTWVzc2FnZSkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2UubmFtZSA9PT0gXCJjaGF0LmNyZWF0ZWRcIikge1xuICAgICAgICBpZiAoYWN0aXZlVGFiUmVmLmN1cnJlbnQgPT09IFwiY2hhdFwiKSB7XG4gICAgICAgICAgdm9pZCByZWZyZXNoQ2hhdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJ5Q3VycmVudFVzZXIgPVxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UuZGF0YSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgbWVzc2FnZS5kYXRhICE9PSBudWxsICYmXG4gICAgICAgICAgICBcInVzZXJJZFwiIGluIG1lc3NhZ2UuZGF0YSAmJlxuICAgICAgICAgICAgbWVzc2FnZS5kYXRhLnVzZXJJZCA9PT0gY3VycmVudFVzZXJJZDtcbiAgICAgICAgICBpZiAoIWJ5Q3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHNldFVucmVhZENvdW50KChjb3VudCkgPT4gY291bnQgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIG1lc3NhZ2UubmFtZSA9PT0gXCJtb3ZlLmNyZWF0ZWRcIiB8fFxuICAgICAgICBtZXNzYWdlLm5hbWUgPT09IFwiZ2FtZS5maW5pc2hlZFwiIHx8XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9PT0gXCJnYW1lLmNyZWF0ZWRcIlxuICAgICAgKSB7XG4gICAgICAgIHZvaWQgbG9hZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjaGFubmVsLnN1YnNjcmliZShvbk1lc3NhZ2UpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNoYW5uZWwudW5zdWJzY3JpYmUob25NZXNzYWdlKTtcbiAgICAgIGNsaWVudC5jbG9zZSgpO1xuICAgIH07XG4gIH0sIFtnYW1lSWQsIGN1cnJlbnRVc2VySWQsIGxvYWQsIHJlZnJlc2hDaGF0XSk7XG5cbiAgY29uc3QgcGllY2VzQnlTcXVhcmUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwPHN0cmluZywgUGllY2U+KCk7XG4gICAgZm9yIChjb25zdCBwIG9mIHN0YXR1cz8ucGllY2VzID8/IFtdKSB7XG4gICAgICBtYXAuc2V0KHAuc3F1YXJlLCBwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwgW3N0YXR1cz8ucGllY2VzXSk7XG5cbiAgY29uc3QgbXlDb2xvciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZ2FtZSB8fCAhY3VycmVudFVzZXJJZCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKGdhbWUud2hpdGUuaWQgPT09IGN1cnJlbnRVc2VySWQpIHJldHVybiBcIndcIiBhcyBjb25zdDtcbiAgICBpZiAoZ2FtZS5ibGFjay5pZCA9PT0gY3VycmVudFVzZXJJZCkgcmV0dXJuIFwiYlwiIGFzIGNvbnN0O1xuICAgIHJldHVybiBudWxsO1xuICB9LCBbZ2FtZSwgY3VycmVudFVzZXJJZF0pO1xuICBjb25zdCBpc0dhbWVBY3RpdmUgPSBzdGF0dXM/LmdhbWVTdGF0dXMgPT09IFwiQUNUSVZFXCI7XG4gIGNvbnN0IGNhblBsYXkgPSBCb29sZWFuKGdhbWU/LmNhbk1vdmUgJiYgbXlDb2xvciAmJiBpc0dhbWVBY3RpdmUpO1xuICBjb25zdCBpc015VHVybiA9IEJvb2xlYW4oY2FuUGxheSAmJiBzdGF0dXM/LnR1cm4gPT09IG15Q29sb3IpO1xuICBjb25zdCBnYW1lUmVzdWx0TWVzc2FnZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghc3RhdHVzIHx8IGlzR2FtZUFjdGl2ZSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoc3RhdHVzLmlzQ2hlY2ttYXRlKSB7XG4gICAgICBjb25zdCB3aW5uZXIgPSBzdGF0dXMudHVybiA9PT0gXCJ3XCIgPyBnYW1lPy5ibGFjayA6IGdhbWU/LndoaXRlO1xuICAgICAgcmV0dXJuIGBDaGVja21hdGUuIFdpbm5lcjogJHt3aW5uZXI/LmVtYWlsID8/IHdpbm5lcj8uaWQgPz8gXCJVbmtub3duIHBsYXllclwifS5gO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMuaXNEcmF3IHx8IHN0YXR1cy5pc1N0YWxlbWF0ZSkge1xuICAgICAgcmV0dXJuIFwiR2FtZSBvdmVyOiBEcmF3LlwiO1xuICAgIH1cblxuICAgIHJldHVybiBcIkdhbWUgZmluaXNoZWQuXCI7XG4gIH0sIFtzdGF0dXMsIGlzR2FtZUFjdGl2ZSwgZ2FtZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc015VHVybiB8fCBhY3RpdmVUYWIgIT09IFwiYm9hcmRcIikge1xuICAgICAgc2V0U2VsZWN0ZWRGcm9tKG51bGwpO1xuICAgIH1cbiAgfSwgW2lzTXlUdXJuLCBhY3RpdmVUYWJdKTtcblxuICBmdW5jdGlvbiBwdXNoVG9hc3QobGV2ZWw6IFRvYXN0W1wibGV2ZWxcIl0sIG1lc3NhZ2U6IHN0cmluZykge1xuICAgIGNvbnN0IGlkID0gdG9hc3RJZFJlZi5jdXJyZW50ICsgMTtcbiAgICB0b2FzdElkUmVmLmN1cnJlbnQgPSBpZDtcbiAgICBzZXRUb2FzdHMoKHByZXYpID0+IFsuLi5wcmV2LCB7IGlkLCBsZXZlbCwgbWVzc2FnZSB9XSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRUb2FzdHMoKHByZXYpID0+IHByZXYuZmlsdGVyKCh0KSA9PiB0LmlkICE9PSBpZCkpO1xuICAgIH0sIDMyMDApO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlU3F1YXJlQ2xpY2soc3F1YXJlOiBzdHJpbmcpIHtcbiAgICBpZiAoIXN0YXR1cyB8fCAhZ2FtZT8uY2FuTW92ZSB8fCAhbXlDb2xvcikgcmV0dXJuO1xuICAgIGlmIChzdGF0dXMudHVybiAhPT0gbXlDb2xvcikge1xuICAgICAgcHVzaFRvYXN0KFwid2FybmluZ1wiLCBcIk5vdCB5b3VyIHR1cm4uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghc2VsZWN0ZWRGcm9tKSB7XG4gICAgICBjb25zdCBwaWVjZSA9IHBpZWNlc0J5U3F1YXJlLmdldChzcXVhcmUpO1xuICAgICAgaWYgKCFwaWVjZSB8fCBwaWVjZS5jb2xvciAhPT0gbXlDb2xvcikge1xuICAgICAgICBwdXNoVG9hc3QoXCJ3YXJuaW5nXCIsIFwiU2VsZWN0IG9uZSBvZiB5b3VyIHBpZWNlcyBmaXJzdC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFNlbGVjdGVkRnJvbShzcXVhcmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RlZEZyb20gPT09IHNxdWFyZSkge1xuICAgICAgc2V0U2VsZWN0ZWRGcm9tKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFBpZWNlID0gcGllY2VzQnlTcXVhcmUuZ2V0KHNxdWFyZSk7XG4gICAgaWYgKHRhcmdldFBpZWNlPy5jb2xvciA9PT0gbXlDb2xvcikge1xuICAgICAgc2V0U2VsZWN0ZWRGcm9tKHNxdWFyZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3Moc3RhdHVzLmZlbik7XG4gICAgY29uc3QgbGVnYWxUYXJnZXRzID0gY2hlc3NcbiAgICAgIC5tb3Zlcyh7IHNxdWFyZTogc2VsZWN0ZWRGcm9tIGFzIFNxdWFyZSwgdmVyYm9zZTogdHJ1ZSB9KVxuICAgICAgLm1hcCgobSkgPT4gbS50byk7XG5cbiAgICBpZiAoIWxlZ2FsVGFyZ2V0cy5pbmNsdWRlcyhzcXVhcmUgYXMgU3F1YXJlKSkge1xuICAgICAgcHVzaFRvYXN0KFwid2FybmluZ1wiLCBcIlRoYXQgZGVzdGluYXRpb24gaXMgbm90IGxlZ2FsIGZvciB0aGUgc2VsZWN0ZWQgcGllY2UuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldEVycm9yKG51bGwpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjYWxsTWNwVG9vbChcIm1vdmVfcGllY2VcIiwge1xuICAgICAgICBnYW1lSWQsXG4gICAgICAgIGZyb206IHNlbGVjdGVkRnJvbSxcbiAgICAgICAgdG86IHNxdWFyZSxcbiAgICAgICAgcHJvbW90aW9uOiBcInFcIlxuICAgICAgfSk7XG4gICAgICBzZXRTZWxlY3RlZEZyb20obnVsbCk7XG4gICAgICBhd2FpdCBsb2FkKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiTW92ZSBmYWlsZWRcIjtcbiAgICAgIHNldEVycm9yKG1lc3NhZ2UpO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoXCJJbGxlZ2FsIG1vdmVcIikpIHtcbiAgICAgICAgcHVzaFRvYXN0KFxuICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICBcIklsbGVnYWwgbW92ZS4gVGhpcyBtb3ZlIHdvdWxkIGJyZWFrIGNoZXNzIHJ1bGVzIChmb3IgZXhhbXBsZSwgZXhwb3NpbmcgeW91ciBraW5nKS5cIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmluY2x1ZGVzKFwibm90IHlvdXIgdHVyblwiKSkge1xuICAgICAgICBwdXNoVG9hc3QoXCJ3YXJuaW5nXCIsIFwiTm90IHlvdXIgdHVybi5cIik7XG4gICAgICB9XG4gICAgICBzZXRTZWxlY3RlZEZyb20obnVsbCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc2VuZE1lc3NhZ2UoYm9keTogc3RyaW5nKSB7XG4gICAgYXdhaXQgY2FsbE1jcFRvb2woXCJwb3N0X2NoYXRfbWVzc2FnZVwiLCB7XG4gICAgICBnYW1lSWQsXG4gICAgICBib2R5XG4gICAgfSk7XG5cbiAgICBjb25zdCBjaGF0ID0gYXdhaXQgY2FsbE1jcFRvb2w8Q2hhdERhdGE+KFwiZ2V0X2NoYXRfbWVzc2FnZXNcIiwge1xuICAgICAgZ2FtZUlkLFxuICAgICAgbGltaXQ6IDgwXG4gICAgfSk7XG4gICAgc2V0TWVzc2FnZXMoY2hhdC5tZXNzYWdlcyk7XG4gICAgc2V0VW5yZWFkQ291bnQoMCk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBsb2FkU25hcHNob3QoKSB7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNuYXAgPSBhd2FpdCBjYWxsTWNwVG9vbDx7IGRhdGFVcmw6IHN0cmluZyB9PihcInNuYXBzaG90XCIsIHsgZ2FtZUlkLCBzaXplOiA1NjAgfSk7XG4gICAgICBzZXRTbmFwc2hvdFVybChzbmFwLmRhdGFVcmwpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiU25hcHNob3QgZmFpbGVkXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsb2FkaW5nKSB7XG4gICAgcmV0dXJuIDxwIGNsYXNzTmFtZT1cIm11dGVkXCI+TG9hZGluZyBnYW1lLi4uPC9wPjtcbiAgfVxuXG4gIGlmICghZ2FtZSB8fCAhc3RhdHVzKSB7XG4gICAgcmV0dXJuIDxwIGNsYXNzTmFtZT1cImVycm9yXCI+R2FtZSB1bmF2YWlsYWJsZS48L3A+O1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInN0YWNrXCIgc3R5bGU9e3sgbWFyZ2luVG9wOiBcIjFyZW1cIiB9fT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9hc3Qtc3RhY2tcIiBhcmlhLWxpdmU9XCJwb2xpdGVcIj5cbiAgICAgICAge3RvYXN0cy5tYXAoKHRvYXN0KSA9PiAoXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAga2V5PXt0b2FzdC5pZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YHRvYXN0ICR7dG9hc3QubGV2ZWwgPT09IFwiZXJyb3JcIiA/IFwidG9hc3QtZXJyb3JcIiA6IFwidG9hc3Qtd2FybmluZ1wifWB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3RvYXN0Lm1lc3NhZ2V9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkpfVxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cInBhbmVsIHN0YWNrXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCIgc3R5bGU9e3sganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiIH19PlxuICAgICAgICAgIDxoMiBzdHlsZT17eyBtYXJnaW46IDAgfX0+XG4gICAgICAgICAgICB7Z2FtZS53aGl0ZS5lbWFpbCA/PyBnYW1lLndoaXRlLmlkfSB2cyB7Z2FtZS5ibGFjay5lbWFpbCA/PyBnYW1lLmJsYWNrLmlkfVxuICAgICAgICAgIDwvaDI+XG4gICAgICAgICAgPHN0cm9uZz57c3RhdHVzLmdhbWVTdGF0dXN9PC9zdHJvbmc+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxwIGNsYXNzTmFtZT1cIm11dGVkXCI+XG4gICAgICAgICAgVHVybjoge3N0YXR1cy50dXJuID09PSBcIndcIiA/IFwiV2hpdGVcIiA6IFwiQmxhY2tcIn0g4oCiIE1vdmVzOiB7Z2FtZS5tb3ZlQ291bnR9XG4gICAgICAgIDwvcD5cblxuICAgICAgICB7Z2FtZVJlc3VsdE1lc3NhZ2UgJiYgPGRpdiBjbGFzc05hbWU9XCJnYW1lLXJlc3VsdC1iYW5uZXJcIj57Z2FtZVJlc3VsdE1lc3NhZ2V9PC9kaXY+fVxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGFic1wiPlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YHRhYiAke2FjdGl2ZVRhYiA9PT0gXCJib2FyZFwiID8gXCJhY3RpdmVcIiA6IFwiXCJ9YH1cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVGFiKFwiYm9hcmRcIil9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgQm9hcmRcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9e2B0YWIgJHthY3RpdmVUYWIgPT09IFwiaGlzdG9yeVwiID8gXCJhY3RpdmVcIiA6IFwiXCJ9YH1cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVGFiKFwiaGlzdG9yeVwiKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBNb3ZlIEhpc3RvcnlcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9e2B0YWIgJHthY3RpdmVUYWIgPT09IFwiY2hhdFwiID8gXCJhY3RpdmVcIiA6IFwiXCJ9YH1cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVGFiKFwiY2hhdFwiKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBDaGF0XG4gICAgICAgICAgICB7dW5yZWFkQ291bnQgPiAwICYmIDxzcGFuIGNsYXNzTmFtZT1cInRhYi1iYWRnZVwiPnt1bnJlYWRDb3VudH08L3NwYW4+fVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICB7YWN0aXZlVGFiID09PSBcImJvYXJkXCIgJiYgKFxuICAgICAgICAgIDw+XG4gICAgICAgICAgICB7Y2FuUGxheSA/IChcbiAgICAgICAgICAgICAgaXNNeVR1cm4gPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0dXJuLWJhbm5lciBteS10dXJuXCI+WW91ciB0dXJuIHRvIG1vdmU8L2Rpdj5cbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInR1cm4tYmFubmVyIHdhaXRpbmctdHVyblwiPlxuICAgICAgICAgICAgICAgICAgTm90IHlvdXIgdHVybi4gV2FpdGluZyBmb3Igb3Bwb25lbnQuXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidHVybi1iYW5uZXIgc3BlY3RhdG9yLXR1cm5cIj5cbiAgICAgICAgICAgICAgICBZb3UgY2FuIHZpZXcgdGhpcyBnYW1lLCBidXQgb25seSB0aGUgdHdvIHBsYXllcnMgY2FuIG1vdmUuXG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgICAge3N0YXR1cy5pc0NoZWNrICYmIDxzcGFuPkNoZWNrPC9zcGFuPn1cbiAgICAgICAgICAgICAge3N0YXR1cy5pc0NoZWNrbWF0ZSAmJiA8c3Bhbj5DaGVja21hdGU8L3NwYW4+fVxuICAgICAgICAgICAgICB7c3RhdHVzLmlzU3RhbGVtYXRlICYmIDxzcGFuPlN0YWxlbWF0ZTwvc3Bhbj59XG4gICAgICAgICAgICAgIHtzdGF0dXMuaXNEcmF3ICYmIDxzcGFuPkRyYXc8L3NwYW4+fVxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxDaGVzc0JvYXJkXG4gICAgICAgICAgICAgIHBpZWNlcz17c3RhdHVzLnBpZWNlc31cbiAgICAgICAgICAgICAgc2VsZWN0ZWRTcXVhcmU9e3NlbGVjdGVkRnJvbX1cbiAgICAgICAgICAgICAgb25TcXVhcmVDbGljaz17KHNxKSA9PiB2b2lkIGhhbmRsZVNxdWFyZUNsaWNrKHNxKX1cbiAgICAgICAgICAgICAgaW50ZXJhY3RpdmU9e2lzTXlUdXJufVxuICAgICAgICAgICAgICBvcmllbnRhdGlvbj17bXlDb2xvciA9PT0gXCJiXCIgPyBcImJsYWNrXCIgOiBcIndoaXRlXCJ9XG4gICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtdXRlZFwiPlxuICAgICAgICAgICAgICB7aXNNeVR1cm5cbiAgICAgICAgICAgICAgICA/IFwiU2VsZWN0IG9uZSBvZiB5b3VyIHBpZWNlcywgdGhlbiBhIGRlc3RpbmF0aW9uIHNxdWFyZS5cIlxuICAgICAgICAgICAgICAgIDogXCJCb2FyZCBpcyBsb2NrZWQgdW50aWwgeW91ciB0dXJuLlwifVxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuXG4gICAgICAgIHthY3RpdmVUYWIgPT09IFwiaGlzdG9yeVwiICYmIChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIiBzdHlsZT17eyBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIgfX0+XG4gICAgICAgICAgICAgIDxoMyBzdHlsZT17eyBtYXJnaW46IDAgfX0+SGlzdG9yeTwvaDM+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzTmFtZT1cInByaW1hcnlcIiBvbkNsaWNrPXsoKSA9PiB2b2lkIGxvYWRTbmFwc2hvdCgpfT5cbiAgICAgICAgICAgICAgICBTbmFwc2hvdFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICB7aGlzdG9yeS5sZW5ndGggPT09IDAgPyAoXG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cIm11dGVkXCI+Tm8gbW92ZXMgeWV0LjwvcD5cbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJnYW1lLWxpc3RcIj5cbiAgICAgICAgICAgICAgICB7aGlzdG9yeS5tYXAoKG0pID0+IChcbiAgICAgICAgICAgICAgICAgIDxsaSBrZXk9e20uaWR9PlxuICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPlxuICAgICAgICAgICAgICAgICAgICAgIHttLnBseX0uIHttLnNhbn1cbiAgICAgICAgICAgICAgICAgICAgPC9zdHJvbmc+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cIm11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAge20uYnlVc2VyLmVtYWlsID8/IG0uYnlVc2VyLmlkfSDigKIge25ldyBEYXRlKG0uY3JlYXRlZEF0KS50b0xvY2FsZVN0cmluZygpfVxuICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAge3NuYXBzaG90VXJsICYmIChcbiAgICAgICAgICAgICAgPGltZyBzcmM9e3NuYXBzaG90VXJsfSBhbHQ9XCJDaGVzcyBib2FyZCBzbmFwc2hvdFwiIGNsYXNzTmFtZT1cInNuYXBzaG90XCIgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC8+XG4gICAgICAgICl9XG5cbiAgICAgICAge2FjdGl2ZVRhYiA9PT0gXCJjaGF0XCIgJiYgKFxuICAgICAgICAgIDxDaGF0UGFuZWxcbiAgICAgICAgICAgIG1lc3NhZ2VzPXttZXNzYWdlc31cbiAgICAgICAgICAgIGNhblNlbmQ9e0Jvb2xlYW4oZ2FtZS5jYW5Nb3ZlICYmIGN1cnJlbnRVc2VySWQpfVxuICAgICAgICAgICAgb25TZW5kPXtzZW5kTWVzc2FnZX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9zZWN0aW9uPlxuXG4gICAgICB7ZXJyb3IgJiYgPHAgY2xhc3NOYW1lPVwiZXJyb3JcIj57ZXJyb3J9PC9wPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIkNoZXNzIiwiQWJseSIsImNhbGxNY3BUb29sIiwiQ2hlc3NCb2FyZCIsIkNoYXRQYW5lbCIsIkdhbWVWaWV3IiwiZ2FtZUlkIiwiY3VycmVudFVzZXJJZCIsImdhbWUiLCJzZXRHYW1lIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiaGlzdG9yeSIsInNldEhpc3RvcnkiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwic2VsZWN0ZWRGcm9tIiwic2V0U2VsZWN0ZWRGcm9tIiwic25hcHNob3RVcmwiLCJzZXRTbmFwc2hvdFVybCIsImVycm9yIiwic2V0RXJyb3IiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsInRvYXN0cyIsInNldFRvYXN0cyIsImFjdGl2ZVRhYiIsInNldEFjdGl2ZVRhYiIsInVucmVhZENvdW50Iiwic2V0VW5yZWFkQ291bnQiLCJ0b2FzdElkUmVmIiwiYWN0aXZlVGFiUmVmIiwibG9hZCIsImciLCJzIiwiaCIsImMiLCJQcm9taXNlIiwiYWxsIiwibGltaXQiLCJtb3ZlcyIsImVyciIsIkVycm9yIiwibWVzc2FnZSIsImN1cnJlbnQiLCJyZWZyZXNoQ2hhdCIsImNoYXQiLCJjbGllbnQiLCJSZWFsdGltZSIsImF1dGhVcmwiLCJhdXRvQ29ubmVjdCIsImNsb3NlT25VbmxvYWQiLCJjaGFubmVsIiwiY2hhbm5lbHMiLCJnZXQiLCJvbk1lc3NhZ2UiLCJuYW1lIiwiYnlDdXJyZW50VXNlciIsImRhdGEiLCJ1c2VySWQiLCJjb3VudCIsInN1YnNjcmliZSIsInVuc3Vic2NyaWJlIiwiY2xvc2UiLCJwaWVjZXNCeVNxdWFyZSIsIm1hcCIsIk1hcCIsInAiLCJwaWVjZXMiLCJzZXQiLCJzcXVhcmUiLCJteUNvbG9yIiwid2hpdGUiLCJpZCIsImJsYWNrIiwiaXNHYW1lQWN0aXZlIiwiZ2FtZVN0YXR1cyIsImNhblBsYXkiLCJCb29sZWFuIiwiY2FuTW92ZSIsImlzTXlUdXJuIiwidHVybiIsImdhbWVSZXN1bHRNZXNzYWdlIiwiaXNDaGVja21hdGUiLCJ3aW5uZXIiLCJlbWFpbCIsImlzRHJhdyIsImlzU3RhbGVtYXRlIiwicHVzaFRvYXN0IiwibGV2ZWwiLCJwcmV2Iiwic2V0VGltZW91dCIsImZpbHRlciIsInQiLCJoYW5kbGVTcXVhcmVDbGljayIsInBpZWNlIiwiY29sb3IiLCJ0YXJnZXRQaWVjZSIsImNoZXNzIiwiZmVuIiwibGVnYWxUYXJnZXRzIiwidmVyYm9zZSIsIm0iLCJ0byIsImluY2x1ZGVzIiwiZnJvbSIsInByb21vdGlvbiIsInNlbmRNZXNzYWdlIiwiYm9keSIsImxvYWRTbmFwc2hvdCIsInNuYXAiLCJzaXplIiwiZGF0YVVybCIsImNsYXNzTmFtZSIsImRpdiIsInN0eWxlIiwibWFyZ2luVG9wIiwiYXJpYS1saXZlIiwidG9hc3QiLCJzZWN0aW9uIiwianVzdGlmeUNvbnRlbnQiLCJoMiIsIm1hcmdpbiIsInN0cm9uZyIsIm1vdmVDb3VudCIsImJ1dHRvbiIsInR5cGUiLCJvbkNsaWNrIiwic3BhbiIsImlzQ2hlY2siLCJzZWxlY3RlZFNxdWFyZSIsIm9uU3F1YXJlQ2xpY2siLCJzcSIsImludGVyYWN0aXZlIiwib3JpZW50YXRpb24iLCJoMyIsImxlbmd0aCIsInVsIiwibGkiLCJwbHkiLCJzYW4iLCJieVVzZXIiLCJEYXRlIiwiY3JlYXRlZEF0IiwidG9Mb2NhbGVTdHJpbmciLCJpbWciLCJzcmMiLCJhbHQiLCJjYW5TZW5kIiwib25TZW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/game-view.tsx\n"));

/***/ })

});